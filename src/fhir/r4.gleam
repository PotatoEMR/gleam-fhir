////FHIR r4 types
////https://hl7.org/fhir/r4
import gleam/json.{type Json}
import gleam/dynamic/decode.{type Decoder}
import gleam/option.{type Option, None, Some}
import fhir/r4valuesets

///http://hl7.org/fhir/r4/StructureDefinition/Element#resource
pub type Element
{
Element(id: Option(String),
extension: List(Extension),
)
}

pub fn element_new() ->Element{Element(extension: [],id: None,)
}

pub fn element_to_json(element: Element) -> Json {
    let Element(extension:,id:,) = element
    let fields = []
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn element_decoder() -> Decoder(Element) {use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Element(extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Address#resource
pub type Address
{
Address(id: Option(String),
extension: List(Extension),
use_: Option(r4valuesets.Addressuse),
type_: Option(r4valuesets.Addresstype),
text: Option(String),
line: List(String),
city: Option(String),
district: Option(String),
state: Option(String),
postal_code: Option(String),
country: Option(String),
period: Option(Period),
)
}

pub fn address_new() ->Address{Address(period: None,country: None,postal_code: None,state: None,district: None,city: None,line: [],text: None,type_: None,use_: None,extension: [],id: None,)
}

pub fn address_to_json(address: Address) -> Json {
    let Address(period:,country:,postal_code:,state:,district:,city:,line:,text:,type_:,use_:,extension:,id:,) = address
    let fields = []
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case country {
                          Some(v) -> [#("country", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case postal_code {
                          Some(v) -> [#("postalCode", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case state {
                          Some(v) -> [#("state", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case district {
                          Some(v) -> [#("district", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case city {
                          Some(v) -> [#("city", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case line {
                        [] -> fields
                        _ -> [#("line", json.array(line,json.string)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.addresstype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case use_ {
                          Some(v) -> [#("use", r4valuesets.addressuse_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn address_decoder() -> Decoder(Address) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use country <- decode.optional_field("country", None, decode.optional(decode.string))
use postal_code <- decode.optional_field("postalCode", None, decode.optional(decode.string))
use state <- decode.optional_field("state", None, decode.optional(decode.string))
use district <- decode.optional_field("district", None, decode.optional(decode.string))
use city <- decode.optional_field("city", None, decode.optional(decode.string))
use line <- decode.optional_field("line", [], decode.list(decode.string))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.addresstype_decoder()))
use use_ <- decode.optional_field("use", None, decode.optional(r4valuesets.addressuse_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Address(period:,country:,postal_code:,state:,district:,city:,line:,text:,type_:,use_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Age#resource
pub type Age
{
Age(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn age_new() ->Age{Age(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn age_to_json(age: Age) -> Json {
    let Age(code:,system:,unit:,comparator:,value:,extension:,id:,) = age
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn age_decoder() -> Decoder(Age) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Age(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Annotation#resource
pub type Annotation
{
Annotation(id: Option(String),
extension: List(Extension),
author: Option(AnnotationAuthor),
time: Option(String),
text: String,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Annotation#resource
pub type AnnotationAuthor{
AnnotationAuthorReference(author: Reference)
AnnotationAuthorString(author: String)}
pub fn annotation_author_to_json(elt: AnnotationAuthor) -> Json {case elt{AnnotationAuthorReference(v) -> reference_to_json(v)
AnnotationAuthorString(v) -> json.string(v)
}}
pub fn annotation_author_decoder() -> Decoder(AnnotationAuthor){decode.one_of(decode.field("authorReference", reference_decoder(), decode.success) |> decode.map(AnnotationAuthorReference),[decode.field("authorString", decode.string, decode.success) |> decode.map(AnnotationAuthorString),])}
pub fn annotation_new(text text: String,) ->Annotation{Annotation(text:,time: None,author: None,extension: [],id: None,)
}

pub fn annotation_to_json(annotation: Annotation) -> Json {
    let Annotation(text:,time:,author:,extension:,id:,) = annotation
    let fields = [#("text", json.string(text)),]
let fields = case time {
                          Some(v) -> [#("time", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                          Some(v) -> [#("author", annotation_author_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn annotation_decoder() -> Decoder(Annotation) {use text <- decode.field("text",decode.string)
use time <- decode.optional_field("time", None, decode.optional(decode.string))
use author <- decode.then(none_if_omitted(annotation_author_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Annotation(text:,time:,author:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Attachment#resource
pub type Attachment
{
Attachment(id: Option(String),
extension: List(Extension),
content_type: Option(String),
language: Option(String),
data: Option(String),
url: Option(String),
size: Option(Int),
hash: Option(String),
title: Option(String),
creation: Option(String),
)
}

pub fn attachment_new() ->Attachment{Attachment(creation: None,title: None,hash: None,size: None,url: None,data: None,language: None,content_type: None,extension: [],id: None,)
}

pub fn attachment_to_json(attachment: Attachment) -> Json {
    let Attachment(creation:,title:,hash:,size:,url:,data:,language:,content_type:,extension:,id:,) = attachment
    let fields = []
let fields = case creation {
                          Some(v) -> [#("creation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case hash {
                          Some(v) -> [#("hash", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case size {
                          Some(v) -> [#("size", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case data {
                          Some(v) -> [#("data", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case content_type {
                          Some(v) -> [#("contentType", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn attachment_decoder() -> Decoder(Attachment) {use creation <- decode.optional_field("creation", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use hash <- decode.optional_field("hash", None, decode.optional(decode.string))
use size <- decode.optional_field("size", None, decode.optional(decode.int))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use data <- decode.optional_field("data", None, decode.optional(decode.string))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use content_type <- decode.optional_field("contentType", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Attachment(creation:,title:,hash:,size:,url:,data:,language:,content_type:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CodeableConcept#resource
pub type Codeableconcept
{
Codeableconcept(id: Option(String),
extension: List(Extension),
coding: List(Coding),
text: Option(String),
)
}

pub fn codeableconcept_new() ->Codeableconcept{Codeableconcept(text: None,coding: [],extension: [],id: None,)
}

pub fn codeableconcept_to_json(codeableconcept: Codeableconcept) -> Json {
    let Codeableconcept(text:,coding:,extension:,id:,) = codeableconcept
    let fields = []
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case coding {
                        [] -> fields
                        _ -> [#("coding", json.array(coding,coding_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codeableconcept_decoder() -> Decoder(Codeableconcept) {use text <- decode.optional_field("text", None, decode.optional(decode.string))
use coding <- decode.optional_field("coding", [], decode.list(coding_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Codeableconcept(text:,coding:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Coding#resource
pub type Coding
{
Coding(id: Option(String),
extension: List(Extension),
system: Option(String),
version: Option(String),
code: Option(String),
display: Option(String),
user_selected: Option(Bool),
)
}

pub fn coding_new() ->Coding{Coding(user_selected: None,display: None,code: None,version: None,system: None,extension: [],id: None,)
}

pub fn coding_to_json(coding: Coding) -> Json {
    let Coding(user_selected:,display:,code:,version:,system:,extension:,id:,) = coding
    let fields = []
let fields = case user_selected {
                          Some(v) -> [#("userSelected", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coding_decoder() -> Decoder(Coding) {use user_selected <- decode.optional_field("userSelected", None, decode.optional(decode.bool))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Coding(user_selected:,display:,code:,version:,system:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ContactDetail#resource
pub type Contactdetail
{
Contactdetail(id: Option(String),
extension: List(Extension),
name: Option(String),
telecom: List(Contactpoint),
)
}

pub fn contactdetail_new() ->Contactdetail{Contactdetail(telecom: [],name: None,extension: [],id: None,)
}

pub fn contactdetail_to_json(contactdetail: Contactdetail) -> Json {
    let Contactdetail(telecom:,name:,extension:,id:,) = contactdetail
    let fields = []
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contactdetail_decoder() -> Decoder(Contactdetail) {use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Contactdetail(telecom:,name:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ContactPoint#resource
pub type Contactpoint
{
Contactpoint(id: Option(String),
extension: List(Extension),
system: Option(r4valuesets.Contactpointsystem),
value: Option(String),
use_: Option(r4valuesets.Contactpointuse),
rank: Option(Int),
period: Option(Period),
)
}

pub fn contactpoint_new() ->Contactpoint{Contactpoint(period: None,rank: None,use_: None,value: None,system: None,extension: [],id: None,)
}

pub fn contactpoint_to_json(contactpoint: Contactpoint) -> Json {
    let Contactpoint(period:,rank:,use_:,value:,system:,extension:,id:,) = contactpoint
    let fields = []
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case rank {
                          Some(v) -> [#("rank", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case use_ {
                          Some(v) -> [#("use", r4valuesets.contactpointuse_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", r4valuesets.contactpointsystem_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contactpoint_decoder() -> Decoder(Contactpoint) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
use use_ <- decode.optional_field("use", None, decode.optional(r4valuesets.contactpointuse_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(r4valuesets.contactpointsystem_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Contactpoint(period:,rank:,use_:,value:,system:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Contributor#resource
pub type Contributor
{
Contributor(id: Option(String),
extension: List(Extension),
type_: r4valuesets.Contributortype,
name: String,
contact: List(Contactdetail),
)
}

pub fn contributor_new(name name: String,type_ type_: r4valuesets.Contributortype,) ->Contributor{Contributor(contact: [],name:,type_:,extension: [],id: None,)
}

pub fn contributor_to_json(contributor: Contributor) -> Json {
    let Contributor(contact:,name:,type_:,extension:,id:,) = contributor
    let fields = [#("name", json.string(name)),#("type", r4valuesets.contributortype_to_json(type_)),]
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contributor_decoder() -> Decoder(Contributor) {use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use name <- decode.field("name",decode.string)
use type_ <- decode.field("type",r4valuesets.contributortype_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Contributor(contact:,name:,type_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Count#resource
pub type Count
{
Count(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn count_new() ->Count{Count(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn count_to_json(count: Count) -> Json {
    let Count(code:,system:,unit:,comparator:,value:,extension:,id:,) = count
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn count_decoder() -> Decoder(Count) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Count(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DataRequirement#resource
pub type Datarequirement
{
Datarequirement(id: Option(String),
extension: List(Extension),
type_: r4valuesets.Alltypes,
profile: List(String),
subject: Option(DatarequirementSubject),
must_support: List(String),
code_filter: List(Element),
date_filter: List(Element),
limit: Option(Int),
sort: List(Element),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DataRequirement#resource
pub type DatarequirementSubject{
DatarequirementSubjectCodeableconcept(subject: Codeableconcept)
DatarequirementSubjectReference(subject: Reference)}
pub fn datarequirement_subject_to_json(elt: DatarequirementSubject) -> Json {case elt{DatarequirementSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
DatarequirementSubjectReference(v) -> reference_to_json(v)
}}
pub fn datarequirement_subject_decoder() -> Decoder(DatarequirementSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(DatarequirementSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(DatarequirementSubjectReference),])}
pub fn datarequirement_new(type_ type_: r4valuesets.Alltypes,) ->Datarequirement{Datarequirement(sort: [],limit: None,date_filter: [],code_filter: [],must_support: [],subject: None,profile: [],type_:,extension: [],id: None,)
}

pub fn datarequirement_to_json(datarequirement: Datarequirement) -> Json {
    let Datarequirement(sort:,limit:,date_filter:,code_filter:,must_support:,subject:,profile:,type_:,extension:,id:,) = datarequirement
    let fields = [#("type", r4valuesets.alltypes_to_json(type_)),]
let fields = case sort {
                        [] -> fields
                        _ -> [#("sort", json.array(sort,element_to_json)), ..fields]
                          }
let fields = case limit {
                          Some(v) -> [#("limit", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case date_filter {
                        [] -> fields
                        _ -> [#("dateFilter", json.array(date_filter,element_to_json)), ..fields]
                          }
let fields = case code_filter {
                        [] -> fields
                        _ -> [#("codeFilter", json.array(code_filter,element_to_json)), ..fields]
                          }
let fields = case must_support {
                        [] -> fields
                        _ -> [#("mustSupport", json.array(must_support,json.string)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", datarequirement_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case profile {
                        [] -> fields
                        _ -> [#("profile", json.array(profile,json.string)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn datarequirement_decoder() -> Decoder(Datarequirement) {use sort <- decode.optional_field("sort", [], decode.list(element_decoder()))
use limit <- decode.optional_field("limit", None, decode.optional(decode.int))
use date_filter <- decode.optional_field("dateFilter", [], decode.list(element_decoder()))
use code_filter <- decode.optional_field("codeFilter", [], decode.list(element_decoder()))
use must_support <- decode.optional_field("mustSupport", [], decode.list(decode.string))
use subject <- decode.then(none_if_omitted(datarequirement_subject_decoder()))
use profile <- decode.optional_field("profile", [], decode.list(decode.string))
use type_ <- decode.field("type",r4valuesets.alltypes_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Datarequirement(sort:,limit:,date_filter:,code_filter:,must_support:,subject:,profile:,type_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Distance#resource
pub type Distance
{
Distance(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn distance_new() ->Distance{Distance(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn distance_to_json(distance: Distance) -> Json {
    let Distance(code:,system:,unit:,comparator:,value:,extension:,id:,) = distance
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn distance_decoder() -> Decoder(Distance) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Distance(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Dosage#resource
pub type Dosage
{
Dosage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Option(Int),
text: Option(String),
additional_instruction: List(Codeableconcept),
patient_instruction: Option(String),
timing: Option(Timing),
as_needed: Option(DosageAsneeded),
site: Option(Codeableconcept),
route: Option(Codeableconcept),
method: Option(Codeableconcept),
dose_and_rate: List(Element),
max_dose_per_period: Option(Ratio),
max_dose_per_administration: Option(Quantity),
max_dose_per_lifetime: Option(Quantity),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Dosage#resource
pub type DosageAsneeded{
DosageAsneededBoolean(as_needed: Bool)
DosageAsneededCodeableconcept(as_needed: Codeableconcept)}
pub fn dosage_asneeded_to_json(elt: DosageAsneeded) -> Json {case elt{DosageAsneededBoolean(v) -> json.bool(v)
DosageAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn dosage_asneeded_decoder() -> Decoder(DosageAsneeded){decode.one_of(decode.field("asNeededBoolean", decode.bool, decode.success) |> decode.map(DosageAsneededBoolean),[decode.field("asNeededCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(DosageAsneededCodeableconcept),])}
pub fn dosage_new() ->Dosage{Dosage(max_dose_per_lifetime: None,max_dose_per_administration: None,max_dose_per_period: None,dose_and_rate: [],method: None,route: None,site: None,as_needed: None,timing: None,patient_instruction: None,additional_instruction: [],text: None,sequence: None,modifier_extension: [],extension: [],id: None,)
}

pub fn dosage_to_json(dosage: Dosage) -> Json {
    let Dosage(max_dose_per_lifetime:,max_dose_per_administration:,max_dose_per_period:,dose_and_rate:,method:,route:,site:,as_needed:,timing:,patient_instruction:,additional_instruction:,text:,sequence:,modifier_extension:,extension:,id:,) = dosage
    let fields = []
let fields = case max_dose_per_lifetime {
                          Some(v) -> [#("maxDosePerLifetime", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max_dose_per_administration {
                          Some(v) -> [#("maxDosePerAdministration", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max_dose_per_period {
                          Some(v) -> [#("maxDosePerPeriod", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dose_and_rate {
                        [] -> fields
                        _ -> [#("doseAndRate", json.array(dose_and_rate,element_to_json)), ..fields]
                          }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case route {
                          Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case site {
                          Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case as_needed {
                          Some(v) -> [#("asNeeded", dosage_asneeded_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case timing {
                          Some(v) -> [#("timing", timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case patient_instruction {
                          Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case additional_instruction {
                        [] -> fields
                        _ -> [#("additionalInstruction", json.array(additional_instruction,codeableconcept_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence {
                          Some(v) -> [#("sequence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn dosage_decoder() -> Decoder(Dosage) {use max_dose_per_lifetime <- decode.optional_field("maxDosePerLifetime", None, decode.optional(quantity_decoder()))
use max_dose_per_administration <- decode.optional_field("maxDosePerAdministration", None, decode.optional(quantity_decoder()))
use max_dose_per_period <- decode.optional_field("maxDosePerPeriod", None, decode.optional(ratio_decoder()))
use dose_and_rate <- decode.optional_field("doseAndRate", [], decode.list(element_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use route <- decode.optional_field("route", None, decode.optional(codeableconcept_decoder()))
use site <- decode.optional_field("site", None, decode.optional(codeableconcept_decoder()))
use as_needed <- decode.then(none_if_omitted(dosage_asneeded_decoder()))
use timing <- decode.optional_field("timing", None, decode.optional(timing_decoder()))
use patient_instruction <- decode.optional_field("patientInstruction", None, decode.optional(decode.string))
use additional_instruction <- decode.optional_field("additionalInstruction", [], decode.list(codeableconcept_decoder()))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use sequence <- decode.optional_field("sequence", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Dosage(max_dose_per_lifetime:,max_dose_per_administration:,max_dose_per_period:,dose_and_rate:,method:,route:,site:,as_needed:,timing:,patient_instruction:,additional_instruction:,text:,sequence:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Duration#resource
pub type Duration
{
Duration(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn duration_new() ->Duration{Duration(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn duration_to_json(duration: Duration) -> Json {
    let Duration(code:,system:,unit:,comparator:,value:,extension:,id:,) = duration
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn duration_decoder() -> Decoder(Duration) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Duration(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type Elementdefinition
{
Elementdefinition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
path: String,
representation: List(r4valuesets.Propertyrepresentation),
slice_name: Option(String),
slice_is_constraining: Option(Bool),
label: Option(String),
code: List(Coding),
slicing: Option(Element),
short: Option(String),
definition: Option(String),
comment: Option(String),
requirements: Option(String),
alias: List(String),
min: Option(Int),
max: Option(String),
base: Option(Element),
content_reference: Option(String),
type_: List(Element),
default_value: Option(ElementdefinitionDefaultvalue),
meaning_when_missing: Option(String),
order_meaning: Option(String),
fixed: Option(ElementdefinitionFixed),
pattern: Option(ElementdefinitionPattern),
example: List(Element),
min_value: Option(ElementdefinitionMinvalue),
max_value: Option(ElementdefinitionMaxvalue),
max_length: Option(Int),
condition: List(String),
constraint: List(Element),
must_support: Option(Bool),
is_modifier: Option(Bool),
is_modifier_reason: Option(String),
is_summary: Option(Bool),
binding: Option(Element),
mapping: List(Element),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionDefaultvalue{
ElementdefinitionDefaultvalueBase64binary(default_value: String)
ElementdefinitionDefaultvalueBoolean(default_value: Bool)
ElementdefinitionDefaultvalueCanonical(default_value: String)
ElementdefinitionDefaultvalueCode(default_value: String)
ElementdefinitionDefaultvalueDate(default_value: String)
ElementdefinitionDefaultvalueDatetime(default_value: String)
ElementdefinitionDefaultvalueDecimal(default_value: Float)
ElementdefinitionDefaultvalueId(default_value: String)
ElementdefinitionDefaultvalueInstant(default_value: String)
ElementdefinitionDefaultvalueInteger(default_value: Int)
ElementdefinitionDefaultvalueMarkdown(default_value: String)
ElementdefinitionDefaultvalueOid(default_value: String)
ElementdefinitionDefaultvaluePositiveint(default_value: Int)
ElementdefinitionDefaultvalueString(default_value: String)
ElementdefinitionDefaultvalueTime(default_value: String)
ElementdefinitionDefaultvalueUnsignedint(default_value: Int)
ElementdefinitionDefaultvalueUri(default_value: String)
ElementdefinitionDefaultvalueUrl(default_value: String)
ElementdefinitionDefaultvalueUuid(default_value: String)
ElementdefinitionDefaultvalueAddress(default_value: Address)
ElementdefinitionDefaultvalueAge(default_value: Age)
ElementdefinitionDefaultvalueAnnotation(default_value: Annotation)
ElementdefinitionDefaultvalueAttachment(default_value: Attachment)
ElementdefinitionDefaultvalueCodeableconcept(default_value: Codeableconcept)
ElementdefinitionDefaultvalueCoding(default_value: Coding)
ElementdefinitionDefaultvalueContactpoint(default_value: Contactpoint)
ElementdefinitionDefaultvalueCount(default_value: Count)
ElementdefinitionDefaultvalueDistance(default_value: Distance)
ElementdefinitionDefaultvalueDuration(default_value: Duration)
ElementdefinitionDefaultvalueHumanname(default_value: Humanname)
ElementdefinitionDefaultvalueIdentifier(default_value: Identifier)
ElementdefinitionDefaultvalueMoney(default_value: Money)
ElementdefinitionDefaultvaluePeriod(default_value: Period)
ElementdefinitionDefaultvalueQuantity(default_value: Quantity)
ElementdefinitionDefaultvalueRange(default_value: Range)
ElementdefinitionDefaultvalueRatio(default_value: Ratio)
ElementdefinitionDefaultvalueReference(default_value: Reference)
ElementdefinitionDefaultvalueSampleddata(default_value: Sampleddata)
ElementdefinitionDefaultvalueSignature(default_value: Signature)
ElementdefinitionDefaultvalueTiming(default_value: Timing)
ElementdefinitionDefaultvalueContactdetail(default_value: Contactdetail)
ElementdefinitionDefaultvalueContributor(default_value: Contributor)
ElementdefinitionDefaultvalueDatarequirement(default_value: Datarequirement)
ElementdefinitionDefaultvalueExpression(default_value: Expression)
ElementdefinitionDefaultvalueParameterdefinition(default_value: Parameterdefinition)
ElementdefinitionDefaultvalueRelatedartifact(default_value: Relatedartifact)
ElementdefinitionDefaultvalueTriggerdefinition(default_value: Triggerdefinition)
ElementdefinitionDefaultvalueUsagecontext(default_value: Usagecontext)
ElementdefinitionDefaultvalueDosage(default_value: Dosage)
ElementdefinitionDefaultvalueMeta(default_value: Meta)}
pub fn elementdefinition_defaultvalue_to_json(elt: ElementdefinitionDefaultvalue) -> Json {case elt{ElementdefinitionDefaultvalueBase64binary(v) -> json.string(v)
ElementdefinitionDefaultvalueBoolean(v) -> json.bool(v)
ElementdefinitionDefaultvalueCanonical(v) -> json.string(v)
ElementdefinitionDefaultvalueCode(v) -> json.string(v)
ElementdefinitionDefaultvalueDate(v) -> json.string(v)
ElementdefinitionDefaultvalueDatetime(v) -> json.string(v)
ElementdefinitionDefaultvalueDecimal(v) -> json.float(v)
ElementdefinitionDefaultvalueId(v) -> json.string(v)
ElementdefinitionDefaultvalueInstant(v) -> json.string(v)
ElementdefinitionDefaultvalueInteger(v) -> json.int(v)
ElementdefinitionDefaultvalueMarkdown(v) -> json.string(v)
ElementdefinitionDefaultvalueOid(v) -> json.string(v)
ElementdefinitionDefaultvaluePositiveint(v) -> json.int(v)
ElementdefinitionDefaultvalueString(v) -> json.string(v)
ElementdefinitionDefaultvalueTime(v) -> json.string(v)
ElementdefinitionDefaultvalueUnsignedint(v) -> json.int(v)
ElementdefinitionDefaultvalueUri(v) -> json.string(v)
ElementdefinitionDefaultvalueUrl(v) -> json.string(v)
ElementdefinitionDefaultvalueUuid(v) -> json.string(v)
ElementdefinitionDefaultvalueAddress(v) -> address_to_json(v)
ElementdefinitionDefaultvalueAge(v) -> age_to_json(v)
ElementdefinitionDefaultvalueAnnotation(v) -> annotation_to_json(v)
ElementdefinitionDefaultvalueAttachment(v) -> attachment_to_json(v)
ElementdefinitionDefaultvalueCodeableconcept(v) -> codeableconcept_to_json(v)
ElementdefinitionDefaultvalueCoding(v) -> coding_to_json(v)
ElementdefinitionDefaultvalueContactpoint(v) -> contactpoint_to_json(v)
ElementdefinitionDefaultvalueCount(v) -> count_to_json(v)
ElementdefinitionDefaultvalueDistance(v) -> distance_to_json(v)
ElementdefinitionDefaultvalueDuration(v) -> duration_to_json(v)
ElementdefinitionDefaultvalueHumanname(v) -> humanname_to_json(v)
ElementdefinitionDefaultvalueIdentifier(v) -> identifier_to_json(v)
ElementdefinitionDefaultvalueMoney(v) -> money_to_json(v)
ElementdefinitionDefaultvaluePeriod(v) -> period_to_json(v)
ElementdefinitionDefaultvalueQuantity(v) -> quantity_to_json(v)
ElementdefinitionDefaultvalueRange(v) -> range_to_json(v)
ElementdefinitionDefaultvalueRatio(v) -> ratio_to_json(v)
ElementdefinitionDefaultvalueReference(v) -> reference_to_json(v)
ElementdefinitionDefaultvalueSampleddata(v) -> sampleddata_to_json(v)
ElementdefinitionDefaultvalueSignature(v) -> signature_to_json(v)
ElementdefinitionDefaultvalueTiming(v) -> timing_to_json(v)
ElementdefinitionDefaultvalueContactdetail(v) -> contactdetail_to_json(v)
ElementdefinitionDefaultvalueContributor(v) -> contributor_to_json(v)
ElementdefinitionDefaultvalueDatarequirement(v) -> datarequirement_to_json(v)
ElementdefinitionDefaultvalueExpression(v) -> expression_to_json(v)
ElementdefinitionDefaultvalueParameterdefinition(v) -> parameterdefinition_to_json(v)
ElementdefinitionDefaultvalueRelatedartifact(v) -> relatedartifact_to_json(v)
ElementdefinitionDefaultvalueTriggerdefinition(v) -> triggerdefinition_to_json(v)
ElementdefinitionDefaultvalueUsagecontext(v) -> usagecontext_to_json(v)
ElementdefinitionDefaultvalueDosage(v) -> dosage_to_json(v)
ElementdefinitionDefaultvalueMeta(v) -> meta_to_json(v)
}}
pub fn elementdefinition_defaultvalue_decoder() -> Decoder(ElementdefinitionDefaultvalue){decode.one_of(decode.field("defaultValueBase64Binary", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueBase64binary),[decode.field("defaultValueBoolean", decode.bool, decode.success) |> decode.map(ElementdefinitionDefaultvalueBoolean),decode.field("defaultValueCanonical", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueCanonical),decode.field("defaultValueCode", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueCode),decode.field("defaultValueDate", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueDate),decode.field("defaultValueDateTime", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueDatetime),decode.field("defaultValueDecimal", decode.float, decode.success) |> decode.map(ElementdefinitionDefaultvalueDecimal),decode.field("defaultValueId", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueId),decode.field("defaultValueInstant", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueInstant),decode.field("defaultValueInteger", decode.int, decode.success) |> decode.map(ElementdefinitionDefaultvalueInteger),decode.field("defaultValueMarkdown", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueMarkdown),decode.field("defaultValueOid", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueOid),decode.field("defaultValuePositiveInt", decode.int, decode.success) |> decode.map(ElementdefinitionDefaultvaluePositiveint),decode.field("defaultValueString", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueString),decode.field("defaultValueTime", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueTime),decode.field("defaultValueUnsignedInt", decode.int, decode.success) |> decode.map(ElementdefinitionDefaultvalueUnsignedint),decode.field("defaultValueUri", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueUri),decode.field("defaultValueUrl", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueUrl),decode.field("defaultValueUuid", decode.string, decode.success) |> decode.map(ElementdefinitionDefaultvalueUuid),decode.field("defaultValueAddress", address_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueAddress),decode.field("defaultValueAge", age_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueAge),decode.field("defaultValueAnnotation", annotation_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueAnnotation),decode.field("defaultValueAttachment", attachment_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueAttachment),decode.field("defaultValueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueCodeableconcept),decode.field("defaultValueCoding", coding_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueCoding),decode.field("defaultValueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueContactpoint),decode.field("defaultValueCount", count_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueCount),decode.field("defaultValueDistance", distance_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueDistance),decode.field("defaultValueDuration", duration_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueDuration),decode.field("defaultValueHumanName", humanname_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueHumanname),decode.field("defaultValueIdentifier", identifier_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueIdentifier),decode.field("defaultValueMoney", money_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueMoney),decode.field("defaultValuePeriod", period_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvaluePeriod),decode.field("defaultValueQuantity", quantity_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueQuantity),decode.field("defaultValueRange", range_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueRange),decode.field("defaultValueRatio", ratio_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueRatio),decode.field("defaultValueReference", reference_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueReference),decode.field("defaultValueSampledData", sampleddata_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueSampleddata),decode.field("defaultValueSignature", signature_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueSignature),decode.field("defaultValueTiming", timing_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueTiming),decode.field("defaultValueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueContactdetail),decode.field("defaultValueContributor", contributor_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueContributor),decode.field("defaultValueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueDatarequirement),decode.field("defaultValueExpression", expression_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueExpression),decode.field("defaultValueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueParameterdefinition),decode.field("defaultValueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueRelatedartifact),decode.field("defaultValueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueTriggerdefinition),decode.field("defaultValueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueUsagecontext),decode.field("defaultValueDosage", dosage_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueDosage),decode.field("defaultValueMeta", meta_decoder(), decode.success) |> decode.map(ElementdefinitionDefaultvalueMeta),])}

///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionFixed{
ElementdefinitionFixedBase64binary(fixed: String)
ElementdefinitionFixedBoolean(fixed: Bool)
ElementdefinitionFixedCanonical(fixed: String)
ElementdefinitionFixedCode(fixed: String)
ElementdefinitionFixedDate(fixed: String)
ElementdefinitionFixedDatetime(fixed: String)
ElementdefinitionFixedDecimal(fixed: Float)
ElementdefinitionFixedId(fixed: String)
ElementdefinitionFixedInstant(fixed: String)
ElementdefinitionFixedInteger(fixed: Int)
ElementdefinitionFixedMarkdown(fixed: String)
ElementdefinitionFixedOid(fixed: String)
ElementdefinitionFixedPositiveint(fixed: Int)
ElementdefinitionFixedString(fixed: String)
ElementdefinitionFixedTime(fixed: String)
ElementdefinitionFixedUnsignedint(fixed: Int)
ElementdefinitionFixedUri(fixed: String)
ElementdefinitionFixedUrl(fixed: String)
ElementdefinitionFixedUuid(fixed: String)
ElementdefinitionFixedAddress(fixed: Address)
ElementdefinitionFixedAge(fixed: Age)
ElementdefinitionFixedAnnotation(fixed: Annotation)
ElementdefinitionFixedAttachment(fixed: Attachment)
ElementdefinitionFixedCodeableconcept(fixed: Codeableconcept)
ElementdefinitionFixedCoding(fixed: Coding)
ElementdefinitionFixedContactpoint(fixed: Contactpoint)
ElementdefinitionFixedCount(fixed: Count)
ElementdefinitionFixedDistance(fixed: Distance)
ElementdefinitionFixedDuration(fixed: Duration)
ElementdefinitionFixedHumanname(fixed: Humanname)
ElementdefinitionFixedIdentifier(fixed: Identifier)
ElementdefinitionFixedMoney(fixed: Money)
ElementdefinitionFixedPeriod(fixed: Period)
ElementdefinitionFixedQuantity(fixed: Quantity)
ElementdefinitionFixedRange(fixed: Range)
ElementdefinitionFixedRatio(fixed: Ratio)
ElementdefinitionFixedReference(fixed: Reference)
ElementdefinitionFixedSampleddata(fixed: Sampleddata)
ElementdefinitionFixedSignature(fixed: Signature)
ElementdefinitionFixedTiming(fixed: Timing)
ElementdefinitionFixedContactdetail(fixed: Contactdetail)
ElementdefinitionFixedContributor(fixed: Contributor)
ElementdefinitionFixedDatarequirement(fixed: Datarequirement)
ElementdefinitionFixedExpression(fixed: Expression)
ElementdefinitionFixedParameterdefinition(fixed: Parameterdefinition)
ElementdefinitionFixedRelatedartifact(fixed: Relatedartifact)
ElementdefinitionFixedTriggerdefinition(fixed: Triggerdefinition)
ElementdefinitionFixedUsagecontext(fixed: Usagecontext)
ElementdefinitionFixedDosage(fixed: Dosage)
ElementdefinitionFixedMeta(fixed: Meta)}
pub fn elementdefinition_fixed_to_json(elt: ElementdefinitionFixed) -> Json {case elt{ElementdefinitionFixedBase64binary(v) -> json.string(v)
ElementdefinitionFixedBoolean(v) -> json.bool(v)
ElementdefinitionFixedCanonical(v) -> json.string(v)
ElementdefinitionFixedCode(v) -> json.string(v)
ElementdefinitionFixedDate(v) -> json.string(v)
ElementdefinitionFixedDatetime(v) -> json.string(v)
ElementdefinitionFixedDecimal(v) -> json.float(v)
ElementdefinitionFixedId(v) -> json.string(v)
ElementdefinitionFixedInstant(v) -> json.string(v)
ElementdefinitionFixedInteger(v) -> json.int(v)
ElementdefinitionFixedMarkdown(v) -> json.string(v)
ElementdefinitionFixedOid(v) -> json.string(v)
ElementdefinitionFixedPositiveint(v) -> json.int(v)
ElementdefinitionFixedString(v) -> json.string(v)
ElementdefinitionFixedTime(v) -> json.string(v)
ElementdefinitionFixedUnsignedint(v) -> json.int(v)
ElementdefinitionFixedUri(v) -> json.string(v)
ElementdefinitionFixedUrl(v) -> json.string(v)
ElementdefinitionFixedUuid(v) -> json.string(v)
ElementdefinitionFixedAddress(v) -> address_to_json(v)
ElementdefinitionFixedAge(v) -> age_to_json(v)
ElementdefinitionFixedAnnotation(v) -> annotation_to_json(v)
ElementdefinitionFixedAttachment(v) -> attachment_to_json(v)
ElementdefinitionFixedCodeableconcept(v) -> codeableconcept_to_json(v)
ElementdefinitionFixedCoding(v) -> coding_to_json(v)
ElementdefinitionFixedContactpoint(v) -> contactpoint_to_json(v)
ElementdefinitionFixedCount(v) -> count_to_json(v)
ElementdefinitionFixedDistance(v) -> distance_to_json(v)
ElementdefinitionFixedDuration(v) -> duration_to_json(v)
ElementdefinitionFixedHumanname(v) -> humanname_to_json(v)
ElementdefinitionFixedIdentifier(v) -> identifier_to_json(v)
ElementdefinitionFixedMoney(v) -> money_to_json(v)
ElementdefinitionFixedPeriod(v) -> period_to_json(v)
ElementdefinitionFixedQuantity(v) -> quantity_to_json(v)
ElementdefinitionFixedRange(v) -> range_to_json(v)
ElementdefinitionFixedRatio(v) -> ratio_to_json(v)
ElementdefinitionFixedReference(v) -> reference_to_json(v)
ElementdefinitionFixedSampleddata(v) -> sampleddata_to_json(v)
ElementdefinitionFixedSignature(v) -> signature_to_json(v)
ElementdefinitionFixedTiming(v) -> timing_to_json(v)
ElementdefinitionFixedContactdetail(v) -> contactdetail_to_json(v)
ElementdefinitionFixedContributor(v) -> contributor_to_json(v)
ElementdefinitionFixedDatarequirement(v) -> datarequirement_to_json(v)
ElementdefinitionFixedExpression(v) -> expression_to_json(v)
ElementdefinitionFixedParameterdefinition(v) -> parameterdefinition_to_json(v)
ElementdefinitionFixedRelatedartifact(v) -> relatedartifact_to_json(v)
ElementdefinitionFixedTriggerdefinition(v) -> triggerdefinition_to_json(v)
ElementdefinitionFixedUsagecontext(v) -> usagecontext_to_json(v)
ElementdefinitionFixedDosage(v) -> dosage_to_json(v)
ElementdefinitionFixedMeta(v) -> meta_to_json(v)
}}
pub fn elementdefinition_fixed_decoder() -> Decoder(ElementdefinitionFixed){decode.one_of(decode.field("fixedBase64Binary", decode.string, decode.success) |> decode.map(ElementdefinitionFixedBase64binary),[decode.field("fixedBoolean", decode.bool, decode.success) |> decode.map(ElementdefinitionFixedBoolean),decode.field("fixedCanonical", decode.string, decode.success) |> decode.map(ElementdefinitionFixedCanonical),decode.field("fixedCode", decode.string, decode.success) |> decode.map(ElementdefinitionFixedCode),decode.field("fixedDate", decode.string, decode.success) |> decode.map(ElementdefinitionFixedDate),decode.field("fixedDateTime", decode.string, decode.success) |> decode.map(ElementdefinitionFixedDatetime),decode.field("fixedDecimal", decode.float, decode.success) |> decode.map(ElementdefinitionFixedDecimal),decode.field("fixedId", decode.string, decode.success) |> decode.map(ElementdefinitionFixedId),decode.field("fixedInstant", decode.string, decode.success) |> decode.map(ElementdefinitionFixedInstant),decode.field("fixedInteger", decode.int, decode.success) |> decode.map(ElementdefinitionFixedInteger),decode.field("fixedMarkdown", decode.string, decode.success) |> decode.map(ElementdefinitionFixedMarkdown),decode.field("fixedOid", decode.string, decode.success) |> decode.map(ElementdefinitionFixedOid),decode.field("fixedPositiveInt", decode.int, decode.success) |> decode.map(ElementdefinitionFixedPositiveint),decode.field("fixedString", decode.string, decode.success) |> decode.map(ElementdefinitionFixedString),decode.field("fixedTime", decode.string, decode.success) |> decode.map(ElementdefinitionFixedTime),decode.field("fixedUnsignedInt", decode.int, decode.success) |> decode.map(ElementdefinitionFixedUnsignedint),decode.field("fixedUri", decode.string, decode.success) |> decode.map(ElementdefinitionFixedUri),decode.field("fixedUrl", decode.string, decode.success) |> decode.map(ElementdefinitionFixedUrl),decode.field("fixedUuid", decode.string, decode.success) |> decode.map(ElementdefinitionFixedUuid),decode.field("fixedAddress", address_decoder(), decode.success) |> decode.map(ElementdefinitionFixedAddress),decode.field("fixedAge", age_decoder(), decode.success) |> decode.map(ElementdefinitionFixedAge),decode.field("fixedAnnotation", annotation_decoder(), decode.success) |> decode.map(ElementdefinitionFixedAnnotation),decode.field("fixedAttachment", attachment_decoder(), decode.success) |> decode.map(ElementdefinitionFixedAttachment),decode.field("fixedCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ElementdefinitionFixedCodeableconcept),decode.field("fixedCoding", coding_decoder(), decode.success) |> decode.map(ElementdefinitionFixedCoding),decode.field("fixedContactPoint", contactpoint_decoder(), decode.success) |> decode.map(ElementdefinitionFixedContactpoint),decode.field("fixedCount", count_decoder(), decode.success) |> decode.map(ElementdefinitionFixedCount),decode.field("fixedDistance", distance_decoder(), decode.success) |> decode.map(ElementdefinitionFixedDistance),decode.field("fixedDuration", duration_decoder(), decode.success) |> decode.map(ElementdefinitionFixedDuration),decode.field("fixedHumanName", humanname_decoder(), decode.success) |> decode.map(ElementdefinitionFixedHumanname),decode.field("fixedIdentifier", identifier_decoder(), decode.success) |> decode.map(ElementdefinitionFixedIdentifier),decode.field("fixedMoney", money_decoder(), decode.success) |> decode.map(ElementdefinitionFixedMoney),decode.field("fixedPeriod", period_decoder(), decode.success) |> decode.map(ElementdefinitionFixedPeriod),decode.field("fixedQuantity", quantity_decoder(), decode.success) |> decode.map(ElementdefinitionFixedQuantity),decode.field("fixedRange", range_decoder(), decode.success) |> decode.map(ElementdefinitionFixedRange),decode.field("fixedRatio", ratio_decoder(), decode.success) |> decode.map(ElementdefinitionFixedRatio),decode.field("fixedReference", reference_decoder(), decode.success) |> decode.map(ElementdefinitionFixedReference),decode.field("fixedSampledData", sampleddata_decoder(), decode.success) |> decode.map(ElementdefinitionFixedSampleddata),decode.field("fixedSignature", signature_decoder(), decode.success) |> decode.map(ElementdefinitionFixedSignature),decode.field("fixedTiming", timing_decoder(), decode.success) |> decode.map(ElementdefinitionFixedTiming),decode.field("fixedContactDetail", contactdetail_decoder(), decode.success) |> decode.map(ElementdefinitionFixedContactdetail),decode.field("fixedContributor", contributor_decoder(), decode.success) |> decode.map(ElementdefinitionFixedContributor),decode.field("fixedDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ElementdefinitionFixedDatarequirement),decode.field("fixedExpression", expression_decoder(), decode.success) |> decode.map(ElementdefinitionFixedExpression),decode.field("fixedParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionFixedParameterdefinition),decode.field("fixedRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(ElementdefinitionFixedRelatedartifact),decode.field("fixedTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionFixedTriggerdefinition),decode.field("fixedUsageContext", usagecontext_decoder(), decode.success) |> decode.map(ElementdefinitionFixedUsagecontext),decode.field("fixedDosage", dosage_decoder(), decode.success) |> decode.map(ElementdefinitionFixedDosage),decode.field("fixedMeta", meta_decoder(), decode.success) |> decode.map(ElementdefinitionFixedMeta),])}

///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionPattern{
ElementdefinitionPatternBase64binary(pattern: String)
ElementdefinitionPatternBoolean(pattern: Bool)
ElementdefinitionPatternCanonical(pattern: String)
ElementdefinitionPatternCode(pattern: String)
ElementdefinitionPatternDate(pattern: String)
ElementdefinitionPatternDatetime(pattern: String)
ElementdefinitionPatternDecimal(pattern: Float)
ElementdefinitionPatternId(pattern: String)
ElementdefinitionPatternInstant(pattern: String)
ElementdefinitionPatternInteger(pattern: Int)
ElementdefinitionPatternMarkdown(pattern: String)
ElementdefinitionPatternOid(pattern: String)
ElementdefinitionPatternPositiveint(pattern: Int)
ElementdefinitionPatternString(pattern: String)
ElementdefinitionPatternTime(pattern: String)
ElementdefinitionPatternUnsignedint(pattern: Int)
ElementdefinitionPatternUri(pattern: String)
ElementdefinitionPatternUrl(pattern: String)
ElementdefinitionPatternUuid(pattern: String)
ElementdefinitionPatternAddress(pattern: Address)
ElementdefinitionPatternAge(pattern: Age)
ElementdefinitionPatternAnnotation(pattern: Annotation)
ElementdefinitionPatternAttachment(pattern: Attachment)
ElementdefinitionPatternCodeableconcept(pattern: Codeableconcept)
ElementdefinitionPatternCoding(pattern: Coding)
ElementdefinitionPatternContactpoint(pattern: Contactpoint)
ElementdefinitionPatternCount(pattern: Count)
ElementdefinitionPatternDistance(pattern: Distance)
ElementdefinitionPatternDuration(pattern: Duration)
ElementdefinitionPatternHumanname(pattern: Humanname)
ElementdefinitionPatternIdentifier(pattern: Identifier)
ElementdefinitionPatternMoney(pattern: Money)
ElementdefinitionPatternPeriod(pattern: Period)
ElementdefinitionPatternQuantity(pattern: Quantity)
ElementdefinitionPatternRange(pattern: Range)
ElementdefinitionPatternRatio(pattern: Ratio)
ElementdefinitionPatternReference(pattern: Reference)
ElementdefinitionPatternSampleddata(pattern: Sampleddata)
ElementdefinitionPatternSignature(pattern: Signature)
ElementdefinitionPatternTiming(pattern: Timing)
ElementdefinitionPatternContactdetail(pattern: Contactdetail)
ElementdefinitionPatternContributor(pattern: Contributor)
ElementdefinitionPatternDatarequirement(pattern: Datarequirement)
ElementdefinitionPatternExpression(pattern: Expression)
ElementdefinitionPatternParameterdefinition(pattern: Parameterdefinition)
ElementdefinitionPatternRelatedartifact(pattern: Relatedartifact)
ElementdefinitionPatternTriggerdefinition(pattern: Triggerdefinition)
ElementdefinitionPatternUsagecontext(pattern: Usagecontext)
ElementdefinitionPatternDosage(pattern: Dosage)
ElementdefinitionPatternMeta(pattern: Meta)}
pub fn elementdefinition_pattern_to_json(elt: ElementdefinitionPattern) -> Json {case elt{ElementdefinitionPatternBase64binary(v) -> json.string(v)
ElementdefinitionPatternBoolean(v) -> json.bool(v)
ElementdefinitionPatternCanonical(v) -> json.string(v)
ElementdefinitionPatternCode(v) -> json.string(v)
ElementdefinitionPatternDate(v) -> json.string(v)
ElementdefinitionPatternDatetime(v) -> json.string(v)
ElementdefinitionPatternDecimal(v) -> json.float(v)
ElementdefinitionPatternId(v) -> json.string(v)
ElementdefinitionPatternInstant(v) -> json.string(v)
ElementdefinitionPatternInteger(v) -> json.int(v)
ElementdefinitionPatternMarkdown(v) -> json.string(v)
ElementdefinitionPatternOid(v) -> json.string(v)
ElementdefinitionPatternPositiveint(v) -> json.int(v)
ElementdefinitionPatternString(v) -> json.string(v)
ElementdefinitionPatternTime(v) -> json.string(v)
ElementdefinitionPatternUnsignedint(v) -> json.int(v)
ElementdefinitionPatternUri(v) -> json.string(v)
ElementdefinitionPatternUrl(v) -> json.string(v)
ElementdefinitionPatternUuid(v) -> json.string(v)
ElementdefinitionPatternAddress(v) -> address_to_json(v)
ElementdefinitionPatternAge(v) -> age_to_json(v)
ElementdefinitionPatternAnnotation(v) -> annotation_to_json(v)
ElementdefinitionPatternAttachment(v) -> attachment_to_json(v)
ElementdefinitionPatternCodeableconcept(v) -> codeableconcept_to_json(v)
ElementdefinitionPatternCoding(v) -> coding_to_json(v)
ElementdefinitionPatternContactpoint(v) -> contactpoint_to_json(v)
ElementdefinitionPatternCount(v) -> count_to_json(v)
ElementdefinitionPatternDistance(v) -> distance_to_json(v)
ElementdefinitionPatternDuration(v) -> duration_to_json(v)
ElementdefinitionPatternHumanname(v) -> humanname_to_json(v)
ElementdefinitionPatternIdentifier(v) -> identifier_to_json(v)
ElementdefinitionPatternMoney(v) -> money_to_json(v)
ElementdefinitionPatternPeriod(v) -> period_to_json(v)
ElementdefinitionPatternQuantity(v) -> quantity_to_json(v)
ElementdefinitionPatternRange(v) -> range_to_json(v)
ElementdefinitionPatternRatio(v) -> ratio_to_json(v)
ElementdefinitionPatternReference(v) -> reference_to_json(v)
ElementdefinitionPatternSampleddata(v) -> sampleddata_to_json(v)
ElementdefinitionPatternSignature(v) -> signature_to_json(v)
ElementdefinitionPatternTiming(v) -> timing_to_json(v)
ElementdefinitionPatternContactdetail(v) -> contactdetail_to_json(v)
ElementdefinitionPatternContributor(v) -> contributor_to_json(v)
ElementdefinitionPatternDatarequirement(v) -> datarequirement_to_json(v)
ElementdefinitionPatternExpression(v) -> expression_to_json(v)
ElementdefinitionPatternParameterdefinition(v) -> parameterdefinition_to_json(v)
ElementdefinitionPatternRelatedartifact(v) -> relatedartifact_to_json(v)
ElementdefinitionPatternTriggerdefinition(v) -> triggerdefinition_to_json(v)
ElementdefinitionPatternUsagecontext(v) -> usagecontext_to_json(v)
ElementdefinitionPatternDosage(v) -> dosage_to_json(v)
ElementdefinitionPatternMeta(v) -> meta_to_json(v)
}}
pub fn elementdefinition_pattern_decoder() -> Decoder(ElementdefinitionPattern){decode.one_of(decode.field("patternBase64Binary", decode.string, decode.success) |> decode.map(ElementdefinitionPatternBase64binary),[decode.field("patternBoolean", decode.bool, decode.success) |> decode.map(ElementdefinitionPatternBoolean),decode.field("patternCanonical", decode.string, decode.success) |> decode.map(ElementdefinitionPatternCanonical),decode.field("patternCode", decode.string, decode.success) |> decode.map(ElementdefinitionPatternCode),decode.field("patternDate", decode.string, decode.success) |> decode.map(ElementdefinitionPatternDate),decode.field("patternDateTime", decode.string, decode.success) |> decode.map(ElementdefinitionPatternDatetime),decode.field("patternDecimal", decode.float, decode.success) |> decode.map(ElementdefinitionPatternDecimal),decode.field("patternId", decode.string, decode.success) |> decode.map(ElementdefinitionPatternId),decode.field("patternInstant", decode.string, decode.success) |> decode.map(ElementdefinitionPatternInstant),decode.field("patternInteger", decode.int, decode.success) |> decode.map(ElementdefinitionPatternInteger),decode.field("patternMarkdown", decode.string, decode.success) |> decode.map(ElementdefinitionPatternMarkdown),decode.field("patternOid", decode.string, decode.success) |> decode.map(ElementdefinitionPatternOid),decode.field("patternPositiveInt", decode.int, decode.success) |> decode.map(ElementdefinitionPatternPositiveint),decode.field("patternString", decode.string, decode.success) |> decode.map(ElementdefinitionPatternString),decode.field("patternTime", decode.string, decode.success) |> decode.map(ElementdefinitionPatternTime),decode.field("patternUnsignedInt", decode.int, decode.success) |> decode.map(ElementdefinitionPatternUnsignedint),decode.field("patternUri", decode.string, decode.success) |> decode.map(ElementdefinitionPatternUri),decode.field("patternUrl", decode.string, decode.success) |> decode.map(ElementdefinitionPatternUrl),decode.field("patternUuid", decode.string, decode.success) |> decode.map(ElementdefinitionPatternUuid),decode.field("patternAddress", address_decoder(), decode.success) |> decode.map(ElementdefinitionPatternAddress),decode.field("patternAge", age_decoder(), decode.success) |> decode.map(ElementdefinitionPatternAge),decode.field("patternAnnotation", annotation_decoder(), decode.success) |> decode.map(ElementdefinitionPatternAnnotation),decode.field("patternAttachment", attachment_decoder(), decode.success) |> decode.map(ElementdefinitionPatternAttachment),decode.field("patternCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ElementdefinitionPatternCodeableconcept),decode.field("patternCoding", coding_decoder(), decode.success) |> decode.map(ElementdefinitionPatternCoding),decode.field("patternContactPoint", contactpoint_decoder(), decode.success) |> decode.map(ElementdefinitionPatternContactpoint),decode.field("patternCount", count_decoder(), decode.success) |> decode.map(ElementdefinitionPatternCount),decode.field("patternDistance", distance_decoder(), decode.success) |> decode.map(ElementdefinitionPatternDistance),decode.field("patternDuration", duration_decoder(), decode.success) |> decode.map(ElementdefinitionPatternDuration),decode.field("patternHumanName", humanname_decoder(), decode.success) |> decode.map(ElementdefinitionPatternHumanname),decode.field("patternIdentifier", identifier_decoder(), decode.success) |> decode.map(ElementdefinitionPatternIdentifier),decode.field("patternMoney", money_decoder(), decode.success) |> decode.map(ElementdefinitionPatternMoney),decode.field("patternPeriod", period_decoder(), decode.success) |> decode.map(ElementdefinitionPatternPeriod),decode.field("patternQuantity", quantity_decoder(), decode.success) |> decode.map(ElementdefinitionPatternQuantity),decode.field("patternRange", range_decoder(), decode.success) |> decode.map(ElementdefinitionPatternRange),decode.field("patternRatio", ratio_decoder(), decode.success) |> decode.map(ElementdefinitionPatternRatio),decode.field("patternReference", reference_decoder(), decode.success) |> decode.map(ElementdefinitionPatternReference),decode.field("patternSampledData", sampleddata_decoder(), decode.success) |> decode.map(ElementdefinitionPatternSampleddata),decode.field("patternSignature", signature_decoder(), decode.success) |> decode.map(ElementdefinitionPatternSignature),decode.field("patternTiming", timing_decoder(), decode.success) |> decode.map(ElementdefinitionPatternTiming),decode.field("patternContactDetail", contactdetail_decoder(), decode.success) |> decode.map(ElementdefinitionPatternContactdetail),decode.field("patternContributor", contributor_decoder(), decode.success) |> decode.map(ElementdefinitionPatternContributor),decode.field("patternDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ElementdefinitionPatternDatarequirement),decode.field("patternExpression", expression_decoder(), decode.success) |> decode.map(ElementdefinitionPatternExpression),decode.field("patternParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionPatternParameterdefinition),decode.field("patternRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(ElementdefinitionPatternRelatedartifact),decode.field("patternTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(ElementdefinitionPatternTriggerdefinition),decode.field("patternUsageContext", usagecontext_decoder(), decode.success) |> decode.map(ElementdefinitionPatternUsagecontext),decode.field("patternDosage", dosage_decoder(), decode.success) |> decode.map(ElementdefinitionPatternDosage),decode.field("patternMeta", meta_decoder(), decode.success) |> decode.map(ElementdefinitionPatternMeta),])}

///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMinvalue{
ElementdefinitionMinvalueDate(min_value: String)
ElementdefinitionMinvalueDatetime(min_value: String)
ElementdefinitionMinvalueInstant(min_value: String)
ElementdefinitionMinvalueTime(min_value: String)
ElementdefinitionMinvalueDecimal(min_value: Float)
ElementdefinitionMinvalueInteger(min_value: Int)
ElementdefinitionMinvaluePositiveint(min_value: Int)
ElementdefinitionMinvalueUnsignedint(min_value: Int)
ElementdefinitionMinvalueQuantity(min_value: Quantity)}
pub fn elementdefinition_minvalue_to_json(elt: ElementdefinitionMinvalue) -> Json {case elt{ElementdefinitionMinvalueDate(v) -> json.string(v)
ElementdefinitionMinvalueDatetime(v) -> json.string(v)
ElementdefinitionMinvalueInstant(v) -> json.string(v)
ElementdefinitionMinvalueTime(v) -> json.string(v)
ElementdefinitionMinvalueDecimal(v) -> json.float(v)
ElementdefinitionMinvalueInteger(v) -> json.int(v)
ElementdefinitionMinvaluePositiveint(v) -> json.int(v)
ElementdefinitionMinvalueUnsignedint(v) -> json.int(v)
ElementdefinitionMinvalueQuantity(v) -> quantity_to_json(v)
}}
pub fn elementdefinition_minvalue_decoder() -> Decoder(ElementdefinitionMinvalue){decode.one_of(decode.field("minValueDate", decode.string, decode.success) |> decode.map(ElementdefinitionMinvalueDate),[decode.field("minValueDateTime", decode.string, decode.success) |> decode.map(ElementdefinitionMinvalueDatetime),decode.field("minValueInstant", decode.string, decode.success) |> decode.map(ElementdefinitionMinvalueInstant),decode.field("minValueTime", decode.string, decode.success) |> decode.map(ElementdefinitionMinvalueTime),decode.field("minValueDecimal", decode.float, decode.success) |> decode.map(ElementdefinitionMinvalueDecimal),decode.field("minValueInteger", decode.int, decode.success) |> decode.map(ElementdefinitionMinvalueInteger),decode.field("minValuePositiveInt", decode.int, decode.success) |> decode.map(ElementdefinitionMinvaluePositiveint),decode.field("minValueUnsignedInt", decode.int, decode.success) |> decode.map(ElementdefinitionMinvalueUnsignedint),decode.field("minValueQuantity", quantity_decoder(), decode.success) |> decode.map(ElementdefinitionMinvalueQuantity),])}

///http://hl7.org/fhir/r4/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMaxvalue{
ElementdefinitionMaxvalueDate(max_value: String)
ElementdefinitionMaxvalueDatetime(max_value: String)
ElementdefinitionMaxvalueInstant(max_value: String)
ElementdefinitionMaxvalueTime(max_value: String)
ElementdefinitionMaxvalueDecimal(max_value: Float)
ElementdefinitionMaxvalueInteger(max_value: Int)
ElementdefinitionMaxvaluePositiveint(max_value: Int)
ElementdefinitionMaxvalueUnsignedint(max_value: Int)
ElementdefinitionMaxvalueQuantity(max_value: Quantity)}
pub fn elementdefinition_maxvalue_to_json(elt: ElementdefinitionMaxvalue) -> Json {case elt{ElementdefinitionMaxvalueDate(v) -> json.string(v)
ElementdefinitionMaxvalueDatetime(v) -> json.string(v)
ElementdefinitionMaxvalueInstant(v) -> json.string(v)
ElementdefinitionMaxvalueTime(v) -> json.string(v)
ElementdefinitionMaxvalueDecimal(v) -> json.float(v)
ElementdefinitionMaxvalueInteger(v) -> json.int(v)
ElementdefinitionMaxvaluePositiveint(v) -> json.int(v)
ElementdefinitionMaxvalueUnsignedint(v) -> json.int(v)
ElementdefinitionMaxvalueQuantity(v) -> quantity_to_json(v)
}}
pub fn elementdefinition_maxvalue_decoder() -> Decoder(ElementdefinitionMaxvalue){decode.one_of(decode.field("maxValueDate", decode.string, decode.success) |> decode.map(ElementdefinitionMaxvalueDate),[decode.field("maxValueDateTime", decode.string, decode.success) |> decode.map(ElementdefinitionMaxvalueDatetime),decode.field("maxValueInstant", decode.string, decode.success) |> decode.map(ElementdefinitionMaxvalueInstant),decode.field("maxValueTime", decode.string, decode.success) |> decode.map(ElementdefinitionMaxvalueTime),decode.field("maxValueDecimal", decode.float, decode.success) |> decode.map(ElementdefinitionMaxvalueDecimal),decode.field("maxValueInteger", decode.int, decode.success) |> decode.map(ElementdefinitionMaxvalueInteger),decode.field("maxValuePositiveInt", decode.int, decode.success) |> decode.map(ElementdefinitionMaxvaluePositiveint),decode.field("maxValueUnsignedInt", decode.int, decode.success) |> decode.map(ElementdefinitionMaxvalueUnsignedint),decode.field("maxValueQuantity", quantity_decoder(), decode.success) |> decode.map(ElementdefinitionMaxvalueQuantity),])}
pub fn elementdefinition_new(path path: String,) ->Elementdefinition{Elementdefinition(mapping: [],binding: None,is_summary: None,is_modifier_reason: None,is_modifier: None,must_support: None,constraint: [],condition: [],max_length: None,max_value: None,min_value: None,example: [],pattern: None,fixed: None,order_meaning: None,meaning_when_missing: None,default_value: None,type_: [],content_reference: None,base: None,max: None,min: None,alias: [],requirements: None,comment: None,definition: None,short: None,slicing: None,code: [],label: None,slice_is_constraining: None,slice_name: None,representation: [],path:,modifier_extension: [],extension: [],id: None,)
}

pub fn elementdefinition_to_json(elementdefinition: Elementdefinition) -> Json {
    let Elementdefinition(mapping:,binding:,is_summary:,is_modifier_reason:,is_modifier:,must_support:,constraint:,condition:,max_length:,max_value:,min_value:,example:,pattern:,fixed:,order_meaning:,meaning_when_missing:,default_value:,type_:,content_reference:,base:,max:,min:,alias:,requirements:,comment:,definition:,short:,slicing:,code:,label:,slice_is_constraining:,slice_name:,representation:,path:,modifier_extension:,extension:,id:,) = elementdefinition
    let fields = [#("path", json.string(path)),]
let fields = case mapping {
                        [] -> fields
                        _ -> [#("mapping", json.array(mapping,element_to_json)), ..fields]
                          }
let fields = case binding {
                          Some(v) -> [#("binding", element_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_summary {
                          Some(v) -> [#("isSummary", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case is_modifier_reason {
                          Some(v) -> [#("isModifierReason", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case is_modifier {
                          Some(v) -> [#("isModifier", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case must_support {
                          Some(v) -> [#("mustSupport", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case constraint {
                        [] -> fields
                        _ -> [#("constraint", json.array(constraint,element_to_json)), ..fields]
                          }
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,json.string)), ..fields]
                          }
let fields = case max_length {
                          Some(v) -> [#("maxLength", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case max_value {
                          Some(v) -> [#("maxValue", elementdefinition_maxvalue_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case min_value {
                          Some(v) -> [#("minValue", elementdefinition_minvalue_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case example {
                        [] -> fields
                        _ -> [#("example", json.array(example,element_to_json)), ..fields]
                          }
let fields = case pattern {
                          Some(v) -> [#("pattern", elementdefinition_pattern_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case fixed {
                          Some(v) -> [#("fixed", elementdefinition_fixed_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case order_meaning {
                          Some(v) -> [#("orderMeaning", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meaning_when_missing {
                          Some(v) -> [#("meaningWhenMissing", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case default_value {
                          Some(v) -> [#("defaultValue", elementdefinition_defaultvalue_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,element_to_json)), ..fields]
                          }
let fields = case content_reference {
                          Some(v) -> [#("contentReference", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case base {
                          Some(v) -> [#("base", element_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max {
                          Some(v) -> [#("max", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case min {
                          Some(v) -> [#("min", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case alias {
                        [] -> fields
                        _ -> [#("alias", json.array(alias,json.string)), ..fields]
                          }
let fields = case requirements {
                          Some(v) -> [#("requirements", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case short {
                          Some(v) -> [#("short", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case slicing {
                          Some(v) -> [#("slicing", element_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,coding_to_json)), ..fields]
                          }
let fields = case label {
                          Some(v) -> [#("label", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case slice_is_constraining {
                          Some(v) -> [#("sliceIsConstraining", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case slice_name {
                          Some(v) -> [#("sliceName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case representation {
                        [] -> fields
                        _ -> [#("representation", json.array(representation,r4valuesets.propertyrepresentation_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn elementdefinition_decoder() -> Decoder(Elementdefinition) {use mapping <- decode.optional_field("mapping", [], decode.list(element_decoder()))
use binding <- decode.optional_field("binding", None, decode.optional(element_decoder()))
use is_summary <- decode.optional_field("isSummary", None, decode.optional(decode.bool))
use is_modifier_reason <- decode.optional_field("isModifierReason", None, decode.optional(decode.string))
use is_modifier <- decode.optional_field("isModifier", None, decode.optional(decode.bool))
use must_support <- decode.optional_field("mustSupport", None, decode.optional(decode.bool))
use constraint <- decode.optional_field("constraint", [], decode.list(element_decoder()))
use condition <- decode.optional_field("condition", [], decode.list(decode.string))
use max_length <- decode.optional_field("maxLength", None, decode.optional(decode.int))
use max_value <- decode.then(none_if_omitted(elementdefinition_maxvalue_decoder()))
use min_value <- decode.then(none_if_omitted(elementdefinition_minvalue_decoder()))
use example <- decode.optional_field("example", [], decode.list(element_decoder()))
use pattern <- decode.then(none_if_omitted(elementdefinition_pattern_decoder()))
use fixed <- decode.then(none_if_omitted(elementdefinition_fixed_decoder()))
use order_meaning <- decode.optional_field("orderMeaning", None, decode.optional(decode.string))
use meaning_when_missing <- decode.optional_field("meaningWhenMissing", None, decode.optional(decode.string))
use default_value <- decode.then(none_if_omitted(elementdefinition_defaultvalue_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(element_decoder()))
use content_reference <- decode.optional_field("contentReference", None, decode.optional(decode.string))
use base <- decode.optional_field("base", None, decode.optional(element_decoder()))
use max <- decode.optional_field("max", None, decode.optional(decode.string))
use min <- decode.optional_field("min", None, decode.optional(decode.int))
use alias <- decode.optional_field("alias", [], decode.list(decode.string))
use requirements <- decode.optional_field("requirements", None, decode.optional(decode.string))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use short <- decode.optional_field("short", None, decode.optional(decode.string))
use slicing <- decode.optional_field("slicing", None, decode.optional(element_decoder()))
use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
use label <- decode.optional_field("label", None, decode.optional(decode.string))
use slice_is_constraining <- decode.optional_field("sliceIsConstraining", None, decode.optional(decode.bool))
use slice_name <- decode.optional_field("sliceName", None, decode.optional(decode.string))
use representation <- decode.optional_field("representation", [], decode.list(r4valuesets.propertyrepresentation_decoder()))
use path <- decode.field("path",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Elementdefinition(mapping:,binding:,is_summary:,is_modifier_reason:,is_modifier:,must_support:,constraint:,condition:,max_length:,max_value:,min_value:,example:,pattern:,fixed:,order_meaning:,meaning_when_missing:,default_value:,type_:,content_reference:,base:,max:,min:,alias:,requirements:,comment:,definition:,short:,slicing:,code:,label:,slice_is_constraining:,slice_name:,representation:,path:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Expression#resource
pub type Expression
{
Expression(id: Option(String),
extension: List(Extension),
description: Option(String),
name: Option(String),
language: String,
expression: Option(String),
reference: Option(String),
)
}

pub fn expression_new(language language: String,) ->Expression{Expression(reference: None,expression: None,language:,name: None,description: None,extension: [],id: None,)
}

pub fn expression_to_json(expression: Expression) -> Json {
    let Expression(reference:,expression:,language:,name:,description:,extension:,id:,) = expression
    let fields = [#("language", json.string(language)),]
let fields = case reference {
                          Some(v) -> [#("reference", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn expression_decoder() -> Decoder(Expression) {use reference <- decode.optional_field("reference", None, decode.optional(decode.string))
use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use language <- decode.field("language",decode.string)
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Expression(reference:,expression:,language:,name:,description:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Extension#resource
pub type Extension
{
Extension(id: Option(String),
extension: List(Extension),
url: String,
value: Option(ExtensionValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Extension#resource
pub type ExtensionValue{
ExtensionValueBase64binary(value: String)
ExtensionValueBoolean(value: Bool)
ExtensionValueCanonical(value: String)
ExtensionValueCode(value: String)
ExtensionValueDate(value: String)
ExtensionValueDatetime(value: String)
ExtensionValueDecimal(value: Float)
ExtensionValueId(value: String)
ExtensionValueInstant(value: String)
ExtensionValueInteger(value: Int)
ExtensionValueMarkdown(value: String)
ExtensionValueOid(value: String)
ExtensionValuePositiveint(value: Int)
ExtensionValueString(value: String)
ExtensionValueTime(value: String)
ExtensionValueUnsignedint(value: Int)
ExtensionValueUri(value: String)
ExtensionValueUrl(value: String)
ExtensionValueUuid(value: String)
ExtensionValueAddress(value: Address)
ExtensionValueAge(value: Age)
ExtensionValueAnnotation(value: Annotation)
ExtensionValueAttachment(value: Attachment)
ExtensionValueCodeableconcept(value: Codeableconcept)
ExtensionValueCoding(value: Coding)
ExtensionValueContactpoint(value: Contactpoint)
ExtensionValueCount(value: Count)
ExtensionValueDistance(value: Distance)
ExtensionValueDuration(value: Duration)
ExtensionValueHumanname(value: Humanname)
ExtensionValueIdentifier(value: Identifier)
ExtensionValueMoney(value: Money)
ExtensionValuePeriod(value: Period)
ExtensionValueQuantity(value: Quantity)
ExtensionValueRange(value: Range)
ExtensionValueRatio(value: Ratio)
ExtensionValueReference(value: Reference)
ExtensionValueSampleddata(value: Sampleddata)
ExtensionValueSignature(value: Signature)
ExtensionValueTiming(value: Timing)
ExtensionValueContactdetail(value: Contactdetail)
ExtensionValueContributor(value: Contributor)
ExtensionValueDatarequirement(value: Datarequirement)
ExtensionValueExpression(value: Expression)
ExtensionValueParameterdefinition(value: Parameterdefinition)
ExtensionValueRelatedartifact(value: Relatedartifact)
ExtensionValueTriggerdefinition(value: Triggerdefinition)
ExtensionValueUsagecontext(value: Usagecontext)
ExtensionValueDosage(value: Dosage)
ExtensionValueMeta(value: Meta)}
pub fn extension_value_to_json(elt: ExtensionValue) -> Json {case elt{ExtensionValueBase64binary(v) -> json.string(v)
ExtensionValueBoolean(v) -> json.bool(v)
ExtensionValueCanonical(v) -> json.string(v)
ExtensionValueCode(v) -> json.string(v)
ExtensionValueDate(v) -> json.string(v)
ExtensionValueDatetime(v) -> json.string(v)
ExtensionValueDecimal(v) -> json.float(v)
ExtensionValueId(v) -> json.string(v)
ExtensionValueInstant(v) -> json.string(v)
ExtensionValueInteger(v) -> json.int(v)
ExtensionValueMarkdown(v) -> json.string(v)
ExtensionValueOid(v) -> json.string(v)
ExtensionValuePositiveint(v) -> json.int(v)
ExtensionValueString(v) -> json.string(v)
ExtensionValueTime(v) -> json.string(v)
ExtensionValueUnsignedint(v) -> json.int(v)
ExtensionValueUri(v) -> json.string(v)
ExtensionValueUrl(v) -> json.string(v)
ExtensionValueUuid(v) -> json.string(v)
ExtensionValueAddress(v) -> address_to_json(v)
ExtensionValueAge(v) -> age_to_json(v)
ExtensionValueAnnotation(v) -> annotation_to_json(v)
ExtensionValueAttachment(v) -> attachment_to_json(v)
ExtensionValueCodeableconcept(v) -> codeableconcept_to_json(v)
ExtensionValueCoding(v) -> coding_to_json(v)
ExtensionValueContactpoint(v) -> contactpoint_to_json(v)
ExtensionValueCount(v) -> count_to_json(v)
ExtensionValueDistance(v) -> distance_to_json(v)
ExtensionValueDuration(v) -> duration_to_json(v)
ExtensionValueHumanname(v) -> humanname_to_json(v)
ExtensionValueIdentifier(v) -> identifier_to_json(v)
ExtensionValueMoney(v) -> money_to_json(v)
ExtensionValuePeriod(v) -> period_to_json(v)
ExtensionValueQuantity(v) -> quantity_to_json(v)
ExtensionValueRange(v) -> range_to_json(v)
ExtensionValueRatio(v) -> ratio_to_json(v)
ExtensionValueReference(v) -> reference_to_json(v)
ExtensionValueSampleddata(v) -> sampleddata_to_json(v)
ExtensionValueSignature(v) -> signature_to_json(v)
ExtensionValueTiming(v) -> timing_to_json(v)
ExtensionValueContactdetail(v) -> contactdetail_to_json(v)
ExtensionValueContributor(v) -> contributor_to_json(v)
ExtensionValueDatarequirement(v) -> datarequirement_to_json(v)
ExtensionValueExpression(v) -> expression_to_json(v)
ExtensionValueParameterdefinition(v) -> parameterdefinition_to_json(v)
ExtensionValueRelatedartifact(v) -> relatedartifact_to_json(v)
ExtensionValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
ExtensionValueUsagecontext(v) -> usagecontext_to_json(v)
ExtensionValueDosage(v) -> dosage_to_json(v)
ExtensionValueMeta(v) -> meta_to_json(v)
}}
pub fn extension_value_decoder() -> Decoder(ExtensionValue){decode.one_of(decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(ExtensionValueBase64binary),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ExtensionValueBoolean),decode.field("valueCanonical", decode.string, decode.success) |> decode.map(ExtensionValueCanonical),decode.field("valueCode", decode.string, decode.success) |> decode.map(ExtensionValueCode),decode.field("valueDate", decode.string, decode.success) |> decode.map(ExtensionValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ExtensionValueDatetime),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(ExtensionValueDecimal),decode.field("valueId", decode.string, decode.success) |> decode.map(ExtensionValueId),decode.field("valueInstant", decode.string, decode.success) |> decode.map(ExtensionValueInstant),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ExtensionValueInteger),decode.field("valueMarkdown", decode.string, decode.success) |> decode.map(ExtensionValueMarkdown),decode.field("valueOid", decode.string, decode.success) |> decode.map(ExtensionValueOid),decode.field("valuePositiveInt", decode.int, decode.success) |> decode.map(ExtensionValuePositiveint),decode.field("valueString", decode.string, decode.success) |> decode.map(ExtensionValueString),decode.field("valueTime", decode.string, decode.success) |> decode.map(ExtensionValueTime),decode.field("valueUnsignedInt", decode.int, decode.success) |> decode.map(ExtensionValueUnsignedint),decode.field("valueUri", decode.string, decode.success) |> decode.map(ExtensionValueUri),decode.field("valueUrl", decode.string, decode.success) |> decode.map(ExtensionValueUrl),decode.field("valueUuid", decode.string, decode.success) |> decode.map(ExtensionValueUuid),decode.field("valueAddress", address_decoder(), decode.success) |> decode.map(ExtensionValueAddress),decode.field("valueAge", age_decoder(), decode.success) |> decode.map(ExtensionValueAge),decode.field("valueAnnotation", annotation_decoder(), decode.success) |> decode.map(ExtensionValueAnnotation),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(ExtensionValueAttachment),decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ExtensionValueCodeableconcept),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(ExtensionValueCoding),decode.field("valueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(ExtensionValueContactpoint),decode.field("valueCount", count_decoder(), decode.success) |> decode.map(ExtensionValueCount),decode.field("valueDistance", distance_decoder(), decode.success) |> decode.map(ExtensionValueDistance),decode.field("valueDuration", duration_decoder(), decode.success) |> decode.map(ExtensionValueDuration),decode.field("valueHumanName", humanname_decoder(), decode.success) |> decode.map(ExtensionValueHumanname),decode.field("valueIdentifier", identifier_decoder(), decode.success) |> decode.map(ExtensionValueIdentifier),decode.field("valueMoney", money_decoder(), decode.success) |> decode.map(ExtensionValueMoney),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(ExtensionValuePeriod),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ExtensionValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(ExtensionValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(ExtensionValueRatio),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(ExtensionValueReference),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(ExtensionValueSampleddata),decode.field("valueSignature", signature_decoder(), decode.success) |> decode.map(ExtensionValueSignature),decode.field("valueTiming", timing_decoder(), decode.success) |> decode.map(ExtensionValueTiming),decode.field("valueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(ExtensionValueContactdetail),decode.field("valueContributor", contributor_decoder(), decode.success) |> decode.map(ExtensionValueContributor),decode.field("valueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ExtensionValueDatarequirement),decode.field("valueExpression", expression_decoder(), decode.success) |> decode.map(ExtensionValueExpression),decode.field("valueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(ExtensionValueParameterdefinition),decode.field("valueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(ExtensionValueRelatedartifact),decode.field("valueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(ExtensionValueTriggerdefinition),decode.field("valueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(ExtensionValueUsagecontext),decode.field("valueDosage", dosage_decoder(), decode.success) |> decode.map(ExtensionValueDosage),decode.field("valueMeta", meta_decoder(), decode.success) |> decode.map(ExtensionValueMeta),])}
pub fn extension_new(url url: String,) ->Extension{Extension(value: None,url:,extension: [],id: None,)
}

pub fn extension_to_json(extension: Extension) -> Json {
    let Extension(value:,url:,extension:,id:,) = extension
    let fields = [#("url", json.string(url)),]
let fields = case value {
                          Some(v) -> [#("value", extension_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn extension_decoder() -> Decoder(Extension) {use value <- decode.then(none_if_omitted(extension_value_decoder()))
use url <- decode.field("url",decode.string)
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Extension(value:,url:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/HumanName#resource
pub type Humanname
{
Humanname(id: Option(String),
extension: List(Extension),
use_: Option(r4valuesets.Nameuse),
text: Option(String),
family: Option(String),
given: List(String),
prefix: List(String),
suffix: List(String),
period: Option(Period),
)
}

pub fn humanname_new() ->Humanname{Humanname(period: None,suffix: [],prefix: [],given: [],family: None,text: None,use_: None,extension: [],id: None,)
}

pub fn humanname_to_json(humanname: Humanname) -> Json {
    let Humanname(period:,suffix:,prefix:,given:,family:,text:,use_:,extension:,id:,) = humanname
    let fields = []
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case suffix {
                        [] -> fields
                        _ -> [#("suffix", json.array(suffix,json.string)), ..fields]
                          }
let fields = case prefix {
                        [] -> fields
                        _ -> [#("prefix", json.array(prefix,json.string)), ..fields]
                          }
let fields = case given {
                        [] -> fields
                        _ -> [#("given", json.array(given,json.string)), ..fields]
                          }
let fields = case family {
                          Some(v) -> [#("family", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case use_ {
                          Some(v) -> [#("use", r4valuesets.nameuse_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn humanname_decoder() -> Decoder(Humanname) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use suffix <- decode.optional_field("suffix", [], decode.list(decode.string))
use prefix <- decode.optional_field("prefix", [], decode.list(decode.string))
use given <- decode.optional_field("given", [], decode.list(decode.string))
use family <- decode.optional_field("family", None, decode.optional(decode.string))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use use_ <- decode.optional_field("use", None, decode.optional(r4valuesets.nameuse_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Humanname(period:,suffix:,prefix:,given:,family:,text:,use_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Identifier#resource
pub type Identifier
{
Identifier(id: Option(String),
extension: List(Extension),
use_: Option(r4valuesets.Identifieruse),
type_: Option(Codeableconcept),
system: Option(String),
value: Option(String),
period: Option(Period),
assigner: Option(Reference),
)
}

pub fn identifier_new() ->Identifier{Identifier(assigner: None,period: None,value: None,system: None,type_: None,use_: None,extension: [],id: None,)
}

pub fn identifier_to_json(identifier: Identifier) -> Json {
    let Identifier(assigner:,period:,value:,system:,type_:,use_:,extension:,id:,) = identifier
    let fields = []
let fields = case assigner {
                          Some(v) -> [#("assigner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case use_ {
                          Some(v) -> [#("use", r4valuesets.identifieruse_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn identifier_decoder() -> Decoder(Identifier) {use assigner <- decode.optional_field("assigner", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use use_ <- decode.optional_field("use", None, decode.optional(r4valuesets.identifieruse_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Identifier(assigner:,period:,value:,system:,type_:,use_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MarketingStatus#resource
pub type Marketingstatus
{
Marketingstatus(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
country: Codeableconcept,
jurisdiction: Option(Codeableconcept),
status: Codeableconcept,
date_range: Period,
restore_date: Option(String),
)
}

pub fn marketingstatus_new(date_range date_range: Period,status status: Codeableconcept,country country: Codeableconcept,) ->Marketingstatus{Marketingstatus(restore_date: None,date_range:,status:,jurisdiction: None,country:,modifier_extension: [],extension: [],id: None,)
}

pub fn marketingstatus_to_json(marketingstatus: Marketingstatus) -> Json {
    let Marketingstatus(restore_date:,date_range:,status:,jurisdiction:,country:,modifier_extension:,extension:,id:,) = marketingstatus
    let fields = [#("dateRange", period_to_json(date_range)),#("status", codeableconcept_to_json(status)),#("country", codeableconcept_to_json(country)),]
let fields = case restore_date {
                          Some(v) -> [#("restoreDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                          Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn marketingstatus_decoder() -> Decoder(Marketingstatus) {use restore_date <- decode.optional_field("restoreDate", None, decode.optional(decode.string))
use date_range <- decode.field("dateRange",period_decoder())
use status <- decode.field("status",codeableconcept_decoder())
use jurisdiction <- decode.optional_field("jurisdiction", None, decode.optional(codeableconcept_decoder()))
use country <- decode.field("country",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Marketingstatus(restore_date:,date_range:,status:,jurisdiction:,country:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Meta#resource
pub type Meta
{
Meta(id: Option(String),
extension: List(Extension),
version_id: Option(String),
last_updated: Option(String),
source: Option(String),
profile: List(String),
security: List(Coding),
tag: List(Coding),
)
}

pub fn meta_new() ->Meta{Meta(tag: [],security: [],profile: [],source: None,last_updated: None,version_id: None,extension: [],id: None,)
}

pub fn meta_to_json(meta: Meta) -> Json {
    let Meta(tag:,security:,profile:,source:,last_updated:,version_id:,extension:,id:,) = meta
    let fields = []
let fields = case tag {
                        [] -> fields
                        _ -> [#("tag", json.array(tag,coding_to_json)), ..fields]
                          }
let fields = case security {
                        [] -> fields
                        _ -> [#("security", json.array(security,coding_to_json)), ..fields]
                          }
let fields = case profile {
                        [] -> fields
                        _ -> [#("profile", json.array(profile,json.string)), ..fields]
                          }
let fields = case source {
                          Some(v) -> [#("source", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case last_updated {
                          Some(v) -> [#("lastUpdated", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version_id {
                          Some(v) -> [#("versionId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn meta_decoder() -> Decoder(Meta) {use tag <- decode.optional_field("tag", [], decode.list(coding_decoder()))
use security <- decode.optional_field("security", [], decode.list(coding_decoder()))
use profile <- decode.optional_field("profile", [], decode.list(decode.string))
use source <- decode.optional_field("source", None, decode.optional(decode.string))
use last_updated <- decode.optional_field("lastUpdated", None, decode.optional(decode.string))
use version_id <- decode.optional_field("versionId", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Meta(tag:,security:,profile:,source:,last_updated:,version_id:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Money#resource
pub type Money
{
Money(id: Option(String),
extension: List(Extension),
value: Option(Float),
currency: Option(String),
)
}

pub fn money_new() ->Money{Money(currency: None,value: None,extension: [],id: None,)
}

pub fn money_to_json(money: Money) -> Json {
    let Money(currency:,value:,extension:,id:,) = money
    let fields = []
let fields = case currency {
                          Some(v) -> [#("currency", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn money_decoder() -> Decoder(Money) {use currency <- decode.optional_field("currency", None, decode.optional(decode.string))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Money(currency:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Narrative#resource
pub type Narrative
{
Narrative(id: Option(String),
extension: List(Extension),
status: r4valuesets.Narrativestatus,
div: String,
)
}

pub fn narrative_new(div div: String,status status: r4valuesets.Narrativestatus,) ->Narrative{Narrative(div:,status:,extension: [],id: None,)
}

pub fn narrative_to_json(narrative: Narrative) -> Json {
    let Narrative(div:,status:,extension:,id:,) = narrative
    let fields = [#("div", json.string(div)),#("status", r4valuesets.narrativestatus_to_json(status)),]
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn narrative_decoder() -> Decoder(Narrative) {use div <- decode.field("div",decode.string)
use status <- decode.field("status",r4valuesets.narrativestatus_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Narrative(div:,status:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ParameterDefinition#resource
pub type Parameterdefinition
{
Parameterdefinition(id: Option(String),
extension: List(Extension),
name: Option(String),
use_: r4valuesets.Operationparameteruse,
min: Option(Int),
max: Option(String),
documentation: Option(String),
type_: r4valuesets.Alltypes,
profile: Option(String),
)
}

pub fn parameterdefinition_new(type_ type_: r4valuesets.Alltypes,use_ use_: r4valuesets.Operationparameteruse,) ->Parameterdefinition{Parameterdefinition(profile: None,type_:,documentation: None,max: None,min: None,use_:,name: None,extension: [],id: None,)
}

pub fn parameterdefinition_to_json(parameterdefinition: Parameterdefinition) -> Json {
    let Parameterdefinition(profile:,type_:,documentation:,max:,min:,use_:,name:,extension:,id:,) = parameterdefinition
    let fields = [#("type", r4valuesets.alltypes_to_json(type_)),#("use", r4valuesets.operationparameteruse_to_json(use_)),]
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max {
                          Some(v) -> [#("max", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case min {
                          Some(v) -> [#("min", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn parameterdefinition_decoder() -> Decoder(Parameterdefinition) {use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.alltypes_decoder())
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use max <- decode.optional_field("max", None, decode.optional(decode.string))
use min <- decode.optional_field("min", None, decode.optional(decode.int))
use use_ <- decode.field("use",r4valuesets.operationparameteruse_decoder())
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Parameterdefinition(profile:,type_:,documentation:,max:,min:,use_:,name:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Period#resource
pub type Period
{
Period(id: Option(String),
extension: List(Extension),
start: Option(String),
end: Option(String),
)
}

pub fn period_new() ->Period{Period(end: None,start: None,extension: [],id: None,)
}

pub fn period_to_json(period: Period) -> Json {
    let Period(end:,start:,extension:,id:,) = period
    let fields = []
let fields = case end {
                          Some(v) -> [#("end", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn period_decoder() -> Decoder(Period) {use end <- decode.optional_field("end", None, decode.optional(decode.string))
use start <- decode.optional_field("start", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Period(end:,start:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Population#resource
pub type Population
{
Population(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
age: Option(PopulationAge),
gender: Option(Codeableconcept),
race: Option(Codeableconcept),
physiological_condition: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Population#resource
pub type PopulationAge{
PopulationAgeRange(age: Range)
PopulationAgeCodeableconcept(age: Codeableconcept)}
pub fn population_age_to_json(elt: PopulationAge) -> Json {case elt{PopulationAgeRange(v) -> range_to_json(v)
PopulationAgeCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn population_age_decoder() -> Decoder(PopulationAge){decode.one_of(decode.field("ageRange", range_decoder(), decode.success) |> decode.map(PopulationAgeRange),[decode.field("ageCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(PopulationAgeCodeableconcept),])}
pub fn population_new() ->Population{Population(physiological_condition: None,race: None,gender: None,age: None,modifier_extension: [],extension: [],id: None,)
}

pub fn population_to_json(population: Population) -> Json {
    let Population(physiological_condition:,race:,gender:,age:,modifier_extension:,extension:,id:,) = population
    let fields = []
let fields = case physiological_condition {
                          Some(v) -> [#("physiologicalCondition", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case race {
                          Some(v) -> [#("race", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case age {
                          Some(v) -> [#("age", population_age_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn population_decoder() -> Decoder(Population) {use physiological_condition <- decode.optional_field("physiologicalCondition", None, decode.optional(codeableconcept_decoder()))
use race <- decode.optional_field("race", None, decode.optional(codeableconcept_decoder()))
use gender <- decode.optional_field("gender", None, decode.optional(codeableconcept_decoder()))
use age <- decode.then(none_if_omitted(population_age_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Population(physiological_condition:,race:,gender:,age:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ProdCharacteristic#resource
pub type Prodcharacteristic
{
Prodcharacteristic(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
height: Option(Quantity),
width: Option(Quantity),
depth: Option(Quantity),
weight: Option(Quantity),
nominal_volume: Option(Quantity),
external_diameter: Option(Quantity),
shape: Option(String),
color: List(String),
imprint: List(String),
image: List(Attachment),
scoring: Option(Codeableconcept),
)
}

pub fn prodcharacteristic_new() ->Prodcharacteristic{Prodcharacteristic(scoring: None,image: [],imprint: [],color: [],shape: None,external_diameter: None,nominal_volume: None,weight: None,depth: None,width: None,height: None,modifier_extension: [],extension: [],id: None,)
}

pub fn prodcharacteristic_to_json(prodcharacteristic: Prodcharacteristic) -> Json {
    let Prodcharacteristic(scoring:,image:,imprint:,color:,shape:,external_diameter:,nominal_volume:,weight:,depth:,width:,height:,modifier_extension:,extension:,id:,) = prodcharacteristic
    let fields = []
let fields = case scoring {
                          Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case image {
                        [] -> fields
                        _ -> [#("image", json.array(image,attachment_to_json)), ..fields]
                          }
let fields = case imprint {
                        [] -> fields
                        _ -> [#("imprint", json.array(imprint,json.string)), ..fields]
                          }
let fields = case color {
                        [] -> fields
                        _ -> [#("color", json.array(color,json.string)), ..fields]
                          }
let fields = case shape {
                          Some(v) -> [#("shape", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case external_diameter {
                          Some(v) -> [#("externalDiameter", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case nominal_volume {
                          Some(v) -> [#("nominalVolume", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case weight {
                          Some(v) -> [#("weight", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case depth {
                          Some(v) -> [#("depth", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case width {
                          Some(v) -> [#("width", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case height {
                          Some(v) -> [#("height", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn prodcharacteristic_decoder() -> Decoder(Prodcharacteristic) {use scoring <- decode.optional_field("scoring", None, decode.optional(codeableconcept_decoder()))
use image <- decode.optional_field("image", [], decode.list(attachment_decoder()))
use imprint <- decode.optional_field("imprint", [], decode.list(decode.string))
use color <- decode.optional_field("color", [], decode.list(decode.string))
use shape <- decode.optional_field("shape", None, decode.optional(decode.string))
use external_diameter <- decode.optional_field("externalDiameter", None, decode.optional(quantity_decoder()))
use nominal_volume <- decode.optional_field("nominalVolume", None, decode.optional(quantity_decoder()))
use weight <- decode.optional_field("weight", None, decode.optional(quantity_decoder()))
use depth <- decode.optional_field("depth", None, decode.optional(quantity_decoder()))
use width <- decode.optional_field("width", None, decode.optional(quantity_decoder()))
use height <- decode.optional_field("height", None, decode.optional(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Prodcharacteristic(scoring:,image:,imprint:,color:,shape:,external_diameter:,nominal_volume:,weight:,depth:,width:,height:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ProductShelfLife#resource
pub type Productshelflife
{
Productshelflife(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
type_: Codeableconcept,
period: Quantity,
special_precautions_for_storage: List(Codeableconcept),
)
}

pub fn productshelflife_new(period period: Quantity,type_ type_: Codeableconcept,) ->Productshelflife{Productshelflife(special_precautions_for_storage: [],period:,type_:,identifier: None,modifier_extension: [],extension: [],id: None,)
}

pub fn productshelflife_to_json(productshelflife: Productshelflife) -> Json {
    let Productshelflife(special_precautions_for_storage:,period:,type_:,identifier:,modifier_extension:,extension:,id:,) = productshelflife
    let fields = [#("period", quantity_to_json(period)),#("type", codeableconcept_to_json(type_)),]
let fields = case special_precautions_for_storage {
                        [] -> fields
                        _ -> [#("specialPrecautionsForStorage", json.array(special_precautions_for_storage,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn productshelflife_decoder() -> Decoder(Productshelflife) {use special_precautions_for_storage <- decode.optional_field("specialPrecautionsForStorage", [], decode.list(codeableconcept_decoder()))
use period <- decode.field("period",quantity_decoder())
use type_ <- decode.field("type",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Productshelflife(special_precautions_for_storage:,period:,type_:,identifier:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Quantity#resource
pub type Quantity
{
Quantity(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn quantity_new() ->Quantity{Quantity(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn quantity_to_json(quantity: Quantity) -> Json {
    let Quantity(code:,system:,unit:,comparator:,value:,extension:,id:,) = quantity
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn quantity_decoder() -> Decoder(Quantity) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Quantity(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Range#resource
pub type Range
{
Range(id: Option(String),
extension: List(Extension),
low: Option(Quantity),
high: Option(Quantity),
)
}

pub fn range_new() ->Range{Range(high: None,low: None,extension: [],id: None,)
}

pub fn range_to_json(range: Range) -> Json {
    let Range(high:,low:,extension:,id:,) = range
    let fields = []
let fields = case high {
                          Some(v) -> [#("high", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case low {
                          Some(v) -> [#("low", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn range_decoder() -> Decoder(Range) {use high <- decode.optional_field("high", None, decode.optional(quantity_decoder()))
use low <- decode.optional_field("low", None, decode.optional(quantity_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Range(high:,low:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Ratio#resource
pub type Ratio
{
Ratio(id: Option(String),
extension: List(Extension),
numerator: Option(Quantity),
denominator: Option(Quantity),
)
}

pub fn ratio_new() ->Ratio{Ratio(denominator: None,numerator: None,extension: [],id: None,)
}

pub fn ratio_to_json(ratio: Ratio) -> Json {
    let Ratio(denominator:,numerator:,extension:,id:,) = ratio
    let fields = []
let fields = case denominator {
                          Some(v) -> [#("denominator", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case numerator {
                          Some(v) -> [#("numerator", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn ratio_decoder() -> Decoder(Ratio) {use denominator <- decode.optional_field("denominator", None, decode.optional(quantity_decoder()))
use numerator <- decode.optional_field("numerator", None, decode.optional(quantity_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Ratio(denominator:,numerator:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Reference#resource
pub type Reference
{
Reference(id: Option(String),
extension: List(Extension),
reference: Option(String),
type_: Option(String),
identifier: Option(Identifier),
display: Option(String),
)
}

pub fn reference_new() ->Reference{Reference(display: None,identifier: None,type_: None,reference: None,extension: [],id: None,)
}

pub fn reference_to_json(reference: Reference) -> Json {
    let Reference(display:,identifier:,type_:,reference:,extension:,id:,) = reference
    let fields = []
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case reference {
                          Some(v) -> [#("reference", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn reference_decoder() -> Decoder(Reference) {use display <- decode.optional_field("display", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(decode.string))
use reference <- decode.optional_field("reference", None, decode.optional(decode.string))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Reference(display:,identifier:,type_:,reference:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/RelatedArtifact#resource
pub type Relatedartifact
{
Relatedartifact(id: Option(String),
extension: List(Extension),
type_: r4valuesets.Relatedartifacttype,
label: Option(String),
display: Option(String),
citation: Option(String),
url: Option(String),
document: Option(Attachment),
resource: Option(String),
)
}

pub fn relatedartifact_new(type_ type_: r4valuesets.Relatedartifacttype,) ->Relatedartifact{Relatedartifact(resource: None,document: None,url: None,citation: None,display: None,label: None,type_:,extension: [],id: None,)
}

pub fn relatedartifact_to_json(relatedartifact: Relatedartifact) -> Json {
    let Relatedartifact(resource:,document:,url:,citation:,display:,label:,type_:,extension:,id:,) = relatedartifact
    let fields = [#("type", r4valuesets.relatedartifacttype_to_json(type_)),]
let fields = case resource {
                          Some(v) -> [#("resource", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case document {
                          Some(v) -> [#("document", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case citation {
                          Some(v) -> [#("citation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case label {
                          Some(v) -> [#("label", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn relatedartifact_decoder() -> Decoder(Relatedartifact) {use resource <- decode.optional_field("resource", None, decode.optional(decode.string))
use document <- decode.optional_field("document", None, decode.optional(attachment_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use citation <- decode.optional_field("citation", None, decode.optional(decode.string))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use label <- decode.optional_field("label", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.relatedartifacttype_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Relatedartifact(resource:,document:,url:,citation:,display:,label:,type_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SampledData#resource
pub type Sampleddata
{
Sampleddata(id: Option(String),
extension: List(Extension),
origin: Quantity,
period: Float,
factor: Option(Float),
lower_limit: Option(Float),
upper_limit: Option(Float),
dimensions: Int,
data: Option(String),
)
}

pub fn sampleddata_new(dimensions dimensions: Int,period period: Float,origin origin: Quantity,) ->Sampleddata{Sampleddata(data: None,dimensions:,upper_limit: None,lower_limit: None,factor: None,period:,origin:,extension: [],id: None,)
}

pub fn sampleddata_to_json(sampleddata: Sampleddata) -> Json {
    let Sampleddata(data:,dimensions:,upper_limit:,lower_limit:,factor:,period:,origin:,extension:,id:,) = sampleddata
    let fields = [#("dimensions", json.int(dimensions)),#("period", json.float(period)),#("origin", quantity_to_json(origin)),]
let fields = case data {
                          Some(v) -> [#("data", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case upper_limit {
                          Some(v) -> [#("upperLimit", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case lower_limit {
                          Some(v) -> [#("lowerLimit", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn sampleddata_decoder() -> Decoder(Sampleddata) {use data <- decode.optional_field("data", None, decode.optional(decode.string))
use dimensions <- decode.field("dimensions",decode.int)
use upper_limit <- decode.optional_field("upperLimit", None, decode.optional(decode.float))
use lower_limit <- decode.optional_field("lowerLimit", None, decode.optional(decode.float))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use period <- decode.field("period",decode.float)
use origin <- decode.field("origin",quantity_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Sampleddata(data:,dimensions:,upper_limit:,lower_limit:,factor:,period:,origin:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Signature#resource
pub type Signature
{
Signature(id: Option(String),
extension: List(Extension),
type_: List(Coding),
when: String,
who: Reference,
on_behalf_of: Option(Reference),
target_format: Option(String),
sig_format: Option(String),
data: Option(String),
)
}

pub fn signature_new(who who: Reference,when when: String,) ->Signature{Signature(data: None,sig_format: None,target_format: None,on_behalf_of: None,who:,when:,type_: [],extension: [],id: None,)
}

pub fn signature_to_json(signature: Signature) -> Json {
    let Signature(data:,sig_format:,target_format:,on_behalf_of:,who:,when:,type_:,extension:,id:,) = signature
    let fields = [#("who", reference_to_json(who)),#("when", json.string(when)),]
let fields = case data {
                          Some(v) -> [#("data", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case sig_format {
                          Some(v) -> [#("sigFormat", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case target_format {
                          Some(v) -> [#("targetFormat", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case on_behalf_of {
                          Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,coding_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn signature_decoder() -> Decoder(Signature) {use data <- decode.optional_field("data", None, decode.optional(decode.string))
use sig_format <- decode.optional_field("sigFormat", None, decode.optional(decode.string))
use target_format <- decode.optional_field("targetFormat", None, decode.optional(decode.string))
use on_behalf_of <- decode.optional_field("onBehalfOf", None, decode.optional(reference_decoder()))
use who <- decode.field("who",reference_decoder())
use when <- decode.field("when",decode.string)
use type_ <- decode.optional_field("type", [], decode.list(coding_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Signature(data:,sig_format:,target_format:,on_behalf_of:,who:,when:,type_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceAmount#resource
pub type Substanceamount
{
Substanceamount(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
amount: Option(SubstanceamountAmount),
amount_type: Option(Codeableconcept),
amount_text: Option(String),
reference_range: Option(Element),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceAmount#resource
pub type SubstanceamountAmount{
SubstanceamountAmountQuantity(amount: Quantity)
SubstanceamountAmountRange(amount: Range)
SubstanceamountAmountString(amount: String)}
pub fn substanceamount_amount_to_json(elt: SubstanceamountAmount) -> Json {case elt{SubstanceamountAmountQuantity(v) -> quantity_to_json(v)
SubstanceamountAmountRange(v) -> range_to_json(v)
SubstanceamountAmountString(v) -> json.string(v)
}}
pub fn substanceamount_amount_decoder() -> Decoder(SubstanceamountAmount){decode.one_of(decode.field("amountQuantity", quantity_decoder(), decode.success) |> decode.map(SubstanceamountAmountQuantity),[decode.field("amountRange", range_decoder(), decode.success) |> decode.map(SubstanceamountAmountRange),decode.field("amountString", decode.string, decode.success) |> decode.map(SubstanceamountAmountString),])}
pub fn substanceamount_new() ->Substanceamount{Substanceamount(reference_range: None,amount_text: None,amount_type: None,amount: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substanceamount_to_json(substanceamount: Substanceamount) -> Json {
    let Substanceamount(reference_range:,amount_text:,amount_type:,amount:,modifier_extension:,extension:,id:,) = substanceamount
    let fields = []
let fields = case reference_range {
                          Some(v) -> [#("referenceRange", element_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount_text {
                          Some(v) -> [#("amountText", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case amount_type {
                          Some(v) -> [#("amountType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", substanceamount_amount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substanceamount_decoder() -> Decoder(Substanceamount) {use reference_range <- decode.optional_field("referenceRange", None, decode.optional(element_decoder()))
use amount_text <- decode.optional_field("amountText", None, decode.optional(decode.string))
use amount_type <- decode.optional_field("amountType", None, decode.optional(codeableconcept_decoder()))
use amount <- decode.then(none_if_omitted(substanceamount_amount_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substanceamount(reference_range:,amount_text:,amount_type:,amount:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Timing#resource
pub type Timing
{
Timing(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
event: List(String),
repeat: Option(Element),
code: Option(Codeableconcept),
)
}

pub fn timing_new() ->Timing{Timing(code: None,repeat: None,event: [],modifier_extension: [],extension: [],id: None,)
}

pub fn timing_to_json(timing: Timing) -> Json {
    let Timing(code:,repeat:,event:,modifier_extension:,extension:,id:,) = timing
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case repeat {
                          Some(v) -> [#("repeat", element_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case event {
                        [] -> fields
                        _ -> [#("event", json.array(event,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn timing_decoder() -> Decoder(Timing) {use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use repeat <- decode.optional_field("repeat", None, decode.optional(element_decoder()))
use event <- decode.optional_field("event", [], decode.list(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Timing(code:,repeat:,event:,modifier_extension:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/TriggerDefinition#resource
pub type Triggerdefinition
{
Triggerdefinition(id: Option(String),
extension: List(Extension),
type_: r4valuesets.Triggertype,
name: Option(String),
timing: Option(TriggerdefinitionTiming),
data: List(Datarequirement),
condition: Option(Expression),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/TriggerDefinition#resource
pub type TriggerdefinitionTiming{
TriggerdefinitionTimingTiming(timing: Timing)
TriggerdefinitionTimingReference(timing: Reference)
TriggerdefinitionTimingDate(timing: String)
TriggerdefinitionTimingDatetime(timing: String)}
pub fn triggerdefinition_timing_to_json(elt: TriggerdefinitionTiming) -> Json {case elt{TriggerdefinitionTimingTiming(v) -> timing_to_json(v)
TriggerdefinitionTimingReference(v) -> reference_to_json(v)
TriggerdefinitionTimingDate(v) -> json.string(v)
TriggerdefinitionTimingDatetime(v) -> json.string(v)
}}
pub fn triggerdefinition_timing_decoder() -> Decoder(TriggerdefinitionTiming){decode.one_of(decode.field("timingTiming", timing_decoder(), decode.success) |> decode.map(TriggerdefinitionTimingTiming),[decode.field("timingReference", reference_decoder(), decode.success) |> decode.map(TriggerdefinitionTimingReference),decode.field("timingDate", decode.string, decode.success) |> decode.map(TriggerdefinitionTimingDate),decode.field("timingDateTime", decode.string, decode.success) |> decode.map(TriggerdefinitionTimingDatetime),])}
pub fn triggerdefinition_new(type_ type_: r4valuesets.Triggertype,) ->Triggerdefinition{Triggerdefinition(condition: None,data: [],timing: None,name: None,type_:,extension: [],id: None,)
}

pub fn triggerdefinition_to_json(triggerdefinition: Triggerdefinition) -> Json {
    let Triggerdefinition(condition:,data:,timing:,name:,type_:,extension:,id:,) = triggerdefinition
    let fields = [#("type", r4valuesets.triggertype_to_json(type_)),]
let fields = case condition {
                          Some(v) -> [#("condition", expression_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case data {
                        [] -> fields
                        _ -> [#("data", json.array(data,datarequirement_to_json)), ..fields]
                          }
let fields = case timing {
                          Some(v) -> [#("timing", triggerdefinition_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn triggerdefinition_decoder() -> Decoder(Triggerdefinition) {use condition <- decode.optional_field("condition", None, decode.optional(expression_decoder()))
use data <- decode.optional_field("data", [], decode.list(datarequirement_decoder()))
use timing <- decode.then(none_if_omitted(triggerdefinition_timing_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.triggertype_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Triggerdefinition(condition:,data:,timing:,name:,type_:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/UsageContext#resource
pub type Usagecontext
{
Usagecontext(id: Option(String),
extension: List(Extension),
code: Coding,
value: UsagecontextValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/UsageContext#resource
pub type UsagecontextValue{
UsagecontextValueCodeableconcept(value: Codeableconcept)
UsagecontextValueQuantity(value: Quantity)
UsagecontextValueRange(value: Range)
UsagecontextValueReference(value: Reference)}
pub fn usagecontext_value_to_json(elt: UsagecontextValue) -> Json {case elt{UsagecontextValueCodeableconcept(v) -> codeableconcept_to_json(v)
UsagecontextValueQuantity(v) -> quantity_to_json(v)
UsagecontextValueRange(v) -> range_to_json(v)
UsagecontextValueReference(v) -> reference_to_json(v)
}}
pub fn usagecontext_value_decoder() -> Decoder(UsagecontextValue){decode.one_of(decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(UsagecontextValueCodeableconcept),[decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(UsagecontextValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(UsagecontextValueRange),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(UsagecontextValueReference),])}
pub fn usagecontext_new(value value: UsagecontextValue,code code: Coding,) ->Usagecontext{Usagecontext(value:,code:,extension: [],id: None,)
}

pub fn usagecontext_to_json(usagecontext: Usagecontext) -> Json {
    let Usagecontext(value:,code:,extension:,id:,) = usagecontext
    let fields = [#("value", usagecontext_value_to_json(value)),#("code", coding_to_json(code)),]
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn usagecontext_decoder() -> Decoder(Usagecontext) {use value <- decode.then(usagecontext_value_decoder())
use code <- decode.field("code",coding_decoder())
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Usagecontext(value:,code:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MoneyQuantity#resource
pub type Moneyquantity
{
Moneyquantity(id: Option(String),
extension: List(Extension),
value: Option(Float),
comparator: Option(r4valuesets.Quantitycomparator),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn moneyquantity_new() ->Moneyquantity{Moneyquantity(code: None,system: None,unit: None,comparator: None,value: None,extension: [],id: None,)
}

pub fn moneyquantity_to_json(moneyquantity: Moneyquantity) -> Json {
    let Moneyquantity(code:,system:,unit:,comparator:,value:,extension:,id:,) = moneyquantity
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comparator {
                          Some(v) -> [#("comparator", r4valuesets.quantitycomparator_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn moneyquantity_decoder() -> Decoder(Moneyquantity) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use comparator <- decode.optional_field("comparator", None, decode.optional(r4valuesets.quantitycomparator_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Moneyquantity(code:,system:,unit:,comparator:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SimpleQuantity#resource
pub type Simplequantity
{
Simplequantity(id: Option(String),
extension: List(Extension),
value: Option(Float),
unit: Option(String),
system: Option(String),
code: Option(String),
)
}

pub fn simplequantity_new() ->Simplequantity{Simplequantity(code: None,system: None,unit: None,value: None,extension: [],id: None,)
}

pub fn simplequantity_to_json(simplequantity: Simplequantity) -> Json {
    let Simplequantity(code:,system:,unit:,value:,extension:,id:,) = simplequantity
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn simplequantity_decoder() -> Decoder(Simplequantity) {use code <- decode.optional_field("code", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use unit <- decode.optional_field("unit", None, decode.optional(decode.string))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Simplequantity(code:,system:,unit:,value:,extension:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Resource#resource
pub type Resource
{
Resource(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
)
}

pub fn resource_new() ->Resource{Resource(language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn resource_to_json(resource: Resource) -> Json {
    let Resource(language:,implicit_rules:,meta:,id:,) = resource
    let fields = []
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn resource_decoder() -> Decoder(Resource) {use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Resource(language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Account#resource
pub type Account
{
Account(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Accountstatus,
type_: Option(Codeableconcept),
name: Option(String),
subject: List(Reference),
service_period: Option(Period),
coverage: List(AccountCoverage),
owner: Option(Reference),
description: Option(String),
guarantor: List(AccountGuarantor),
part_of: Option(Reference),
)
}

pub fn account_new(status status: r4valuesets.Accountstatus,) ->Account{Account(part_of: None,guarantor: [],description: None,owner: None,coverage: [],service_period: None,subject: [],name: None,type_: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Account#resource
pub type AccountCoverage
{
AccountCoverage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
coverage: Reference,
priority: Option(Int),
)
}

pub fn account_coverage_new(coverage coverage: Reference,) ->AccountCoverage{AccountCoverage(priority: None,coverage:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Account#resource
pub type AccountGuarantor
{
AccountGuarantor(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
party: Reference,
on_hold: Option(Bool),
period: Option(Period),
)
}

pub fn account_guarantor_new(party party: Reference,) ->AccountGuarantor{AccountGuarantor(period: None,on_hold: None,party:,modifier_extension: [],extension: [],id: None,)
}

pub fn account_guarantor_to_json(account_guarantor: AccountGuarantor) -> Json {
    let AccountGuarantor(period:,on_hold:,party:,modifier_extension:,extension:,id:,) = account_guarantor
    let fields = [#("party", reference_to_json(party)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case on_hold {
                          Some(v) -> [#("onHold", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn account_guarantor_decoder() -> Decoder(AccountGuarantor) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use on_hold <- decode.optional_field("onHold", None, decode.optional(decode.bool))
use party <- decode.field("party",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AccountGuarantor(period:,on_hold:,party:,modifier_extension:,extension:,id:,))}
pub fn account_coverage_to_json(account_coverage: AccountCoverage) -> Json {
    let AccountCoverage(priority:,coverage:,modifier_extension:,extension:,id:,) = account_coverage
    let fields = [#("coverage", reference_to_json(coverage)),]
let fields = case priority {
                          Some(v) -> [#("priority", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn account_coverage_decoder() -> Decoder(AccountCoverage) {use priority <- decode.optional_field("priority", None, decode.optional(decode.int))
use coverage <- decode.field("coverage",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AccountCoverage(priority:,coverage:,modifier_extension:,extension:,id:,))}
pub fn account_to_json(account: Account) -> Json {
    let Account(part_of:,guarantor:,description:,owner:,coverage:,service_period:,subject:,name:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = account
    let fields = [#("status", r4valuesets.accountstatus_to_json(status)),]
let fields = case part_of {
                          Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case guarantor {
                        [] -> fields
                        _ -> [#("guarantor", json.array(guarantor,account_guarantor_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case owner {
                          Some(v) -> [#("owner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case coverage {
                        [] -> fields
                        _ -> [#("coverage", json.array(coverage,account_coverage_to_json)), ..fields]
                          }
let fields = case service_period {
                          Some(v) -> [#("servicePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn account_decoder() -> Decoder(Account) {use part_of <- decode.optional_field("partOf", None, decode.optional(reference_decoder()))
use guarantor <- decode.optional_field("guarantor", [], decode.list(account_guarantor_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use owner <- decode.optional_field("owner", None, decode.optional(reference_decoder()))
use coverage <- decode.optional_field("coverage", [], decode.list(account_coverage_decoder()))
use service_period <- decode.optional_field("servicePeriod", None, decode.optional(period_decoder()))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.accountstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Account(part_of:,guarantor:,description:,owner:,coverage:,service_period:,subject:,name:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type Activitydefinition
{
Activitydefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(ActivitydefinitionSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
library: List(String),
kind: Option(r4valuesets.Requestresourcetypes),
profile: Option(String),
code: Option(Codeableconcept),
intent: Option(r4valuesets.Requestintent),
priority: Option(r4valuesets.Requestpriority),
do_not_perform: Option(Bool),
timing: Option(ActivitydefinitionTiming),
location: Option(Reference),
participant: List(ActivitydefinitionParticipant),
product: Option(ActivitydefinitionProduct),
quantity: Option(Quantity),
dosage: List(Dosage),
body_site: List(Codeableconcept),
specimen_requirement: List(Reference),
observation_requirement: List(Reference),
observation_result_requirement: List(Reference),
transform: Option(String),
dynamic_value: List(ActivitydefinitionDynamicvalue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionSubject{
ActivitydefinitionSubjectCodeableconcept(subject: Codeableconcept)
ActivitydefinitionSubjectReference(subject: Reference)}
pub fn activitydefinition_subject_to_json(elt: ActivitydefinitionSubject) -> Json {case elt{ActivitydefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
ActivitydefinitionSubjectReference(v) -> reference_to_json(v)
}}
pub fn activitydefinition_subject_decoder() -> Decoder(ActivitydefinitionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ActivitydefinitionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(ActivitydefinitionSubjectReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionTiming{
ActivitydefinitionTimingTiming(timing: Timing)
ActivitydefinitionTimingDatetime(timing: String)
ActivitydefinitionTimingAge(timing: Age)
ActivitydefinitionTimingPeriod(timing: Period)
ActivitydefinitionTimingRange(timing: Range)
ActivitydefinitionTimingDuration(timing: Duration)}
pub fn activitydefinition_timing_to_json(elt: ActivitydefinitionTiming) -> Json {case elt{ActivitydefinitionTimingTiming(v) -> timing_to_json(v)
ActivitydefinitionTimingDatetime(v) -> json.string(v)
ActivitydefinitionTimingAge(v) -> age_to_json(v)
ActivitydefinitionTimingPeriod(v) -> period_to_json(v)
ActivitydefinitionTimingRange(v) -> range_to_json(v)
ActivitydefinitionTimingDuration(v) -> duration_to_json(v)
}}
pub fn activitydefinition_timing_decoder() -> Decoder(ActivitydefinitionTiming){decode.one_of(decode.field("timingTiming", timing_decoder(), decode.success) |> decode.map(ActivitydefinitionTimingTiming),[decode.field("timingDateTime", decode.string, decode.success) |> decode.map(ActivitydefinitionTimingDatetime),decode.field("timingAge", age_decoder(), decode.success) |> decode.map(ActivitydefinitionTimingAge),decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(ActivitydefinitionTimingPeriod),decode.field("timingRange", range_decoder(), decode.success) |> decode.map(ActivitydefinitionTimingRange),decode.field("timingDuration", duration_decoder(), decode.success) |> decode.map(ActivitydefinitionTimingDuration),])}

///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionProduct{
ActivitydefinitionProductReference(product: Reference)
ActivitydefinitionProductCodeableconcept(product: Codeableconcept)}
pub fn activitydefinition_product_to_json(elt: ActivitydefinitionProduct) -> Json {case elt{ActivitydefinitionProductReference(v) -> reference_to_json(v)
ActivitydefinitionProductCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn activitydefinition_product_decoder() -> Decoder(ActivitydefinitionProduct){decode.one_of(decode.field("productReference", reference_decoder(), decode.success) |> decode.map(ActivitydefinitionProductReference),[decode.field("productCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ActivitydefinitionProductCodeableconcept),])}
pub fn activitydefinition_new(status status: r4valuesets.Publicationstatus,) ->Activitydefinition{Activitydefinition(dynamic_value: [],transform: None,observation_result_requirement: [],observation_requirement: [],specimen_requirement: [],body_site: [],dosage: [],quantity: None,product: None,participant: [],location: None,timing: None,do_not_perform: None,priority: None,intent: None,code: None,profile: None,kind: None,library: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,subtitle: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionParticipant
{
ActivitydefinitionParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Actionparticipanttype,
role: Option(Codeableconcept),
)
}

pub fn activitydefinition_participant_new(type_ type_: r4valuesets.Actionparticipanttype,) ->ActivitydefinitionParticipant{ActivitydefinitionParticipant(role: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionDynamicvalue
{
ActivitydefinitionDynamicvalue(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
path: String,
expression: Expression,
)
}

pub fn activitydefinition_dynamicvalue_new(expression expression: Expression,path path: String,) ->ActivitydefinitionDynamicvalue{ActivitydefinitionDynamicvalue(expression:,path:,modifier_extension: [],extension: [],id: None,)
}

pub fn activitydefinition_dynamicvalue_to_json(activitydefinition_dynamicvalue: ActivitydefinitionDynamicvalue) -> Json {
    let ActivitydefinitionDynamicvalue(expression:,path:,modifier_extension:,extension:,id:,) = activitydefinition_dynamicvalue
    let fields = [#("expression", expression_to_json(expression)),#("path", json.string(path)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn activitydefinition_dynamicvalue_decoder() -> Decoder(ActivitydefinitionDynamicvalue) {use expression <- decode.field("expression",expression_decoder())
use path <- decode.field("path",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ActivitydefinitionDynamicvalue(expression:,path:,modifier_extension:,extension:,id:,))}
pub fn activitydefinition_participant_to_json(activitydefinition_participant: ActivitydefinitionParticipant) -> Json {
    let ActivitydefinitionParticipant(role:,type_:,modifier_extension:,extension:,id:,) = activitydefinition_participant
    let fields = [#("type", r4valuesets.actionparticipanttype_to_json(type_)),]
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn activitydefinition_participant_decoder() -> Decoder(ActivitydefinitionParticipant) {use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",r4valuesets.actionparticipanttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ActivitydefinitionParticipant(role:,type_:,modifier_extension:,extension:,id:,))}
pub fn activitydefinition_to_json(activitydefinition: Activitydefinition) -> Json {
    let Activitydefinition(dynamic_value:,transform:,observation_result_requirement:,observation_requirement:,specimen_requirement:,body_site:,dosage:,quantity:,product:,participant:,location:,timing:,do_not_perform:,priority:,intent:,code:,profile:,kind:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = activitydefinition
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case dynamic_value {
                        [] -> fields
                        _ -> [#("dynamicValue", json.array(dynamic_value,activitydefinition_dynamicvalue_to_json)), ..fields]
                          }
let fields = case transform {
                          Some(v) -> [#("transform", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case observation_result_requirement {
                        [] -> fields
                        _ -> [#("observationResultRequirement", json.array(observation_result_requirement,reference_to_json)), ..fields]
                          }
let fields = case observation_requirement {
                        [] -> fields
                        _ -> [#("observationRequirement", json.array(observation_requirement,reference_to_json)), ..fields]
                          }
let fields = case specimen_requirement {
                        [] -> fields
                        _ -> [#("specimenRequirement", json.array(specimen_requirement,reference_to_json)), ..fields]
                          }
let fields = case body_site {
                        [] -> fields
                        _ -> [#("bodySite", json.array(body_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case dosage {
                        [] -> fields
                        _ -> [#("dosage", json.array(dosage,dosage_to_json)), ..fields]
                          }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case product {
                          Some(v) -> [#("product", activitydefinition_product_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,activitydefinition_participant_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case timing {
                          Some(v) -> [#("timing", activitydefinition_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case intent {
                          Some(v) -> [#("intent", r4valuesets.requestintent_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case kind {
                          Some(v) -> [#("kind", r4valuesets.requestresourcetypes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case library {
                        [] -> fields
                        _ -> [#("library", json.array(library,json.string)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", activitydefinition_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn activitydefinition_decoder() -> Decoder(Activitydefinition) {use dynamic_value <- decode.optional_field("dynamicValue", [], decode.list(activitydefinition_dynamicvalue_decoder()))
use transform <- decode.optional_field("transform", None, decode.optional(decode.string))
use observation_result_requirement <- decode.optional_field("observationResultRequirement", [], decode.list(reference_decoder()))
use observation_requirement <- decode.optional_field("observationRequirement", [], decode.list(reference_decoder()))
use specimen_requirement <- decode.optional_field("specimenRequirement", [], decode.list(reference_decoder()))
use body_site <- decode.optional_field("bodySite", [], decode.list(codeableconcept_decoder()))
use dosage <- decode.optional_field("dosage", [], decode.list(dosage_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use product <- decode.then(none_if_omitted(activitydefinition_product_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(activitydefinition_participant_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use timing <- decode.then(none_if_omitted(activitydefinition_timing_decoder()))
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use intent <- decode.optional_field("intent", None, decode.optional(r4valuesets.requestintent_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use kind <- decode.optional_field("kind", None, decode.optional(r4valuesets.requestresourcetypes_decoder()))
use library <- decode.optional_field("library", [], decode.list(decode.string))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(activitydefinition_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Activitydefinition(dynamic_value:,transform:,observation_result_requirement:,observation_requirement:,specimen_requirement:,body_site:,dosage:,quantity:,product:,participant:,location:,timing:,do_not_perform:,priority:,intent:,code:,profile:,kind:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/AdverseEvent#resource
pub type Adverseevent
{
Adverseevent(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
actuality: r4valuesets.Adverseeventactuality,
category: List(Codeableconcept),
event: Option(Codeableconcept),
subject: Reference,
encounter: Option(Reference),
date: Option(String),
detected: Option(String),
recorded_date: Option(String),
resulting_condition: List(Reference),
location: Option(Reference),
seriousness: Option(Codeableconcept),
severity: Option(Codeableconcept),
outcome: Option(Codeableconcept),
recorder: Option(Reference),
contributor: List(Reference),
suspect_entity: List(AdverseeventSuspectentity),
subject_medical_history: List(Reference),
reference_document: List(Reference),
study: List(Reference),
)
}

pub fn adverseevent_new(subject subject: Reference,actuality actuality: r4valuesets.Adverseeventactuality,) ->Adverseevent{Adverseevent(study: [],reference_document: [],subject_medical_history: [],suspect_entity: [],contributor: [],recorder: None,outcome: None,severity: None,seriousness: None,location: None,resulting_condition: [],recorded_date: None,detected: None,date: None,encounter: None,subject:,event: None,category: [],actuality:,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentity
{
AdverseeventSuspectentity(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
instance: Reference,
causality: List(AdverseeventSuspectentityCausality),
)
}

pub fn adverseevent_suspectentity_new(instance instance: Reference,) ->AdverseeventSuspectentity{AdverseeventSuspectentity(causality: [],instance:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentityCausality
{
AdverseeventSuspectentityCausality(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
assessment: Option(Codeableconcept),
product_relatedness: Option(String),
author: Option(Reference),
method: Option(Codeableconcept),
)
}

pub fn adverseevent_suspectentity_causality_new() ->AdverseeventSuspectentityCausality{AdverseeventSuspectentityCausality(method: None,author: None,product_relatedness: None,assessment: None,modifier_extension: [],extension: [],id: None,)
}

pub fn adverseevent_suspectentity_causality_to_json(adverseevent_suspectentity_causality: AdverseeventSuspectentityCausality) -> Json {
    let AdverseeventSuspectentityCausality(method:,author:,product_relatedness:,assessment:,modifier_extension:,extension:,id:,) = adverseevent_suspectentity_causality
    let fields = []
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case product_relatedness {
                          Some(v) -> [#("productRelatedness", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case assessment {
                          Some(v) -> [#("assessment", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn adverseevent_suspectentity_causality_decoder() -> Decoder(AdverseeventSuspectentityCausality) {use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use product_relatedness <- decode.optional_field("productRelatedness", None, decode.optional(decode.string))
use assessment <- decode.optional_field("assessment", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AdverseeventSuspectentityCausality(method:,author:,product_relatedness:,assessment:,modifier_extension:,extension:,id:,))}
pub fn adverseevent_suspectentity_to_json(adverseevent_suspectentity: AdverseeventSuspectentity) -> Json {
    let AdverseeventSuspectentity(causality:,instance:,modifier_extension:,extension:,id:,) = adverseevent_suspectentity
    let fields = [#("instance", reference_to_json(instance)),]
let fields = case causality {
                        [] -> fields
                        _ -> [#("causality", json.array(causality,adverseevent_suspectentity_causality_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn adverseevent_suspectentity_decoder() -> Decoder(AdverseeventSuspectentity) {use causality <- decode.optional_field("causality", [], decode.list(adverseevent_suspectentity_causality_decoder()))
use instance <- decode.field("instance",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AdverseeventSuspectentity(causality:,instance:,modifier_extension:,extension:,id:,))}
pub fn adverseevent_to_json(adverseevent: Adverseevent) -> Json {
    let Adverseevent(study:,reference_document:,subject_medical_history:,suspect_entity:,contributor:,recorder:,outcome:,severity:,seriousness:,location:,resulting_condition:,recorded_date:,detected:,date:,encounter:,subject:,event:,category:,actuality:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = adverseevent
    let fields = [#("subject", reference_to_json(subject)),#("actuality", r4valuesets.adverseeventactuality_to_json(actuality)),]
let fields = case study {
                        [] -> fields
                        _ -> [#("study", json.array(study,reference_to_json)), ..fields]
                          }
let fields = case reference_document {
                        [] -> fields
                        _ -> [#("referenceDocument", json.array(reference_document,reference_to_json)), ..fields]
                          }
let fields = case subject_medical_history {
                        [] -> fields
                        _ -> [#("subjectMedicalHistory", json.array(subject_medical_history,reference_to_json)), ..fields]
                          }
let fields = case suspect_entity {
                        [] -> fields
                        _ -> [#("suspectEntity", json.array(suspect_entity,adverseevent_suspectentity_to_json)), ..fields]
                          }
let fields = case contributor {
                        [] -> fields
                        _ -> [#("contributor", json.array(contributor,reference_to_json)), ..fields]
                          }
let fields = case recorder {
                          Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case severity {
                          Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case seriousness {
                          Some(v) -> [#("seriousness", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case resulting_condition {
                        [] -> fields
                        _ -> [#("resultingCondition", json.array(resulting_condition,reference_to_json)), ..fields]
                          }
let fields = case recorded_date {
                          Some(v) -> [#("recordedDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case detected {
                          Some(v) -> [#("detected", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case event {
                          Some(v) -> [#("event", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn adverseevent_decoder() -> Decoder(Adverseevent) {use study <- decode.optional_field("study", [], decode.list(reference_decoder()))
use reference_document <- decode.optional_field("referenceDocument", [], decode.list(reference_decoder()))
use subject_medical_history <- decode.optional_field("subjectMedicalHistory", [], decode.list(reference_decoder()))
use suspect_entity <- decode.optional_field("suspectEntity", [], decode.list(adverseevent_suspectentity_decoder()))
use contributor <- decode.optional_field("contributor", [], decode.list(reference_decoder()))
use recorder <- decode.optional_field("recorder", None, decode.optional(reference_decoder()))
use outcome <- decode.optional_field("outcome", None, decode.optional(codeableconcept_decoder()))
use severity <- decode.optional_field("severity", None, decode.optional(codeableconcept_decoder()))
use seriousness <- decode.optional_field("seriousness", None, decode.optional(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use resulting_condition <- decode.optional_field("resultingCondition", [], decode.list(reference_decoder()))
use recorded_date <- decode.optional_field("recordedDate", None, decode.optional(decode.string))
use detected <- decode.optional_field("detected", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use event <- decode.optional_field("event", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use actuality <- decode.field("actuality",r4valuesets.adverseeventactuality_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Adverseevent(study:,reference_document:,subject_medical_history:,suspect_entity:,contributor:,recorder:,outcome:,severity:,seriousness:,location:,resulting_condition:,recorded_date:,detected:,date:,encounter:,subject:,event:,category:,actuality:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/AllergyIntolerance#resource
pub type Allergyintolerance
{
Allergyintolerance(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
clinical_status: Option(Codeableconcept),
verification_status: Option(Codeableconcept),
type_: Option(r4valuesets.Allergyintolerancetype),
category: List(r4valuesets.Allergyintolerancecategory),
criticality: Option(r4valuesets.Allergyintolerancecriticality),
code: Option(Codeableconcept),
patient: Reference,
encounter: Option(Reference),
onset: Option(AllergyintoleranceOnset),
recorded_date: Option(String),
recorder: Option(Reference),
asserter: Option(Reference),
last_occurrence: Option(String),
note: List(Annotation),
reaction: List(AllergyintoleranceReaction),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceOnset{
AllergyintoleranceOnsetDatetime(onset: String)
AllergyintoleranceOnsetAge(onset: Age)
AllergyintoleranceOnsetPeriod(onset: Period)
AllergyintoleranceOnsetRange(onset: Range)
AllergyintoleranceOnsetString(onset: String)}
pub fn allergyintolerance_onset_to_json(elt: AllergyintoleranceOnset) -> Json {case elt{AllergyintoleranceOnsetDatetime(v) -> json.string(v)
AllergyintoleranceOnsetAge(v) -> age_to_json(v)
AllergyintoleranceOnsetPeriod(v) -> period_to_json(v)
AllergyintoleranceOnsetRange(v) -> range_to_json(v)
AllergyintoleranceOnsetString(v) -> json.string(v)
}}
pub fn allergyintolerance_onset_decoder() -> Decoder(AllergyintoleranceOnset){decode.one_of(decode.field("onsetDateTime", decode.string, decode.success) |> decode.map(AllergyintoleranceOnsetDatetime),[decode.field("onsetAge", age_decoder(), decode.success) |> decode.map(AllergyintoleranceOnsetAge),decode.field("onsetPeriod", period_decoder(), decode.success) |> decode.map(AllergyintoleranceOnsetPeriod),decode.field("onsetRange", range_decoder(), decode.success) |> decode.map(AllergyintoleranceOnsetRange),decode.field("onsetString", decode.string, decode.success) |> decode.map(AllergyintoleranceOnsetString),])}
pub fn allergyintolerance_new(patient patient: Reference,) ->Allergyintolerance{Allergyintolerance(reaction: [],note: [],last_occurrence: None,asserter: None,recorder: None,recorded_date: None,onset: None,encounter: None,patient:,code: None,criticality: None,category: [],type_: None,verification_status: None,clinical_status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceReaction
{
AllergyintoleranceReaction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
substance: Option(Codeableconcept),
manifestation: List(Codeableconcept),
description: Option(String),
onset: Option(String),
severity: Option(r4valuesets.Reactioneventseverity),
exposure_route: Option(Codeableconcept),
note: List(Annotation),
)
}

pub fn allergyintolerance_reaction_new() ->AllergyintoleranceReaction{AllergyintoleranceReaction(note: [],exposure_route: None,severity: None,onset: None,description: None,manifestation: [],substance: None,modifier_extension: [],extension: [],id: None,)
}

pub fn allergyintolerance_reaction_to_json(allergyintolerance_reaction: AllergyintoleranceReaction) -> Json {
    let AllergyintoleranceReaction(note:,exposure_route:,severity:,onset:,description:,manifestation:,substance:,modifier_extension:,extension:,id:,) = allergyintolerance_reaction
    let fields = []
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case exposure_route {
                          Some(v) -> [#("exposureRoute", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case severity {
                          Some(v) -> [#("severity", r4valuesets.reactioneventseverity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case onset {
                          Some(v) -> [#("onset", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case manifestation {
                        [] -> fields
                        _ -> [#("manifestation", json.array(manifestation,codeableconcept_to_json)), ..fields]
                          }
let fields = case substance {
                          Some(v) -> [#("substance", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn allergyintolerance_reaction_decoder() -> Decoder(AllergyintoleranceReaction) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use exposure_route <- decode.optional_field("exposureRoute", None, decode.optional(codeableconcept_decoder()))
use severity <- decode.optional_field("severity", None, decode.optional(r4valuesets.reactioneventseverity_decoder()))
use onset <- decode.optional_field("onset", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use manifestation <- decode.optional_field("manifestation", [], decode.list(codeableconcept_decoder()))
use substance <- decode.optional_field("substance", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AllergyintoleranceReaction(note:,exposure_route:,severity:,onset:,description:,manifestation:,substance:,modifier_extension:,extension:,id:,))}
pub fn allergyintolerance_to_json(allergyintolerance: Allergyintolerance) -> Json {
    let Allergyintolerance(reaction:,note:,last_occurrence:,asserter:,recorder:,recorded_date:,onset:,encounter:,patient:,code:,criticality:,category:,type_:,verification_status:,clinical_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = allergyintolerance
    let fields = [#("patient", reference_to_json(patient)),]
let fields = case reaction {
                        [] -> fields
                        _ -> [#("reaction", json.array(reaction,allergyintolerance_reaction_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case last_occurrence {
                          Some(v) -> [#("lastOccurrence", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case asserter {
                          Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorder {
                          Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorded_date {
                          Some(v) -> [#("recordedDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case onset {
                          Some(v) -> [#("onset", allergyintolerance_onset_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case criticality {
                          Some(v) -> [#("criticality", r4valuesets.allergyintolerancecriticality_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,r4valuesets.allergyintolerancecategory_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.allergyintolerancetype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case verification_status {
                          Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case clinical_status {
                          Some(v) -> [#("clinicalStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn allergyintolerance_decoder() -> Decoder(Allergyintolerance) {use reaction <- decode.optional_field("reaction", [], decode.list(allergyintolerance_reaction_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use last_occurrence <- decode.optional_field("lastOccurrence", None, decode.optional(decode.string))
use asserter <- decode.optional_field("asserter", None, decode.optional(reference_decoder()))
use recorder <- decode.optional_field("recorder", None, decode.optional(reference_decoder()))
use recorded_date <- decode.optional_field("recordedDate", None, decode.optional(decode.string))
use onset <- decode.then(none_if_omitted(allergyintolerance_onset_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use patient <- decode.field("patient",reference_decoder())
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use criticality <- decode.optional_field("criticality", None, decode.optional(r4valuesets.allergyintolerancecriticality_decoder()))
use category <- decode.optional_field("category", [], decode.list(r4valuesets.allergyintolerancecategory_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.allergyintolerancetype_decoder()))
use verification_status <- decode.optional_field("verificationStatus", None, decode.optional(codeableconcept_decoder()))
use clinical_status <- decode.optional_field("clinicalStatus", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Allergyintolerance(reaction:,note:,last_occurrence:,asserter:,recorder:,recorded_date:,onset:,encounter:,patient:,code:,criticality:,category:,type_:,verification_status:,clinical_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Appointment#resource
pub type Appointment
{
Appointment(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Appointmentstatus,
cancelation_reason: Option(Codeableconcept),
service_category: List(Codeableconcept),
service_type: List(Codeableconcept),
specialty: List(Codeableconcept),
appointment_type: Option(Codeableconcept),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
priority: Option(Int),
description: Option(String),
supporting_information: List(Reference),
start: Option(String),
end: Option(String),
minutes_duration: Option(Int),
slot: List(Reference),
created: Option(String),
comment: Option(String),
patient_instruction: Option(String),
based_on: List(Reference),
participant: List(AppointmentParticipant),
requested_period: List(Period),
)
}

pub fn appointment_new(status status: r4valuesets.Appointmentstatus,) ->Appointment{Appointment(requested_period: [],participant: [],based_on: [],patient_instruction: None,comment: None,created: None,slot: [],minutes_duration: None,end: None,start: None,supporting_information: [],description: None,priority: None,reason_reference: [],reason_code: [],appointment_type: None,specialty: [],service_type: [],service_category: [],cancelation_reason: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Appointment#resource
pub type AppointmentParticipant
{
AppointmentParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: List(Codeableconcept),
actor: Option(Reference),
required: Option(r4valuesets.Participantrequired),
status: r4valuesets.Participationstatus,
period: Option(Period),
)
}

pub fn appointment_participant_new(status status: r4valuesets.Participationstatus,) ->AppointmentParticipant{AppointmentParticipant(period: None,status:,required: None,actor: None,type_: [],modifier_extension: [],extension: [],id: None,)
}

pub fn appointment_participant_to_json(appointment_participant: AppointmentParticipant) -> Json {
    let AppointmentParticipant(period:,status:,required:,actor:,type_:,modifier_extension:,extension:,id:,) = appointment_participant
    let fields = [#("status", r4valuesets.participationstatus_to_json(status)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case required {
                          Some(v) -> [#("required", r4valuesets.participantrequired_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case actor {
                          Some(v) -> [#("actor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn appointment_participant_decoder() -> Decoder(AppointmentParticipant) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use status <- decode.field("status",r4valuesets.participationstatus_decoder())
use required <- decode.optional_field("required", None, decode.optional(r4valuesets.participantrequired_decoder()))
use actor <- decode.optional_field("actor", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AppointmentParticipant(period:,status:,required:,actor:,type_:,modifier_extension:,extension:,id:,))}
pub fn appointment_to_json(appointment: Appointment) -> Json {
    let Appointment(requested_period:,participant:,based_on:,patient_instruction:,comment:,created:,slot:,minutes_duration:,end:,start:,supporting_information:,description:,priority:,reason_reference:,reason_code:,appointment_type:,specialty:,service_type:,service_category:,cancelation_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = appointment
    let fields = [#("status", r4valuesets.appointmentstatus_to_json(status)),]
let fields = case requested_period {
                        [] -> fields
                        _ -> [#("requestedPeriod", json.array(requested_period,period_to_json)), ..fields]
                          }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,appointment_participant_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case patient_instruction {
                          Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case slot {
                        [] -> fields
                        _ -> [#("slot", json.array(slot,reference_to_json)), ..fields]
                          }
let fields = case minutes_duration {
                          Some(v) -> [#("minutesDuration", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case end {
                          Some(v) -> [#("end", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case supporting_information {
                        [] -> fields
                        _ -> [#("supportingInformation", json.array(supporting_information,reference_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case appointment_type {
                          Some(v) -> [#("appointmentType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_type {
                        [] -> fields
                        _ -> [#("serviceType", json.array(service_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_category {
                        [] -> fields
                        _ -> [#("serviceCategory", json.array(service_category,codeableconcept_to_json)), ..fields]
                          }
let fields = case cancelation_reason {
                          Some(v) -> [#("cancelationReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn appointment_decoder() -> Decoder(Appointment) {use requested_period <- decode.optional_field("requestedPeriod", [], decode.list(period_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(appointment_participant_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use patient_instruction <- decode.optional_field("patientInstruction", None, decode.optional(decode.string))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use slot <- decode.optional_field("slot", [], decode.list(reference_decoder()))
use minutes_duration <- decode.optional_field("minutesDuration", None, decode.optional(decode.int))
use end <- decode.optional_field("end", None, decode.optional(decode.string))
use start <- decode.optional_field("start", None, decode.optional(decode.string))
use supporting_information <- decode.optional_field("supportingInformation", [], decode.list(reference_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use priority <- decode.optional_field("priority", None, decode.optional(decode.int))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use appointment_type <- decode.optional_field("appointmentType", None, decode.optional(codeableconcept_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use service_type <- decode.optional_field("serviceType", [], decode.list(codeableconcept_decoder()))
use service_category <- decode.optional_field("serviceCategory", [], decode.list(codeableconcept_decoder()))
use cancelation_reason <- decode.optional_field("cancelationReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.appointmentstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Appointment(requested_period:,participant:,based_on:,patient_instruction:,comment:,created:,slot:,minutes_duration:,end:,start:,supporting_information:,description:,priority:,reason_reference:,reason_code:,appointment_type:,specialty:,service_type:,service_category:,cancelation_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/AppointmentResponse#resource
pub type Appointmentresponse
{
Appointmentresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
appointment: Reference,
start: Option(String),
end: Option(String),
participant_type: List(Codeableconcept),
actor: Option(Reference),
participant_status: r4valuesets.Participationstatus,
comment: Option(String),
)
}

pub fn appointmentresponse_new(participant_status participant_status: r4valuesets.Participationstatus,appointment appointment: Reference,) ->Appointmentresponse{Appointmentresponse(comment: None,participant_status:,actor: None,participant_type: [],end: None,start: None,appointment:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn appointmentresponse_to_json(appointmentresponse: Appointmentresponse) -> Json {
    let Appointmentresponse(comment:,participant_status:,actor:,participant_type:,end:,start:,appointment:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = appointmentresponse
    let fields = [#("participantStatus", r4valuesets.participationstatus_to_json(participant_status)),#("appointment", reference_to_json(appointment)),]
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case actor {
                          Some(v) -> [#("actor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant_type {
                        [] -> fields
                        _ -> [#("participantType", json.array(participant_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case end {
                          Some(v) -> [#("end", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn appointmentresponse_decoder() -> Decoder(Appointmentresponse) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use participant_status <- decode.field("participantStatus",r4valuesets.participationstatus_decoder())
use actor <- decode.optional_field("actor", None, decode.optional(reference_decoder()))
use participant_type <- decode.optional_field("participantType", [], decode.list(codeableconcept_decoder()))
use end <- decode.optional_field("end", None, decode.optional(decode.string))
use start <- decode.optional_field("start", None, decode.optional(decode.string))
use appointment <- decode.field("appointment",reference_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Appointmentresponse(comment:,participant_status:,actor:,participant_type:,end:,start:,appointment:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type Auditevent
{
Auditevent(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Coding,
subtype: List(Coding),
action: Option(r4valuesets.Auditeventaction),
period: Option(Period),
recorded: String,
outcome: Option(r4valuesets.Auditeventoutcome),
outcome_desc: Option(String),
purpose_of_event: List(Codeableconcept),
agent: List(AuditeventAgent),
source: AuditeventSource,
entity: List(AuditeventEntity),
)
}

pub fn auditevent_new(source source: AuditeventSource,recorded recorded: String,type_ type_: Coding,) ->Auditevent{Auditevent(entity: [],source:,agent: [],purpose_of_event: [],outcome_desc: None,outcome: None,recorded:,period: None,action: None,subtype: [],type_:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventAgent
{
AuditeventAgent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
role: List(Codeableconcept),
who: Option(Reference),
alt_id: Option(String),
name: Option(String),
requestor: Bool,
location: Option(Reference),
policy: List(String),
media: Option(Coding),
network: Option(AuditeventAgentNetwork),
purpose_of_use: List(Codeableconcept),
)
}

pub fn auditevent_agent_new(requestor requestor: Bool,) ->AuditeventAgent{AuditeventAgent(purpose_of_use: [],network: None,media: None,policy: [],location: None,requestor:,name: None,alt_id: None,who: None,role: [],type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventAgentNetwork
{
AuditeventAgentNetwork(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
address: Option(String),
type_: Option(r4valuesets.Networktype),
)
}

pub fn auditevent_agent_network_new() ->AuditeventAgentNetwork{AuditeventAgentNetwork(type_: None,address: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventSource
{
AuditeventSource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
site: Option(String),
observer: Reference,
type_: List(Coding),
)
}

pub fn auditevent_source_new(observer observer: Reference,) ->AuditeventSource{AuditeventSource(type_: [],observer:,site: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventEntity
{
AuditeventEntity(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
what: Option(Reference),
type_: Option(Coding),
role: Option(Coding),
lifecycle: Option(Coding),
security_label: List(Coding),
name: Option(String),
description: Option(String),
query: Option(String),
detail: List(AuditeventEntityDetail),
)
}

pub fn auditevent_entity_new() ->AuditeventEntity{AuditeventEntity(detail: [],query: None,description: None,name: None,security_label: [],lifecycle: None,role: None,type_: None,what: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetail
{
AuditeventEntityDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: String,
value: AuditeventEntityDetailValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetailValue{
AuditeventEntityDetailValueString(value: String)
AuditeventEntityDetailValueBase64binary(value: String)}
pub fn auditevent_entity_detail_value_to_json(elt: AuditeventEntityDetailValue) -> Json {case elt{AuditeventEntityDetailValueString(v) -> json.string(v)
AuditeventEntityDetailValueBase64binary(v) -> json.string(v)
}}
pub fn auditevent_entity_detail_value_decoder() -> Decoder(AuditeventEntityDetailValue){decode.one_of(decode.field("valueString", decode.string, decode.success) |> decode.map(AuditeventEntityDetailValueString),[decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(AuditeventEntityDetailValueBase64binary),])}
pub fn auditevent_entity_detail_new(value value: AuditeventEntityDetailValue,type_ type_: String,) ->AuditeventEntityDetail{AuditeventEntityDetail(value:,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn auditevent_entity_detail_to_json(auditevent_entity_detail: AuditeventEntityDetail) -> Json {
    let AuditeventEntityDetail(value:,type_:,modifier_extension:,extension:,id:,) = auditevent_entity_detail
    let fields = [#("value", auditevent_entity_detail_value_to_json(value)),#("type", json.string(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_entity_detail_decoder() -> Decoder(AuditeventEntityDetail) {use value <- decode.then(auditevent_entity_detail_value_decoder())
use type_ <- decode.field("type",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AuditeventEntityDetail(value:,type_:,modifier_extension:,extension:,id:,))}
pub fn auditevent_entity_to_json(auditevent_entity: AuditeventEntity) -> Json {
    let AuditeventEntity(detail:,query:,description:,name:,security_label:,lifecycle:,role:,type_:,what:,modifier_extension:,extension:,id:,) = auditevent_entity
    let fields = []
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,auditevent_entity_detail_to_json)), ..fields]
                          }
let fields = case query {
                          Some(v) -> [#("query", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case security_label {
                        [] -> fields
                        _ -> [#("securityLabel", json.array(security_label,coding_to_json)), ..fields]
                          }
let fields = case lifecycle {
                          Some(v) -> [#("lifecycle", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                          Some(v) -> [#("role", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case what {
                          Some(v) -> [#("what", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_entity_decoder() -> Decoder(AuditeventEntity) {use detail <- decode.optional_field("detail", [], decode.list(auditevent_entity_detail_decoder()))
use query <- decode.optional_field("query", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use security_label <- decode.optional_field("securityLabel", [], decode.list(coding_decoder()))
use lifecycle <- decode.optional_field("lifecycle", None, decode.optional(coding_decoder()))
use role <- decode.optional_field("role", None, decode.optional(coding_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(coding_decoder()))
use what <- decode.optional_field("what", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AuditeventEntity(detail:,query:,description:,name:,security_label:,lifecycle:,role:,type_:,what:,modifier_extension:,extension:,id:,))}
pub fn auditevent_source_to_json(auditevent_source: AuditeventSource) -> Json {
    let AuditeventSource(type_:,observer:,site:,modifier_extension:,extension:,id:,) = auditevent_source
    let fields = [#("observer", reference_to_json(observer)),]
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,coding_to_json)), ..fields]
                          }
let fields = case site {
                          Some(v) -> [#("site", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_source_decoder() -> Decoder(AuditeventSource) {use type_ <- decode.optional_field("type", [], decode.list(coding_decoder()))
use observer <- decode.field("observer",reference_decoder())
use site <- decode.optional_field("site", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AuditeventSource(type_:,observer:,site:,modifier_extension:,extension:,id:,))}
pub fn auditevent_agent_network_to_json(auditevent_agent_network: AuditeventAgentNetwork) -> Json {
    let AuditeventAgentNetwork(type_:,address:,modifier_extension:,extension:,id:,) = auditevent_agent_network
    let fields = []
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.networktype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                          Some(v) -> [#("address", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_agent_network_decoder() -> Decoder(AuditeventAgentNetwork) {use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.networktype_decoder()))
use address <- decode.optional_field("address", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AuditeventAgentNetwork(type_:,address:,modifier_extension:,extension:,id:,))}
pub fn auditevent_agent_to_json(auditevent_agent: AuditeventAgent) -> Json {
    let AuditeventAgent(purpose_of_use:,network:,media:,policy:,location:,requestor:,name:,alt_id:,who:,role:,type_:,modifier_extension:,extension:,id:,) = auditevent_agent
    let fields = [#("requestor", json.bool(requestor)),]
let fields = case purpose_of_use {
                        [] -> fields
                        _ -> [#("purposeOfUse", json.array(purpose_of_use,codeableconcept_to_json)), ..fields]
                          }
let fields = case network {
                          Some(v) -> [#("network", auditevent_agent_network_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case media {
                          Some(v) -> [#("media", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case policy {
                        [] -> fields
                        _ -> [#("policy", json.array(policy,json.string)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case alt_id {
                          Some(v) -> [#("altId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case who {
                          Some(v) -> [#("who", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                        [] -> fields
                        _ -> [#("role", json.array(role,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_agent_decoder() -> Decoder(AuditeventAgent) {use purpose_of_use <- decode.optional_field("purposeOfUse", [], decode.list(codeableconcept_decoder()))
use network <- decode.optional_field("network", None, decode.optional(auditevent_agent_network_decoder()))
use media <- decode.optional_field("media", None, decode.optional(coding_decoder()))
use policy <- decode.optional_field("policy", [], decode.list(decode.string))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use requestor <- decode.field("requestor",decode.bool)
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use alt_id <- decode.optional_field("altId", None, decode.optional(decode.string))
use who <- decode.optional_field("who", None, decode.optional(reference_decoder()))
use role <- decode.optional_field("role", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(AuditeventAgent(purpose_of_use:,network:,media:,policy:,location:,requestor:,name:,alt_id:,who:,role:,type_:,modifier_extension:,extension:,id:,))}
pub fn auditevent_to_json(auditevent: Auditevent) -> Json {
    let Auditevent(entity:,source:,agent:,purpose_of_event:,outcome_desc:,outcome:,recorded:,period:,action:,subtype:,type_:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = auditevent
    let fields = [#("source", auditevent_source_to_json(source)),#("recorded", json.string(recorded)),#("type", coding_to_json(type_)),]
let fields = case entity {
                        [] -> fields
                        _ -> [#("entity", json.array(entity,auditevent_entity_to_json)), ..fields]
                          }
let fields = case agent {
                        [] -> fields
                        _ -> [#("agent", json.array(agent,auditevent_agent_to_json)), ..fields]
                          }
let fields = case purpose_of_event {
                        [] -> fields
                        _ -> [#("purposeOfEvent", json.array(purpose_of_event,codeableconcept_to_json)), ..fields]
                          }
let fields = case outcome_desc {
                          Some(v) -> [#("outcomeDesc", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", r4valuesets.auditeventoutcome_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case action {
                          Some(v) -> [#("action", r4valuesets.auditeventaction_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subtype {
                        [] -> fields
                        _ -> [#("subtype", json.array(subtype,coding_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn auditevent_decoder() -> Decoder(Auditevent) {use entity <- decode.optional_field("entity", [], decode.list(auditevent_entity_decoder()))
use source <- decode.field("source",auditevent_source_decoder())
use agent <- decode.optional_field("agent", [], decode.list(auditevent_agent_decoder()))
use purpose_of_event <- decode.optional_field("purposeOfEvent", [], decode.list(codeableconcept_decoder()))
use outcome_desc <- decode.optional_field("outcomeDesc", None, decode.optional(decode.string))
use outcome <- decode.optional_field("outcome", None, decode.optional(r4valuesets.auditeventoutcome_decoder()))
use recorded <- decode.field("recorded",decode.string)
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use action <- decode.optional_field("action", None, decode.optional(r4valuesets.auditeventaction_decoder()))
use subtype <- decode.optional_field("subtype", [], decode.list(coding_decoder()))
use type_ <- decode.field("type",coding_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Auditevent(entity:,source:,agent:,purpose_of_event:,outcome_desc:,outcome:,recorded:,period:,action:,subtype:,type_:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Basic#resource
pub type Basic
{
Basic(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
code: Codeableconcept,
subject: Option(Reference),
created: Option(String),
author: Option(Reference),
)
}

pub fn basic_new(code code: Codeableconcept,) ->Basic{Basic(author: None,created: None,subject: None,code:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn basic_to_json(basic: Basic) -> Json {
    let Basic(author:,created:,subject:,code:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = basic
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn basic_decoder() -> Decoder(Basic) {use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Basic(author:,created:,subject:,code:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Binary#resource
pub type Binary
{
Binary(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
content_type: String,
security_context: Option(Reference),
data: Option(String),
)
}

pub fn binary_new(content_type content_type: String,) ->Binary{Binary(data: None,security_context: None,content_type:,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn binary_to_json(binary: Binary) -> Json {
    let Binary(data:,security_context:,content_type:,language:,implicit_rules:,meta:,id:,) = binary
    let fields = [#("contentType", json.string(content_type)),]
let fields = case data {
                          Some(v) -> [#("data", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case security_context {
                          Some(v) -> [#("securityContext", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn binary_decoder() -> Decoder(Binary) {use data <- decode.optional_field("data", None, decode.optional(decode.string))
use security_context <- decode.optional_field("securityContext", None, decode.optional(reference_decoder()))
use content_type <- decode.field("contentType",decode.string)
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Binary(data:,security_context:,content_type:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type Biologicallyderivedproduct
{
Biologicallyderivedproduct(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
product_category: Option(r4valuesets.Productcategory),
product_code: Option(Codeableconcept),
status: Option(r4valuesets.Productstatus),
request: List(Reference),
quantity: Option(Int),
parent: List(Reference),
collection: Option(BiologicallyderivedproductCollection),
processing: List(BiologicallyderivedproductProcessing),
manipulation: Option(BiologicallyderivedproductManipulation),
storage: List(BiologicallyderivedproductStorage),
)
}

pub fn biologicallyderivedproduct_new() ->Biologicallyderivedproduct{Biologicallyderivedproduct(storage: [],manipulation: None,processing: [],collection: None,parent: [],quantity: None,request: [],status: None,product_code: None,product_category: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollection
{
BiologicallyderivedproductCollection(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
collector: Option(Reference),
source: Option(Reference),
collected: Option(BiologicallyderivedproductCollectionCollected),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollectionCollected{
BiologicallyderivedproductCollectionCollectedDatetime(collected: String)
BiologicallyderivedproductCollectionCollectedPeriod(collected: Period)}
pub fn biologicallyderivedproduct_collection_collected_to_json(elt: BiologicallyderivedproductCollectionCollected) -> Json {case elt{BiologicallyderivedproductCollectionCollectedDatetime(v) -> json.string(v)
BiologicallyderivedproductCollectionCollectedPeriod(v) -> period_to_json(v)
}}
pub fn biologicallyderivedproduct_collection_collected_decoder() -> Decoder(BiologicallyderivedproductCollectionCollected){decode.one_of(decode.field("collectedDateTime", decode.string, decode.success) |> decode.map(BiologicallyderivedproductCollectionCollectedDatetime),[decode.field("collectedPeriod", period_decoder(), decode.success) |> decode.map(BiologicallyderivedproductCollectionCollectedPeriod),])}
pub fn biologicallyderivedproduct_collection_new() ->BiologicallyderivedproductCollection{BiologicallyderivedproductCollection(collected: None,source: None,collector: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductProcessing
{
BiologicallyderivedproductProcessing(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
procedure: Option(Codeableconcept),
additive: Option(Reference),
time: Option(BiologicallyderivedproductProcessingTime),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductProcessingTime{
BiologicallyderivedproductProcessingTimeDatetime(time: String)
BiologicallyderivedproductProcessingTimePeriod(time: Period)}
pub fn biologicallyderivedproduct_processing_time_to_json(elt: BiologicallyderivedproductProcessingTime) -> Json {case elt{BiologicallyderivedproductProcessingTimeDatetime(v) -> json.string(v)
BiologicallyderivedproductProcessingTimePeriod(v) -> period_to_json(v)
}}
pub fn biologicallyderivedproduct_processing_time_decoder() -> Decoder(BiologicallyderivedproductProcessingTime){decode.one_of(decode.field("timeDateTime", decode.string, decode.success) |> decode.map(BiologicallyderivedproductProcessingTimeDatetime),[decode.field("timePeriod", period_decoder(), decode.success) |> decode.map(BiologicallyderivedproductProcessingTimePeriod),])}
pub fn biologicallyderivedproduct_processing_new() ->BiologicallyderivedproductProcessing{BiologicallyderivedproductProcessing(time: None,additive: None,procedure: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductManipulation
{
BiologicallyderivedproductManipulation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
time: Option(BiologicallyderivedproductManipulationTime),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductManipulationTime{
BiologicallyderivedproductManipulationTimeDatetime(time: String)
BiologicallyderivedproductManipulationTimePeriod(time: Period)}
pub fn biologicallyderivedproduct_manipulation_time_to_json(elt: BiologicallyderivedproductManipulationTime) -> Json {case elt{BiologicallyderivedproductManipulationTimeDatetime(v) -> json.string(v)
BiologicallyderivedproductManipulationTimePeriod(v) -> period_to_json(v)
}}
pub fn biologicallyderivedproduct_manipulation_time_decoder() -> Decoder(BiologicallyderivedproductManipulationTime){decode.one_of(decode.field("timeDateTime", decode.string, decode.success) |> decode.map(BiologicallyderivedproductManipulationTimeDatetime),[decode.field("timePeriod", period_decoder(), decode.success) |> decode.map(BiologicallyderivedproductManipulationTimePeriod),])}
pub fn biologicallyderivedproduct_manipulation_new() ->BiologicallyderivedproductManipulation{BiologicallyderivedproductManipulation(time: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductStorage
{
BiologicallyderivedproductStorage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
temperature: Option(Float),
scale: Option(r4valuesets.Productstoragescale),
duration: Option(Period),
)
}

pub fn biologicallyderivedproduct_storage_new() ->BiologicallyderivedproductStorage{BiologicallyderivedproductStorage(duration: None,scale: None,temperature: None,description: None,modifier_extension: [],extension: [],id: None,)
}

pub fn biologicallyderivedproduct_storage_to_json(biologicallyderivedproduct_storage: BiologicallyderivedproductStorage) -> Json {
    let BiologicallyderivedproductStorage(duration:,scale:,temperature:,description:,modifier_extension:,extension:,id:,) = biologicallyderivedproduct_storage
    let fields = []
let fields = case duration {
                          Some(v) -> [#("duration", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case scale {
                          Some(v) -> [#("scale", r4valuesets.productstoragescale_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case temperature {
                          Some(v) -> [#("temperature", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn biologicallyderivedproduct_storage_decoder() -> Decoder(BiologicallyderivedproductStorage) {use duration <- decode.optional_field("duration", None, decode.optional(period_decoder()))
use scale <- decode.optional_field("scale", None, decode.optional(r4valuesets.productstoragescale_decoder()))
use temperature <- decode.optional_field("temperature", None, decode.optional(decode.float))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BiologicallyderivedproductStorage(duration:,scale:,temperature:,description:,modifier_extension:,extension:,id:,))}
pub fn biologicallyderivedproduct_manipulation_to_json(biologicallyderivedproduct_manipulation: BiologicallyderivedproductManipulation) -> Json {
    let BiologicallyderivedproductManipulation(time:,description:,modifier_extension:,extension:,id:,) = biologicallyderivedproduct_manipulation
    let fields = []
let fields = case time {
                          Some(v) -> [#("time", biologicallyderivedproduct_manipulation_time_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn biologicallyderivedproduct_manipulation_decoder() -> Decoder(BiologicallyderivedproductManipulation) {use time <- decode.then(none_if_omitted(biologicallyderivedproduct_manipulation_time_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BiologicallyderivedproductManipulation(time:,description:,modifier_extension:,extension:,id:,))}
pub fn biologicallyderivedproduct_processing_to_json(biologicallyderivedproduct_processing: BiologicallyderivedproductProcessing) -> Json {
    let BiologicallyderivedproductProcessing(time:,additive:,procedure:,description:,modifier_extension:,extension:,id:,) = biologicallyderivedproduct_processing
    let fields = []
let fields = case time {
                          Some(v) -> [#("time", biologicallyderivedproduct_processing_time_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case additive {
                          Some(v) -> [#("additive", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case procedure {
                          Some(v) -> [#("procedure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn biologicallyderivedproduct_processing_decoder() -> Decoder(BiologicallyderivedproductProcessing) {use time <- decode.then(none_if_omitted(biologicallyderivedproduct_processing_time_decoder()))
use additive <- decode.optional_field("additive", None, decode.optional(reference_decoder()))
use procedure <- decode.optional_field("procedure", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BiologicallyderivedproductProcessing(time:,additive:,procedure:,description:,modifier_extension:,extension:,id:,))}
pub fn biologicallyderivedproduct_collection_to_json(biologicallyderivedproduct_collection: BiologicallyderivedproductCollection) -> Json {
    let BiologicallyderivedproductCollection(collected:,source:,collector:,modifier_extension:,extension:,id:,) = biologicallyderivedproduct_collection
    let fields = []
let fields = case collected {
                          Some(v) -> [#("collected", biologicallyderivedproduct_collection_collected_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case collector {
                          Some(v) -> [#("collector", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn biologicallyderivedproduct_collection_decoder() -> Decoder(BiologicallyderivedproductCollection) {use collected <- decode.then(none_if_omitted(biologicallyderivedproduct_collection_collected_decoder()))
use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use collector <- decode.optional_field("collector", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BiologicallyderivedproductCollection(collected:,source:,collector:,modifier_extension:,extension:,id:,))}
pub fn biologicallyderivedproduct_to_json(biologicallyderivedproduct: Biologicallyderivedproduct) -> Json {
    let Biologicallyderivedproduct(storage:,manipulation:,processing:,collection:,parent:,quantity:,request:,status:,product_code:,product_category:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = biologicallyderivedproduct
    let fields = []
let fields = case storage {
                        [] -> fields
                        _ -> [#("storage", json.array(storage,biologicallyderivedproduct_storage_to_json)), ..fields]
                          }
let fields = case manipulation {
                          Some(v) -> [#("manipulation", biologicallyderivedproduct_manipulation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case processing {
                        [] -> fields
                        _ -> [#("processing", json.array(processing,biologicallyderivedproduct_processing_to_json)), ..fields]
                          }
let fields = case collection {
                          Some(v) -> [#("collection", biologicallyderivedproduct_collection_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parent {
                        [] -> fields
                        _ -> [#("parent", json.array(parent,reference_to_json)), ..fields]
                          }
let fields = case quantity {
                          Some(v) -> [#("quantity", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                        [] -> fields
                        _ -> [#("request", json.array(request,reference_to_json)), ..fields]
                          }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.productstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case product_code {
                          Some(v) -> [#("productCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case product_category {
                          Some(v) -> [#("productCategory", r4valuesets.productcategory_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn biologicallyderivedproduct_decoder() -> Decoder(Biologicallyderivedproduct) {use storage <- decode.optional_field("storage", [], decode.list(biologicallyderivedproduct_storage_decoder()))
use manipulation <- decode.optional_field("manipulation", None, decode.optional(biologicallyderivedproduct_manipulation_decoder()))
use processing <- decode.optional_field("processing", [], decode.list(biologicallyderivedproduct_processing_decoder()))
use collection <- decode.optional_field("collection", None, decode.optional(biologicallyderivedproduct_collection_decoder()))
use parent <- decode.optional_field("parent", [], decode.list(reference_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(decode.int))
use request <- decode.optional_field("request", [], decode.list(reference_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.productstatus_decoder()))
use product_code <- decode.optional_field("productCode", None, decode.optional(codeableconcept_decoder()))
use product_category <- decode.optional_field("productCategory", None, decode.optional(r4valuesets.productcategory_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Biologicallyderivedproduct(storage:,manipulation:,processing:,collection:,parent:,quantity:,request:,status:,product_code:,product_category:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/BodyStructure#resource
pub type Bodystructure
{
Bodystructure(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
morphology: Option(Codeableconcept),
location: Option(Codeableconcept),
location_qualifier: List(Codeableconcept),
description: Option(String),
image: List(Attachment),
patient: Reference,
)
}

pub fn bodystructure_new(patient patient: Reference,) ->Bodystructure{Bodystructure(patient:,image: [],description: None,location_qualifier: [],location: None,morphology: None,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn bodystructure_to_json(bodystructure: Bodystructure) -> Json {
    let Bodystructure(patient:,image:,description:,location_qualifier:,location:,morphology:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = bodystructure
    let fields = [#("patient", reference_to_json(patient)),]
let fields = case image {
                        [] -> fields
                        _ -> [#("image", json.array(image,attachment_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case location_qualifier {
                        [] -> fields
                        _ -> [#("locationQualifier", json.array(location_qualifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case morphology {
                          Some(v) -> [#("morphology", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bodystructure_decoder() -> Decoder(Bodystructure) {use patient <- decode.field("patient",reference_decoder())
use image <- decode.optional_field("image", [], decode.list(attachment_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use location_qualifier <- decode.optional_field("locationQualifier", [], decode.list(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(codeableconcept_decoder()))
use morphology <- decode.optional_field("morphology", None, decode.optional(codeableconcept_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Bodystructure(patient:,image:,description:,location_qualifier:,location:,morphology:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type Bundle
{
Bundle(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
identifier: Option(Identifier),
type_: r4valuesets.Bundletype,
timestamp: Option(String),
total: Option(Int),
link: List(BundleLink),
entry: List(BundleEntry),
signature: Option(Signature),
)
}

pub fn bundle_new(type_ type_: r4valuesets.Bundletype,) ->Bundle{Bundle(signature: None,entry: [],link: [],total: None,timestamp: None,type_:,identifier: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type BundleLink
{
BundleLink(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
relation: String,
url: String,
)
}

pub fn bundle_link_new(url url: String,relation relation: String,) ->BundleLink{BundleLink(url:,relation:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type BundleEntry
{
BundleEntry(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
full_url: Option(String),
resource: Option(Resource),
search: Option(BundleEntrySearch),
request: Option(BundleEntryRequest),
response: Option(BundleEntryResponse),
)
}

pub fn bundle_entry_new() ->BundleEntry{BundleEntry(response: None,request: None,search: None,resource: None,full_url: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type BundleEntrySearch
{
BundleEntrySearch(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: Option(r4valuesets.Searchentrymode),
score: Option(Float),
)
}

pub fn bundle_entry_search_new() ->BundleEntrySearch{BundleEntrySearch(score: None,mode: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type BundleEntryRequest
{
BundleEntryRequest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
method: r4valuesets.Httpverb,
url: String,
if_none_match: Option(String),
if_modified_since: Option(String),
if_match: Option(String),
if_none_exist: Option(String),
)
}

pub fn bundle_entry_request_new(url url: String,method method: r4valuesets.Httpverb,) ->BundleEntryRequest{BundleEntryRequest(if_none_exist: None,if_match: None,if_modified_since: None,if_none_match: None,url:,method:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Bundle#resource
pub type BundleEntryResponse
{
BundleEntryResponse(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
status: String,
location: Option(String),
etag: Option(String),
last_modified: Option(String),
outcome: Option(Resource),
)
}

pub fn bundle_entry_response_new(status status: String,) ->BundleEntryResponse{BundleEntryResponse(outcome: None,last_modified: None,etag: None,location: None,status:,modifier_extension: [],extension: [],id: None,)
}

pub fn bundle_entry_response_to_json(bundle_entry_response: BundleEntryResponse) -> Json {
    let BundleEntryResponse(outcome:,last_modified:,etag:,location:,status:,modifier_extension:,extension:,id:,) = bundle_entry_response
    let fields = [#("status", json.string(status)),]
let fields = case outcome {
                          Some(v) -> [#("outcome", resource_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_modified {
                          Some(v) -> [#("lastModified", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case etag {
                          Some(v) -> [#("etag", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_entry_response_decoder() -> Decoder(BundleEntryResponse) {use outcome <- decode.optional_field("outcome", None, decode.optional(resource_decoder()))
use last_modified <- decode.optional_field("lastModified", None, decode.optional(decode.string))
use etag <- decode.optional_field("etag", None, decode.optional(decode.string))
use location <- decode.optional_field("location", None, decode.optional(decode.string))
use status <- decode.field("status",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BundleEntryResponse(outcome:,last_modified:,etag:,location:,status:,modifier_extension:,extension:,id:,))}
pub fn bundle_entry_request_to_json(bundle_entry_request: BundleEntryRequest) -> Json {
    let BundleEntryRequest(if_none_exist:,if_match:,if_modified_since:,if_none_match:,url:,method:,modifier_extension:,extension:,id:,) = bundle_entry_request
    let fields = [#("url", json.string(url)),#("method", r4valuesets.httpverb_to_json(method)),]
let fields = case if_none_exist {
                          Some(v) -> [#("ifNoneExist", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case if_match {
                          Some(v) -> [#("ifMatch", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case if_modified_since {
                          Some(v) -> [#("ifModifiedSince", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case if_none_match {
                          Some(v) -> [#("ifNoneMatch", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_entry_request_decoder() -> Decoder(BundleEntryRequest) {use if_none_exist <- decode.optional_field("ifNoneExist", None, decode.optional(decode.string))
use if_match <- decode.optional_field("ifMatch", None, decode.optional(decode.string))
use if_modified_since <- decode.optional_field("ifModifiedSince", None, decode.optional(decode.string))
use if_none_match <- decode.optional_field("ifNoneMatch", None, decode.optional(decode.string))
use url <- decode.field("url",decode.string)
use method <- decode.field("method",r4valuesets.httpverb_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BundleEntryRequest(if_none_exist:,if_match:,if_modified_since:,if_none_match:,url:,method:,modifier_extension:,extension:,id:,))}
pub fn bundle_entry_search_to_json(bundle_entry_search: BundleEntrySearch) -> Json {
    let BundleEntrySearch(score:,mode:,modifier_extension:,extension:,id:,) = bundle_entry_search
    let fields = []
let fields = case score {
                          Some(v) -> [#("score", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case mode {
                          Some(v) -> [#("mode", r4valuesets.searchentrymode_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_entry_search_decoder() -> Decoder(BundleEntrySearch) {use score <- decode.optional_field("score", None, decode.optional(decode.float))
use mode <- decode.optional_field("mode", None, decode.optional(r4valuesets.searchentrymode_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BundleEntrySearch(score:,mode:,modifier_extension:,extension:,id:,))}
pub fn bundle_entry_to_json(bundle_entry: BundleEntry) -> Json {
    let BundleEntry(response:,request:,search:,resource:,full_url:,modifier_extension:,extension:,id:,) = bundle_entry
    let fields = []
let fields = case response {
                          Some(v) -> [#("response", bundle_entry_response_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", bundle_entry_request_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case search {
                          Some(v) -> [#("search", bundle_entry_search_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case resource {
                          Some(v) -> [#("resource", resource_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case full_url {
                          Some(v) -> [#("fullUrl", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_entry_decoder() -> Decoder(BundleEntry) {use response <- decode.optional_field("response", None, decode.optional(bundle_entry_response_decoder()))
use request <- decode.optional_field("request", None, decode.optional(bundle_entry_request_decoder()))
use search <- decode.optional_field("search", None, decode.optional(bundle_entry_search_decoder()))
use resource <- decode.optional_field("resource", None, decode.optional(resource_decoder()))
use full_url <- decode.optional_field("fullUrl", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BundleEntry(response:,request:,search:,resource:,full_url:,modifier_extension:,extension:,id:,))}
pub fn bundle_link_to_json(bundle_link: BundleLink) -> Json {
    let BundleLink(url:,relation:,modifier_extension:,extension:,id:,) = bundle_link
    let fields = [#("url", json.string(url)),#("relation", json.string(relation)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_link_decoder() -> Decoder(BundleLink) {use url <- decode.field("url",decode.string)
use relation <- decode.field("relation",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(BundleLink(url:,relation:,modifier_extension:,extension:,id:,))}
pub fn bundle_to_json(bundle: Bundle) -> Json {
    let Bundle(signature:,entry:,link:,total:,timestamp:,type_:,identifier:,language:,implicit_rules:,meta:,id:,) = bundle
    let fields = [#("type", r4valuesets.bundletype_to_json(type_)),]
let fields = case signature {
                          Some(v) -> [#("signature", signature_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case entry {
                        [] -> fields
                        _ -> [#("entry", json.array(entry,bundle_entry_to_json)), ..fields]
                          }
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,bundle_link_to_json)), ..fields]
                          }
let fields = case total {
                          Some(v) -> [#("total", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case timestamp {
                          Some(v) -> [#("timestamp", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn bundle_decoder() -> Decoder(Bundle) {use signature <- decode.optional_field("signature", None, decode.optional(signature_decoder()))
use entry <- decode.optional_field("entry", [], decode.list(bundle_entry_decoder()))
use link <- decode.optional_field("link", [], decode.list(bundle_link_decoder()))
use total <- decode.optional_field("total", None, decode.optional(decode.int))
use timestamp <- decode.optional_field("timestamp", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.bundletype_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Bundle(signature:,entry:,link:,total:,timestamp:,type_:,identifier:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type Capabilitystatement
{
Capabilitystatement(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: String,
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
kind: r4valuesets.Capabilitystatementkind,
instantiates: List(String),
imports: List(String),
software: Option(CapabilitystatementSoftware),
implementation: Option(CapabilitystatementImplementation),
fhir_version: r4valuesets.Fhirversion,
format: List(String),
patch_format: List(String),
implementation_guide: List(String),
rest: List(CapabilitystatementRest),
messaging: List(CapabilitystatementMessaging),
document: List(CapabilitystatementDocument),
)
}

pub fn capabilitystatement_new(fhir_version fhir_version: r4valuesets.Fhirversion,kind kind: r4valuesets.Capabilitystatementkind,date date: String,status status: r4valuesets.Publicationstatus,) ->Capabilitystatement{Capabilitystatement(document: [],messaging: [],rest: [],implementation_guide: [],patch_format: [],format: [],fhir_version:,implementation: None,software: None,imports: [],instantiates: [],kind:,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date:,experimental: None,status:,title: None,name: None,version: None,url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementSoftware
{
CapabilitystatementSoftware(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
version: Option(String),
release_date: Option(String),
)
}

pub fn capabilitystatement_software_new(name name: String,) ->CapabilitystatementSoftware{CapabilitystatementSoftware(release_date: None,version: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementImplementation
{
CapabilitystatementImplementation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: String,
url: Option(String),
custodian: Option(Reference),
)
}

pub fn capabilitystatement_implementation_new(description description: String,) ->CapabilitystatementImplementation{CapabilitystatementImplementation(custodian: None,url: None,description:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRest
{
CapabilitystatementRest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: r4valuesets.Restfulcapabilitymode,
documentation: Option(String),
security: Option(CapabilitystatementRestSecurity),
resource: List(CapabilitystatementRestResource),
interaction: List(CapabilitystatementRestInteraction),
compartment: List(String),
)
}

pub fn capabilitystatement_rest_new(mode mode: r4valuesets.Restfulcapabilitymode,) ->CapabilitystatementRest{CapabilitystatementRest(compartment: [],interaction: [],resource: [],security: None,documentation: None,mode:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestSecurity
{
CapabilitystatementRestSecurity(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
cors: Option(Bool),
service: List(Codeableconcept),
description: Option(String),
)
}

pub fn capabilitystatement_rest_security_new() ->CapabilitystatementRestSecurity{CapabilitystatementRestSecurity(description: None,service: [],cors: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResource
{
CapabilitystatementRestResource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Resourcetypes,
profile: Option(String),
supported_profile: List(String),
documentation: Option(String),
interaction: List(CapabilitystatementRestResourceInteraction),
versioning: Option(r4valuesets.Versioningpolicy),
read_history: Option(Bool),
update_create: Option(Bool),
conditional_create: Option(Bool),
conditional_read: Option(r4valuesets.Conditionalreadstatus),
conditional_update: Option(Bool),
conditional_delete: Option(r4valuesets.Conditionaldeletestatus),
reference_policy: List(r4valuesets.Referencehandlingpolicy),
search_include: List(String),
search_rev_include: List(String),
search_param: List(CapabilitystatementRestResourceSearchparam),
operation: List(CapabilitystatementRestResourceOperation),
)
}

pub fn capabilitystatement_rest_resource_new(type_ type_: r4valuesets.Resourcetypes,) ->CapabilitystatementRestResource{CapabilitystatementRestResource(operation: [],search_param: [],search_rev_include: [],search_include: [],reference_policy: [],conditional_delete: None,conditional_update: None,conditional_read: None,conditional_create: None,update_create: None,read_history: None,versioning: None,interaction: [],documentation: None,supported_profile: [],profile: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceInteraction
{
CapabilitystatementRestResourceInteraction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Typerestfulinteraction,
documentation: Option(String),
)
}

pub fn capabilitystatement_rest_resource_interaction_new(code code: r4valuesets.Typerestfulinteraction,) ->CapabilitystatementRestResourceInteraction{CapabilitystatementRestResourceInteraction(documentation: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceSearchparam
{
CapabilitystatementRestResourceSearchparam(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
definition: Option(String),
type_: r4valuesets.Searchparamtype,
documentation: Option(String),
)
}

pub fn capabilitystatement_rest_resource_searchparam_new(type_ type_: r4valuesets.Searchparamtype,name name: String,) ->CapabilitystatementRestResourceSearchparam{CapabilitystatementRestResourceSearchparam(documentation: None,type_:,definition: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceOperation
{
CapabilitystatementRestResourceOperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
definition: String,
documentation: Option(String),
)
}

pub fn capabilitystatement_rest_resource_operation_new(definition definition: String,name name: String,) ->CapabilitystatementRestResourceOperation{CapabilitystatementRestResourceOperation(documentation: None,definition:,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestInteraction
{
CapabilitystatementRestInteraction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Systemrestfulinteraction,
documentation: Option(String),
)
}

pub fn capabilitystatement_rest_interaction_new(code code: r4valuesets.Systemrestfulinteraction,) ->CapabilitystatementRestInteraction{CapabilitystatementRestInteraction(documentation: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessaging
{
CapabilitystatementMessaging(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
endpoint: List(CapabilitystatementMessagingEndpoint),
reliable_cache: Option(Int),
documentation: Option(String),
supported_message: List(CapabilitystatementMessagingSupportedmessage),
)
}

pub fn capabilitystatement_messaging_new() ->CapabilitystatementMessaging{CapabilitystatementMessaging(supported_message: [],documentation: None,reliable_cache: None,endpoint: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingEndpoint
{
CapabilitystatementMessagingEndpoint(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
protocol: Coding,
address: String,
)
}

pub fn capabilitystatement_messaging_endpoint_new(address address: String,protocol protocol: Coding,) ->CapabilitystatementMessagingEndpoint{CapabilitystatementMessagingEndpoint(address:,protocol:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingSupportedmessage
{
CapabilitystatementMessagingSupportedmessage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: r4valuesets.Eventcapabilitymode,
definition: String,
)
}

pub fn capabilitystatement_messaging_supportedmessage_new(definition definition: String,mode mode: r4valuesets.Eventcapabilitymode,) ->CapabilitystatementMessagingSupportedmessage{CapabilitystatementMessagingSupportedmessage(definition:,mode:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementDocument
{
CapabilitystatementDocument(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: r4valuesets.Documentmode,
documentation: Option(String),
profile: String,
)
}

pub fn capabilitystatement_document_new(profile profile: String,mode mode: r4valuesets.Documentmode,) ->CapabilitystatementDocument{CapabilitystatementDocument(profile:,documentation: None,mode:,modifier_extension: [],extension: [],id: None,)
}

pub fn capabilitystatement_document_to_json(capabilitystatement_document: CapabilitystatementDocument) -> Json {
    let CapabilitystatementDocument(profile:,documentation:,mode:,modifier_extension:,extension:,id:,) = capabilitystatement_document
    let fields = [#("profile", json.string(profile)),#("mode", r4valuesets.documentmode_to_json(mode)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_document_decoder() -> Decoder(CapabilitystatementDocument) {use profile <- decode.field("profile",decode.string)
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.documentmode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementDocument(profile:,documentation:,mode:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_messaging_supportedmessage_to_json(capabilitystatement_messaging_supportedmessage: CapabilitystatementMessagingSupportedmessage) -> Json {
    let CapabilitystatementMessagingSupportedmessage(definition:,mode:,modifier_extension:,extension:,id:,) = capabilitystatement_messaging_supportedmessage
    let fields = [#("definition", json.string(definition)),#("mode", r4valuesets.eventcapabilitymode_to_json(mode)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_messaging_supportedmessage_decoder() -> Decoder(CapabilitystatementMessagingSupportedmessage) {use definition <- decode.field("definition",decode.string)
use mode <- decode.field("mode",r4valuesets.eventcapabilitymode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementMessagingSupportedmessage(definition:,mode:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_messaging_endpoint_to_json(capabilitystatement_messaging_endpoint: CapabilitystatementMessagingEndpoint) -> Json {
    let CapabilitystatementMessagingEndpoint(address:,protocol:,modifier_extension:,extension:,id:,) = capabilitystatement_messaging_endpoint
    let fields = [#("address", json.string(address)),#("protocol", coding_to_json(protocol)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_messaging_endpoint_decoder() -> Decoder(CapabilitystatementMessagingEndpoint) {use address <- decode.field("address",decode.string)
use protocol <- decode.field("protocol",coding_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementMessagingEndpoint(address:,protocol:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_messaging_to_json(capabilitystatement_messaging: CapabilitystatementMessaging) -> Json {
    let CapabilitystatementMessaging(supported_message:,documentation:,reliable_cache:,endpoint:,modifier_extension:,extension:,id:,) = capabilitystatement_messaging
    let fields = []
let fields = case supported_message {
                        [] -> fields
                        _ -> [#("supportedMessage", json.array(supported_message,capabilitystatement_messaging_supportedmessage_to_json)), ..fields]
                          }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case reliable_cache {
                          Some(v) -> [#("reliableCache", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,capabilitystatement_messaging_endpoint_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_messaging_decoder() -> Decoder(CapabilitystatementMessaging) {use supported_message <- decode.optional_field("supportedMessage", [], decode.list(capabilitystatement_messaging_supportedmessage_decoder()))
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use reliable_cache <- decode.optional_field("reliableCache", None, decode.optional(decode.int))
use endpoint <- decode.optional_field("endpoint", [], decode.list(capabilitystatement_messaging_endpoint_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementMessaging(supported_message:,documentation:,reliable_cache:,endpoint:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_interaction_to_json(capabilitystatement_rest_interaction: CapabilitystatementRestInteraction) -> Json {
    let CapabilitystatementRestInteraction(documentation:,code:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_interaction
    let fields = [#("code", r4valuesets.systemrestfulinteraction_to_json(code)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_interaction_decoder() -> Decoder(CapabilitystatementRestInteraction) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use code <- decode.field("code",r4valuesets.systemrestfulinteraction_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestInteraction(documentation:,code:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_resource_operation_to_json(capabilitystatement_rest_resource_operation: CapabilitystatementRestResourceOperation) -> Json {
    let CapabilitystatementRestResourceOperation(documentation:,definition:,name:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_resource_operation
    let fields = [#("definition", json.string(definition)),#("name", json.string(name)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_resource_operation_decoder() -> Decoder(CapabilitystatementRestResourceOperation) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use definition <- decode.field("definition",decode.string)
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestResourceOperation(documentation:,definition:,name:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_resource_searchparam_to_json(capabilitystatement_rest_resource_searchparam: CapabilitystatementRestResourceSearchparam) -> Json {
    let CapabilitystatementRestResourceSearchparam(documentation:,type_:,definition:,name:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_resource_searchparam
    let fields = [#("type", r4valuesets.searchparamtype_to_json(type_)),#("name", json.string(name)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_resource_searchparam_decoder() -> Decoder(CapabilitystatementRestResourceSearchparam) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.searchparamtype_decoder())
use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestResourceSearchparam(documentation:,type_:,definition:,name:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_resource_interaction_to_json(capabilitystatement_rest_resource_interaction: CapabilitystatementRestResourceInteraction) -> Json {
    let CapabilitystatementRestResourceInteraction(documentation:,code:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_resource_interaction
    let fields = [#("code", r4valuesets.typerestfulinteraction_to_json(code)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_resource_interaction_decoder() -> Decoder(CapabilitystatementRestResourceInteraction) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use code <- decode.field("code",r4valuesets.typerestfulinteraction_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestResourceInteraction(documentation:,code:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_resource_to_json(capabilitystatement_rest_resource: CapabilitystatementRestResource) -> Json {
    let CapabilitystatementRestResource(operation:,search_param:,search_rev_include:,search_include:,reference_policy:,conditional_delete:,conditional_update:,conditional_read:,conditional_create:,update_create:,read_history:,versioning:,interaction:,documentation:,supported_profile:,profile:,type_:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_resource
    let fields = [#("type", r4valuesets.resourcetypes_to_json(type_)),]
let fields = case operation {
                        [] -> fields
                        _ -> [#("operation", json.array(operation,capabilitystatement_rest_resource_operation_to_json)), ..fields]
                          }
let fields = case search_param {
                        [] -> fields
                        _ -> [#("searchParam", json.array(search_param,capabilitystatement_rest_resource_searchparam_to_json)), ..fields]
                          }
let fields = case search_rev_include {
                        [] -> fields
                        _ -> [#("searchRevInclude", json.array(search_rev_include,json.string)), ..fields]
                          }
let fields = case search_include {
                        [] -> fields
                        _ -> [#("searchInclude", json.array(search_include,json.string)), ..fields]
                          }
let fields = case reference_policy {
                        [] -> fields
                        _ -> [#("referencePolicy", json.array(reference_policy,r4valuesets.referencehandlingpolicy_to_json)), ..fields]
                          }
let fields = case conditional_delete {
                          Some(v) -> [#("conditionalDelete", r4valuesets.conditionaldeletestatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case conditional_update {
                          Some(v) -> [#("conditionalUpdate", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case conditional_read {
                          Some(v) -> [#("conditionalRead", r4valuesets.conditionalreadstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case conditional_create {
                          Some(v) -> [#("conditionalCreate", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case update_create {
                          Some(v) -> [#("updateCreate", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case read_history {
                          Some(v) -> [#("readHistory", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case versioning {
                          Some(v) -> [#("versioning", r4valuesets.versioningpolicy_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case interaction {
                        [] -> fields
                        _ -> [#("interaction", json.array(interaction,capabilitystatement_rest_resource_interaction_to_json)), ..fields]
                          }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case supported_profile {
                        [] -> fields
                        _ -> [#("supportedProfile", json.array(supported_profile,json.string)), ..fields]
                          }
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_resource_decoder() -> Decoder(CapabilitystatementRestResource) {use operation <- decode.optional_field("operation", [], decode.list(capabilitystatement_rest_resource_operation_decoder()))
use search_param <- decode.optional_field("searchParam", [], decode.list(capabilitystatement_rest_resource_searchparam_decoder()))
use search_rev_include <- decode.optional_field("searchRevInclude", [], decode.list(decode.string))
use search_include <- decode.optional_field("searchInclude", [], decode.list(decode.string))
use reference_policy <- decode.optional_field("referencePolicy", [], decode.list(r4valuesets.referencehandlingpolicy_decoder()))
use conditional_delete <- decode.optional_field("conditionalDelete", None, decode.optional(r4valuesets.conditionaldeletestatus_decoder()))
use conditional_update <- decode.optional_field("conditionalUpdate", None, decode.optional(decode.bool))
use conditional_read <- decode.optional_field("conditionalRead", None, decode.optional(r4valuesets.conditionalreadstatus_decoder()))
use conditional_create <- decode.optional_field("conditionalCreate", None, decode.optional(decode.bool))
use update_create <- decode.optional_field("updateCreate", None, decode.optional(decode.bool))
use read_history <- decode.optional_field("readHistory", None, decode.optional(decode.bool))
use versioning <- decode.optional_field("versioning", None, decode.optional(r4valuesets.versioningpolicy_decoder()))
use interaction <- decode.optional_field("interaction", [], decode.list(capabilitystatement_rest_resource_interaction_decoder()))
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use supported_profile <- decode.optional_field("supportedProfile", [], decode.list(decode.string))
use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.resourcetypes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestResource(operation:,search_param:,search_rev_include:,search_include:,reference_policy:,conditional_delete:,conditional_update:,conditional_read:,conditional_create:,update_create:,read_history:,versioning:,interaction:,documentation:,supported_profile:,profile:,type_:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_security_to_json(capabilitystatement_rest_security: CapabilitystatementRestSecurity) -> Json {
    let CapabilitystatementRestSecurity(description:,service:,cors:,modifier_extension:,extension:,id:,) = capabilitystatement_rest_security
    let fields = []
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case service {
                        [] -> fields
                        _ -> [#("service", json.array(service,codeableconcept_to_json)), ..fields]
                          }
let fields = case cors {
                          Some(v) -> [#("cors", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_security_decoder() -> Decoder(CapabilitystatementRestSecurity) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use service <- decode.optional_field("service", [], decode.list(codeableconcept_decoder()))
use cors <- decode.optional_field("cors", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRestSecurity(description:,service:,cors:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_rest_to_json(capabilitystatement_rest: CapabilitystatementRest) -> Json {
    let CapabilitystatementRest(compartment:,interaction:,resource:,security:,documentation:,mode:,modifier_extension:,extension:,id:,) = capabilitystatement_rest
    let fields = [#("mode", r4valuesets.restfulcapabilitymode_to_json(mode)),]
let fields = case compartment {
                        [] -> fields
                        _ -> [#("compartment", json.array(compartment,json.string)), ..fields]
                          }
let fields = case interaction {
                        [] -> fields
                        _ -> [#("interaction", json.array(interaction,capabilitystatement_rest_interaction_to_json)), ..fields]
                          }
let fields = case resource {
                        [] -> fields
                        _ -> [#("resource", json.array(resource,capabilitystatement_rest_resource_to_json)), ..fields]
                          }
let fields = case security {
                          Some(v) -> [#("security", capabilitystatement_rest_security_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_rest_decoder() -> Decoder(CapabilitystatementRest) {use compartment <- decode.optional_field("compartment", [], decode.list(decode.string))
use interaction <- decode.optional_field("interaction", [], decode.list(capabilitystatement_rest_interaction_decoder()))
use resource <- decode.optional_field("resource", [], decode.list(capabilitystatement_rest_resource_decoder()))
use security <- decode.optional_field("security", None, decode.optional(capabilitystatement_rest_security_decoder()))
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.restfulcapabilitymode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementRest(compartment:,interaction:,resource:,security:,documentation:,mode:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_implementation_to_json(capabilitystatement_implementation: CapabilitystatementImplementation) -> Json {
    let CapabilitystatementImplementation(custodian:,url:,description:,modifier_extension:,extension:,id:,) = capabilitystatement_implementation
    let fields = [#("description", json.string(description)),]
let fields = case custodian {
                          Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_implementation_decoder() -> Decoder(CapabilitystatementImplementation) {use custodian <- decode.optional_field("custodian", None, decode.optional(reference_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use description <- decode.field("description",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementImplementation(custodian:,url:,description:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_software_to_json(capabilitystatement_software: CapabilitystatementSoftware) -> Json {
    let CapabilitystatementSoftware(release_date:,version:,name:,modifier_extension:,extension:,id:,) = capabilitystatement_software
    let fields = [#("name", json.string(name)),]
let fields = case release_date {
                          Some(v) -> [#("releaseDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_software_decoder() -> Decoder(CapabilitystatementSoftware) {use release_date <- decode.optional_field("releaseDate", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CapabilitystatementSoftware(release_date:,version:,name:,modifier_extension:,extension:,id:,))}
pub fn capabilitystatement_to_json(capabilitystatement: Capabilitystatement) -> Json {
    let Capabilitystatement(document:,messaging:,rest:,implementation_guide:,patch_format:,format:,fhir_version:,implementation:,software:,imports:,instantiates:,kind:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = capabilitystatement
    let fields = [#("fhirVersion", r4valuesets.fhirversion_to_json(fhir_version)),#("kind", r4valuesets.capabilitystatementkind_to_json(kind)),#("date", json.string(date)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case document {
                        [] -> fields
                        _ -> [#("document", json.array(document,capabilitystatement_document_to_json)), ..fields]
                          }
let fields = case messaging {
                        [] -> fields
                        _ -> [#("messaging", json.array(messaging,capabilitystatement_messaging_to_json)), ..fields]
                          }
let fields = case rest {
                        [] -> fields
                        _ -> [#("rest", json.array(rest,capabilitystatement_rest_to_json)), ..fields]
                          }
let fields = case implementation_guide {
                        [] -> fields
                        _ -> [#("implementationGuide", json.array(implementation_guide,json.string)), ..fields]
                          }
let fields = case patch_format {
                        [] -> fields
                        _ -> [#("patchFormat", json.array(patch_format,json.string)), ..fields]
                          }
let fields = case format {
                        [] -> fields
                        _ -> [#("format", json.array(format,json.string)), ..fields]
                          }
let fields = case implementation {
                          Some(v) -> [#("implementation", capabilitystatement_implementation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case software {
                          Some(v) -> [#("software", capabilitystatement_software_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case imports {
                        [] -> fields
                        _ -> [#("imports", json.array(imports,json.string)), ..fields]
                          }
let fields = case instantiates {
                        [] -> fields
                        _ -> [#("instantiates", json.array(instantiates,json.string)), ..fields]
                          }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn capabilitystatement_decoder() -> Decoder(Capabilitystatement) {use document <- decode.optional_field("document", [], decode.list(capabilitystatement_document_decoder()))
use messaging <- decode.optional_field("messaging", [], decode.list(capabilitystatement_messaging_decoder()))
use rest <- decode.optional_field("rest", [], decode.list(capabilitystatement_rest_decoder()))
use implementation_guide <- decode.optional_field("implementationGuide", [], decode.list(decode.string))
use patch_format <- decode.optional_field("patchFormat", [], decode.list(decode.string))
use format <- decode.optional_field("format", [], decode.list(decode.string))
use fhir_version <- decode.field("fhirVersion",r4valuesets.fhirversion_decoder())
use implementation <- decode.optional_field("implementation", None, decode.optional(capabilitystatement_implementation_decoder()))
use software <- decode.optional_field("software", None, decode.optional(capabilitystatement_software_decoder()))
use imports <- decode.optional_field("imports", [], decode.list(decode.string))
use instantiates <- decode.optional_field("instantiates", [], decode.list(decode.string))
use kind <- decode.field("kind",r4valuesets.capabilitystatementkind_decoder())
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.field("date",decode.string)
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Capabilitystatement(document:,messaging:,rest:,implementation_guide:,patch_format:,format:,fhir_version:,implementation:,software:,imports:,instantiates:,kind:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CarePlan#resource
pub type Careplan
{
Careplan(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
replaces: List(Reference),
part_of: List(Reference),
status: r4valuesets.Requeststatus,
intent: r4valuesets.Careplanintent,
category: List(Codeableconcept),
title: Option(String),
description: Option(String),
subject: Reference,
encounter: Option(Reference),
period: Option(Period),
created: Option(String),
author: Option(Reference),
contributor: List(Reference),
care_team: List(Reference),
addresses: List(Reference),
supporting_info: List(Reference),
goal: List(Reference),
activity: List(CareplanActivity),
note: List(Annotation),
)
}

pub fn careplan_new(subject subject: Reference,intent intent: r4valuesets.Careplanintent,status status: r4valuesets.Requeststatus,) ->Careplan{Careplan(note: [],activity: [],goal: [],supporting_info: [],addresses: [],care_team: [],contributor: [],author: None,created: None,period: None,encounter: None,subject:,description: None,title: None,category: [],intent:,status:,part_of: [],replaces: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CarePlan#resource
pub type CareplanActivity
{
CareplanActivity(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
outcome_codeable_concept: List(Codeableconcept),
outcome_reference: List(Reference),
progress: List(Annotation),
reference: Option(Reference),
detail: Option(CareplanActivityDetail),
)
}

pub fn careplan_activity_new() ->CareplanActivity{CareplanActivity(detail: None,reference: None,progress: [],outcome_reference: [],outcome_codeable_concept: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetail
{
CareplanActivityDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
kind: Option(r4valuesets.Careplanactivitykind),
instantiates_canonical: List(String),
instantiates_uri: List(String),
code: Option(Codeableconcept),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
goal: List(Reference),
status: r4valuesets.Careplanactivitystatus,
status_reason: Option(Codeableconcept),
do_not_perform: Option(Bool),
scheduled: Option(CareplanActivityDetailScheduled),
location: Option(Reference),
performer: List(Reference),
product: Option(CareplanActivityDetailProduct),
daily_amount: Option(Quantity),
quantity: Option(Quantity),
description: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetailScheduled{
CareplanActivityDetailScheduledTiming(scheduled: Timing)
CareplanActivityDetailScheduledPeriod(scheduled: Period)
CareplanActivityDetailScheduledString(scheduled: String)}
pub fn careplan_activity_detail_scheduled_to_json(elt: CareplanActivityDetailScheduled) -> Json {case elt{CareplanActivityDetailScheduledTiming(v) -> timing_to_json(v)
CareplanActivityDetailScheduledPeriod(v) -> period_to_json(v)
CareplanActivityDetailScheduledString(v) -> json.string(v)
}}
pub fn careplan_activity_detail_scheduled_decoder() -> Decoder(CareplanActivityDetailScheduled){decode.one_of(decode.field("scheduledTiming", timing_decoder(), decode.success) |> decode.map(CareplanActivityDetailScheduledTiming),[decode.field("scheduledPeriod", period_decoder(), decode.success) |> decode.map(CareplanActivityDetailScheduledPeriod),decode.field("scheduledString", decode.string, decode.success) |> decode.map(CareplanActivityDetailScheduledString),])}

///http://hl7.org/fhir/r4/StructureDefinition/CarePlan#resource
pub type CareplanActivityDetailProduct{
CareplanActivityDetailProductCodeableconcept(product: Codeableconcept)
CareplanActivityDetailProductReference(product: Reference)}
pub fn careplan_activity_detail_product_to_json(elt: CareplanActivityDetailProduct) -> Json {case elt{CareplanActivityDetailProductCodeableconcept(v) -> codeableconcept_to_json(v)
CareplanActivityDetailProductReference(v) -> reference_to_json(v)
}}
pub fn careplan_activity_detail_product_decoder() -> Decoder(CareplanActivityDetailProduct){decode.one_of(decode.field("productCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(CareplanActivityDetailProductCodeableconcept),[decode.field("productReference", reference_decoder(), decode.success) |> decode.map(CareplanActivityDetailProductReference),])}
pub fn careplan_activity_detail_new(status status: r4valuesets.Careplanactivitystatus,) ->CareplanActivityDetail{CareplanActivityDetail(description: None,quantity: None,daily_amount: None,product: None,performer: [],location: None,scheduled: None,do_not_perform: None,status_reason: None,status:,goal: [],reason_reference: [],reason_code: [],code: None,instantiates_uri: [],instantiates_canonical: [],kind: None,modifier_extension: [],extension: [],id: None,)
}

pub fn careplan_activity_detail_to_json(careplan_activity_detail: CareplanActivityDetail) -> Json {
    let CareplanActivityDetail(description:,quantity:,daily_amount:,product:,performer:,location:,scheduled:,do_not_perform:,status_reason:,status:,goal:,reason_reference:,reason_code:,code:,instantiates_uri:,instantiates_canonical:,kind:,modifier_extension:,extension:,id:,) = careplan_activity_detail
    let fields = [#("status", r4valuesets.careplanactivitystatus_to_json(status)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case daily_amount {
                          Some(v) -> [#("dailyAmount", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case product {
                          Some(v) -> [#("product", careplan_activity_detail_product_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,reference_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case scheduled {
                          Some(v) -> [#("scheduled", careplan_activity_detail_scheduled_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case goal {
                        [] -> fields
                        _ -> [#("goal", json.array(goal,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case kind {
                          Some(v) -> [#("kind", r4valuesets.careplanactivitykind_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn careplan_activity_detail_decoder() -> Decoder(CareplanActivityDetail) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use daily_amount <- decode.optional_field("dailyAmount", None, decode.optional(quantity_decoder()))
use product <- decode.then(none_if_omitted(careplan_activity_detail_product_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(reference_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use scheduled <- decode.then(none_if_omitted(careplan_activity_detail_scheduled_decoder()))
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.careplanactivitystatus_decoder())
use goal <- decode.optional_field("goal", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use kind <- decode.optional_field("kind", None, decode.optional(r4valuesets.careplanactivitykind_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CareplanActivityDetail(description:,quantity:,daily_amount:,product:,performer:,location:,scheduled:,do_not_perform:,status_reason:,status:,goal:,reason_reference:,reason_code:,code:,instantiates_uri:,instantiates_canonical:,kind:,modifier_extension:,extension:,id:,))}
pub fn careplan_activity_to_json(careplan_activity: CareplanActivity) -> Json {
    let CareplanActivity(detail:,reference:,progress:,outcome_reference:,outcome_codeable_concept:,modifier_extension:,extension:,id:,) = careplan_activity
    let fields = []
let fields = case detail {
                          Some(v) -> [#("detail", careplan_activity_detail_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reference {
                          Some(v) -> [#("reference", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case progress {
                        [] -> fields
                        _ -> [#("progress", json.array(progress,annotation_to_json)), ..fields]
                          }
let fields = case outcome_reference {
                        [] -> fields
                        _ -> [#("outcomeReference", json.array(outcome_reference,reference_to_json)), ..fields]
                          }
let fields = case outcome_codeable_concept {
                        [] -> fields
                        _ -> [#("outcomeCodeableConcept", json.array(outcome_codeable_concept,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn careplan_activity_decoder() -> Decoder(CareplanActivity) {use detail <- decode.optional_field("detail", None, decode.optional(careplan_activity_detail_decoder()))
use reference <- decode.optional_field("reference", None, decode.optional(reference_decoder()))
use progress <- decode.optional_field("progress", [], decode.list(annotation_decoder()))
use outcome_reference <- decode.optional_field("outcomeReference", [], decode.list(reference_decoder()))
use outcome_codeable_concept <- decode.optional_field("outcomeCodeableConcept", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CareplanActivity(detail:,reference:,progress:,outcome_reference:,outcome_codeable_concept:,modifier_extension:,extension:,id:,))}
pub fn careplan_to_json(careplan: Careplan) -> Json {
    let Careplan(note:,activity:,goal:,supporting_info:,addresses:,care_team:,contributor:,author:,created:,period:,encounter:,subject:,description:,title:,category:,intent:,status:,part_of:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = careplan
    let fields = [#("subject", reference_to_json(subject)),#("intent", r4valuesets.careplanintent_to_json(intent)),#("status", r4valuesets.requeststatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case activity {
                        [] -> fields
                        _ -> [#("activity", json.array(activity,careplan_activity_to_json)), ..fields]
                          }
let fields = case goal {
                        [] -> fields
                        _ -> [#("goal", json.array(goal,reference_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,reference_to_json)), ..fields]
                          }
let fields = case addresses {
                        [] -> fields
                        _ -> [#("addresses", json.array(addresses,reference_to_json)), ..fields]
                          }
let fields = case care_team {
                        [] -> fields
                        _ -> [#("careTeam", json.array(care_team,reference_to_json)), ..fields]
                          }
let fields = case contributor {
                        [] -> fields
                        _ -> [#("contributor", json.array(contributor,reference_to_json)), ..fields]
                          }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn careplan_decoder() -> Decoder(Careplan) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use activity <- decode.optional_field("activity", [], decode.list(careplan_activity_decoder()))
use goal <- decode.optional_field("goal", [], decode.list(reference_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(reference_decoder()))
use addresses <- decode.optional_field("addresses", [], decode.list(reference_decoder()))
use care_team <- decode.optional_field("careTeam", [], decode.list(reference_decoder()))
use contributor <- decode.optional_field("contributor", [], decode.list(reference_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use intent <- decode.field("intent",r4valuesets.careplanintent_decoder())
use status <- decode.field("status",r4valuesets.requeststatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use replaces <- decode.optional_field("replaces", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Careplan(note:,activity:,goal:,supporting_info:,addresses:,care_team:,contributor:,author:,created:,period:,encounter:,subject:,description:,title:,category:,intent:,status:,part_of:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CareTeam#resource
pub type Careteam
{
Careteam(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Careteamstatus),
category: List(Codeableconcept),
name: Option(String),
subject: Option(Reference),
encounter: Option(Reference),
period: Option(Period),
participant: List(CareteamParticipant),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
managing_organization: List(Reference),
telecom: List(Contactpoint),
note: List(Annotation),
)
}

pub fn careteam_new() ->Careteam{Careteam(note: [],telecom: [],managing_organization: [],reason_reference: [],reason_code: [],participant: [],period: None,encounter: None,subject: None,name: None,category: [],status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CareTeam#resource
pub type CareteamParticipant
{
CareteamParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
role: List(Codeableconcept),
member: Option(Reference),
on_behalf_of: Option(Reference),
period: Option(Period),
)
}

pub fn careteam_participant_new() ->CareteamParticipant{CareteamParticipant(period: None,on_behalf_of: None,member: None,role: [],modifier_extension: [],extension: [],id: None,)
}

pub fn careteam_participant_to_json(careteam_participant: CareteamParticipant) -> Json {
    let CareteamParticipant(period:,on_behalf_of:,member:,role:,modifier_extension:,extension:,id:,) = careteam_participant
    let fields = []
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case on_behalf_of {
                          Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case member {
                          Some(v) -> [#("member", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                        [] -> fields
                        _ -> [#("role", json.array(role,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn careteam_participant_decoder() -> Decoder(CareteamParticipant) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use on_behalf_of <- decode.optional_field("onBehalfOf", None, decode.optional(reference_decoder()))
use member <- decode.optional_field("member", None, decode.optional(reference_decoder()))
use role <- decode.optional_field("role", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CareteamParticipant(period:,on_behalf_of:,member:,role:,modifier_extension:,extension:,id:,))}
pub fn careteam_to_json(careteam: Careteam) -> Json {
    let Careteam(note:,telecom:,managing_organization:,reason_reference:,reason_code:,participant:,period:,encounter:,subject:,name:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = careteam
    let fields = []
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case managing_organization {
                        [] -> fields
                        _ -> [#("managingOrganization", json.array(managing_organization,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,careteam_participant_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.careteamstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn careteam_decoder() -> Decoder(Careteam) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use managing_organization <- decode.optional_field("managingOrganization", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(careteam_participant_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.careteamstatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Careteam(note:,telecom:,managing_organization:,reason_reference:,reason_code:,participant:,period:,encounter:,subject:,name:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CatalogEntry#resource
pub type Catalogentry
{
Catalogentry(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Option(Codeableconcept),
orderable: Bool,
referenced_item: Reference,
additional_identifier: List(Identifier),
classification: List(Codeableconcept),
status: Option(r4valuesets.Publicationstatus),
validity_period: Option(Period),
valid_to: Option(String),
last_updated: Option(String),
additional_characteristic: List(Codeableconcept),
additional_classification: List(Codeableconcept),
related_entry: List(CatalogentryRelatedentry),
)
}

pub fn catalogentry_new(referenced_item referenced_item: Reference,orderable orderable: Bool,) ->Catalogentry{Catalogentry(related_entry: [],additional_classification: [],additional_characteristic: [],last_updated: None,valid_to: None,validity_period: None,status: None,classification: [],additional_identifier: [],referenced_item:,orderable:,type_: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CatalogEntry#resource
pub type CatalogentryRelatedentry
{
CatalogentryRelatedentry(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
relationtype: r4valuesets.Relationtype,
item: Reference,
)
}

pub fn catalogentry_relatedentry_new(item item: Reference,relationtype relationtype: r4valuesets.Relationtype,) ->CatalogentryRelatedentry{CatalogentryRelatedentry(item:,relationtype:,modifier_extension: [],extension: [],id: None,)
}

pub fn catalogentry_relatedentry_to_json(catalogentry_relatedentry: CatalogentryRelatedentry) -> Json {
    let CatalogentryRelatedentry(item:,relationtype:,modifier_extension:,extension:,id:,) = catalogentry_relatedentry
    let fields = [#("item", reference_to_json(item)),#("relationtype", r4valuesets.relationtype_to_json(relationtype)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn catalogentry_relatedentry_decoder() -> Decoder(CatalogentryRelatedentry) {use item <- decode.field("item",reference_decoder())
use relationtype <- decode.field("relationtype",r4valuesets.relationtype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CatalogentryRelatedentry(item:,relationtype:,modifier_extension:,extension:,id:,))}
pub fn catalogentry_to_json(catalogentry: Catalogentry) -> Json {
    let Catalogentry(related_entry:,additional_classification:,additional_characteristic:,last_updated:,valid_to:,validity_period:,status:,classification:,additional_identifier:,referenced_item:,orderable:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = catalogentry
    let fields = [#("referencedItem", reference_to_json(referenced_item)),#("orderable", json.bool(orderable)),]
let fields = case related_entry {
                        [] -> fields
                        _ -> [#("relatedEntry", json.array(related_entry,catalogentry_relatedentry_to_json)), ..fields]
                          }
let fields = case additional_classification {
                        [] -> fields
                        _ -> [#("additionalClassification", json.array(additional_classification,codeableconcept_to_json)), ..fields]
                          }
let fields = case additional_characteristic {
                        [] -> fields
                        _ -> [#("additionalCharacteristic", json.array(additional_characteristic,codeableconcept_to_json)), ..fields]
                          }
let fields = case last_updated {
                          Some(v) -> [#("lastUpdated", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case valid_to {
                          Some(v) -> [#("validTo", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case validity_period {
                          Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.publicationstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case classification {
                        [] -> fields
                        _ -> [#("classification", json.array(classification,codeableconcept_to_json)), ..fields]
                          }
let fields = case additional_identifier {
                        [] -> fields
                        _ -> [#("additionalIdentifier", json.array(additional_identifier,identifier_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn catalogentry_decoder() -> Decoder(Catalogentry) {use related_entry <- decode.optional_field("relatedEntry", [], decode.list(catalogentry_relatedentry_decoder()))
use additional_classification <- decode.optional_field("additionalClassification", [], decode.list(codeableconcept_decoder()))
use additional_characteristic <- decode.optional_field("additionalCharacteristic", [], decode.list(codeableconcept_decoder()))
use last_updated <- decode.optional_field("lastUpdated", None, decode.optional(decode.string))
use valid_to <- decode.optional_field("validTo", None, decode.optional(decode.string))
use validity_period <- decode.optional_field("validityPeriod", None, decode.optional(period_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.publicationstatus_decoder()))
use classification <- decode.optional_field("classification", [], decode.list(codeableconcept_decoder()))
use additional_identifier <- decode.optional_field("additionalIdentifier", [], decode.list(identifier_decoder()))
use referenced_item <- decode.field("referencedItem",reference_decoder())
use orderable <- decode.field("orderable",decode.bool)
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Catalogentry(related_entry:,additional_classification:,additional_characteristic:,last_updated:,valid_to:,validity_period:,status:,classification:,additional_identifier:,referenced_item:,orderable:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItem#resource
pub type Chargeitem
{
Chargeitem(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
definition_uri: List(String),
definition_canonical: List(String),
status: r4valuesets.Chargeitemstatus,
part_of: List(Reference),
code: Codeableconcept,
subject: Reference,
context: Option(Reference),
occurrence: Option(ChargeitemOccurrence),
performer: List(ChargeitemPerformer),
performing_organization: Option(Reference),
requesting_organization: Option(Reference),
cost_center: Option(Reference),
quantity: Option(Quantity),
bodysite: List(Codeableconcept),
factor_override: Option(Float),
price_override: Option(Money),
override_reason: Option(String),
enterer: Option(Reference),
entered_date: Option(String),
reason: List(Codeableconcept),
service: List(Reference),
product: Option(ChargeitemProduct),
account: List(Reference),
note: List(Annotation),
supporting_information: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ChargeItem#resource
pub type ChargeitemOccurrence{
ChargeitemOccurrenceDatetime(occurrence: String)
ChargeitemOccurrencePeriod(occurrence: Period)
ChargeitemOccurrenceTiming(occurrence: Timing)}
pub fn chargeitem_occurrence_to_json(elt: ChargeitemOccurrence) -> Json {case elt{ChargeitemOccurrenceDatetime(v) -> json.string(v)
ChargeitemOccurrencePeriod(v) -> period_to_json(v)
ChargeitemOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn chargeitem_occurrence_decoder() -> Decoder(ChargeitemOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(ChargeitemOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(ChargeitemOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(ChargeitemOccurrenceTiming),])}

///http://hl7.org/fhir/r4/StructureDefinition/ChargeItem#resource
pub type ChargeitemProduct{
ChargeitemProductReference(product: Reference)
ChargeitemProductCodeableconcept(product: Codeableconcept)}
pub fn chargeitem_product_to_json(elt: ChargeitemProduct) -> Json {case elt{ChargeitemProductReference(v) -> reference_to_json(v)
ChargeitemProductCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn chargeitem_product_decoder() -> Decoder(ChargeitemProduct){decode.one_of(decode.field("productReference", reference_decoder(), decode.success) |> decode.map(ChargeitemProductReference),[decode.field("productCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ChargeitemProductCodeableconcept),])}
pub fn chargeitem_new(subject subject: Reference,code code: Codeableconcept,status status: r4valuesets.Chargeitemstatus,) ->Chargeitem{Chargeitem(supporting_information: [],note: [],account: [],product: None,service: [],reason: [],entered_date: None,enterer: None,override_reason: None,price_override: None,factor_override: None,bodysite: [],quantity: None,cost_center: None,requesting_organization: None,performing_organization: None,performer: [],occurrence: None,context: None,subject:,code:,part_of: [],status:,definition_canonical: [],definition_uri: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItem#resource
pub type ChargeitemPerformer
{
ChargeitemPerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
)
}

pub fn chargeitem_performer_new(actor actor: Reference,) ->ChargeitemPerformer{ChargeitemPerformer(actor:,function: None,modifier_extension: [],extension: [],id: None,)
}

pub fn chargeitem_performer_to_json(chargeitem_performer: ChargeitemPerformer) -> Json {
    let ChargeitemPerformer(actor:,function:,modifier_extension:,extension:,id:,) = chargeitem_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitem_performer_decoder() -> Decoder(ChargeitemPerformer) {use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ChargeitemPerformer(actor:,function:,modifier_extension:,extension:,id:,))}
pub fn chargeitem_to_json(chargeitem: Chargeitem) -> Json {
    let Chargeitem(supporting_information:,note:,account:,product:,service:,reason:,entered_date:,enterer:,override_reason:,price_override:,factor_override:,bodysite:,quantity:,cost_center:,requesting_organization:,performing_organization:,performer:,occurrence:,context:,subject:,code:,part_of:,status:,definition_canonical:,definition_uri:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = chargeitem
    let fields = [#("subject", reference_to_json(subject)),#("code", codeableconcept_to_json(code)),#("status", r4valuesets.chargeitemstatus_to_json(status)),]
let fields = case supporting_information {
                        [] -> fields
                        _ -> [#("supportingInformation", json.array(supporting_information,reference_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case account {
                        [] -> fields
                        _ -> [#("account", json.array(account,reference_to_json)), ..fields]
                          }
let fields = case product {
                          Some(v) -> [#("product", chargeitem_product_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case service {
                        [] -> fields
                        _ -> [#("service", json.array(service,reference_to_json)), ..fields]
                          }
let fields = case reason {
                        [] -> fields
                        _ -> [#("reason", json.array(reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case entered_date {
                          Some(v) -> [#("enteredDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case enterer {
                          Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case override_reason {
                          Some(v) -> [#("overrideReason", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case price_override {
                          Some(v) -> [#("priceOverride", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor_override {
                          Some(v) -> [#("factorOverride", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case bodysite {
                        [] -> fields
                        _ -> [#("bodysite", json.array(bodysite,codeableconcept_to_json)), ..fields]
                          }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case cost_center {
                          Some(v) -> [#("costCenter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requesting_organization {
                          Some(v) -> [#("requestingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performing_organization {
                          Some(v) -> [#("performingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,chargeitem_performer_to_json)), ..fields]
                          }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", chargeitem_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case context {
                          Some(v) -> [#("context", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case definition_canonical {
                        [] -> fields
                        _ -> [#("definitionCanonical", json.array(definition_canonical,json.string)), ..fields]
                          }
let fields = case definition_uri {
                        [] -> fields
                        _ -> [#("definitionUri", json.array(definition_uri,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitem_decoder() -> Decoder(Chargeitem) {use supporting_information <- decode.optional_field("supportingInformation", [], decode.list(reference_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use account <- decode.optional_field("account", [], decode.list(reference_decoder()))
use product <- decode.then(none_if_omitted(chargeitem_product_decoder()))
use service <- decode.optional_field("service", [], decode.list(reference_decoder()))
use reason <- decode.optional_field("reason", [], decode.list(codeableconcept_decoder()))
use entered_date <- decode.optional_field("enteredDate", None, decode.optional(decode.string))
use enterer <- decode.optional_field("enterer", None, decode.optional(reference_decoder()))
use override_reason <- decode.optional_field("overrideReason", None, decode.optional(decode.string))
use price_override <- decode.optional_field("priceOverride", None, decode.optional(money_decoder()))
use factor_override <- decode.optional_field("factorOverride", None, decode.optional(decode.float))
use bodysite <- decode.optional_field("bodysite", [], decode.list(codeableconcept_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use cost_center <- decode.optional_field("costCenter", None, decode.optional(reference_decoder()))
use requesting_organization <- decode.optional_field("requestingOrganization", None, decode.optional(reference_decoder()))
use performing_organization <- decode.optional_field("performingOrganization", None, decode.optional(reference_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(chargeitem_performer_decoder()))
use occurrence <- decode.then(none_if_omitted(chargeitem_occurrence_decoder()))
use context <- decode.optional_field("context", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use code <- decode.field("code",codeableconcept_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use status <- decode.field("status",r4valuesets.chargeitemstatus_decoder())
use definition_canonical <- decode.optional_field("definitionCanonical", [], decode.list(decode.string))
use definition_uri <- decode.optional_field("definitionUri", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Chargeitem(supporting_information:,note:,account:,product:,service:,reason:,entered_date:,enterer:,override_reason:,price_override:,factor_override:,bodysite:,quantity:,cost_center:,requesting_organization:,performing_organization:,performer:,occurrence:,context:,subject:,code:,part_of:,status:,definition_canonical:,definition_uri:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItemDefinition#resource
pub type Chargeitemdefinition
{
Chargeitemdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
identifier: List(Identifier),
version: Option(String),
title: Option(String),
derived_from_uri: List(String),
part_of: List(String),
replaces: List(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
code: Option(Codeableconcept),
instance: List(Reference),
applicability: List(ChargeitemdefinitionApplicability),
property_group: List(ChargeitemdefinitionPropertygroup),
)
}

pub fn chargeitemdefinition_new(status status: r4valuesets.Publicationstatus,url url: String,) ->Chargeitemdefinition{Chargeitemdefinition(property_group: [],applicability: [],instance: [],code: None,effective_period: None,last_review_date: None,approval_date: None,copyright: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,replaces: [],part_of: [],derived_from_uri: [],title: None,version: None,identifier: [],url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionApplicability
{
ChargeitemdefinitionApplicability(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
language: Option(String),
expression: Option(String),
)
}

pub fn chargeitemdefinition_applicability_new() ->ChargeitemdefinitionApplicability{ChargeitemdefinitionApplicability(expression: None,language: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionPropertygroup
{
ChargeitemdefinitionPropertygroup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
price_component: List(ChargeitemdefinitionPropertygroupPricecomponent),
)
}

pub fn chargeitemdefinition_propertygroup_new() ->ChargeitemdefinitionPropertygroup{ChargeitemdefinitionPropertygroup(price_component: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionPropertygroupPricecomponent
{
ChargeitemdefinitionPropertygroupPricecomponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Invoicepricecomponenttype,
code: Option(Codeableconcept),
factor: Option(Float),
amount: Option(Money),
)
}

pub fn chargeitemdefinition_propertygroup_pricecomponent_new(type_ type_: r4valuesets.Invoicepricecomponenttype,) ->ChargeitemdefinitionPropertygroupPricecomponent{ChargeitemdefinitionPropertygroupPricecomponent(amount: None,factor: None,code: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn chargeitemdefinition_propertygroup_pricecomponent_to_json(chargeitemdefinition_propertygroup_pricecomponent: ChargeitemdefinitionPropertygroupPricecomponent) -> Json {
    let ChargeitemdefinitionPropertygroupPricecomponent(amount:,factor:,code:,type_:,modifier_extension:,extension:,id:,) = chargeitemdefinition_propertygroup_pricecomponent
    let fields = [#("type", r4valuesets.invoicepricecomponenttype_to_json(type_)),]
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitemdefinition_propertygroup_pricecomponent_decoder() -> Decoder(ChargeitemdefinitionPropertygroupPricecomponent) {use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",r4valuesets.invoicepricecomponenttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ChargeitemdefinitionPropertygroupPricecomponent(amount:,factor:,code:,type_:,modifier_extension:,extension:,id:,))}
pub fn chargeitemdefinition_propertygroup_to_json(chargeitemdefinition_propertygroup: ChargeitemdefinitionPropertygroup) -> Json {
    let ChargeitemdefinitionPropertygroup(price_component:,modifier_extension:,extension:,id:,) = chargeitemdefinition_propertygroup
    let fields = []
let fields = case price_component {
                        [] -> fields
                        _ -> [#("priceComponent", json.array(price_component,chargeitemdefinition_propertygroup_pricecomponent_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitemdefinition_propertygroup_decoder() -> Decoder(ChargeitemdefinitionPropertygroup) {use price_component <- decode.optional_field("priceComponent", [], decode.list(chargeitemdefinition_propertygroup_pricecomponent_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ChargeitemdefinitionPropertygroup(price_component:,modifier_extension:,extension:,id:,))}
pub fn chargeitemdefinition_applicability_to_json(chargeitemdefinition_applicability: ChargeitemdefinitionApplicability) -> Json {
    let ChargeitemdefinitionApplicability(expression:,language:,description:,modifier_extension:,extension:,id:,) = chargeitemdefinition_applicability
    let fields = []
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitemdefinition_applicability_decoder() -> Decoder(ChargeitemdefinitionApplicability) {use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ChargeitemdefinitionApplicability(expression:,language:,description:,modifier_extension:,extension:,id:,))}
pub fn chargeitemdefinition_to_json(chargeitemdefinition: Chargeitemdefinition) -> Json {
    let Chargeitemdefinition(property_group:,applicability:,instance:,code:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,replaces:,part_of:,derived_from_uri:,title:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = chargeitemdefinition
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),#("url", json.string(url)),]
let fields = case property_group {
                        [] -> fields
                        _ -> [#("propertyGroup", json.array(property_group,chargeitemdefinition_propertygroup_to_json)), ..fields]
                          }
let fields = case applicability {
                        [] -> fields
                        _ -> [#("applicability", json.array(applicability,chargeitemdefinition_applicability_to_json)), ..fields]
                          }
let fields = case instance {
                        [] -> fields
                        _ -> [#("instance", json.array(instance,reference_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,json.string)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,json.string)), ..fields]
                          }
let fields = case derived_from_uri {
                        [] -> fields
                        _ -> [#("derivedFromUri", json.array(derived_from_uri,json.string)), ..fields]
                          }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn chargeitemdefinition_decoder() -> Decoder(Chargeitemdefinition) {use property_group <- decode.optional_field("propertyGroup", [], decode.list(chargeitemdefinition_propertygroup_decoder()))
use applicability <- decode.optional_field("applicability", [], decode.list(chargeitemdefinition_applicability_decoder()))
use instance <- decode.optional_field("instance", [], decode.list(reference_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use replaces <- decode.optional_field("replaces", [], decode.list(decode.string))
use part_of <- decode.optional_field("partOf", [], decode.list(decode.string))
use derived_from_uri <- decode.optional_field("derivedFromUri", [], decode.list(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Chargeitemdefinition(property_group:,applicability:,instance:,code:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,replaces:,part_of:,derived_from_uri:,title:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type Claim
{
Claim(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
type_: Codeableconcept,
sub_type: Option(Codeableconcept),
use_: r4valuesets.Claimuse,
patient: Reference,
billable_period: Option(Period),
created: String,
enterer: Option(Reference),
insurer: Option(Reference),
provider: Reference,
priority: Codeableconcept,
funds_reserve: Option(Codeableconcept),
related: List(ClaimRelated),
prescription: Option(Reference),
original_prescription: Option(Reference),
payee: Option(ClaimPayee),
referral: Option(Reference),
facility: Option(Reference),
care_team: List(ClaimCareteam),
supporting_info: List(ClaimSupportinginfo),
diagnosis: List(ClaimDiagnosis),
procedure: List(ClaimProcedure),
insurance: List(ClaimInsurance),
accident: Option(ClaimAccident),
item: List(ClaimItem),
total: Option(Money),
)
}

pub fn claim_new(priority priority: Codeableconcept,provider provider: Reference,created created: String,patient patient: Reference,use_ use_: r4valuesets.Claimuse,type_ type_: Codeableconcept,status status: r4valuesets.Fmstatus,) ->Claim{Claim(total: None,item: [],accident: None,insurance: [],procedure: [],diagnosis: [],supporting_info: [],care_team: [],facility: None,referral: None,payee: None,original_prescription: None,prescription: None,related: [],funds_reserve: None,priority:,provider:,insurer: None,enterer: None,created:,billable_period: None,patient:,use_:,sub_type: None,type_:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimRelated
{
ClaimRelated(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
claim: Option(Reference),
relationship: Option(Codeableconcept),
reference: Option(Identifier),
)
}

pub fn claim_related_new() ->ClaimRelated{ClaimRelated(reference: None,relationship: None,claim: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimPayee
{
ClaimPayee(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
party: Option(Reference),
)
}

pub fn claim_payee_new(type_ type_: Codeableconcept,) ->ClaimPayee{ClaimPayee(party: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimCareteam
{
ClaimCareteam(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
provider: Reference,
responsible: Option(Bool),
role: Option(Codeableconcept),
qualification: Option(Codeableconcept),
)
}

pub fn claim_careteam_new(provider provider: Reference,sequence sequence: Int,) ->ClaimCareteam{ClaimCareteam(qualification: None,role: None,responsible: None,provider:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimSupportinginfo
{
ClaimSupportinginfo(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
category: Codeableconcept,
code: Option(Codeableconcept),
timing: Option(ClaimSupportinginfoTiming),
value: Option(ClaimSupportinginfoValue),
reason: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoTiming{
ClaimSupportinginfoTimingDate(timing: String)
ClaimSupportinginfoTimingPeriod(timing: Period)}
pub fn claim_supportinginfo_timing_to_json(elt: ClaimSupportinginfoTiming) -> Json {case elt{ClaimSupportinginfoTimingDate(v) -> json.string(v)
ClaimSupportinginfoTimingPeriod(v) -> period_to_json(v)
}}
pub fn claim_supportinginfo_timing_decoder() -> Decoder(ClaimSupportinginfoTiming){decode.one_of(decode.field("timingDate", decode.string, decode.success) |> decode.map(ClaimSupportinginfoTimingDate),[decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(ClaimSupportinginfoTimingPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoValue{
ClaimSupportinginfoValueBoolean(value: Bool)
ClaimSupportinginfoValueString(value: String)
ClaimSupportinginfoValueQuantity(value: Quantity)
ClaimSupportinginfoValueAttachment(value: Attachment)
ClaimSupportinginfoValueReference(value: Reference)}
pub fn claim_supportinginfo_value_to_json(elt: ClaimSupportinginfoValue) -> Json {case elt{ClaimSupportinginfoValueBoolean(v) -> json.bool(v)
ClaimSupportinginfoValueString(v) -> json.string(v)
ClaimSupportinginfoValueQuantity(v) -> quantity_to_json(v)
ClaimSupportinginfoValueAttachment(v) -> attachment_to_json(v)
ClaimSupportinginfoValueReference(v) -> reference_to_json(v)
}}
pub fn claim_supportinginfo_value_decoder() -> Decoder(ClaimSupportinginfoValue){decode.one_of(decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ClaimSupportinginfoValueBoolean),[decode.field("valueString", decode.string, decode.success) |> decode.map(ClaimSupportinginfoValueString),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ClaimSupportinginfoValueQuantity),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(ClaimSupportinginfoValueAttachment),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(ClaimSupportinginfoValueReference),])}
pub fn claim_supportinginfo_new(category category: Codeableconcept,sequence sequence: Int,) ->ClaimSupportinginfo{ClaimSupportinginfo(reason: None,value: None,timing: None,code: None,category:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimDiagnosis
{
ClaimDiagnosis(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
diagnosis: ClaimDiagnosisDiagnosis,
type_: List(Codeableconcept),
on_admission: Option(Codeableconcept),
package_code: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimDiagnosisDiagnosis{
ClaimDiagnosisDiagnosisCodeableconcept(diagnosis: Codeableconcept)
ClaimDiagnosisDiagnosisReference(diagnosis: Reference)}
pub fn claim_diagnosis_diagnosis_to_json(elt: ClaimDiagnosisDiagnosis) -> Json {case elt{ClaimDiagnosisDiagnosisCodeableconcept(v) -> codeableconcept_to_json(v)
ClaimDiagnosisDiagnosisReference(v) -> reference_to_json(v)
}}
pub fn claim_diagnosis_diagnosis_decoder() -> Decoder(ClaimDiagnosisDiagnosis){decode.one_of(decode.field("diagnosisCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ClaimDiagnosisDiagnosisCodeableconcept),[decode.field("diagnosisReference", reference_decoder(), decode.success) |> decode.map(ClaimDiagnosisDiagnosisReference),])}
pub fn claim_diagnosis_new(diagnosis diagnosis: ClaimDiagnosisDiagnosis,sequence sequence: Int,) ->ClaimDiagnosis{ClaimDiagnosis(package_code: None,on_admission: None,type_: [],diagnosis:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimProcedure
{
ClaimProcedure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
type_: List(Codeableconcept),
date: Option(String),
procedure: ClaimProcedureProcedure,
udi: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimProcedureProcedure{
ClaimProcedureProcedureCodeableconcept(procedure: Codeableconcept)
ClaimProcedureProcedureReference(procedure: Reference)}
pub fn claim_procedure_procedure_to_json(elt: ClaimProcedureProcedure) -> Json {case elt{ClaimProcedureProcedureCodeableconcept(v) -> codeableconcept_to_json(v)
ClaimProcedureProcedureReference(v) -> reference_to_json(v)
}}
pub fn claim_procedure_procedure_decoder() -> Decoder(ClaimProcedureProcedure){decode.one_of(decode.field("procedureCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ClaimProcedureProcedureCodeableconcept),[decode.field("procedureReference", reference_decoder(), decode.success) |> decode.map(ClaimProcedureProcedureReference),])}
pub fn claim_procedure_new(procedure procedure: ClaimProcedureProcedure,sequence sequence: Int,) ->ClaimProcedure{ClaimProcedure(udi: [],procedure:,date: None,type_: [],sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimInsurance
{
ClaimInsurance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
focal: Bool,
identifier: Option(Identifier),
coverage: Reference,
business_arrangement: Option(String),
pre_auth_ref: List(String),
claim_response: Option(Reference),
)
}

pub fn claim_insurance_new(coverage coverage: Reference,focal focal: Bool,sequence sequence: Int,) ->ClaimInsurance{ClaimInsurance(claim_response: None,pre_auth_ref: [],business_arrangement: None,coverage:,identifier: None,focal:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimAccident
{
ClaimAccident(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
date: String,
type_: Option(Codeableconcept),
location: Option(ClaimAccidentLocation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimAccidentLocation{
ClaimAccidentLocationAddress(location: Address)
ClaimAccidentLocationReference(location: Reference)}
pub fn claim_accident_location_to_json(elt: ClaimAccidentLocation) -> Json {case elt{ClaimAccidentLocationAddress(v) -> address_to_json(v)
ClaimAccidentLocationReference(v) -> reference_to_json(v)
}}
pub fn claim_accident_location_decoder() -> Decoder(ClaimAccidentLocation){decode.one_of(decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ClaimAccidentLocationAddress),[decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ClaimAccidentLocationReference),])}
pub fn claim_accident_new(date date: String,) ->ClaimAccident{ClaimAccident(location: None,type_: None,date:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimItem
{
ClaimItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
care_team_sequence: List(Int),
diagnosis_sequence: List(Int),
procedure_sequence: List(Int),
information_sequence: List(Int),
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
serviced: Option(ClaimItemServiced),
location: Option(ClaimItemLocation),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
body_site: Option(Codeableconcept),
sub_site: List(Codeableconcept),
encounter: List(Reference),
detail: List(ClaimItemDetail),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimItemServiced{
ClaimItemServicedDate(serviced: String)
ClaimItemServicedPeriod(serviced: Period)}
pub fn claim_item_serviced_to_json(elt: ClaimItemServiced) -> Json {case elt{ClaimItemServicedDate(v) -> json.string(v)
ClaimItemServicedPeriod(v) -> period_to_json(v)
}}
pub fn claim_item_serviced_decoder() -> Decoder(ClaimItemServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(ClaimItemServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(ClaimItemServicedPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimItemLocation{
ClaimItemLocationCodeableconcept(location: Codeableconcept)
ClaimItemLocationAddress(location: Address)
ClaimItemLocationReference(location: Reference)}
pub fn claim_item_location_to_json(elt: ClaimItemLocation) -> Json {case elt{ClaimItemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
ClaimItemLocationAddress(v) -> address_to_json(v)
ClaimItemLocationReference(v) -> reference_to_json(v)
}}
pub fn claim_item_location_decoder() -> Decoder(ClaimItemLocation){decode.one_of(decode.field("locationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ClaimItemLocationCodeableconcept),[decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ClaimItemLocationAddress),decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ClaimItemLocationReference),])}
pub fn claim_item_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ClaimItem{ClaimItem(detail: [],encounter: [],sub_site: [],body_site: None,udi: [],net: None,factor: None,unit_price: None,quantity: None,location: None,serviced: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,information_sequence: [],procedure_sequence: [],diagnosis_sequence: [],care_team_sequence: [],sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimItemDetail
{
ClaimItemDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
sub_detail: List(ClaimItemDetailSubdetail),
)
}

pub fn claim_item_detail_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ClaimItemDetail{ClaimItemDetail(sub_detail: [],udi: [],net: None,factor: None,unit_price: None,quantity: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Claim#resource
pub type ClaimItemDetailSubdetail
{
ClaimItemDetailSubdetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
)
}

pub fn claim_item_detail_subdetail_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ClaimItemDetailSubdetail{ClaimItemDetailSubdetail(udi: [],net: None,factor: None,unit_price: None,quantity: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,sequence:,modifier_extension: [],extension: [],id: None,)
}

pub fn claim_item_detail_subdetail_to_json(claim_item_detail_subdetail: ClaimItemDetailSubdetail) -> Json {
    let ClaimItemDetailSubdetail(udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,) = claim_item_detail_subdetail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_item_detail_subdetail_decoder() -> Decoder(ClaimItemDetailSubdetail) {use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimItemDetailSubdetail(udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_item_detail_to_json(claim_item_detail: ClaimItemDetail) -> Json {
    let ClaimItemDetail(sub_detail:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,) = claim_item_detail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case sub_detail {
                        [] -> fields
                        _ -> [#("subDetail", json.array(sub_detail,claim_item_detail_subdetail_to_json)), ..fields]
                          }
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_item_detail_decoder() -> Decoder(ClaimItemDetail) {use sub_detail <- decode.optional_field("subDetail", [], decode.list(claim_item_detail_subdetail_decoder()))
use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimItemDetail(sub_detail:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_item_to_json(claim_item: ClaimItem) -> Json {
    let ClaimItem(detail:,encounter:,sub_site:,body_site:,udi:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,category:,revenue:,information_sequence:,procedure_sequence:,diagnosis_sequence:,care_team_sequence:,sequence:,modifier_extension:,extension:,id:,) = claim_item
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,claim_item_detail_to_json)), ..fields]
                          }
let fields = case encounter {
                        [] -> fields
                        _ -> [#("encounter", json.array(encounter,reference_to_json)), ..fields]
                          }
let fields = case sub_site {
                        [] -> fields
                        _ -> [#("subSite", json.array(sub_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", claim_item_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", claim_item_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case information_sequence {
                        [] -> fields
                        _ -> [#("informationSequence", json.array(information_sequence,json.int)), ..fields]
                          }
let fields = case procedure_sequence {
                        [] -> fields
                        _ -> [#("procedureSequence", json.array(procedure_sequence,json.int)), ..fields]
                          }
let fields = case diagnosis_sequence {
                        [] -> fields
                        _ -> [#("diagnosisSequence", json.array(diagnosis_sequence,json.int)), ..fields]
                          }
let fields = case care_team_sequence {
                        [] -> fields
                        _ -> [#("careTeamSequence", json.array(care_team_sequence,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_item_decoder() -> Decoder(ClaimItem) {use detail <- decode.optional_field("detail", [], decode.list(claim_item_detail_decoder()))
use encounter <- decode.optional_field("encounter", [], decode.list(reference_decoder()))
use sub_site <- decode.optional_field("subSite", [], decode.list(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use location <- decode.then(none_if_omitted(claim_item_location_decoder()))
use serviced <- decode.then(none_if_omitted(claim_item_serviced_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use information_sequence <- decode.optional_field("informationSequence", [], decode.list(decode.int))
use procedure_sequence <- decode.optional_field("procedureSequence", [], decode.list(decode.int))
use diagnosis_sequence <- decode.optional_field("diagnosisSequence", [], decode.list(decode.int))
use care_team_sequence <- decode.optional_field("careTeamSequence", [], decode.list(decode.int))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimItem(detail:,encounter:,sub_site:,body_site:,udi:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,category:,revenue:,information_sequence:,procedure_sequence:,diagnosis_sequence:,care_team_sequence:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_accident_to_json(claim_accident: ClaimAccident) -> Json {
    let ClaimAccident(location:,type_:,date:,modifier_extension:,extension:,id:,) = claim_accident
    let fields = [#("date", json.string(date)),]
let fields = case location {
                          Some(v) -> [#("location", claim_accident_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_accident_decoder() -> Decoder(ClaimAccident) {use location <- decode.then(none_if_omitted(claim_accident_location_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use date <- decode.field("date",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimAccident(location:,type_:,date:,modifier_extension:,extension:,id:,))}
pub fn claim_insurance_to_json(claim_insurance: ClaimInsurance) -> Json {
    let ClaimInsurance(claim_response:,pre_auth_ref:,business_arrangement:,coverage:,identifier:,focal:,sequence:,modifier_extension:,extension:,id:,) = claim_insurance
    let fields = [#("coverage", reference_to_json(coverage)),#("focal", json.bool(focal)),#("sequence", json.int(sequence)),]
let fields = case claim_response {
                          Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_auth_ref {
                        [] -> fields
                        _ -> [#("preAuthRef", json.array(pre_auth_ref,json.string)), ..fields]
                          }
let fields = case business_arrangement {
                          Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_insurance_decoder() -> Decoder(ClaimInsurance) {use claim_response <- decode.optional_field("claimResponse", None, decode.optional(reference_decoder()))
use pre_auth_ref <- decode.optional_field("preAuthRef", [], decode.list(decode.string))
use business_arrangement <- decode.optional_field("businessArrangement", None, decode.optional(decode.string))
use coverage <- decode.field("coverage",reference_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use focal <- decode.field("focal",decode.bool)
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimInsurance(claim_response:,pre_auth_ref:,business_arrangement:,coverage:,identifier:,focal:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_procedure_to_json(claim_procedure: ClaimProcedure) -> Json {
    let ClaimProcedure(udi:,procedure:,date:,type_:,sequence:,modifier_extension:,extension:,id:,) = claim_procedure
    let fields = [#("procedure", claim_procedure_procedure_to_json(procedure)),#("sequence", json.int(sequence)),]
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_procedure_decoder() -> Decoder(ClaimProcedure) {use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use procedure <- decode.then(claim_procedure_procedure_decoder())
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimProcedure(udi:,procedure:,date:,type_:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_diagnosis_to_json(claim_diagnosis: ClaimDiagnosis) -> Json {
    let ClaimDiagnosis(package_code:,on_admission:,type_:,diagnosis:,sequence:,modifier_extension:,extension:,id:,) = claim_diagnosis
    let fields = [#("diagnosis", claim_diagnosis_diagnosis_to_json(diagnosis)),#("sequence", json.int(sequence)),]
let fields = case package_code {
                          Some(v) -> [#("packageCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case on_admission {
                          Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_diagnosis_decoder() -> Decoder(ClaimDiagnosis) {use package_code <- decode.optional_field("packageCode", None, decode.optional(codeableconcept_decoder()))
use on_admission <- decode.optional_field("onAdmission", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use diagnosis <- decode.then(claim_diagnosis_diagnosis_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimDiagnosis(package_code:,on_admission:,type_:,diagnosis:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_supportinginfo_to_json(claim_supportinginfo: ClaimSupportinginfo) -> Json {
    let ClaimSupportinginfo(reason:,value:,timing:,code:,category:,sequence:,modifier_extension:,extension:,id:,) = claim_supportinginfo
    let fields = [#("category", codeableconcept_to_json(category)),#("sequence", json.int(sequence)),]
let fields = case reason {
                          Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", claim_supportinginfo_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case timing {
                          Some(v) -> [#("timing", claim_supportinginfo_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_supportinginfo_decoder() -> Decoder(ClaimSupportinginfo) {use reason <- decode.optional_field("reason", None, decode.optional(codeableconcept_decoder()))
use value <- decode.then(none_if_omitted(claim_supportinginfo_value_decoder()))
use timing <- decode.then(none_if_omitted(claim_supportinginfo_timing_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use category <- decode.field("category",codeableconcept_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimSupportinginfo(reason:,value:,timing:,code:,category:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_careteam_to_json(claim_careteam: ClaimCareteam) -> Json {
    let ClaimCareteam(qualification:,role:,responsible:,provider:,sequence:,modifier_extension:,extension:,id:,) = claim_careteam
    let fields = [#("provider", reference_to_json(provider)),#("sequence", json.int(sequence)),]
let fields = case qualification {
                          Some(v) -> [#("qualification", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_careteam_decoder() -> Decoder(ClaimCareteam) {use qualification <- decode.optional_field("qualification", None, decode.optional(codeableconcept_decoder()))
use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(decode.bool))
use provider <- decode.field("provider",reference_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimCareteam(qualification:,role:,responsible:,provider:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claim_payee_to_json(claim_payee: ClaimPayee) -> Json {
    let ClaimPayee(party:,type_:,modifier_extension:,extension:,id:,) = claim_payee
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case party {
                          Some(v) -> [#("party", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_payee_decoder() -> Decoder(ClaimPayee) {use party <- decode.optional_field("party", None, decode.optional(reference_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimPayee(party:,type_:,modifier_extension:,extension:,id:,))}
pub fn claim_related_to_json(claim_related: ClaimRelated) -> Json {
    let ClaimRelated(reference:,relationship:,claim:,modifier_extension:,extension:,id:,) = claim_related
    let fields = []
let fields = case reference {
                          Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                          Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case claim {
                          Some(v) -> [#("claim", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_related_decoder() -> Decoder(ClaimRelated) {use reference <- decode.optional_field("reference", None, decode.optional(identifier_decoder()))
use relationship <- decode.optional_field("relationship", None, decode.optional(codeableconcept_decoder()))
use claim <- decode.optional_field("claim", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimRelated(reference:,relationship:,claim:,modifier_extension:,extension:,id:,))}
pub fn claim_to_json(claim: Claim) -> Json {
    let Claim(total:,item:,accident:,insurance:,procedure:,diagnosis:,supporting_info:,care_team:,facility:,referral:,payee:,original_prescription:,prescription:,related:,funds_reserve:,priority:,provider:,insurer:,enterer:,created:,billable_period:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = claim
    let fields = [#("priority", codeableconcept_to_json(priority)),#("provider", reference_to_json(provider)),#("created", json.string(created)),#("patient", reference_to_json(patient)),#("use", r4valuesets.claimuse_to_json(use_)),#("type", codeableconcept_to_json(type_)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case total {
                          Some(v) -> [#("total", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,claim_item_to_json)), ..fields]
                          }
let fields = case accident {
                          Some(v) -> [#("accident", claim_accident_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,claim_insurance_to_json)), ..fields]
                          }
let fields = case procedure {
                        [] -> fields
                        _ -> [#("procedure", json.array(procedure,claim_procedure_to_json)), ..fields]
                          }
let fields = case diagnosis {
                        [] -> fields
                        _ -> [#("diagnosis", json.array(diagnosis,claim_diagnosis_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,claim_supportinginfo_to_json)), ..fields]
                          }
let fields = case care_team {
                        [] -> fields
                        _ -> [#("careTeam", json.array(care_team,claim_careteam_to_json)), ..fields]
                          }
let fields = case facility {
                          Some(v) -> [#("facility", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case referral {
                          Some(v) -> [#("referral", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payee {
                          Some(v) -> [#("payee", claim_payee_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case original_prescription {
                          Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case prescription {
                          Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related {
                        [] -> fields
                        _ -> [#("related", json.array(related,claim_related_to_json)), ..fields]
                          }
let fields = case funds_reserve {
                          Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case insurer {
                          Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enterer {
                          Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case billable_period {
                          Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                          Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claim_decoder() -> Decoder(Claim) {use total <- decode.optional_field("total", None, decode.optional(money_decoder()))
use item <- decode.optional_field("item", [], decode.list(claim_item_decoder()))
use accident <- decode.optional_field("accident", None, decode.optional(claim_accident_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(claim_insurance_decoder()))
use procedure <- decode.optional_field("procedure", [], decode.list(claim_procedure_decoder()))
use diagnosis <- decode.optional_field("diagnosis", [], decode.list(claim_diagnosis_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(claim_supportinginfo_decoder()))
use care_team <- decode.optional_field("careTeam", [], decode.list(claim_careteam_decoder()))
use facility <- decode.optional_field("facility", None, decode.optional(reference_decoder()))
use referral <- decode.optional_field("referral", None, decode.optional(reference_decoder()))
use payee <- decode.optional_field("payee", None, decode.optional(claim_payee_decoder()))
use original_prescription <- decode.optional_field("originalPrescription", None, decode.optional(reference_decoder()))
use prescription <- decode.optional_field("prescription", None, decode.optional(reference_decoder()))
use related <- decode.optional_field("related", [], decode.list(claim_related_decoder()))
use funds_reserve <- decode.optional_field("fundsReserve", None, decode.optional(codeableconcept_decoder()))
use priority <- decode.field("priority",codeableconcept_decoder())
use provider <- decode.field("provider",reference_decoder())
use insurer <- decode.optional_field("insurer", None, decode.optional(reference_decoder()))
use enterer <- decode.optional_field("enterer", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use billable_period <- decode.optional_field("billablePeriod", None, decode.optional(period_decoder()))
use patient <- decode.field("patient",reference_decoder())
use use_ <- decode.field("use",r4valuesets.claimuse_decoder())
use sub_type <- decode.optional_field("subType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Claim(total:,item:,accident:,insurance:,procedure:,diagnosis:,supporting_info:,care_team:,facility:,referral:,payee:,original_prescription:,prescription:,related:,funds_reserve:,priority:,provider:,insurer:,enterer:,created:,billable_period:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type Claimresponse
{
Claimresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
type_: Codeableconcept,
sub_type: Option(Codeableconcept),
use_: r4valuesets.Claimuse,
patient: Reference,
created: String,
insurer: Reference,
requestor: Option(Reference),
request: Option(Reference),
outcome: r4valuesets.Remittanceoutcome,
disposition: Option(String),
pre_auth_ref: Option(String),
pre_auth_period: Option(Period),
payee_type: Option(Codeableconcept),
item: List(ClaimresponseItem),
add_item: List(ClaimresponseAdditem),
total: List(ClaimresponseTotal),
payment: Option(ClaimresponsePayment),
funds_reserve: Option(Codeableconcept),
form_code: Option(Codeableconcept),
form: Option(Attachment),
process_note: List(ClaimresponseProcessnote),
communication_request: List(Reference),
insurance: List(ClaimresponseInsurance),
error: List(ClaimresponseError),
)
}

pub fn claimresponse_new(outcome outcome: r4valuesets.Remittanceoutcome,insurer insurer: Reference,created created: String,patient patient: Reference,use_ use_: r4valuesets.Claimuse,type_ type_: Codeableconcept,status status: r4valuesets.Fmstatus,) ->Claimresponse{Claimresponse(error: [],insurance: [],communication_request: [],process_note: [],form: None,form_code: None,funds_reserve: None,payment: None,total: [],add_item: [],item: [],payee_type: None,pre_auth_period: None,pre_auth_ref: None,disposition: None,outcome:,request: None,requestor: None,insurer:,created:,patient:,use_:,sub_type: None,type_:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItem
{
ClaimresponseItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item_sequence: Int,
note_number: List(Int),
adjudication: List(ClaimresponseItemAdjudication),
detail: List(ClaimresponseItemDetail),
)
}

pub fn claimresponse_item_new(item_sequence item_sequence: Int,) ->ClaimresponseItem{ClaimresponseItem(detail: [],adjudication: [],note_number: [],item_sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemAdjudication
{
ClaimresponseItemAdjudication(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
reason: Option(Codeableconcept),
amount: Option(Money),
value: Option(Float),
)
}

pub fn claimresponse_item_adjudication_new(category category: Codeableconcept,) ->ClaimresponseItemAdjudication{ClaimresponseItemAdjudication(value: None,amount: None,reason: None,category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetail
{
ClaimresponseItemDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
detail_sequence: Int,
note_number: List(Int),
sub_detail: List(ClaimresponseItemDetailSubdetail),
)
}

pub fn claimresponse_item_detail_new(detail_sequence detail_sequence: Int,) ->ClaimresponseItemDetail{ClaimresponseItemDetail(sub_detail: [],note_number: [],detail_sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetailSubdetail
{
ClaimresponseItemDetailSubdetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sub_detail_sequence: Int,
note_number: List(Int),
)
}

pub fn claimresponse_item_detail_subdetail_new(sub_detail_sequence sub_detail_sequence: Int,) ->ClaimresponseItemDetailSubdetail{ClaimresponseItemDetailSubdetail(note_number: [],sub_detail_sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditem
{
ClaimresponseAdditem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item_sequence: List(Int),
detail_sequence: List(Int),
subdetail_sequence: List(Int),
provider: List(Reference),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
serviced: Option(ClaimresponseAdditemServiced),
location: Option(ClaimresponseAdditemLocation),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
body_site: Option(Codeableconcept),
sub_site: List(Codeableconcept),
note_number: List(Int),
detail: List(ClaimresponseAdditemDetail),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemServiced{
ClaimresponseAdditemServicedDate(serviced: String)
ClaimresponseAdditemServicedPeriod(serviced: Period)}
pub fn claimresponse_additem_serviced_to_json(elt: ClaimresponseAdditemServiced) -> Json {case elt{ClaimresponseAdditemServicedDate(v) -> json.string(v)
ClaimresponseAdditemServicedPeriod(v) -> period_to_json(v)
}}
pub fn claimresponse_additem_serviced_decoder() -> Decoder(ClaimresponseAdditemServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(ClaimresponseAdditemServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(ClaimresponseAdditemServicedPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemLocation{
ClaimresponseAdditemLocationCodeableconcept(location: Codeableconcept)
ClaimresponseAdditemLocationAddress(location: Address)
ClaimresponseAdditemLocationReference(location: Reference)}
pub fn claimresponse_additem_location_to_json(elt: ClaimresponseAdditemLocation) -> Json {case elt{ClaimresponseAdditemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
ClaimresponseAdditemLocationAddress(v) -> address_to_json(v)
ClaimresponseAdditemLocationReference(v) -> reference_to_json(v)
}}
pub fn claimresponse_additem_location_decoder() -> Decoder(ClaimresponseAdditemLocation){decode.one_of(decode.field("locationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ClaimresponseAdditemLocationCodeableconcept),[decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ClaimresponseAdditemLocationAddress),decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ClaimresponseAdditemLocationReference),])}
pub fn claimresponse_additem_new(product_or_service product_or_service: Codeableconcept,) ->ClaimresponseAdditem{ClaimresponseAdditem(detail: [],note_number: [],sub_site: [],body_site: None,net: None,factor: None,unit_price: None,quantity: None,location: None,serviced: None,program_code: [],modifier: [],product_or_service:,provider: [],subdetail_sequence: [],detail_sequence: [],item_sequence: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetail
{
ClaimresponseAdditemDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
note_number: List(Int),
sub_detail: List(ClaimresponseAdditemDetailSubdetail),
)
}

pub fn claimresponse_additem_detail_new(product_or_service product_or_service: Codeableconcept,) ->ClaimresponseAdditemDetail{ClaimresponseAdditemDetail(sub_detail: [],note_number: [],net: None,factor: None,unit_price: None,quantity: None,modifier: [],product_or_service:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetailSubdetail
{
ClaimresponseAdditemDetailSubdetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
note_number: List(Int),
)
}

pub fn claimresponse_additem_detail_subdetail_new(product_or_service product_or_service: Codeableconcept,) ->ClaimresponseAdditemDetailSubdetail{ClaimresponseAdditemDetailSubdetail(note_number: [],net: None,factor: None,unit_price: None,quantity: None,modifier: [],product_or_service:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseTotal
{
ClaimresponseTotal(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
amount: Money,
)
}

pub fn claimresponse_total_new(amount amount: Money,category category: Codeableconcept,) ->ClaimresponseTotal{ClaimresponseTotal(amount:,category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponsePayment
{
ClaimresponsePayment(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
adjustment: Option(Money),
adjustment_reason: Option(Codeableconcept),
date: Option(String),
amount: Money,
identifier: Option(Identifier),
)
}

pub fn claimresponse_payment_new(amount amount: Money,type_ type_: Codeableconcept,) ->ClaimresponsePayment{ClaimresponsePayment(identifier: None,amount:,date: None,adjustment_reason: None,adjustment: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseProcessnote
{
ClaimresponseProcessnote(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
number: Option(Int),
type_: Option(r4valuesets.Notetype),
text: String,
language: Option(Codeableconcept),
)
}

pub fn claimresponse_processnote_new(text text: String,) ->ClaimresponseProcessnote{ClaimresponseProcessnote(language: None,text:,type_: None,number: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseInsurance
{
ClaimresponseInsurance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
focal: Bool,
coverage: Reference,
business_arrangement: Option(String),
claim_response: Option(Reference),
)
}

pub fn claimresponse_insurance_new(coverage coverage: Reference,focal focal: Bool,sequence sequence: Int,) ->ClaimresponseInsurance{ClaimresponseInsurance(claim_response: None,business_arrangement: None,coverage:,focal:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseError
{
ClaimresponseError(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item_sequence: Option(Int),
detail_sequence: Option(Int),
sub_detail_sequence: Option(Int),
code: Codeableconcept,
)
}

pub fn claimresponse_error_new(code code: Codeableconcept,) ->ClaimresponseError{ClaimresponseError(code:,sub_detail_sequence: None,detail_sequence: None,item_sequence: None,modifier_extension: [],extension: [],id: None,)
}

pub fn claimresponse_error_to_json(claimresponse_error: ClaimresponseError) -> Json {
    let ClaimresponseError(code:,sub_detail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,) = claimresponse_error
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case sub_detail_sequence {
                          Some(v) -> [#("subDetailSequence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case detail_sequence {
                          Some(v) -> [#("detailSequence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case item_sequence {
                          Some(v) -> [#("itemSequence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_error_decoder() -> Decoder(ClaimresponseError) {use code <- decode.field("code",codeableconcept_decoder())
use sub_detail_sequence <- decode.optional_field("subDetailSequence", None, decode.optional(decode.int))
use detail_sequence <- decode.optional_field("detailSequence", None, decode.optional(decode.int))
use item_sequence <- decode.optional_field("itemSequence", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseError(code:,sub_detail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_insurance_to_json(claimresponse_insurance: ClaimresponseInsurance) -> Json {
    let ClaimresponseInsurance(claim_response:,business_arrangement:,coverage:,focal:,sequence:,modifier_extension:,extension:,id:,) = claimresponse_insurance
    let fields = [#("coverage", reference_to_json(coverage)),#("focal", json.bool(focal)),#("sequence", json.int(sequence)),]
let fields = case claim_response {
                          Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case business_arrangement {
                          Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_insurance_decoder() -> Decoder(ClaimresponseInsurance) {use claim_response <- decode.optional_field("claimResponse", None, decode.optional(reference_decoder()))
use business_arrangement <- decode.optional_field("businessArrangement", None, decode.optional(decode.string))
use coverage <- decode.field("coverage",reference_decoder())
use focal <- decode.field("focal",decode.bool)
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseInsurance(claim_response:,business_arrangement:,coverage:,focal:,sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_processnote_to_json(claimresponse_processnote: ClaimresponseProcessnote) -> Json {
    let ClaimresponseProcessnote(language:,text:,type_:,number:,modifier_extension:,extension:,id:,) = claimresponse_processnote
    let fields = [#("text", json.string(text)),]
let fields = case language {
                          Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.notetype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case number {
                          Some(v) -> [#("number", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_processnote_decoder() -> Decoder(ClaimresponseProcessnote) {use language <- decode.optional_field("language", None, decode.optional(codeableconcept_decoder()))
use text <- decode.field("text",decode.string)
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.notetype_decoder()))
use number <- decode.optional_field("number", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseProcessnote(language:,text:,type_:,number:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_payment_to_json(claimresponse_payment: ClaimresponsePayment) -> Json {
    let ClaimresponsePayment(identifier:,amount:,date:,adjustment_reason:,adjustment:,type_:,modifier_extension:,extension:,id:,) = claimresponse_payment
    let fields = [#("amount", money_to_json(amount)),#("type", codeableconcept_to_json(type_)),]
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case adjustment_reason {
                          Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case adjustment {
                          Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_payment_decoder() -> Decoder(ClaimresponsePayment) {use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use amount <- decode.field("amount",money_decoder())
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use adjustment_reason <- decode.optional_field("adjustmentReason", None, decode.optional(codeableconcept_decoder()))
use adjustment <- decode.optional_field("adjustment", None, decode.optional(money_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponsePayment(identifier:,amount:,date:,adjustment_reason:,adjustment:,type_:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_total_to_json(claimresponse_total: ClaimresponseTotal) -> Json {
    let ClaimresponseTotal(amount:,category:,modifier_extension:,extension:,id:,) = claimresponse_total
    let fields = [#("amount", money_to_json(amount)),#("category", codeableconcept_to_json(category)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_total_decoder() -> Decoder(ClaimresponseTotal) {use amount <- decode.field("amount",money_decoder())
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseTotal(amount:,category:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_additem_detail_subdetail_to_json(claimresponse_additem_detail_subdetail: ClaimresponseAdditemDetailSubdetail) -> Json {
    let ClaimresponseAdditemDetailSubdetail(note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,) = claimresponse_additem_detail_subdetail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_additem_detail_subdetail_decoder() -> Decoder(ClaimresponseAdditemDetailSubdetail) {use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseAdditemDetailSubdetail(note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_additem_detail_to_json(claimresponse_additem_detail: ClaimresponseAdditemDetail) -> Json {
    let ClaimresponseAdditemDetail(sub_detail:,note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,) = claimresponse_additem_detail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case sub_detail {
                        [] -> fields
                        _ -> [#("subDetail", json.array(sub_detail,claimresponse_additem_detail_subdetail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_additem_detail_decoder() -> Decoder(ClaimresponseAdditemDetail) {use sub_detail <- decode.optional_field("subDetail", [], decode.list(claimresponse_additem_detail_subdetail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseAdditemDetail(sub_detail:,note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_additem_to_json(claimresponse_additem: ClaimresponseAdditem) -> Json {
    let ClaimresponseAdditem(detail:,note_number:,sub_site:,body_site:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,provider:,subdetail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,) = claimresponse_additem
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,claimresponse_additem_detail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case sub_site {
                        [] -> fields
                        _ -> [#("subSite", json.array(sub_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", claimresponse_additem_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", claimresponse_additem_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case provider {
                        [] -> fields
                        _ -> [#("provider", json.array(provider,reference_to_json)), ..fields]
                          }
let fields = case subdetail_sequence {
                        [] -> fields
                        _ -> [#("subdetailSequence", json.array(subdetail_sequence,json.int)), ..fields]
                          }
let fields = case detail_sequence {
                        [] -> fields
                        _ -> [#("detailSequence", json.array(detail_sequence,json.int)), ..fields]
                          }
let fields = case item_sequence {
                        [] -> fields
                        _ -> [#("itemSequence", json.array(item_sequence,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_additem_decoder() -> Decoder(ClaimresponseAdditem) {use detail <- decode.optional_field("detail", [], decode.list(claimresponse_additem_detail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use sub_site <- decode.optional_field("subSite", [], decode.list(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use location <- decode.then(none_if_omitted(claimresponse_additem_location_decoder()))
use serviced <- decode.then(none_if_omitted(claimresponse_additem_serviced_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use provider <- decode.optional_field("provider", [], decode.list(reference_decoder()))
use subdetail_sequence <- decode.optional_field("subdetailSequence", [], decode.list(decode.int))
use detail_sequence <- decode.optional_field("detailSequence", [], decode.list(decode.int))
use item_sequence <- decode.optional_field("itemSequence", [], decode.list(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseAdditem(detail:,note_number:,sub_site:,body_site:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,provider:,subdetail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_item_detail_subdetail_to_json(claimresponse_item_detail_subdetail: ClaimresponseItemDetailSubdetail) -> Json {
    let ClaimresponseItemDetailSubdetail(note_number:,sub_detail_sequence:,modifier_extension:,extension:,id:,) = claimresponse_item_detail_subdetail
    let fields = [#("subDetailSequence", json.int(sub_detail_sequence)),]
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_item_detail_subdetail_decoder() -> Decoder(ClaimresponseItemDetailSubdetail) {use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use sub_detail_sequence <- decode.field("subDetailSequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseItemDetailSubdetail(note_number:,sub_detail_sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_item_detail_to_json(claimresponse_item_detail: ClaimresponseItemDetail) -> Json {
    let ClaimresponseItemDetail(sub_detail:,note_number:,detail_sequence:,modifier_extension:,extension:,id:,) = claimresponse_item_detail
    let fields = [#("detailSequence", json.int(detail_sequence)),]
let fields = case sub_detail {
                        [] -> fields
                        _ -> [#("subDetail", json.array(sub_detail,claimresponse_item_detail_subdetail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_item_detail_decoder() -> Decoder(ClaimresponseItemDetail) {use sub_detail <- decode.optional_field("subDetail", [], decode.list(claimresponse_item_detail_subdetail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use detail_sequence <- decode.field("detailSequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseItemDetail(sub_detail:,note_number:,detail_sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_item_adjudication_to_json(claimresponse_item_adjudication: ClaimresponseItemAdjudication) -> Json {
    let ClaimresponseItemAdjudication(value:,amount:,reason:,category:,modifier_extension:,extension:,id:,) = claimresponse_item_adjudication
    let fields = [#("category", codeableconcept_to_json(category)),]
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason {
                          Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_item_adjudication_decoder() -> Decoder(ClaimresponseItemAdjudication) {use value <- decode.optional_field("value", None, decode.optional(decode.float))
use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use reason <- decode.optional_field("reason", None, decode.optional(codeableconcept_decoder()))
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseItemAdjudication(value:,amount:,reason:,category:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_item_to_json(claimresponse_item: ClaimresponseItem) -> Json {
    let ClaimresponseItem(detail:,adjudication:,note_number:,item_sequence:,modifier_extension:,extension:,id:,) = claimresponse_item
    let fields = [#("itemSequence", json.int(item_sequence)),]
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,claimresponse_item_detail_to_json)), ..fields]
                          }
let fields = case adjudication {
                        [] -> fields
                        _ -> [#("adjudication", json.array(adjudication,claimresponse_item_adjudication_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_item_decoder() -> Decoder(ClaimresponseItem) {use detail <- decode.optional_field("detail", [], decode.list(claimresponse_item_detail_decoder()))
use adjudication <- decode.optional_field("adjudication", [], decode.list(claimresponse_item_adjudication_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use item_sequence <- decode.field("itemSequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClaimresponseItem(detail:,adjudication:,note_number:,item_sequence:,modifier_extension:,extension:,id:,))}
pub fn claimresponse_to_json(claimresponse: Claimresponse) -> Json {
    let Claimresponse(error:,insurance:,communication_request:,process_note:,form:,form_code:,funds_reserve:,payment:,total:,add_item:,item:,payee_type:,pre_auth_period:,pre_auth_ref:,disposition:,outcome:,request:,requestor:,insurer:,created:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = claimresponse
    let fields = [#("outcome", r4valuesets.remittanceoutcome_to_json(outcome)),#("insurer", reference_to_json(insurer)),#("created", json.string(created)),#("patient", reference_to_json(patient)),#("use", r4valuesets.claimuse_to_json(use_)),#("type", codeableconcept_to_json(type_)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case error {
                        [] -> fields
                        _ -> [#("error", json.array(error,claimresponse_error_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,claimresponse_insurance_to_json)), ..fields]
                          }
let fields = case communication_request {
                        [] -> fields
                        _ -> [#("communicationRequest", json.array(communication_request,reference_to_json)), ..fields]
                          }
let fields = case process_note {
                        [] -> fields
                        _ -> [#("processNote", json.array(process_note,claimresponse_processnote_to_json)), ..fields]
                          }
let fields = case form {
                          Some(v) -> [#("form", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case form_code {
                          Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case funds_reserve {
                          Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payment {
                          Some(v) -> [#("payment", claimresponse_payment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case total {
                        [] -> fields
                        _ -> [#("total", json.array(total,claimresponse_total_to_json)), ..fields]
                          }
let fields = case add_item {
                        [] -> fields
                        _ -> [#("addItem", json.array(add_item,claimresponse_additem_to_json)), ..fields]
                          }
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,claimresponse_item_to_json)), ..fields]
                          }
let fields = case payee_type {
                          Some(v) -> [#("payeeType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_auth_period {
                          Some(v) -> [#("preAuthPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_auth_ref {
                          Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case disposition {
                          Some(v) -> [#("disposition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requestor {
                          Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                          Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn claimresponse_decoder() -> Decoder(Claimresponse) {use error <- decode.optional_field("error", [], decode.list(claimresponse_error_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(claimresponse_insurance_decoder()))
use communication_request <- decode.optional_field("communicationRequest", [], decode.list(reference_decoder()))
use process_note <- decode.optional_field("processNote", [], decode.list(claimresponse_processnote_decoder()))
use form <- decode.optional_field("form", None, decode.optional(attachment_decoder()))
use form_code <- decode.optional_field("formCode", None, decode.optional(codeableconcept_decoder()))
use funds_reserve <- decode.optional_field("fundsReserve", None, decode.optional(codeableconcept_decoder()))
use payment <- decode.optional_field("payment", None, decode.optional(claimresponse_payment_decoder()))
use total <- decode.optional_field("total", [], decode.list(claimresponse_total_decoder()))
use add_item <- decode.optional_field("addItem", [], decode.list(claimresponse_additem_decoder()))
use item <- decode.optional_field("item", [], decode.list(claimresponse_item_decoder()))
use payee_type <- decode.optional_field("payeeType", None, decode.optional(codeableconcept_decoder()))
use pre_auth_period <- decode.optional_field("preAuthPeriod", None, decode.optional(period_decoder()))
use pre_auth_ref <- decode.optional_field("preAuthRef", None, decode.optional(decode.string))
use disposition <- decode.optional_field("disposition", None, decode.optional(decode.string))
use outcome <- decode.field("outcome",r4valuesets.remittanceoutcome_decoder())
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use requestor <- decode.optional_field("requestor", None, decode.optional(reference_decoder()))
use insurer <- decode.field("insurer",reference_decoder())
use created <- decode.field("created",decode.string)
use patient <- decode.field("patient",reference_decoder())
use use_ <- decode.field("use",r4valuesets.claimuse_decoder())
use sub_type <- decode.optional_field("subType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Claimresponse(error:,insurance:,communication_request:,process_note:,form:,form_code:,funds_reserve:,payment:,total:,add_item:,item:,payee_type:,pre_auth_period:,pre_auth_ref:,disposition:,outcome:,request:,requestor:,insurer:,created:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ClinicalImpression#resource
pub type Clinicalimpression
{
Clinicalimpression(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Clinicalimpressionstatus,
status_reason: Option(Codeableconcept),
code: Option(Codeableconcept),
description: Option(String),
subject: Reference,
encounter: Option(Reference),
effective: Option(ClinicalimpressionEffective),
date: Option(String),
assessor: Option(Reference),
previous: Option(Reference),
problem: List(Reference),
investigation: List(ClinicalimpressionInvestigation),
protocol: List(String),
summary: Option(String),
finding: List(ClinicalimpressionFinding),
prognosis_codeable_concept: List(Codeableconcept),
prognosis_reference: List(Reference),
supporting_info: List(Reference),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionEffective{
ClinicalimpressionEffectiveDatetime(effective: String)
ClinicalimpressionEffectivePeriod(effective: Period)}
pub fn clinicalimpression_effective_to_json(elt: ClinicalimpressionEffective) -> Json {case elt{ClinicalimpressionEffectiveDatetime(v) -> json.string(v)
ClinicalimpressionEffectivePeriod(v) -> period_to_json(v)
}}
pub fn clinicalimpression_effective_decoder() -> Decoder(ClinicalimpressionEffective){decode.one_of(decode.field("effectiveDateTime", decode.string, decode.success) |> decode.map(ClinicalimpressionEffectiveDatetime),[decode.field("effectivePeriod", period_decoder(), decode.success) |> decode.map(ClinicalimpressionEffectivePeriod),])}
pub fn clinicalimpression_new(subject subject: Reference,status status: r4valuesets.Clinicalimpressionstatus,) ->Clinicalimpression{Clinicalimpression(note: [],supporting_info: [],prognosis_reference: [],prognosis_codeable_concept: [],finding: [],summary: None,protocol: [],investigation: [],problem: [],previous: None,assessor: None,date: None,effective: None,encounter: None,subject:,description: None,code: None,status_reason: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionInvestigation
{
ClinicalimpressionInvestigation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
item: List(Reference),
)
}

pub fn clinicalimpression_investigation_new(code code: Codeableconcept,) ->ClinicalimpressionInvestigation{ClinicalimpressionInvestigation(item: [],code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionFinding
{
ClinicalimpressionFinding(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item_codeable_concept: Option(Codeableconcept),
item_reference: Option(Reference),
basis: Option(String),
)
}

pub fn clinicalimpression_finding_new() ->ClinicalimpressionFinding{ClinicalimpressionFinding(basis: None,item_reference: None,item_codeable_concept: None,modifier_extension: [],extension: [],id: None,)
}

pub fn clinicalimpression_finding_to_json(clinicalimpression_finding: ClinicalimpressionFinding) -> Json {
    let ClinicalimpressionFinding(basis:,item_reference:,item_codeable_concept:,modifier_extension:,extension:,id:,) = clinicalimpression_finding
    let fields = []
let fields = case basis {
                          Some(v) -> [#("basis", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case item_reference {
                          Some(v) -> [#("itemReference", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case item_codeable_concept {
                          Some(v) -> [#("itemCodeableConcept", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn clinicalimpression_finding_decoder() -> Decoder(ClinicalimpressionFinding) {use basis <- decode.optional_field("basis", None, decode.optional(decode.string))
use item_reference <- decode.optional_field("itemReference", None, decode.optional(reference_decoder()))
use item_codeable_concept <- decode.optional_field("itemCodeableConcept", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClinicalimpressionFinding(basis:,item_reference:,item_codeable_concept:,modifier_extension:,extension:,id:,))}
pub fn clinicalimpression_investigation_to_json(clinicalimpression_investigation: ClinicalimpressionInvestigation) -> Json {
    let ClinicalimpressionInvestigation(item:,code:,modifier_extension:,extension:,id:,) = clinicalimpression_investigation
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn clinicalimpression_investigation_decoder() -> Decoder(ClinicalimpressionInvestigation) {use item <- decode.optional_field("item", [], decode.list(reference_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ClinicalimpressionInvestigation(item:,code:,modifier_extension:,extension:,id:,))}
pub fn clinicalimpression_to_json(clinicalimpression: Clinicalimpression) -> Json {
    let Clinicalimpression(note:,supporting_info:,prognosis_reference:,prognosis_codeable_concept:,finding:,summary:,protocol:,investigation:,problem:,previous:,assessor:,date:,effective:,encounter:,subject:,description:,code:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = clinicalimpression
    let fields = [#("subject", reference_to_json(subject)),#("status", r4valuesets.clinicalimpressionstatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,reference_to_json)), ..fields]
                          }
let fields = case prognosis_reference {
                        [] -> fields
                        _ -> [#("prognosisReference", json.array(prognosis_reference,reference_to_json)), ..fields]
                          }
let fields = case prognosis_codeable_concept {
                        [] -> fields
                        _ -> [#("prognosisCodeableConcept", json.array(prognosis_codeable_concept,codeableconcept_to_json)), ..fields]
                          }
let fields = case finding {
                        [] -> fields
                        _ -> [#("finding", json.array(finding,clinicalimpression_finding_to_json)), ..fields]
                          }
let fields = case summary {
                          Some(v) -> [#("summary", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case protocol {
                        [] -> fields
                        _ -> [#("protocol", json.array(protocol,json.string)), ..fields]
                          }
let fields = case investigation {
                        [] -> fields
                        _ -> [#("investigation", json.array(investigation,clinicalimpression_investigation_to_json)), ..fields]
                          }
let fields = case problem {
                        [] -> fields
                        _ -> [#("problem", json.array(problem,reference_to_json)), ..fields]
                          }
let fields = case previous {
                          Some(v) -> [#("previous", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case assessor {
                          Some(v) -> [#("assessor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case effective {
                          Some(v) -> [#("effective", clinicalimpression_effective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn clinicalimpression_decoder() -> Decoder(Clinicalimpression) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(reference_decoder()))
use prognosis_reference <- decode.optional_field("prognosisReference", [], decode.list(reference_decoder()))
use prognosis_codeable_concept <- decode.optional_field("prognosisCodeableConcept", [], decode.list(codeableconcept_decoder()))
use finding <- decode.optional_field("finding", [], decode.list(clinicalimpression_finding_decoder()))
use summary <- decode.optional_field("summary", None, decode.optional(decode.string))
use protocol <- decode.optional_field("protocol", [], decode.list(decode.string))
use investigation <- decode.optional_field("investigation", [], decode.list(clinicalimpression_investigation_decoder()))
use problem <- decode.optional_field("problem", [], decode.list(reference_decoder()))
use previous <- decode.optional_field("previous", None, decode.optional(reference_decoder()))
use assessor <- decode.optional_field("assessor", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use effective <- decode.then(none_if_omitted(clinicalimpression_effective_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.clinicalimpressionstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Clinicalimpression(note:,supporting_info:,prognosis_reference:,prognosis_codeable_concept:,finding:,summary:,protocol:,investigation:,problem:,previous:,assessor:,date:,effective:,encounter:,subject:,description:,code:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type Codesystem
{
Codesystem(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
case_sensitive: Option(Bool),
value_set: Option(String),
hierarchy_meaning: Option(r4valuesets.Codesystemhierarchymeaning),
compositional: Option(Bool),
version_needed: Option(Bool),
content: r4valuesets.Codesystemcontentmode,
supplements: Option(String),
count: Option(Int),
filter: List(CodesystemFilter),
property: List(CodesystemProperty),
concept: List(CodesystemConcept),
)
}

pub fn codesystem_new(content content: r4valuesets.Codesystemcontentmode,status status: r4valuesets.Publicationstatus,) ->Codesystem{Codesystem(concept: [],property: [],filter: [],count: None,supplements: None,content:,version_needed: None,compositional: None,hierarchy_meaning: None,value_set: None,case_sensitive: None,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemFilter
{
CodesystemFilter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
description: Option(String),
operator: List(r4valuesets.Filteroperator),
value: String,
)
}

pub fn codesystem_filter_new(value value: String,code code: String,) ->CodesystemFilter{CodesystemFilter(value:,operator: [],description: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemProperty
{
CodesystemProperty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
uri: Option(String),
description: Option(String),
type_: r4valuesets.Conceptpropertytype,
)
}

pub fn codesystem_property_new(type_ type_: r4valuesets.Conceptpropertytype,code code: String,) ->CodesystemProperty{CodesystemProperty(type_:,description: None,uri: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemConcept
{
CodesystemConcept(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
display: Option(String),
definition: Option(String),
designation: List(CodesystemConceptDesignation),
property: List(CodesystemConceptProperty),
)
}

pub fn codesystem_concept_new(code code: String,) ->CodesystemConcept{CodesystemConcept(property: [],designation: [],definition: None,display: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptDesignation
{
CodesystemConceptDesignation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
language: Option(String),
use_: Option(Coding),
value: String,
)
}

pub fn codesystem_concept_designation_new(value value: String,) ->CodesystemConceptDesignation{CodesystemConceptDesignation(value:,use_: None,language: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptProperty
{
CodesystemConceptProperty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
value: CodesystemConceptPropertyValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptPropertyValue{
CodesystemConceptPropertyValueCode(value: String)
CodesystemConceptPropertyValueCoding(value: Coding)
CodesystemConceptPropertyValueString(value: String)
CodesystemConceptPropertyValueInteger(value: Int)
CodesystemConceptPropertyValueBoolean(value: Bool)
CodesystemConceptPropertyValueDatetime(value: String)
CodesystemConceptPropertyValueDecimal(value: Float)}
pub fn codesystem_concept_property_value_to_json(elt: CodesystemConceptPropertyValue) -> Json {case elt{CodesystemConceptPropertyValueCode(v) -> json.string(v)
CodesystemConceptPropertyValueCoding(v) -> coding_to_json(v)
CodesystemConceptPropertyValueString(v) -> json.string(v)
CodesystemConceptPropertyValueInteger(v) -> json.int(v)
CodesystemConceptPropertyValueBoolean(v) -> json.bool(v)
CodesystemConceptPropertyValueDatetime(v) -> json.string(v)
CodesystemConceptPropertyValueDecimal(v) -> json.float(v)
}}
pub fn codesystem_concept_property_value_decoder() -> Decoder(CodesystemConceptPropertyValue){decode.one_of(decode.field("valueCode", decode.string, decode.success) |> decode.map(CodesystemConceptPropertyValueCode),[decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(CodesystemConceptPropertyValueCoding),decode.field("valueString", decode.string, decode.success) |> decode.map(CodesystemConceptPropertyValueString),decode.field("valueInteger", decode.int, decode.success) |> decode.map(CodesystemConceptPropertyValueInteger),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(CodesystemConceptPropertyValueBoolean),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(CodesystemConceptPropertyValueDatetime),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(CodesystemConceptPropertyValueDecimal),])}
pub fn codesystem_concept_property_new(value value: CodesystemConceptPropertyValue,code code: String,) ->CodesystemConceptProperty{CodesystemConceptProperty(value:,code:,modifier_extension: [],extension: [],id: None,)
}

pub fn codesystem_concept_property_to_json(codesystem_concept_property: CodesystemConceptProperty) -> Json {
    let CodesystemConceptProperty(value:,code:,modifier_extension:,extension:,id:,) = codesystem_concept_property
    let fields = [#("value", codesystem_concept_property_value_to_json(value)),#("code", json.string(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_concept_property_decoder() -> Decoder(CodesystemConceptProperty) {use value <- decode.then(codesystem_concept_property_value_decoder())
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CodesystemConceptProperty(value:,code:,modifier_extension:,extension:,id:,))}
pub fn codesystem_concept_designation_to_json(codesystem_concept_designation: CodesystemConceptDesignation) -> Json {
    let CodesystemConceptDesignation(value:,use_:,language:,modifier_extension:,extension:,id:,) = codesystem_concept_designation
    let fields = [#("value", json.string(value)),]
let fields = case use_ {
                          Some(v) -> [#("use", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_concept_designation_decoder() -> Decoder(CodesystemConceptDesignation) {use value <- decode.field("value",decode.string)
use use_ <- decode.optional_field("use", None, decode.optional(coding_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CodesystemConceptDesignation(value:,use_:,language:,modifier_extension:,extension:,id:,))}
pub fn codesystem_concept_to_json(codesystem_concept: CodesystemConcept) -> Json {
    let CodesystemConcept(property:,designation:,definition:,display:,code:,modifier_extension:,extension:,id:,) = codesystem_concept
    let fields = [#("code", json.string(code)),]
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,codesystem_concept_property_to_json)), ..fields]
                          }
let fields = case designation {
                        [] -> fields
                        _ -> [#("designation", json.array(designation,codesystem_concept_designation_to_json)), ..fields]
                          }
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_concept_decoder() -> Decoder(CodesystemConcept) {use property <- decode.optional_field("property", [], decode.list(codesystem_concept_property_decoder()))
use designation <- decode.optional_field("designation", [], decode.list(codesystem_concept_designation_decoder()))
use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CodesystemConcept(property:,designation:,definition:,display:,code:,modifier_extension:,extension:,id:,))}
pub fn codesystem_property_to_json(codesystem_property: CodesystemProperty) -> Json {
    let CodesystemProperty(type_:,description:,uri:,code:,modifier_extension:,extension:,id:,) = codesystem_property
    let fields = [#("type", r4valuesets.conceptpropertytype_to_json(type_)),#("code", json.string(code)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case uri {
                          Some(v) -> [#("uri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_property_decoder() -> Decoder(CodesystemProperty) {use type_ <- decode.field("type",r4valuesets.conceptpropertytype_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CodesystemProperty(type_:,description:,uri:,code:,modifier_extension:,extension:,id:,))}
pub fn codesystem_filter_to_json(codesystem_filter: CodesystemFilter) -> Json {
    let CodesystemFilter(value:,operator:,description:,code:,modifier_extension:,extension:,id:,) = codesystem_filter
    let fields = [#("value", json.string(value)),#("code", json.string(code)),]
let fields = case operator {
                        [] -> fields
                        _ -> [#("operator", json.array(operator,r4valuesets.filteroperator_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_filter_decoder() -> Decoder(CodesystemFilter) {use value <- decode.field("value",decode.string)
use operator <- decode.optional_field("operator", [], decode.list(r4valuesets.filteroperator_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CodesystemFilter(value:,operator:,description:,code:,modifier_extension:,extension:,id:,))}
pub fn codesystem_to_json(codesystem: Codesystem) -> Json {
    let Codesystem(concept:,property:,filter:,count:,supplements:,content:,version_needed:,compositional:,hierarchy_meaning:,value_set:,case_sensitive:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = codesystem
    let fields = [#("content", r4valuesets.codesystemcontentmode_to_json(content)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case concept {
                        [] -> fields
                        _ -> [#("concept", json.array(concept,codesystem_concept_to_json)), ..fields]
                          }
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,codesystem_property_to_json)), ..fields]
                          }
let fields = case filter {
                        [] -> fields
                        _ -> [#("filter", json.array(filter,codesystem_filter_to_json)), ..fields]
                          }
let fields = case count {
                          Some(v) -> [#("count", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case supplements {
                          Some(v) -> [#("supplements", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version_needed {
                          Some(v) -> [#("versionNeeded", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case compositional {
                          Some(v) -> [#("compositional", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case hierarchy_meaning {
                          Some(v) -> [#("hierarchyMeaning", r4valuesets.codesystemhierarchymeaning_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value_set {
                          Some(v) -> [#("valueSet", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case case_sensitive {
                          Some(v) -> [#("caseSensitive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn codesystem_decoder() -> Decoder(Codesystem) {use concept <- decode.optional_field("concept", [], decode.list(codesystem_concept_decoder()))
use property <- decode.optional_field("property", [], decode.list(codesystem_property_decoder()))
use filter <- decode.optional_field("filter", [], decode.list(codesystem_filter_decoder()))
use count <- decode.optional_field("count", None, decode.optional(decode.int))
use supplements <- decode.optional_field("supplements", None, decode.optional(decode.string))
use content <- decode.field("content",r4valuesets.codesystemcontentmode_decoder())
use version_needed <- decode.optional_field("versionNeeded", None, decode.optional(decode.bool))
use compositional <- decode.optional_field("compositional", None, decode.optional(decode.bool))
use hierarchy_meaning <- decode.optional_field("hierarchyMeaning", None, decode.optional(r4valuesets.codesystemhierarchymeaning_decoder()))
use value_set <- decode.optional_field("valueSet", None, decode.optional(decode.string))
use case_sensitive <- decode.optional_field("caseSensitive", None, decode.optional(decode.bool))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Codesystem(concept:,property:,filter:,count:,supplements:,content:,version_needed:,compositional:,hierarchy_meaning:,value_set:,case_sensitive:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Communication#resource
pub type Communication
{
Communication(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
part_of: List(Reference),
in_response_to: List(Reference),
status: r4valuesets.Eventstatus,
status_reason: Option(Codeableconcept),
category: List(Codeableconcept),
priority: Option(r4valuesets.Requestpriority),
medium: List(Codeableconcept),
subject: Option(Reference),
topic: Option(Codeableconcept),
about: List(Reference),
encounter: Option(Reference),
sent: Option(String),
received: Option(String),
recipient: List(Reference),
sender: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
payload: List(CommunicationPayload),
note: List(Annotation),
)
}

pub fn communication_new(status status: r4valuesets.Eventstatus,) ->Communication{Communication(note: [],payload: [],reason_reference: [],reason_code: [],sender: None,recipient: [],received: None,sent: None,encounter: None,about: [],topic: None,subject: None,medium: [],priority: None,category: [],status_reason: None,status:,in_response_to: [],part_of: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Communication#resource
pub type CommunicationPayload
{
CommunicationPayload(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
content: CommunicationPayloadContent,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Communication#resource
pub type CommunicationPayloadContent{
CommunicationPayloadContentString(content: String)
CommunicationPayloadContentAttachment(content: Attachment)
CommunicationPayloadContentReference(content: Reference)}
pub fn communication_payload_content_to_json(elt: CommunicationPayloadContent) -> Json {case elt{CommunicationPayloadContentString(v) -> json.string(v)
CommunicationPayloadContentAttachment(v) -> attachment_to_json(v)
CommunicationPayloadContentReference(v) -> reference_to_json(v)
}}
pub fn communication_payload_content_decoder() -> Decoder(CommunicationPayloadContent){decode.one_of(decode.field("contentString", decode.string, decode.success) |> decode.map(CommunicationPayloadContentString),[decode.field("contentAttachment", attachment_decoder(), decode.success) |> decode.map(CommunicationPayloadContentAttachment),decode.field("contentReference", reference_decoder(), decode.success) |> decode.map(CommunicationPayloadContentReference),])}
pub fn communication_payload_new(content content: CommunicationPayloadContent,) ->CommunicationPayload{CommunicationPayload(content:,modifier_extension: [],extension: [],id: None,)
}

pub fn communication_payload_to_json(communication_payload: CommunicationPayload) -> Json {
    let CommunicationPayload(content:,modifier_extension:,extension:,id:,) = communication_payload
    let fields = [#("content", communication_payload_content_to_json(content)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn communication_payload_decoder() -> Decoder(CommunicationPayload) {use content <- decode.then(communication_payload_content_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CommunicationPayload(content:,modifier_extension:,extension:,id:,))}
pub fn communication_to_json(communication: Communication) -> Json {
    let Communication(note:,payload:,reason_reference:,reason_code:,sender:,recipient:,received:,sent:,encounter:,about:,topic:,subject:,medium:,priority:,category:,status_reason:,status:,in_response_to:,part_of:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = communication
    let fields = [#("status", r4valuesets.eventstatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case payload {
                        [] -> fields
                        _ -> [#("payload", json.array(payload,communication_payload_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case sender {
                          Some(v) -> [#("sender", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recipient {
                        [] -> fields
                        _ -> [#("recipient", json.array(recipient,reference_to_json)), ..fields]
                          }
let fields = case received {
                          Some(v) -> [#("received", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case sent {
                          Some(v) -> [#("sent", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case about {
                        [] -> fields
                        _ -> [#("about", json.array(about,reference_to_json)), ..fields]
                          }
let fields = case topic {
                          Some(v) -> [#("topic", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case medium {
                        [] -> fields
                        _ -> [#("medium", json.array(medium,codeableconcept_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case in_response_to {
                        [] -> fields
                        _ -> [#("inResponseTo", json.array(in_response_to,reference_to_json)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn communication_decoder() -> Decoder(Communication) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use payload <- decode.optional_field("payload", [], decode.list(communication_payload_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use sender <- decode.optional_field("sender", None, decode.optional(reference_decoder()))
use recipient <- decode.optional_field("recipient", [], decode.list(reference_decoder()))
use received <- decode.optional_field("received", None, decode.optional(decode.string))
use sent <- decode.optional_field("sent", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use about <- decode.optional_field("about", [], decode.list(reference_decoder()))
use topic <- decode.optional_field("topic", None, decode.optional(codeableconcept_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use medium <- decode.optional_field("medium", [], decode.list(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.eventstatus_decoder())
use in_response_to <- decode.optional_field("inResponseTo", [], decode.list(reference_decoder()))
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Communication(note:,payload:,reason_reference:,reason_code:,sender:,recipient:,received:,sent:,encounter:,about:,topic:,subject:,medium:,priority:,category:,status_reason:,status:,in_response_to:,part_of:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CommunicationRequest#resource
pub type Communicationrequest
{
Communicationrequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
replaces: List(Reference),
group_identifier: Option(Identifier),
status: r4valuesets.Requeststatus,
status_reason: Option(Codeableconcept),
category: List(Codeableconcept),
priority: Option(r4valuesets.Requestpriority),
do_not_perform: Option(Bool),
medium: List(Codeableconcept),
subject: Option(Reference),
about: List(Reference),
encounter: Option(Reference),
payload: List(CommunicationrequestPayload),
occurrence: Option(CommunicationrequestOccurrence),
authored_on: Option(String),
requester: Option(Reference),
recipient: List(Reference),
sender: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestOccurrence{
CommunicationrequestOccurrenceDatetime(occurrence: String)
CommunicationrequestOccurrencePeriod(occurrence: Period)}
pub fn communicationrequest_occurrence_to_json(elt: CommunicationrequestOccurrence) -> Json {case elt{CommunicationrequestOccurrenceDatetime(v) -> json.string(v)
CommunicationrequestOccurrencePeriod(v) -> period_to_json(v)
}}
pub fn communicationrequest_occurrence_decoder() -> Decoder(CommunicationrequestOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(CommunicationrequestOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(CommunicationrequestOccurrencePeriod),])}
pub fn communicationrequest_new(status status: r4valuesets.Requeststatus,) ->Communicationrequest{Communicationrequest(note: [],reason_reference: [],reason_code: [],sender: None,recipient: [],requester: None,authored_on: None,occurrence: None,payload: [],encounter: None,about: [],subject: None,medium: [],do_not_perform: None,priority: None,category: [],status_reason: None,status:,group_identifier: None,replaces: [],based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayload
{
CommunicationrequestPayload(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
content: CommunicationrequestPayloadContent,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayloadContent{
CommunicationrequestPayloadContentString(content: String)
CommunicationrequestPayloadContentAttachment(content: Attachment)
CommunicationrequestPayloadContentReference(content: Reference)}
pub fn communicationrequest_payload_content_to_json(elt: CommunicationrequestPayloadContent) -> Json {case elt{CommunicationrequestPayloadContentString(v) -> json.string(v)
CommunicationrequestPayloadContentAttachment(v) -> attachment_to_json(v)
CommunicationrequestPayloadContentReference(v) -> reference_to_json(v)
}}
pub fn communicationrequest_payload_content_decoder() -> Decoder(CommunicationrequestPayloadContent){decode.one_of(decode.field("contentString", decode.string, decode.success) |> decode.map(CommunicationrequestPayloadContentString),[decode.field("contentAttachment", attachment_decoder(), decode.success) |> decode.map(CommunicationrequestPayloadContentAttachment),decode.field("contentReference", reference_decoder(), decode.success) |> decode.map(CommunicationrequestPayloadContentReference),])}
pub fn communicationrequest_payload_new(content content: CommunicationrequestPayloadContent,) ->CommunicationrequestPayload{CommunicationrequestPayload(content:,modifier_extension: [],extension: [],id: None,)
}

pub fn communicationrequest_payload_to_json(communicationrequest_payload: CommunicationrequestPayload) -> Json {
    let CommunicationrequestPayload(content:,modifier_extension:,extension:,id:,) = communicationrequest_payload
    let fields = [#("content", communicationrequest_payload_content_to_json(content)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn communicationrequest_payload_decoder() -> Decoder(CommunicationrequestPayload) {use content <- decode.then(communicationrequest_payload_content_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CommunicationrequestPayload(content:,modifier_extension:,extension:,id:,))}
pub fn communicationrequest_to_json(communicationrequest: Communicationrequest) -> Json {
    let Communicationrequest(note:,reason_reference:,reason_code:,sender:,recipient:,requester:,authored_on:,occurrence:,payload:,encounter:,about:,subject:,medium:,do_not_perform:,priority:,category:,status_reason:,status:,group_identifier:,replaces:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = communicationrequest
    let fields = [#("status", r4valuesets.requeststatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case sender {
                          Some(v) -> [#("sender", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recipient {
                        [] -> fields
                        _ -> [#("recipient", json.array(recipient,reference_to_json)), ..fields]
                          }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", communicationrequest_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payload {
                        [] -> fields
                        _ -> [#("payload", json.array(payload,communicationrequest_payload_to_json)), ..fields]
                          }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case about {
                        [] -> fields
                        _ -> [#("about", json.array(about,reference_to_json)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case medium {
                        [] -> fields
                        _ -> [#("medium", json.array(medium,codeableconcept_to_json)), ..fields]
                          }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case group_identifier {
                          Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn communicationrequest_decoder() -> Decoder(Communicationrequest) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use sender <- decode.optional_field("sender", None, decode.optional(reference_decoder()))
use recipient <- decode.optional_field("recipient", [], decode.list(reference_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use occurrence <- decode.then(none_if_omitted(communicationrequest_occurrence_decoder()))
use payload <- decode.optional_field("payload", [], decode.list(communicationrequest_payload_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use about <- decode.optional_field("about", [], decode.list(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use medium <- decode.optional_field("medium", [], decode.list(codeableconcept_decoder()))
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.requeststatus_decoder())
use group_identifier <- decode.optional_field("groupIdentifier", None, decode.optional(identifier_decoder()))
use replaces <- decode.optional_field("replaces", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Communicationrequest(note:,reason_reference:,reason_code:,sender:,recipient:,requester:,authored_on:,occurrence:,payload:,encounter:,about:,subject:,medium:,do_not_perform:,priority:,category:,status_reason:,status:,group_identifier:,replaces:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CompartmentDefinition#resource
pub type Compartmentdefinition
{
Compartmentdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
version: Option(String),
name: String,
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
purpose: Option(String),
code: r4valuesets.Compartmenttype,
search: Bool,
resource: List(CompartmentdefinitionResource),
)
}

pub fn compartmentdefinition_new(search search: Bool,code code: r4valuesets.Compartmenttype,status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Compartmentdefinition{Compartmentdefinition(resource: [],search:,code:,purpose: None,use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,name:,version: None,url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CompartmentDefinition#resource
pub type CompartmentdefinitionResource
{
CompartmentdefinitionResource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Resourcetypes,
param: List(String),
documentation: Option(String),
)
}

pub fn compartmentdefinition_resource_new(code code: r4valuesets.Resourcetypes,) ->CompartmentdefinitionResource{CompartmentdefinitionResource(documentation: None,param: [],code:,modifier_extension: [],extension: [],id: None,)
}

pub fn compartmentdefinition_resource_to_json(compartmentdefinition_resource: CompartmentdefinitionResource) -> Json {
    let CompartmentdefinitionResource(documentation:,param:,code:,modifier_extension:,extension:,id:,) = compartmentdefinition_resource
    let fields = [#("code", r4valuesets.resourcetypes_to_json(code)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case param {
                        [] -> fields
                        _ -> [#("param", json.array(param,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn compartmentdefinition_resource_decoder() -> Decoder(CompartmentdefinitionResource) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use param <- decode.optional_field("param", [], decode.list(decode.string))
use code <- decode.field("code",r4valuesets.resourcetypes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CompartmentdefinitionResource(documentation:,param:,code:,modifier_extension:,extension:,id:,))}
pub fn compartmentdefinition_to_json(compartmentdefinition: Compartmentdefinition) -> Json {
    let Compartmentdefinition(resource:,search:,code:,purpose:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = compartmentdefinition
    let fields = [#("search", json.bool(search)),#("code", r4valuesets.compartmenttype_to_json(code)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case resource {
                        [] -> fields
                        _ -> [#("resource", json.array(resource,compartmentdefinition_resource_to_json)), ..fields]
                          }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn compartmentdefinition_decoder() -> Decoder(Compartmentdefinition) {use resource <- decode.optional_field("resource", [], decode.list(compartmentdefinition_resource_decoder()))
use search <- decode.field("search",decode.bool)
use code <- decode.field("code",r4valuesets.compartmenttype_decoder())
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Compartmentdefinition(resource:,search:,code:,purpose:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type Composition
{
Composition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
status: r4valuesets.Compositionstatus,
type_: Codeableconcept,
category: List(Codeableconcept),
subject: Option(Reference),
encounter: Option(Reference),
date: String,
author: List(Reference),
title: String,
confidentiality: Option(String),
attester: List(CompositionAttester),
custodian: Option(Reference),
relates_to: List(CompositionRelatesto),
event: List(CompositionEvent),
section: List(CompositionSection),
)
}

pub fn composition_new(title title: String,date date: String,type_ type_: Codeableconcept,status status: r4valuesets.Compositionstatus,) ->Composition{Composition(section: [],event: [],relates_to: [],custodian: None,attester: [],confidentiality: None,title:,author: [],date:,encounter: None,subject: None,category: [],type_:,status:,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type CompositionAttester
{
CompositionAttester(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: r4valuesets.Compositionattestationmode,
time: Option(String),
party: Option(Reference),
)
}

pub fn composition_attester_new(mode mode: r4valuesets.Compositionattestationmode,) ->CompositionAttester{CompositionAttester(party: None,time: None,mode:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type CompositionRelatesto
{
CompositionRelatesto(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Documentrelationshiptype,
target: CompositionRelatestoTarget,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type CompositionRelatestoTarget{
CompositionRelatestoTargetIdentifier(target: Identifier)
CompositionRelatestoTargetReference(target: Reference)}
pub fn composition_relatesto_target_to_json(elt: CompositionRelatestoTarget) -> Json {case elt{CompositionRelatestoTargetIdentifier(v) -> identifier_to_json(v)
CompositionRelatestoTargetReference(v) -> reference_to_json(v)
}}
pub fn composition_relatesto_target_decoder() -> Decoder(CompositionRelatestoTarget){decode.one_of(decode.field("targetIdentifier", identifier_decoder(), decode.success) |> decode.map(CompositionRelatestoTargetIdentifier),[decode.field("targetReference", reference_decoder(), decode.success) |> decode.map(CompositionRelatestoTargetReference),])}
pub fn composition_relatesto_new(target target: CompositionRelatestoTarget,code code: r4valuesets.Documentrelationshiptype,) ->CompositionRelatesto{CompositionRelatesto(target:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type CompositionEvent
{
CompositionEvent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: List(Codeableconcept),
period: Option(Period),
detail: List(Reference),
)
}

pub fn composition_event_new() ->CompositionEvent{CompositionEvent(detail: [],period: None,code: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Composition#resource
pub type CompositionSection
{
CompositionSection(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
title: Option(String),
code: Option(Codeableconcept),
author: List(Reference),
focus: Option(Reference),
text: Option(Narrative),
mode: Option(r4valuesets.Listmode),
ordered_by: Option(Codeableconcept),
entry: List(Reference),
empty_reason: Option(Codeableconcept),
)
}

pub fn composition_section_new() ->CompositionSection{CompositionSection(empty_reason: None,entry: [],ordered_by: None,mode: None,text: None,focus: None,author: [],code: None,title: None,modifier_extension: [],extension: [],id: None,)
}

pub fn composition_section_to_json(composition_section: CompositionSection) -> Json {
    let CompositionSection(empty_reason:,entry:,ordered_by:,mode:,text:,focus:,author:,code:,title:,modifier_extension:,extension:,id:,) = composition_section
    let fields = []
let fields = case empty_reason {
                          Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case entry {
                        [] -> fields
                        _ -> [#("entry", json.array(entry,reference_to_json)), ..fields]
                          }
let fields = case ordered_by {
                          Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case mode {
                          Some(v) -> [#("mode", r4valuesets.listmode_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case focus {
                          Some(v) -> [#("focus", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,reference_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn composition_section_decoder() -> Decoder(CompositionSection) {use empty_reason <- decode.optional_field("emptyReason", None, decode.optional(codeableconcept_decoder()))
use entry <- decode.optional_field("entry", [], decode.list(reference_decoder()))
use ordered_by <- decode.optional_field("orderedBy", None, decode.optional(codeableconcept_decoder()))
use mode <- decode.optional_field("mode", None, decode.optional(r4valuesets.listmode_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use focus <- decode.optional_field("focus", None, decode.optional(reference_decoder()))
use author <- decode.optional_field("author", [], decode.list(reference_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CompositionSection(empty_reason:,entry:,ordered_by:,mode:,text:,focus:,author:,code:,title:,modifier_extension:,extension:,id:,))}
pub fn composition_event_to_json(composition_event: CompositionEvent) -> Json {
    let CompositionEvent(detail:,period:,code:,modifier_extension:,extension:,id:,) = composition_event
    let fields = []
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,reference_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn composition_event_decoder() -> Decoder(CompositionEvent) {use detail <- decode.optional_field("detail", [], decode.list(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CompositionEvent(detail:,period:,code:,modifier_extension:,extension:,id:,))}
pub fn composition_relatesto_to_json(composition_relatesto: CompositionRelatesto) -> Json {
    let CompositionRelatesto(target:,code:,modifier_extension:,extension:,id:,) = composition_relatesto
    let fields = [#("target", composition_relatesto_target_to_json(target)),#("code", r4valuesets.documentrelationshiptype_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn composition_relatesto_decoder() -> Decoder(CompositionRelatesto) {use target <- decode.then(composition_relatesto_target_decoder())
use code <- decode.field("code",r4valuesets.documentrelationshiptype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CompositionRelatesto(target:,code:,modifier_extension:,extension:,id:,))}
pub fn composition_attester_to_json(composition_attester: CompositionAttester) -> Json {
    let CompositionAttester(party:,time:,mode:,modifier_extension:,extension:,id:,) = composition_attester
    let fields = [#("mode", r4valuesets.compositionattestationmode_to_json(mode)),]
let fields = case party {
                          Some(v) -> [#("party", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case time {
                          Some(v) -> [#("time", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn composition_attester_decoder() -> Decoder(CompositionAttester) {use party <- decode.optional_field("party", None, decode.optional(reference_decoder()))
use time <- decode.optional_field("time", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.compositionattestationmode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CompositionAttester(party:,time:,mode:,modifier_extension:,extension:,id:,))}
pub fn composition_to_json(composition: Composition) -> Json {
    let Composition(section:,event:,relates_to:,custodian:,attester:,confidentiality:,title:,author:,date:,encounter:,subject:,category:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = composition
    let fields = [#("title", json.string(title)),#("date", json.string(date)),#("type", codeableconcept_to_json(type_)),#("status", r4valuesets.compositionstatus_to_json(status)),]
let fields = case section {
                        [] -> fields
                        _ -> [#("section", json.array(section,composition_section_to_json)), ..fields]
                          }
let fields = case event {
                        [] -> fields
                        _ -> [#("event", json.array(event,composition_event_to_json)), ..fields]
                          }
let fields = case relates_to {
                        [] -> fields
                        _ -> [#("relatesTo", json.array(relates_to,composition_relatesto_to_json)), ..fields]
                          }
let fields = case custodian {
                          Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case attester {
                        [] -> fields
                        _ -> [#("attester", json.array(attester,composition_attester_to_json)), ..fields]
                          }
let fields = case confidentiality {
                          Some(v) -> [#("confidentiality", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,reference_to_json)), ..fields]
                          }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn composition_decoder() -> Decoder(Composition) {use section <- decode.optional_field("section", [], decode.list(composition_section_decoder()))
use event <- decode.optional_field("event", [], decode.list(composition_event_decoder()))
use relates_to <- decode.optional_field("relatesTo", [], decode.list(composition_relatesto_decoder()))
use custodian <- decode.optional_field("custodian", None, decode.optional(reference_decoder()))
use attester <- decode.optional_field("attester", [], decode.list(composition_attester_decoder()))
use confidentiality <- decode.optional_field("confidentiality", None, decode.optional(decode.string))
use title <- decode.field("title",decode.string)
use author <- decode.optional_field("author", [], decode.list(reference_decoder()))
use date <- decode.field("date",decode.string)
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use status <- decode.field("status",r4valuesets.compositionstatus_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Composition(section:,event:,relates_to:,custodian:,attester:,confidentiality:,title:,author:,date:,encounter:,subject:,category:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type Conceptmap
{
Conceptmap(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: Option(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
source: Option(ConceptmapSource),
target: Option(ConceptmapTarget),
group: List(ConceptmapGroup),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapSource{
ConceptmapSourceUri(source: String)
ConceptmapSourceCanonical(source: String)}
pub fn conceptmap_source_to_json(elt: ConceptmapSource) -> Json {case elt{ConceptmapSourceUri(v) -> json.string(v)
ConceptmapSourceCanonical(v) -> json.string(v)
}}
pub fn conceptmap_source_decoder() -> Decoder(ConceptmapSource){decode.one_of(decode.field("sourceUri", decode.string, decode.success) |> decode.map(ConceptmapSourceUri),[decode.field("sourceCanonical", decode.string, decode.success) |> decode.map(ConceptmapSourceCanonical),])}

///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapTarget{
ConceptmapTargetUri(target: String)
ConceptmapTargetCanonical(target: String)}
pub fn conceptmap_target_to_json(elt: ConceptmapTarget) -> Json {case elt{ConceptmapTargetUri(v) -> json.string(v)
ConceptmapTargetCanonical(v) -> json.string(v)
}}
pub fn conceptmap_target_decoder() -> Decoder(ConceptmapTarget){decode.one_of(decode.field("targetUri", decode.string, decode.success) |> decode.map(ConceptmapTargetUri),[decode.field("targetCanonical", decode.string, decode.success) |> decode.map(ConceptmapTargetCanonical),])}
pub fn conceptmap_new(status status: r4valuesets.Publicationstatus,) ->Conceptmap{Conceptmap(group: [],target: None,source: None,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name: None,version: None,identifier: None,url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroup
{
ConceptmapGroup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
source: Option(String),
source_version: Option(String),
target: Option(String),
target_version: Option(String),
element: List(ConceptmapGroupElement),
unmapped: Option(ConceptmapGroupUnmapped),
)
}

pub fn conceptmap_group_new() ->ConceptmapGroup{ConceptmapGroup(unmapped: None,element: [],target_version: None,target: None,source_version: None,source: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElement
{
ConceptmapGroupElement(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(String),
display: Option(String),
target: List(ConceptmapGroupElementTarget),
)
}

pub fn conceptmap_group_element_new() ->ConceptmapGroupElement{ConceptmapGroupElement(target: [],display: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTarget
{
ConceptmapGroupElementTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(String),
display: Option(String),
equivalence: r4valuesets.Conceptmapequivalence,
comment: Option(String),
depends_on: List(ConceptmapGroupElementTargetDependson),
)
}

pub fn conceptmap_group_element_target_new(equivalence equivalence: r4valuesets.Conceptmapequivalence,) ->ConceptmapGroupElementTarget{ConceptmapGroupElementTarget(depends_on: [],comment: None,equivalence:,display: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetDependson
{
ConceptmapGroupElementTargetDependson(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
property: String,
system: Option(String),
value: String,
display: Option(String),
)
}

pub fn conceptmap_group_element_target_dependson_new(value value: String,property property: String,) ->ConceptmapGroupElementTargetDependson{ConceptmapGroupElementTargetDependson(display: None,value:,system: None,property:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupUnmapped
{
ConceptmapGroupUnmapped(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
mode: r4valuesets.Conceptmapunmappedmode,
code: Option(String),
display: Option(String),
url: Option(String),
)
}

pub fn conceptmap_group_unmapped_new(mode mode: r4valuesets.Conceptmapunmappedmode,) ->ConceptmapGroupUnmapped{ConceptmapGroupUnmapped(url: None,display: None,code: None,mode:,modifier_extension: [],extension: [],id: None,)
}

pub fn conceptmap_group_unmapped_to_json(conceptmap_group_unmapped: ConceptmapGroupUnmapped) -> Json {
    let ConceptmapGroupUnmapped(url:,display:,code:,mode:,modifier_extension:,extension:,id:,) = conceptmap_group_unmapped
    let fields = [#("mode", r4valuesets.conceptmapunmappedmode_to_json(mode)),]
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_group_unmapped_decoder() -> Decoder(ConceptmapGroupUnmapped) {use url <- decode.optional_field("url", None, decode.optional(decode.string))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.conceptmapunmappedmode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConceptmapGroupUnmapped(url:,display:,code:,mode:,modifier_extension:,extension:,id:,))}
pub fn conceptmap_group_element_target_dependson_to_json(conceptmap_group_element_target_dependson: ConceptmapGroupElementTargetDependson) -> Json {
    let ConceptmapGroupElementTargetDependson(display:,value:,system:,property:,modifier_extension:,extension:,id:,) = conceptmap_group_element_target_dependson
    let fields = [#("value", json.string(value)),#("property", json.string(property)),]
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_group_element_target_dependson_decoder() -> Decoder(ConceptmapGroupElementTargetDependson) {use display <- decode.optional_field("display", None, decode.optional(decode.string))
use value <- decode.field("value",decode.string)
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use property <- decode.field("property",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConceptmapGroupElementTargetDependson(display:,value:,system:,property:,modifier_extension:,extension:,id:,))}
pub fn conceptmap_group_element_target_to_json(conceptmap_group_element_target: ConceptmapGroupElementTarget) -> Json {
    let ConceptmapGroupElementTarget(depends_on:,comment:,equivalence:,display:,code:,modifier_extension:,extension:,id:,) = conceptmap_group_element_target
    let fields = [#("equivalence", r4valuesets.conceptmapequivalence_to_json(equivalence)),]
let fields = case depends_on {
                        [] -> fields
                        _ -> [#("dependsOn", json.array(depends_on,conceptmap_group_element_target_dependson_to_json)), ..fields]
                          }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_group_element_target_decoder() -> Decoder(ConceptmapGroupElementTarget) {use depends_on <- decode.optional_field("dependsOn", [], decode.list(conceptmap_group_element_target_dependson_decoder()))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use equivalence <- decode.field("equivalence",r4valuesets.conceptmapequivalence_decoder())
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConceptmapGroupElementTarget(depends_on:,comment:,equivalence:,display:,code:,modifier_extension:,extension:,id:,))}
pub fn conceptmap_group_element_to_json(conceptmap_group_element: ConceptmapGroupElement) -> Json {
    let ConceptmapGroupElement(target:,display:,code:,modifier_extension:,extension:,id:,) = conceptmap_group_element
    let fields = []
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,conceptmap_group_element_target_to_json)), ..fields]
                          }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_group_element_decoder() -> Decoder(ConceptmapGroupElement) {use target <- decode.optional_field("target", [], decode.list(conceptmap_group_element_target_decoder()))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConceptmapGroupElement(target:,display:,code:,modifier_extension:,extension:,id:,))}
pub fn conceptmap_group_to_json(conceptmap_group: ConceptmapGroup) -> Json {
    let ConceptmapGroup(unmapped:,element:,target_version:,target:,source_version:,source:,modifier_extension:,extension:,id:,) = conceptmap_group
    let fields = []
let fields = case unmapped {
                          Some(v) -> [#("unmapped", conceptmap_group_unmapped_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case element {
                        [] -> fields
                        _ -> [#("element", json.array(element,conceptmap_group_element_to_json)), ..fields]
                          }
let fields = case target_version {
                          Some(v) -> [#("targetVersion", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                          Some(v) -> [#("target", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source_version {
                          Some(v) -> [#("sourceVersion", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_group_decoder() -> Decoder(ConceptmapGroup) {use unmapped <- decode.optional_field("unmapped", None, decode.optional(conceptmap_group_unmapped_decoder()))
use element <- decode.optional_field("element", [], decode.list(conceptmap_group_element_decoder()))
use target_version <- decode.optional_field("targetVersion", None, decode.optional(decode.string))
use target <- decode.optional_field("target", None, decode.optional(decode.string))
use source_version <- decode.optional_field("sourceVersion", None, decode.optional(decode.string))
use source <- decode.optional_field("source", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConceptmapGroup(unmapped:,element:,target_version:,target:,source_version:,source:,modifier_extension:,extension:,id:,))}
pub fn conceptmap_to_json(conceptmap: Conceptmap) -> Json {
    let Conceptmap(group:,target:,source:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = conceptmap
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case group {
                        [] -> fields
                        _ -> [#("group", json.array(group,conceptmap_group_to_json)), ..fields]
                          }
let fields = case target {
                          Some(v) -> [#("target", conceptmap_target_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", conceptmap_source_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn conceptmap_decoder() -> Decoder(Conceptmap) {use group <- decode.optional_field("group", [], decode.list(conceptmap_group_decoder()))
use target <- decode.then(none_if_omitted(conceptmap_target_decoder()))
use source <- decode.then(none_if_omitted(conceptmap_source_decoder()))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Conceptmap(group:,target:,source:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Condition#resource
pub type Condition
{
Condition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
clinical_status: Option(Codeableconcept),
verification_status: Option(Codeableconcept),
category: List(Codeableconcept),
severity: Option(Codeableconcept),
code: Option(Codeableconcept),
body_site: List(Codeableconcept),
subject: Reference,
encounter: Option(Reference),
onset: Option(ConditionOnset),
abatement: Option(ConditionAbatement),
recorded_date: Option(String),
recorder: Option(Reference),
asserter: Option(Reference),
stage: List(ConditionStage),
evidence: List(ConditionEvidence),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Condition#resource
pub type ConditionOnset{
ConditionOnsetDatetime(onset: String)
ConditionOnsetAge(onset: Age)
ConditionOnsetPeriod(onset: Period)
ConditionOnsetRange(onset: Range)
ConditionOnsetString(onset: String)}
pub fn condition_onset_to_json(elt: ConditionOnset) -> Json {case elt{ConditionOnsetDatetime(v) -> json.string(v)
ConditionOnsetAge(v) -> age_to_json(v)
ConditionOnsetPeriod(v) -> period_to_json(v)
ConditionOnsetRange(v) -> range_to_json(v)
ConditionOnsetString(v) -> json.string(v)
}}
pub fn condition_onset_decoder() -> Decoder(ConditionOnset){decode.one_of(decode.field("onsetDateTime", decode.string, decode.success) |> decode.map(ConditionOnsetDatetime),[decode.field("onsetAge", age_decoder(), decode.success) |> decode.map(ConditionOnsetAge),decode.field("onsetPeriod", period_decoder(), decode.success) |> decode.map(ConditionOnsetPeriod),decode.field("onsetRange", range_decoder(), decode.success) |> decode.map(ConditionOnsetRange),decode.field("onsetString", decode.string, decode.success) |> decode.map(ConditionOnsetString),])}

///http://hl7.org/fhir/r4/StructureDefinition/Condition#resource
pub type ConditionAbatement{
ConditionAbatementDatetime(abatement: String)
ConditionAbatementAge(abatement: Age)
ConditionAbatementPeriod(abatement: Period)
ConditionAbatementRange(abatement: Range)
ConditionAbatementString(abatement: String)}
pub fn condition_abatement_to_json(elt: ConditionAbatement) -> Json {case elt{ConditionAbatementDatetime(v) -> json.string(v)
ConditionAbatementAge(v) -> age_to_json(v)
ConditionAbatementPeriod(v) -> period_to_json(v)
ConditionAbatementRange(v) -> range_to_json(v)
ConditionAbatementString(v) -> json.string(v)
}}
pub fn condition_abatement_decoder() -> Decoder(ConditionAbatement){decode.one_of(decode.field("abatementDateTime", decode.string, decode.success) |> decode.map(ConditionAbatementDatetime),[decode.field("abatementAge", age_decoder(), decode.success) |> decode.map(ConditionAbatementAge),decode.field("abatementPeriod", period_decoder(), decode.success) |> decode.map(ConditionAbatementPeriod),decode.field("abatementRange", range_decoder(), decode.success) |> decode.map(ConditionAbatementRange),decode.field("abatementString", decode.string, decode.success) |> decode.map(ConditionAbatementString),])}
pub fn condition_new(subject subject: Reference,) ->Condition{Condition(note: [],evidence: [],stage: [],asserter: None,recorder: None,recorded_date: None,abatement: None,onset: None,encounter: None,subject:,body_site: [],code: None,severity: None,category: [],verification_status: None,clinical_status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Condition#resource
pub type ConditionStage
{
ConditionStage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
summary: Option(Codeableconcept),
assessment: List(Reference),
type_: Option(Codeableconcept),
)
}

pub fn condition_stage_new() ->ConditionStage{ConditionStage(type_: None,assessment: [],summary: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Condition#resource
pub type ConditionEvidence
{
ConditionEvidence(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: List(Codeableconcept),
detail: List(Reference),
)
}

pub fn condition_evidence_new() ->ConditionEvidence{ConditionEvidence(detail: [],code: [],modifier_extension: [],extension: [],id: None,)
}

pub fn condition_evidence_to_json(condition_evidence: ConditionEvidence) -> Json {
    let ConditionEvidence(detail:,code:,modifier_extension:,extension:,id:,) = condition_evidence
    let fields = []
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,reference_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn condition_evidence_decoder() -> Decoder(ConditionEvidence) {use detail <- decode.optional_field("detail", [], decode.list(reference_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConditionEvidence(detail:,code:,modifier_extension:,extension:,id:,))}
pub fn condition_stage_to_json(condition_stage: ConditionStage) -> Json {
    let ConditionStage(type_:,assessment:,summary:,modifier_extension:,extension:,id:,) = condition_stage
    let fields = []
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case assessment {
                        [] -> fields
                        _ -> [#("assessment", json.array(assessment,reference_to_json)), ..fields]
                          }
let fields = case summary {
                          Some(v) -> [#("summary", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn condition_stage_decoder() -> Decoder(ConditionStage) {use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use assessment <- decode.optional_field("assessment", [], decode.list(reference_decoder()))
use summary <- decode.optional_field("summary", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConditionStage(type_:,assessment:,summary:,modifier_extension:,extension:,id:,))}
pub fn condition_to_json(condition: Condition) -> Json {
    let Condition(note:,evidence:,stage:,asserter:,recorder:,recorded_date:,abatement:,onset:,encounter:,subject:,body_site:,code:,severity:,category:,verification_status:,clinical_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = condition
    let fields = [#("subject", reference_to_json(subject)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case evidence {
                        [] -> fields
                        _ -> [#("evidence", json.array(evidence,condition_evidence_to_json)), ..fields]
                          }
let fields = case stage {
                        [] -> fields
                        _ -> [#("stage", json.array(stage,condition_stage_to_json)), ..fields]
                          }
let fields = case asserter {
                          Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorder {
                          Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorded_date {
                          Some(v) -> [#("recordedDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case abatement {
                          Some(v) -> [#("abatement", condition_abatement_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case onset {
                          Some(v) -> [#("onset", condition_onset_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                        [] -> fields
                        _ -> [#("bodySite", json.array(body_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case severity {
                          Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case verification_status {
                          Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case clinical_status {
                          Some(v) -> [#("clinicalStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn condition_decoder() -> Decoder(Condition) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use evidence <- decode.optional_field("evidence", [], decode.list(condition_evidence_decoder()))
use stage <- decode.optional_field("stage", [], decode.list(condition_stage_decoder()))
use asserter <- decode.optional_field("asserter", None, decode.optional(reference_decoder()))
use recorder <- decode.optional_field("recorder", None, decode.optional(reference_decoder()))
use recorded_date <- decode.optional_field("recordedDate", None, decode.optional(decode.string))
use abatement <- decode.then(none_if_omitted(condition_abatement_decoder()))
use onset <- decode.then(none_if_omitted(condition_onset_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use body_site <- decode.optional_field("bodySite", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use severity <- decode.optional_field("severity", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use verification_status <- decode.optional_field("verificationStatus", None, decode.optional(codeableconcept_decoder()))
use clinical_status <- decode.optional_field("clinicalStatus", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Condition(note:,evidence:,stage:,asserter:,recorder:,recorded_date:,abatement:,onset:,encounter:,subject:,body_site:,code:,severity:,category:,verification_status:,clinical_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type Consent
{
Consent(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Consentstatecodes,
scope: Codeableconcept,
category: List(Codeableconcept),
patient: Option(Reference),
date_time: Option(String),
performer: List(Reference),
organization: List(Reference),
source: Option(ConsentSource),
policy: List(ConsentPolicy),
policy_rule: Option(Codeableconcept),
verification: List(ConsentVerification),
provision: Option(ConsentProvision),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentSource{
ConsentSourceAttachment(source: Attachment)
ConsentSourceReference(source: Reference)}
pub fn consent_source_to_json(elt: ConsentSource) -> Json {case elt{ConsentSourceAttachment(v) -> attachment_to_json(v)
ConsentSourceReference(v) -> reference_to_json(v)
}}
pub fn consent_source_decoder() -> Decoder(ConsentSource){decode.one_of(decode.field("sourceAttachment", attachment_decoder(), decode.success) |> decode.map(ConsentSourceAttachment),[decode.field("sourceReference", reference_decoder(), decode.success) |> decode.map(ConsentSourceReference),])}
pub fn consent_new(scope scope: Codeableconcept,status status: r4valuesets.Consentstatecodes,) ->Consent{Consent(provision: None,verification: [],policy_rule: None,policy: [],source: None,organization: [],performer: [],date_time: None,patient: None,category: [],scope:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentPolicy
{
ConsentPolicy(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
authority: Option(String),
uri: Option(String),
)
}

pub fn consent_policy_new() ->ConsentPolicy{ConsentPolicy(uri: None,authority: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentVerification
{
ConsentVerification(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
verified: Bool,
verified_with: Option(Reference),
verification_date: Option(String),
)
}

pub fn consent_verification_new(verified verified: Bool,) ->ConsentVerification{ConsentVerification(verification_date: None,verified_with: None,verified:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentProvision
{
ConsentProvision(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(r4valuesets.Consentprovisiontype),
period: Option(Period),
actor: List(ConsentProvisionActor),
action: List(Codeableconcept),
security_label: List(Coding),
purpose: List(Coding),
class: List(Coding),
code: List(Codeableconcept),
data_period: Option(Period),
data: List(ConsentProvisionData),
)
}

pub fn consent_provision_new() ->ConsentProvision{ConsentProvision(data: [],data_period: None,code: [],class: [],purpose: [],security_label: [],action: [],actor: [],period: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentProvisionActor
{
ConsentProvisionActor(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
role: Codeableconcept,
reference: Reference,
)
}

pub fn consent_provision_actor_new(reference reference: Reference,role role: Codeableconcept,) ->ConsentProvisionActor{ConsentProvisionActor(reference:,role:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Consent#resource
pub type ConsentProvisionData
{
ConsentProvisionData(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
meaning: r4valuesets.Consentdatameaning,
reference: Reference,
)
}

pub fn consent_provision_data_new(reference reference: Reference,meaning meaning: r4valuesets.Consentdatameaning,) ->ConsentProvisionData{ConsentProvisionData(reference:,meaning:,modifier_extension: [],extension: [],id: None,)
}

pub fn consent_provision_data_to_json(consent_provision_data: ConsentProvisionData) -> Json {
    let ConsentProvisionData(reference:,meaning:,modifier_extension:,extension:,id:,) = consent_provision_data
    let fields = [#("reference", reference_to_json(reference)),#("meaning", r4valuesets.consentdatameaning_to_json(meaning)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_provision_data_decoder() -> Decoder(ConsentProvisionData) {use reference <- decode.field("reference",reference_decoder())
use meaning <- decode.field("meaning",r4valuesets.consentdatameaning_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConsentProvisionData(reference:,meaning:,modifier_extension:,extension:,id:,))}
pub fn consent_provision_actor_to_json(consent_provision_actor: ConsentProvisionActor) -> Json {
    let ConsentProvisionActor(reference:,role:,modifier_extension:,extension:,id:,) = consent_provision_actor
    let fields = [#("reference", reference_to_json(reference)),#("role", codeableconcept_to_json(role)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_provision_actor_decoder() -> Decoder(ConsentProvisionActor) {use reference <- decode.field("reference",reference_decoder())
use role <- decode.field("role",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConsentProvisionActor(reference:,role:,modifier_extension:,extension:,id:,))}
pub fn consent_provision_to_json(consent_provision: ConsentProvision) -> Json {
    let ConsentProvision(data:,data_period:,code:,class:,purpose:,security_label:,action:,actor:,period:,type_:,modifier_extension:,extension:,id:,) = consent_provision
    let fields = []
let fields = case data {
                        [] -> fields
                        _ -> [#("data", json.array(data,consent_provision_data_to_json)), ..fields]
                          }
let fields = case data_period {
                          Some(v) -> [#("dataPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case class {
                        [] -> fields
                        _ -> [#("class", json.array(class,coding_to_json)), ..fields]
                          }
let fields = case purpose {
                        [] -> fields
                        _ -> [#("purpose", json.array(purpose,coding_to_json)), ..fields]
                          }
let fields = case security_label {
                        [] -> fields
                        _ -> [#("securityLabel", json.array(security_label,coding_to_json)), ..fields]
                          }
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,codeableconcept_to_json)), ..fields]
                          }
let fields = case actor {
                        [] -> fields
                        _ -> [#("actor", json.array(actor,consent_provision_actor_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.consentprovisiontype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_provision_decoder() -> Decoder(ConsentProvision) {use data <- decode.optional_field("data", [], decode.list(consent_provision_data_decoder()))
use data_period <- decode.optional_field("dataPeriod", None, decode.optional(period_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use class <- decode.optional_field("class", [], decode.list(coding_decoder()))
use purpose <- decode.optional_field("purpose", [], decode.list(coding_decoder()))
use security_label <- decode.optional_field("securityLabel", [], decode.list(coding_decoder()))
use action <- decode.optional_field("action", [], decode.list(codeableconcept_decoder()))
use actor <- decode.optional_field("actor", [], decode.list(consent_provision_actor_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.consentprovisiontype_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConsentProvision(data:,data_period:,code:,class:,purpose:,security_label:,action:,actor:,period:,type_:,modifier_extension:,extension:,id:,))}
pub fn consent_verification_to_json(consent_verification: ConsentVerification) -> Json {
    let ConsentVerification(verification_date:,verified_with:,verified:,modifier_extension:,extension:,id:,) = consent_verification
    let fields = [#("verified", json.bool(verified)),]
let fields = case verification_date {
                          Some(v) -> [#("verificationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case verified_with {
                          Some(v) -> [#("verifiedWith", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_verification_decoder() -> Decoder(ConsentVerification) {use verification_date <- decode.optional_field("verificationDate", None, decode.optional(decode.string))
use verified_with <- decode.optional_field("verifiedWith", None, decode.optional(reference_decoder()))
use verified <- decode.field("verified",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConsentVerification(verification_date:,verified_with:,verified:,modifier_extension:,extension:,id:,))}
pub fn consent_policy_to_json(consent_policy: ConsentPolicy) -> Json {
    let ConsentPolicy(uri:,authority:,modifier_extension:,extension:,id:,) = consent_policy
    let fields = []
let fields = case uri {
                          Some(v) -> [#("uri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case authority {
                          Some(v) -> [#("authority", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_policy_decoder() -> Decoder(ConsentPolicy) {use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
use authority <- decode.optional_field("authority", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ConsentPolicy(uri:,authority:,modifier_extension:,extension:,id:,))}
pub fn consent_to_json(consent: Consent) -> Json {
    let Consent(provision:,verification:,policy_rule:,policy:,source:,organization:,performer:,date_time:,patient:,category:,scope:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = consent
    let fields = [#("scope", codeableconcept_to_json(scope)),#("status", r4valuesets.consentstatecodes_to_json(status)),]
let fields = case provision {
                          Some(v) -> [#("provision", consent_provision_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case verification {
                        [] -> fields
                        _ -> [#("verification", json.array(verification,consent_verification_to_json)), ..fields]
                          }
let fields = case policy_rule {
                          Some(v) -> [#("policyRule", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case policy {
                        [] -> fields
                        _ -> [#("policy", json.array(policy,consent_policy_to_json)), ..fields]
                          }
let fields = case source {
                          Some(v) -> [#("source", consent_source_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organization {
                        [] -> fields
                        _ -> [#("organization", json.array(organization,reference_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,reference_to_json)), ..fields]
                          }
let fields = case date_time {
                          Some(v) -> [#("dateTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case patient {
                          Some(v) -> [#("patient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn consent_decoder() -> Decoder(Consent) {use provision <- decode.optional_field("provision", None, decode.optional(consent_provision_decoder()))
use verification <- decode.optional_field("verification", [], decode.list(consent_verification_decoder()))
use policy_rule <- decode.optional_field("policyRule", None, decode.optional(codeableconcept_decoder()))
use policy <- decode.optional_field("policy", [], decode.list(consent_policy_decoder()))
use source <- decode.then(none_if_omitted(consent_source_decoder()))
use organization <- decode.optional_field("organization", [], decode.list(reference_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(reference_decoder()))
use date_time <- decode.optional_field("dateTime", None, decode.optional(decode.string))
use patient <- decode.optional_field("patient", None, decode.optional(reference_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use scope <- decode.field("scope",codeableconcept_decoder())
use status <- decode.field("status",r4valuesets.consentstatecodes_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Consent(provision:,verification:,policy_rule:,policy:,source:,organization:,performer:,date_time:,patient:,category:,scope:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type Contract
{
Contract(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
url: Option(String),
version: Option(String),
status: Option(r4valuesets.Contractstatus),
legal_state: Option(Codeableconcept),
instantiates_canonical: Option(Reference),
instantiates_uri: Option(String),
content_derivative: Option(Codeableconcept),
issued: Option(String),
applies: Option(Period),
expiration_type: Option(Codeableconcept),
subject: List(Reference),
authority: List(Reference),
domain: List(Reference),
site: List(Reference),
name: Option(String),
title: Option(String),
subtitle: Option(String),
alias: List(String),
author: Option(Reference),
scope: Option(Codeableconcept),
topic: Option(ContractTopic),
type_: Option(Codeableconcept),
sub_type: List(Codeableconcept),
content_definition: Option(ContractContentdefinition),
term: List(ContractTerm),
supporting_info: List(Reference),
relevant_history: List(Reference),
signer: List(ContractSigner),
friendly: List(ContractFriendly),
legal: List(ContractLegal),
rule: List(ContractRule),
legally_binding: Option(ContractLegallybinding),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTopic{
ContractTopicCodeableconcept(topic: Codeableconcept)
ContractTopicReference(topic: Reference)}
pub fn contract_topic_to_json(elt: ContractTopic) -> Json {case elt{ContractTopicCodeableconcept(v) -> codeableconcept_to_json(v)
ContractTopicReference(v) -> reference_to_json(v)
}}
pub fn contract_topic_decoder() -> Decoder(ContractTopic){decode.one_of(decode.field("topicCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ContractTopicCodeableconcept),[decode.field("topicReference", reference_decoder(), decode.success) |> decode.map(ContractTopicReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractLegallybinding{
ContractLegallybindingAttachment(legally_binding: Attachment)
ContractLegallybindingReference(legally_binding: Reference)}
pub fn contract_legallybinding_to_json(elt: ContractLegallybinding) -> Json {case elt{ContractLegallybindingAttachment(v) -> attachment_to_json(v)
ContractLegallybindingReference(v) -> reference_to_json(v)
}}
pub fn contract_legallybinding_decoder() -> Decoder(ContractLegallybinding){decode.one_of(decode.field("legallyBindingAttachment", attachment_decoder(), decode.success) |> decode.map(ContractLegallybindingAttachment),[decode.field("legallyBindingReference", reference_decoder(), decode.success) |> decode.map(ContractLegallybindingReference),])}
pub fn contract_new() ->Contract{Contract(legally_binding: None,rule: [],legal: [],friendly: [],signer: [],relevant_history: [],supporting_info: [],term: [],content_definition: None,sub_type: [],type_: None,topic: None,scope: None,author: None,alias: [],subtitle: None,title: None,name: None,site: [],domain: [],authority: [],subject: [],expiration_type: None,applies: None,issued: None,content_derivative: None,instantiates_uri: None,instantiates_canonical: None,legal_state: None,status: None,version: None,url: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractContentdefinition
{
ContractContentdefinition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
sub_type: Option(Codeableconcept),
publisher: Option(Reference),
publication_date: Option(String),
publication_status: r4valuesets.Contractpublicationstatus,
copyright: Option(String),
)
}

pub fn contract_contentdefinition_new(publication_status publication_status: r4valuesets.Contractpublicationstatus,type_ type_: Codeableconcept,) ->ContractContentdefinition{ContractContentdefinition(copyright: None,publication_status:,publication_date: None,publisher: None,sub_type: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTerm
{
ContractTerm(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
issued: Option(String),
applies: Option(Period),
topic: Option(ContractTermTopic),
type_: Option(Codeableconcept),
sub_type: Option(Codeableconcept),
text: Option(String),
security_label: List(ContractTermSecuritylabel),
offer: ContractTermOffer,
asset: List(ContractTermAsset),
action: List(ContractTermAction),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermTopic{
ContractTermTopicCodeableconcept(topic: Codeableconcept)
ContractTermTopicReference(topic: Reference)}
pub fn contract_term_topic_to_json(elt: ContractTermTopic) -> Json {case elt{ContractTermTopicCodeableconcept(v) -> codeableconcept_to_json(v)
ContractTermTopicReference(v) -> reference_to_json(v)
}}
pub fn contract_term_topic_decoder() -> Decoder(ContractTermTopic){decode.one_of(decode.field("topicCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ContractTermTopicCodeableconcept),[decode.field("topicReference", reference_decoder(), decode.success) |> decode.map(ContractTermTopicReference),])}
pub fn contract_term_new(offer offer: ContractTermOffer,) ->ContractTerm{ContractTerm(action: [],asset: [],offer:,security_label: [],text: None,sub_type: None,type_: None,topic: None,applies: None,issued: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermSecuritylabel
{
ContractTermSecuritylabel(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
number: List(Int),
classification: Coding,
category: List(Coding),
control: List(Coding),
)
}

pub fn contract_term_securitylabel_new(classification classification: Coding,) ->ContractTermSecuritylabel{ContractTermSecuritylabel(control: [],category: [],classification:,number: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermOffer
{
ContractTermOffer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
party: List(ContractTermOfferParty),
topic: Option(Reference),
type_: Option(Codeableconcept),
decision: Option(Codeableconcept),
decision_mode: List(Codeableconcept),
answer: List(ContractTermOfferAnswer),
text: Option(String),
link_id: List(String),
security_label_number: List(Int),
)
}

pub fn contract_term_offer_new() ->ContractTermOffer{ContractTermOffer(security_label_number: [],link_id: [],text: None,answer: [],decision_mode: [],decision: None,type_: None,topic: None,party: [],identifier: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermOfferParty
{
ContractTermOfferParty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
reference: List(Reference),
role: Codeableconcept,
)
}

pub fn contract_term_offer_party_new(role role: Codeableconcept,) ->ContractTermOfferParty{ContractTermOfferParty(role:,reference: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswer
{
ContractTermOfferAnswer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: ContractTermOfferAnswerValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswerValue{
ContractTermOfferAnswerValueBoolean(value: Bool)
ContractTermOfferAnswerValueDecimal(value: Float)
ContractTermOfferAnswerValueInteger(value: Int)
ContractTermOfferAnswerValueDate(value: String)
ContractTermOfferAnswerValueDatetime(value: String)
ContractTermOfferAnswerValueTime(value: String)
ContractTermOfferAnswerValueString(value: String)
ContractTermOfferAnswerValueUri(value: String)
ContractTermOfferAnswerValueAttachment(value: Attachment)
ContractTermOfferAnswerValueCoding(value: Coding)
ContractTermOfferAnswerValueQuantity(value: Quantity)
ContractTermOfferAnswerValueReference(value: Reference)}
pub fn contract_term_offer_answer_value_to_json(elt: ContractTermOfferAnswerValue) -> Json {case elt{ContractTermOfferAnswerValueBoolean(v) -> json.bool(v)
ContractTermOfferAnswerValueDecimal(v) -> json.float(v)
ContractTermOfferAnswerValueInteger(v) -> json.int(v)
ContractTermOfferAnswerValueDate(v) -> json.string(v)
ContractTermOfferAnswerValueDatetime(v) -> json.string(v)
ContractTermOfferAnswerValueTime(v) -> json.string(v)
ContractTermOfferAnswerValueString(v) -> json.string(v)
ContractTermOfferAnswerValueUri(v) -> json.string(v)
ContractTermOfferAnswerValueAttachment(v) -> attachment_to_json(v)
ContractTermOfferAnswerValueCoding(v) -> coding_to_json(v)
ContractTermOfferAnswerValueQuantity(v) -> quantity_to_json(v)
ContractTermOfferAnswerValueReference(v) -> reference_to_json(v)
}}
pub fn contract_term_offer_answer_value_decoder() -> Decoder(ContractTermOfferAnswerValue){decode.one_of(decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ContractTermOfferAnswerValueBoolean),[decode.field("valueDecimal", decode.float, decode.success) |> decode.map(ContractTermOfferAnswerValueDecimal),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ContractTermOfferAnswerValueInteger),decode.field("valueDate", decode.string, decode.success) |> decode.map(ContractTermOfferAnswerValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ContractTermOfferAnswerValueDatetime),decode.field("valueTime", decode.string, decode.success) |> decode.map(ContractTermOfferAnswerValueTime),decode.field("valueString", decode.string, decode.success) |> decode.map(ContractTermOfferAnswerValueString),decode.field("valueUri", decode.string, decode.success) |> decode.map(ContractTermOfferAnswerValueUri),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(ContractTermOfferAnswerValueAttachment),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(ContractTermOfferAnswerValueCoding),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ContractTermOfferAnswerValueQuantity),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(ContractTermOfferAnswerValueReference),])}
pub fn contract_term_offer_answer_new(value value: ContractTermOfferAnswerValue,) ->ContractTermOfferAnswer{ContractTermOfferAnswer(value:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermAsset
{
ContractTermAsset(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
scope: Option(Codeableconcept),
type_: List(Codeableconcept),
type_reference: List(Reference),
subtype: List(Codeableconcept),
relationship: Option(Coding),
context: List(ContractTermAssetContext),
condition: Option(String),
period_type: List(Codeableconcept),
period: List(Period),
use_period: List(Period),
text: Option(String),
link_id: List(String),
security_label_number: List(Int),
valued_item: List(ContractTermAssetValueditem),
)
}

pub fn contract_term_asset_new() ->ContractTermAsset{ContractTermAsset(valued_item: [],security_label_number: [],link_id: [],text: None,use_period: [],period: [],period_type: [],condition: None,context: [],relationship: None,subtype: [],type_reference: [],type_: [],scope: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermAssetContext
{
ContractTermAssetContext(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
reference: Option(Reference),
code: List(Codeableconcept),
text: Option(String),
)
}

pub fn contract_term_asset_context_new() ->ContractTermAssetContext{ContractTermAssetContext(text: None,code: [],reference: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditem
{
ContractTermAssetValueditem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
entity: Option(ContractTermAssetValueditemEntity),
identifier: Option(Identifier),
effective_time: Option(String),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
points: Option(Float),
net: Option(Money),
payment: Option(String),
payment_date: Option(String),
responsible: Option(Reference),
recipient: Option(Reference),
link_id: List(String),
security_label_number: List(Int),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditemEntity{
ContractTermAssetValueditemEntityCodeableconcept(entity: Codeableconcept)
ContractTermAssetValueditemEntityReference(entity: Reference)}
pub fn contract_term_asset_valueditem_entity_to_json(elt: ContractTermAssetValueditemEntity) -> Json {case elt{ContractTermAssetValueditemEntityCodeableconcept(v) -> codeableconcept_to_json(v)
ContractTermAssetValueditemEntityReference(v) -> reference_to_json(v)
}}
pub fn contract_term_asset_valueditem_entity_decoder() -> Decoder(ContractTermAssetValueditemEntity){decode.one_of(decode.field("entityCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ContractTermAssetValueditemEntityCodeableconcept),[decode.field("entityReference", reference_decoder(), decode.success) |> decode.map(ContractTermAssetValueditemEntityReference),])}
pub fn contract_term_asset_valueditem_new() ->ContractTermAssetValueditem{ContractTermAssetValueditem(security_label_number: [],link_id: [],recipient: None,responsible: None,payment_date: None,payment: None,net: None,points: None,factor: None,unit_price: None,quantity: None,effective_time: None,identifier: None,entity: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermAction
{
ContractTermAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
do_not_perform: Option(Bool),
type_: Codeableconcept,
subject: List(ContractTermActionSubject),
intent: Codeableconcept,
link_id: List(String),
status: Codeableconcept,
context: Option(Reference),
context_link_id: List(String),
occurrence: Option(ContractTermActionOccurrence),
requester: List(Reference),
requester_link_id: List(String),
performer_type: List(Codeableconcept),
performer_role: Option(Codeableconcept),
performer: Option(Reference),
performer_link_id: List(String),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
reason: List(String),
reason_link_id: List(String),
note: List(Annotation),
security_label_number: List(Int),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermActionOccurrence{
ContractTermActionOccurrenceDatetime(occurrence: String)
ContractTermActionOccurrencePeriod(occurrence: Period)
ContractTermActionOccurrenceTiming(occurrence: Timing)}
pub fn contract_term_action_occurrence_to_json(elt: ContractTermActionOccurrence) -> Json {case elt{ContractTermActionOccurrenceDatetime(v) -> json.string(v)
ContractTermActionOccurrencePeriod(v) -> period_to_json(v)
ContractTermActionOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn contract_term_action_occurrence_decoder() -> Decoder(ContractTermActionOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(ContractTermActionOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(ContractTermActionOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(ContractTermActionOccurrenceTiming),])}
pub fn contract_term_action_new(status status: Codeableconcept,intent intent: Codeableconcept,type_ type_: Codeableconcept,) ->ContractTermAction{ContractTermAction(security_label_number: [],note: [],reason_link_id: [],reason: [],reason_reference: [],reason_code: [],performer_link_id: [],performer: None,performer_role: None,performer_type: [],requester_link_id: [],requester: [],occurrence: None,context_link_id: [],context: None,status:,link_id: [],intent:,subject: [],type_:,do_not_perform: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractTermActionSubject
{
ContractTermActionSubject(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
reference: List(Reference),
role: Option(Codeableconcept),
)
}

pub fn contract_term_action_subject_new() ->ContractTermActionSubject{ContractTermActionSubject(role: None,reference: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractSigner
{
ContractSigner(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Coding,
party: Reference,
signature: List(Signature),
)
}

pub fn contract_signer_new(party party: Reference,type_ type_: Coding,) ->ContractSigner{ContractSigner(signature: [],party:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractFriendly
{
ContractFriendly(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
content: ContractFriendlyContent,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractFriendlyContent{
ContractFriendlyContentAttachment(content: Attachment)
ContractFriendlyContentReference(content: Reference)}
pub fn contract_friendly_content_to_json(elt: ContractFriendlyContent) -> Json {case elt{ContractFriendlyContentAttachment(v) -> attachment_to_json(v)
ContractFriendlyContentReference(v) -> reference_to_json(v)
}}
pub fn contract_friendly_content_decoder() -> Decoder(ContractFriendlyContent){decode.one_of(decode.field("contentAttachment", attachment_decoder(), decode.success) |> decode.map(ContractFriendlyContentAttachment),[decode.field("contentReference", reference_decoder(), decode.success) |> decode.map(ContractFriendlyContentReference),])}
pub fn contract_friendly_new(content content: ContractFriendlyContent,) ->ContractFriendly{ContractFriendly(content:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractLegal
{
ContractLegal(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
content: ContractLegalContent,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractLegalContent{
ContractLegalContentAttachment(content: Attachment)
ContractLegalContentReference(content: Reference)}
pub fn contract_legal_content_to_json(elt: ContractLegalContent) -> Json {case elt{ContractLegalContentAttachment(v) -> attachment_to_json(v)
ContractLegalContentReference(v) -> reference_to_json(v)
}}
pub fn contract_legal_content_decoder() -> Decoder(ContractLegalContent){decode.one_of(decode.field("contentAttachment", attachment_decoder(), decode.success) |> decode.map(ContractLegalContentAttachment),[decode.field("contentReference", reference_decoder(), decode.success) |> decode.map(ContractLegalContentReference),])}
pub fn contract_legal_new(content content: ContractLegalContent,) ->ContractLegal{ContractLegal(content:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractRule
{
ContractRule(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
content: ContractRuleContent,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Contract#resource
pub type ContractRuleContent{
ContractRuleContentAttachment(content: Attachment)
ContractRuleContentReference(content: Reference)}
pub fn contract_rule_content_to_json(elt: ContractRuleContent) -> Json {case elt{ContractRuleContentAttachment(v) -> attachment_to_json(v)
ContractRuleContentReference(v) -> reference_to_json(v)
}}
pub fn contract_rule_content_decoder() -> Decoder(ContractRuleContent){decode.one_of(decode.field("contentAttachment", attachment_decoder(), decode.success) |> decode.map(ContractRuleContentAttachment),[decode.field("contentReference", reference_decoder(), decode.success) |> decode.map(ContractRuleContentReference),])}
pub fn contract_rule_new(content content: ContractRuleContent,) ->ContractRule{ContractRule(content:,modifier_extension: [],extension: [],id: None,)
}

pub fn contract_rule_to_json(contract_rule: ContractRule) -> Json {
    let ContractRule(content:,modifier_extension:,extension:,id:,) = contract_rule
    let fields = [#("content", contract_rule_content_to_json(content)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_rule_decoder() -> Decoder(ContractRule) {use content <- decode.then(contract_rule_content_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractRule(content:,modifier_extension:,extension:,id:,))}
pub fn contract_legal_to_json(contract_legal: ContractLegal) -> Json {
    let ContractLegal(content:,modifier_extension:,extension:,id:,) = contract_legal
    let fields = [#("content", contract_legal_content_to_json(content)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_legal_decoder() -> Decoder(ContractLegal) {use content <- decode.then(contract_legal_content_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractLegal(content:,modifier_extension:,extension:,id:,))}
pub fn contract_friendly_to_json(contract_friendly: ContractFriendly) -> Json {
    let ContractFriendly(content:,modifier_extension:,extension:,id:,) = contract_friendly
    let fields = [#("content", contract_friendly_content_to_json(content)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_friendly_decoder() -> Decoder(ContractFriendly) {use content <- decode.then(contract_friendly_content_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractFriendly(content:,modifier_extension:,extension:,id:,))}
pub fn contract_signer_to_json(contract_signer: ContractSigner) -> Json {
    let ContractSigner(signature:,party:,type_:,modifier_extension:,extension:,id:,) = contract_signer
    let fields = [#("party", reference_to_json(party)),#("type", coding_to_json(type_)),]
let fields = case signature {
                        [] -> fields
                        _ -> [#("signature", json.array(signature,signature_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_signer_decoder() -> Decoder(ContractSigner) {use signature <- decode.optional_field("signature", [], decode.list(signature_decoder()))
use party <- decode.field("party",reference_decoder())
use type_ <- decode.field("type",coding_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractSigner(signature:,party:,type_:,modifier_extension:,extension:,id:,))}
pub fn contract_term_action_subject_to_json(contract_term_action_subject: ContractTermActionSubject) -> Json {
    let ContractTermActionSubject(role:,reference:,modifier_extension:,extension:,id:,) = contract_term_action_subject
    let fields = []
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reference {
                        [] -> fields
                        _ -> [#("reference", json.array(reference,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_action_subject_decoder() -> Decoder(ContractTermActionSubject) {use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use reference <- decode.optional_field("reference", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermActionSubject(role:,reference:,modifier_extension:,extension:,id:,))}
pub fn contract_term_action_to_json(contract_term_action: ContractTermAction) -> Json {
    let ContractTermAction(security_label_number:,note:,reason_link_id:,reason:,reason_reference:,reason_code:,performer_link_id:,performer:,performer_role:,performer_type:,requester_link_id:,requester:,occurrence:,context_link_id:,context:,status:,link_id:,intent:,subject:,type_:,do_not_perform:,modifier_extension:,extension:,id:,) = contract_term_action
    let fields = [#("status", codeableconcept_to_json(status)),#("intent", codeableconcept_to_json(intent)),#("type", codeableconcept_to_json(type_)),]
let fields = case security_label_number {
                        [] -> fields
                        _ -> [#("securityLabelNumber", json.array(security_label_number,json.int)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_link_id {
                        [] -> fields
                        _ -> [#("reasonLinkId", json.array(reason_link_id,json.string)), ..fields]
                          }
let fields = case reason {
                        [] -> fields
                        _ -> [#("reason", json.array(reason,json.string)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer_link_id {
                        [] -> fields
                        _ -> [#("performerLinkId", json.array(performer_link_id,json.string)), ..fields]
                          }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer_role {
                          Some(v) -> [#("performerRole", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer_type {
                        [] -> fields
                        _ -> [#("performerType", json.array(performer_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case requester_link_id {
                        [] -> fields
                        _ -> [#("requesterLinkId", json.array(requester_link_id,json.string)), ..fields]
                          }
let fields = case requester {
                        [] -> fields
                        _ -> [#("requester", json.array(requester,reference_to_json)), ..fields]
                          }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", contract_term_action_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case context_link_id {
                        [] -> fields
                        _ -> [#("contextLinkId", json.array(context_link_id,json.string)), ..fields]
                          }
let fields = case context {
                          Some(v) -> [#("context", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case link_id {
                        [] -> fields
                        _ -> [#("linkId", json.array(link_id,json.string)), ..fields]
                          }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,contract_term_action_subject_to_json)), ..fields]
                          }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_action_decoder() -> Decoder(ContractTermAction) {use security_label_number <- decode.optional_field("securityLabelNumber", [], decode.list(decode.int))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_link_id <- decode.optional_field("reasonLinkId", [], decode.list(decode.string))
use reason <- decode.optional_field("reason", [], decode.list(decode.string))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use performer_link_id <- decode.optional_field("performerLinkId", [], decode.list(decode.string))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use performer_role <- decode.optional_field("performerRole", None, decode.optional(codeableconcept_decoder()))
use performer_type <- decode.optional_field("performerType", [], decode.list(codeableconcept_decoder()))
use requester_link_id <- decode.optional_field("requesterLinkId", [], decode.list(decode.string))
use requester <- decode.optional_field("requester", [], decode.list(reference_decoder()))
use occurrence <- decode.then(none_if_omitted(contract_term_action_occurrence_decoder()))
use context_link_id <- decode.optional_field("contextLinkId", [], decode.list(decode.string))
use context <- decode.optional_field("context", None, decode.optional(reference_decoder()))
use status <- decode.field("status",codeableconcept_decoder())
use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
use intent <- decode.field("intent",codeableconcept_decoder())
use subject <- decode.optional_field("subject", [], decode.list(contract_term_action_subject_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermAction(security_label_number:,note:,reason_link_id:,reason:,reason_reference:,reason_code:,performer_link_id:,performer:,performer_role:,performer_type:,requester_link_id:,requester:,occurrence:,context_link_id:,context:,status:,link_id:,intent:,subject:,type_:,do_not_perform:,modifier_extension:,extension:,id:,))}
pub fn contract_term_asset_valueditem_to_json(contract_term_asset_valueditem: ContractTermAssetValueditem) -> Json {
    let ContractTermAssetValueditem(security_label_number:,link_id:,recipient:,responsible:,payment_date:,payment:,net:,points:,factor:,unit_price:,quantity:,effective_time:,identifier:,entity:,modifier_extension:,extension:,id:,) = contract_term_asset_valueditem
    let fields = []
let fields = case security_label_number {
                        [] -> fields
                        _ -> [#("securityLabelNumber", json.array(security_label_number,json.int)), ..fields]
                          }
let fields = case link_id {
                        [] -> fields
                        _ -> [#("linkId", json.array(link_id,json.string)), ..fields]
                          }
let fields = case recipient {
                          Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payment_date {
                          Some(v) -> [#("paymentDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case payment {
                          Some(v) -> [#("payment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case points {
                          Some(v) -> [#("points", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case effective_time {
                          Some(v) -> [#("effectiveTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case entity {
                          Some(v) -> [#("entity", contract_term_asset_valueditem_entity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_asset_valueditem_decoder() -> Decoder(ContractTermAssetValueditem) {use security_label_number <- decode.optional_field("securityLabelNumber", [], decode.list(decode.int))
use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
use recipient <- decode.optional_field("recipient", None, decode.optional(reference_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(reference_decoder()))
use payment_date <- decode.optional_field("paymentDate", None, decode.optional(decode.string))
use payment <- decode.optional_field("payment", None, decode.optional(decode.string))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use points <- decode.optional_field("points", None, decode.optional(decode.float))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use effective_time <- decode.optional_field("effectiveTime", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use entity <- decode.then(none_if_omitted(contract_term_asset_valueditem_entity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermAssetValueditem(security_label_number:,link_id:,recipient:,responsible:,payment_date:,payment:,net:,points:,factor:,unit_price:,quantity:,effective_time:,identifier:,entity:,modifier_extension:,extension:,id:,))}
pub fn contract_term_asset_context_to_json(contract_term_asset_context: ContractTermAssetContext) -> Json {
    let ContractTermAssetContext(text:,code:,reference:,modifier_extension:,extension:,id:,) = contract_term_asset_context
    let fields = []
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case reference {
                          Some(v) -> [#("reference", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_asset_context_decoder() -> Decoder(ContractTermAssetContext) {use text <- decode.optional_field("text", None, decode.optional(decode.string))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use reference <- decode.optional_field("reference", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermAssetContext(text:,code:,reference:,modifier_extension:,extension:,id:,))}
pub fn contract_term_asset_to_json(contract_term_asset: ContractTermAsset) -> Json {
    let ContractTermAsset(valued_item:,security_label_number:,link_id:,text:,use_period:,period:,period_type:,condition:,context:,relationship:,subtype:,type_reference:,type_:,scope:,modifier_extension:,extension:,id:,) = contract_term_asset
    let fields = []
let fields = case valued_item {
                        [] -> fields
                        _ -> [#("valuedItem", json.array(valued_item,contract_term_asset_valueditem_to_json)), ..fields]
                          }
let fields = case security_label_number {
                        [] -> fields
                        _ -> [#("securityLabelNumber", json.array(security_label_number,json.int)), ..fields]
                          }
let fields = case link_id {
                        [] -> fields
                        _ -> [#("linkId", json.array(link_id,json.string)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case use_period {
                        [] -> fields
                        _ -> [#("usePeriod", json.array(use_period,period_to_json)), ..fields]
                          }
let fields = case period {
                        [] -> fields
                        _ -> [#("period", json.array(period,period_to_json)), ..fields]
                          }
let fields = case period_type {
                        [] -> fields
                        _ -> [#("periodType", json.array(period_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case condition {
                          Some(v) -> [#("condition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case context {
                        [] -> fields
                        _ -> [#("context", json.array(context,contract_term_asset_context_to_json)), ..fields]
                          }
let fields = case relationship {
                          Some(v) -> [#("relationship", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subtype {
                        [] -> fields
                        _ -> [#("subtype", json.array(subtype,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_reference {
                        [] -> fields
                        _ -> [#("typeReference", json.array(type_reference,reference_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case scope {
                          Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_asset_decoder() -> Decoder(ContractTermAsset) {use valued_item <- decode.optional_field("valuedItem", [], decode.list(contract_term_asset_valueditem_decoder()))
use security_label_number <- decode.optional_field("securityLabelNumber", [], decode.list(decode.int))
use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use use_period <- decode.optional_field("usePeriod", [], decode.list(period_decoder()))
use period <- decode.optional_field("period", [], decode.list(period_decoder()))
use period_type <- decode.optional_field("periodType", [], decode.list(codeableconcept_decoder()))
use condition <- decode.optional_field("condition", None, decode.optional(decode.string))
use context <- decode.optional_field("context", [], decode.list(contract_term_asset_context_decoder()))
use relationship <- decode.optional_field("relationship", None, decode.optional(coding_decoder()))
use subtype <- decode.optional_field("subtype", [], decode.list(codeableconcept_decoder()))
use type_reference <- decode.optional_field("typeReference", [], decode.list(reference_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use scope <- decode.optional_field("scope", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermAsset(valued_item:,security_label_number:,link_id:,text:,use_period:,period:,period_type:,condition:,context:,relationship:,subtype:,type_reference:,type_:,scope:,modifier_extension:,extension:,id:,))}
pub fn contract_term_offer_answer_to_json(contract_term_offer_answer: ContractTermOfferAnswer) -> Json {
    let ContractTermOfferAnswer(value:,modifier_extension:,extension:,id:,) = contract_term_offer_answer
    let fields = [#("value", contract_term_offer_answer_value_to_json(value)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_offer_answer_decoder() -> Decoder(ContractTermOfferAnswer) {use value <- decode.then(contract_term_offer_answer_value_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermOfferAnswer(value:,modifier_extension:,extension:,id:,))}
pub fn contract_term_offer_party_to_json(contract_term_offer_party: ContractTermOfferParty) -> Json {
    let ContractTermOfferParty(role:,reference:,modifier_extension:,extension:,id:,) = contract_term_offer_party
    let fields = [#("role", codeableconcept_to_json(role)),]
let fields = case reference {
                        [] -> fields
                        _ -> [#("reference", json.array(reference,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_offer_party_decoder() -> Decoder(ContractTermOfferParty) {use role <- decode.field("role",codeableconcept_decoder())
use reference <- decode.optional_field("reference", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermOfferParty(role:,reference:,modifier_extension:,extension:,id:,))}
pub fn contract_term_offer_to_json(contract_term_offer: ContractTermOffer) -> Json {
    let ContractTermOffer(security_label_number:,link_id:,text:,answer:,decision_mode:,decision:,type_:,topic:,party:,identifier:,modifier_extension:,extension:,id:,) = contract_term_offer
    let fields = []
let fields = case security_label_number {
                        [] -> fields
                        _ -> [#("securityLabelNumber", json.array(security_label_number,json.int)), ..fields]
                          }
let fields = case link_id {
                        [] -> fields
                        _ -> [#("linkId", json.array(link_id,json.string)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case answer {
                        [] -> fields
                        _ -> [#("answer", json.array(answer,contract_term_offer_answer_to_json)), ..fields]
                          }
let fields = case decision_mode {
                        [] -> fields
                        _ -> [#("decisionMode", json.array(decision_mode,codeableconcept_to_json)), ..fields]
                          }
let fields = case decision {
                          Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case topic {
                          Some(v) -> [#("topic", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case party {
                        [] -> fields
                        _ -> [#("party", json.array(party,contract_term_offer_party_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_offer_decoder() -> Decoder(ContractTermOffer) {use security_label_number <- decode.optional_field("securityLabelNumber", [], decode.list(decode.int))
use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use answer <- decode.optional_field("answer", [], decode.list(contract_term_offer_answer_decoder()))
use decision_mode <- decode.optional_field("decisionMode", [], decode.list(codeableconcept_decoder()))
use decision <- decode.optional_field("decision", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use topic <- decode.optional_field("topic", None, decode.optional(reference_decoder()))
use party <- decode.optional_field("party", [], decode.list(contract_term_offer_party_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermOffer(security_label_number:,link_id:,text:,answer:,decision_mode:,decision:,type_:,topic:,party:,identifier:,modifier_extension:,extension:,id:,))}
pub fn contract_term_securitylabel_to_json(contract_term_securitylabel: ContractTermSecuritylabel) -> Json {
    let ContractTermSecuritylabel(control:,category:,classification:,number:,modifier_extension:,extension:,id:,) = contract_term_securitylabel
    let fields = [#("classification", coding_to_json(classification)),]
let fields = case control {
                        [] -> fields
                        _ -> [#("control", json.array(control,coding_to_json)), ..fields]
                          }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,coding_to_json)), ..fields]
                          }
let fields = case number {
                        [] -> fields
                        _ -> [#("number", json.array(number,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_securitylabel_decoder() -> Decoder(ContractTermSecuritylabel) {use control <- decode.optional_field("control", [], decode.list(coding_decoder()))
use category <- decode.optional_field("category", [], decode.list(coding_decoder()))
use classification <- decode.field("classification",coding_decoder())
use number <- decode.optional_field("number", [], decode.list(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTermSecuritylabel(control:,category:,classification:,number:,modifier_extension:,extension:,id:,))}
pub fn contract_term_to_json(contract_term: ContractTerm) -> Json {
    let ContractTerm(action:,asset:,offer:,security_label:,text:,sub_type:,type_:,topic:,applies:,issued:,identifier:,modifier_extension:,extension:,id:,) = contract_term
    let fields = [#("offer", contract_term_offer_to_json(offer)),]
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,contract_term_action_to_json)), ..fields]
                          }
let fields = case asset {
                        [] -> fields
                        _ -> [#("asset", json.array(asset,contract_term_asset_to_json)), ..fields]
                          }
let fields = case security_label {
                        [] -> fields
                        _ -> [#("securityLabel", json.array(security_label,contract_term_securitylabel_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                          Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case topic {
                          Some(v) -> [#("topic", contract_term_topic_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case applies {
                          Some(v) -> [#("applies", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_term_decoder() -> Decoder(ContractTerm) {use action <- decode.optional_field("action", [], decode.list(contract_term_action_decoder()))
use asset <- decode.optional_field("asset", [], decode.list(contract_term_asset_decoder()))
use offer <- decode.field("offer",contract_term_offer_decoder())
use security_label <- decode.optional_field("securityLabel", [], decode.list(contract_term_securitylabel_decoder()))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use sub_type <- decode.optional_field("subType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use topic <- decode.then(none_if_omitted(contract_term_topic_decoder()))
use applies <- decode.optional_field("applies", None, decode.optional(period_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractTerm(action:,asset:,offer:,security_label:,text:,sub_type:,type_:,topic:,applies:,issued:,identifier:,modifier_extension:,extension:,id:,))}
pub fn contract_contentdefinition_to_json(contract_contentdefinition: ContractContentdefinition) -> Json {
    let ContractContentdefinition(copyright:,publication_status:,publication_date:,publisher:,sub_type:,type_:,modifier_extension:,extension:,id:,) = contract_contentdefinition
    let fields = [#("publicationStatus", r4valuesets.contractpublicationstatus_to_json(publication_status)),#("type", codeableconcept_to_json(type_)),]
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case publication_date {
                          Some(v) -> [#("publicationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case publisher {
                          Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                          Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_contentdefinition_decoder() -> Decoder(ContractContentdefinition) {use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use publication_status <- decode.field("publicationStatus",r4valuesets.contractpublicationstatus_decoder())
use publication_date <- decode.optional_field("publicationDate", None, decode.optional(decode.string))
use publisher <- decode.optional_field("publisher", None, decode.optional(reference_decoder()))
use sub_type <- decode.optional_field("subType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ContractContentdefinition(copyright:,publication_status:,publication_date:,publisher:,sub_type:,type_:,modifier_extension:,extension:,id:,))}
pub fn contract_to_json(contract: Contract) -> Json {
    let Contract(legally_binding:,rule:,legal:,friendly:,signer:,relevant_history:,supporting_info:,term:,content_definition:,sub_type:,type_:,topic:,scope:,author:,alias:,subtitle:,title:,name:,site:,domain:,authority:,subject:,expiration_type:,applies:,issued:,content_derivative:,instantiates_uri:,instantiates_canonical:,legal_state:,status:,version:,url:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = contract
    let fields = []
let fields = case legally_binding {
                          Some(v) -> [#("legallyBinding", contract_legallybinding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case rule {
                        [] -> fields
                        _ -> [#("rule", json.array(rule,contract_rule_to_json)), ..fields]
                          }
let fields = case legal {
                        [] -> fields
                        _ -> [#("legal", json.array(legal,contract_legal_to_json)), ..fields]
                          }
let fields = case friendly {
                        [] -> fields
                        _ -> [#("friendly", json.array(friendly,contract_friendly_to_json)), ..fields]
                          }
let fields = case signer {
                        [] -> fields
                        _ -> [#("signer", json.array(signer,contract_signer_to_json)), ..fields]
                          }
let fields = case relevant_history {
                        [] -> fields
                        _ -> [#("relevantHistory", json.array(relevant_history,reference_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,reference_to_json)), ..fields]
                          }
let fields = case term {
                        [] -> fields
                        _ -> [#("term", json.array(term,contract_term_to_json)), ..fields]
                          }
let fields = case content_definition {
                          Some(v) -> [#("contentDefinition", contract_contentdefinition_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                        [] -> fields
                        _ -> [#("subType", json.array(sub_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case topic {
                          Some(v) -> [#("topic", contract_topic_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case scope {
                          Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case alias {
                        [] -> fields
                        _ -> [#("alias", json.array(alias,json.string)), ..fields]
                          }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case site {
                        [] -> fields
                        _ -> [#("site", json.array(site,reference_to_json)), ..fields]
                          }
let fields = case domain {
                        [] -> fields
                        _ -> [#("domain", json.array(domain,reference_to_json)), ..fields]
                          }
let fields = case authority {
                        [] -> fields
                        _ -> [#("authority", json.array(authority,reference_to_json)), ..fields]
                          }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case expiration_type {
                          Some(v) -> [#("expirationType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case applies {
                          Some(v) -> [#("applies", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case content_derivative {
                          Some(v) -> [#("contentDerivative", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates_uri {
                          Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates_canonical {
                          Some(v) -> [#("instantiatesCanonical", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case legal_state {
                          Some(v) -> [#("legalState", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.contractstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn contract_decoder() -> Decoder(Contract) {use legally_binding <- decode.then(none_if_omitted(contract_legallybinding_decoder()))
use rule <- decode.optional_field("rule", [], decode.list(contract_rule_decoder()))
use legal <- decode.optional_field("legal", [], decode.list(contract_legal_decoder()))
use friendly <- decode.optional_field("friendly", [], decode.list(contract_friendly_decoder()))
use signer <- decode.optional_field("signer", [], decode.list(contract_signer_decoder()))
use relevant_history <- decode.optional_field("relevantHistory", [], decode.list(reference_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(reference_decoder()))
use term <- decode.optional_field("term", [], decode.list(contract_term_decoder()))
use content_definition <- decode.optional_field("contentDefinition", None, decode.optional(contract_contentdefinition_decoder()))
use sub_type <- decode.optional_field("subType", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use topic <- decode.then(none_if_omitted(contract_topic_decoder()))
use scope <- decode.optional_field("scope", None, decode.optional(codeableconcept_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use alias <- decode.optional_field("alias", [], decode.list(decode.string))
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use site <- decode.optional_field("site", [], decode.list(reference_decoder()))
use domain <- decode.optional_field("domain", [], decode.list(reference_decoder()))
use authority <- decode.optional_field("authority", [], decode.list(reference_decoder()))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use expiration_type <- decode.optional_field("expirationType", None, decode.optional(codeableconcept_decoder()))
use applies <- decode.optional_field("applies", None, decode.optional(period_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use content_derivative <- decode.optional_field("contentDerivative", None, decode.optional(codeableconcept_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", None, decode.optional(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", None, decode.optional(reference_decoder()))
use legal_state <- decode.optional_field("legalState", None, decode.optional(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.contractstatus_decoder()))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Contract(legally_binding:,rule:,legal:,friendly:,signer:,relevant_history:,supporting_info:,term:,content_definition:,sub_type:,type_:,topic:,scope:,author:,alias:,subtitle:,title:,name:,site:,domain:,authority:,subject:,expiration_type:,applies:,issued:,content_derivative:,instantiates_uri:,instantiates_canonical:,legal_state:,status:,version:,url:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Coverage#resource
pub type Coverage
{
Coverage(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
type_: Option(Codeableconcept),
policy_holder: Option(Reference),
subscriber: Option(Reference),
subscriber_id: Option(String),
beneficiary: Reference,
dependent: Option(String),
relationship: Option(Codeableconcept),
period: Option(Period),
payor: List(Reference),
class: List(CoverageClass),
order: Option(Int),
network: Option(String),
cost_to_beneficiary: List(CoverageCosttobeneficiary),
subrogation: Option(Bool),
contract: List(Reference),
)
}

pub fn coverage_new(beneficiary beneficiary: Reference,status status: r4valuesets.Fmstatus,) ->Coverage{Coverage(contract: [],subrogation: None,cost_to_beneficiary: [],network: None,order: None,class: [],payor: [],period: None,relationship: None,dependent: None,beneficiary:,subscriber_id: None,subscriber: None,policy_holder: None,type_: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Coverage#resource
pub type CoverageClass
{
CoverageClass(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
value: String,
name: Option(String),
)
}

pub fn coverage_class_new(value value: String,type_ type_: Codeableconcept,) ->CoverageClass{CoverageClass(name: None,value:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiary
{
CoverageCosttobeneficiary(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
value: CoverageCosttobeneficiaryValue,
exception: List(CoverageCosttobeneficiaryException),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryValue{
CoverageCosttobeneficiaryValueQuantity(value: Quantity)
CoverageCosttobeneficiaryValueMoney(value: Money)}
pub fn coverage_costtobeneficiary_value_to_json(elt: CoverageCosttobeneficiaryValue) -> Json {case elt{CoverageCosttobeneficiaryValueQuantity(v) -> quantity_to_json(v)
CoverageCosttobeneficiaryValueMoney(v) -> money_to_json(v)
}}
pub fn coverage_costtobeneficiary_value_decoder() -> Decoder(CoverageCosttobeneficiaryValue){decode.one_of(decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(CoverageCosttobeneficiaryValueQuantity),[decode.field("valueMoney", money_decoder(), decode.success) |> decode.map(CoverageCosttobeneficiaryValueMoney),])}
pub fn coverage_costtobeneficiary_new(value value: CoverageCosttobeneficiaryValue,) ->CoverageCosttobeneficiary{CoverageCosttobeneficiary(exception: [],value:,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryException
{
CoverageCosttobeneficiaryException(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
period: Option(Period),
)
}

pub fn coverage_costtobeneficiary_exception_new(type_ type_: Codeableconcept,) ->CoverageCosttobeneficiaryException{CoverageCosttobeneficiaryException(period: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn coverage_costtobeneficiary_exception_to_json(coverage_costtobeneficiary_exception: CoverageCosttobeneficiaryException) -> Json {
    let CoverageCosttobeneficiaryException(period:,type_:,modifier_extension:,extension:,id:,) = coverage_costtobeneficiary_exception
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverage_costtobeneficiary_exception_decoder() -> Decoder(CoverageCosttobeneficiaryException) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageCosttobeneficiaryException(period:,type_:,modifier_extension:,extension:,id:,))}
pub fn coverage_costtobeneficiary_to_json(coverage_costtobeneficiary: CoverageCosttobeneficiary) -> Json {
    let CoverageCosttobeneficiary(exception:,value:,type_:,modifier_extension:,extension:,id:,) = coverage_costtobeneficiary
    let fields = [#("value", coverage_costtobeneficiary_value_to_json(value)),]
let fields = case exception {
                        [] -> fields
                        _ -> [#("exception", json.array(exception,coverage_costtobeneficiary_exception_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverage_costtobeneficiary_decoder() -> Decoder(CoverageCosttobeneficiary) {use exception <- decode.optional_field("exception", [], decode.list(coverage_costtobeneficiary_exception_decoder()))
use value <- decode.then(coverage_costtobeneficiary_value_decoder())
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageCosttobeneficiary(exception:,value:,type_:,modifier_extension:,extension:,id:,))}
pub fn coverage_class_to_json(coverage_class: CoverageClass) -> Json {
    let CoverageClass(name:,value:,type_:,modifier_extension:,extension:,id:,) = coverage_class
    let fields = [#("value", json.string(value)),#("type", codeableconcept_to_json(type_)),]
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverage_class_decoder() -> Decoder(CoverageClass) {use name <- decode.optional_field("name", None, decode.optional(decode.string))
use value <- decode.field("value",decode.string)
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageClass(name:,value:,type_:,modifier_extension:,extension:,id:,))}
pub fn coverage_to_json(coverage: Coverage) -> Json {
    let Coverage(contract:,subrogation:,cost_to_beneficiary:,network:,order:,class:,payor:,period:,relationship:,dependent:,beneficiary:,subscriber_id:,subscriber:,policy_holder:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = coverage
    let fields = [#("beneficiary", reference_to_json(beneficiary)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case contract {
                        [] -> fields
                        _ -> [#("contract", json.array(contract,reference_to_json)), ..fields]
                          }
let fields = case subrogation {
                          Some(v) -> [#("subrogation", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case cost_to_beneficiary {
                        [] -> fields
                        _ -> [#("costToBeneficiary", json.array(cost_to_beneficiary,coverage_costtobeneficiary_to_json)), ..fields]
                          }
let fields = case network {
                          Some(v) -> [#("network", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case order {
                          Some(v) -> [#("order", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case class {
                        [] -> fields
                        _ -> [#("class", json.array(class,coverage_class_to_json)), ..fields]
                          }
let fields = case payor {
                        [] -> fields
                        _ -> [#("payor", json.array(payor,reference_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                          Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dependent {
                          Some(v) -> [#("dependent", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subscriber_id {
                          Some(v) -> [#("subscriberId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subscriber {
                          Some(v) -> [#("subscriber", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case policy_holder {
                          Some(v) -> [#("policyHolder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverage_decoder() -> Decoder(Coverage) {use contract <- decode.optional_field("contract", [], decode.list(reference_decoder()))
use subrogation <- decode.optional_field("subrogation", None, decode.optional(decode.bool))
use cost_to_beneficiary <- decode.optional_field("costToBeneficiary", [], decode.list(coverage_costtobeneficiary_decoder()))
use network <- decode.optional_field("network", None, decode.optional(decode.string))
use order <- decode.optional_field("order", None, decode.optional(decode.int))
use class <- decode.optional_field("class", [], decode.list(coverage_class_decoder()))
use payor <- decode.optional_field("payor", [], decode.list(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use relationship <- decode.optional_field("relationship", None, decode.optional(codeableconcept_decoder()))
use dependent <- decode.optional_field("dependent", None, decode.optional(decode.string))
use beneficiary <- decode.field("beneficiary",reference_decoder())
use subscriber_id <- decode.optional_field("subscriberId", None, decode.optional(decode.string))
use subscriber <- decode.optional_field("subscriber", None, decode.optional(reference_decoder()))
use policy_holder <- decode.optional_field("policyHolder", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Coverage(contract:,subrogation:,cost_to_beneficiary:,network:,order:,class:,payor:,period:,relationship:,dependent:,beneficiary:,subscriber_id:,subscriber:,policy_holder:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type Coverageeligibilityrequest
{
Coverageeligibilityrequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
priority: Option(Codeableconcept),
purpose: List(r4valuesets.Eligibilityrequestpurpose),
patient: Reference,
serviced: Option(CoverageeligibilityrequestServiced),
created: String,
enterer: Option(Reference),
provider: Option(Reference),
insurer: Reference,
facility: Option(Reference),
supporting_info: List(CoverageeligibilityrequestSupportinginfo),
insurance: List(CoverageeligibilityrequestInsurance),
item: List(CoverageeligibilityrequestItem),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestServiced{
CoverageeligibilityrequestServicedDate(serviced: String)
CoverageeligibilityrequestServicedPeriod(serviced: Period)}
pub fn coverageeligibilityrequest_serviced_to_json(elt: CoverageeligibilityrequestServiced) -> Json {case elt{CoverageeligibilityrequestServicedDate(v) -> json.string(v)
CoverageeligibilityrequestServicedPeriod(v) -> period_to_json(v)
}}
pub fn coverageeligibilityrequest_serviced_decoder() -> Decoder(CoverageeligibilityrequestServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(CoverageeligibilityrequestServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(CoverageeligibilityrequestServicedPeriod),])}
pub fn coverageeligibilityrequest_new(insurer insurer: Reference,created created: String,patient patient: Reference,status status: r4valuesets.Fmstatus,) ->Coverageeligibilityrequest{Coverageeligibilityrequest(item: [],insurance: [],supporting_info: [],facility: None,insurer:,provider: None,enterer: None,created:,serviced: None,patient:,purpose: [],priority: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestSupportinginfo
{
CoverageeligibilityrequestSupportinginfo(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
information: Reference,
applies_to_all: Option(Bool),
)
}

pub fn coverageeligibilityrequest_supportinginfo_new(information information: Reference,sequence sequence: Int,) ->CoverageeligibilityrequestSupportinginfo{CoverageeligibilityrequestSupportinginfo(applies_to_all: None,information:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestInsurance
{
CoverageeligibilityrequestInsurance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
focal: Option(Bool),
coverage: Reference,
business_arrangement: Option(String),
)
}

pub fn coverageeligibilityrequest_insurance_new(coverage coverage: Reference,) ->CoverageeligibilityrequestInsurance{CoverageeligibilityrequestInsurance(business_arrangement: None,coverage:,focal: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItem
{
CoverageeligibilityrequestItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
supporting_info_sequence: List(Int),
category: Option(Codeableconcept),
product_or_service: Option(Codeableconcept),
modifier: List(Codeableconcept),
provider: Option(Reference),
quantity: Option(Quantity),
unit_price: Option(Money),
facility: Option(Reference),
diagnosis: List(CoverageeligibilityrequestItemDiagnosis),
detail: List(Reference),
)
}

pub fn coverageeligibilityrequest_item_new() ->CoverageeligibilityrequestItem{CoverageeligibilityrequestItem(detail: [],diagnosis: [],facility: None,unit_price: None,quantity: None,provider: None,modifier: [],product_or_service: None,category: None,supporting_info_sequence: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosis
{
CoverageeligibilityrequestItemDiagnosis(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
diagnosis: Option(CoverageeligibilityrequestItemDiagnosisDiagnosis),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosisDiagnosis{
CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(diagnosis: Codeableconcept)
CoverageeligibilityrequestItemDiagnosisDiagnosisReference(diagnosis: Reference)}
pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(elt: CoverageeligibilityrequestItemDiagnosisDiagnosis) -> Json {case elt{CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(v) -> codeableconcept_to_json(v)
CoverageeligibilityrequestItemDiagnosisDiagnosisReference(v) -> reference_to_json(v)
}}
pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_decoder() -> Decoder(CoverageeligibilityrequestItemDiagnosisDiagnosis){decode.one_of(decode.field("diagnosisCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept),[decode.field("diagnosisReference", reference_decoder(), decode.success) |> decode.map(CoverageeligibilityrequestItemDiagnosisDiagnosisReference),])}
pub fn coverageeligibilityrequest_item_diagnosis_new() ->CoverageeligibilityrequestItemDiagnosis{CoverageeligibilityrequestItemDiagnosis(diagnosis: None,modifier_extension: [],extension: [],id: None,)
}

pub fn coverageeligibilityrequest_item_diagnosis_to_json(coverageeligibilityrequest_item_diagnosis: CoverageeligibilityrequestItemDiagnosis) -> Json {
    let CoverageeligibilityrequestItemDiagnosis(diagnosis:,modifier_extension:,extension:,id:,) = coverageeligibilityrequest_item_diagnosis
    let fields = []
let fields = case diagnosis {
                          Some(v) -> [#("diagnosis", coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityrequest_item_diagnosis_decoder() -> Decoder(CoverageeligibilityrequestItemDiagnosis) {use diagnosis <- decode.then(none_if_omitted(coverageeligibilityrequest_item_diagnosis_diagnosis_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityrequestItemDiagnosis(diagnosis:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityrequest_item_to_json(coverageeligibilityrequest_item: CoverageeligibilityrequestItem) -> Json {
    let CoverageeligibilityrequestItem(detail:,diagnosis:,facility:,unit_price:,quantity:,provider:,modifier:,product_or_service:,category:,supporting_info_sequence:,modifier_extension:,extension:,id:,) = coverageeligibilityrequest_item
    let fields = []
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,reference_to_json)), ..fields]
                          }
let fields = case diagnosis {
                        [] -> fields
                        _ -> [#("diagnosis", json.array(diagnosis,coverageeligibilityrequest_item_diagnosis_to_json)), ..fields]
                          }
let fields = case facility {
                          Some(v) -> [#("facility", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case provider {
                          Some(v) -> [#("provider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case product_or_service {
                          Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case supporting_info_sequence {
                        [] -> fields
                        _ -> [#("supportingInfoSequence", json.array(supporting_info_sequence,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityrequest_item_decoder() -> Decoder(CoverageeligibilityrequestItem) {use detail <- decode.optional_field("detail", [], decode.list(reference_decoder()))
use diagnosis <- decode.optional_field("diagnosis", [], decode.list(coverageeligibilityrequest_item_diagnosis_decoder()))
use facility <- decode.optional_field("facility", None, decode.optional(reference_decoder()))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use provider <- decode.optional_field("provider", None, decode.optional(reference_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.optional_field("productOrService", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use supporting_info_sequence <- decode.optional_field("supportingInfoSequence", [], decode.list(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityrequestItem(detail:,diagnosis:,facility:,unit_price:,quantity:,provider:,modifier:,product_or_service:,category:,supporting_info_sequence:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityrequest_insurance_to_json(coverageeligibilityrequest_insurance: CoverageeligibilityrequestInsurance) -> Json {
    let CoverageeligibilityrequestInsurance(business_arrangement:,coverage:,focal:,modifier_extension:,extension:,id:,) = coverageeligibilityrequest_insurance
    let fields = [#("coverage", reference_to_json(coverage)),]
let fields = case business_arrangement {
                          Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case focal {
                          Some(v) -> [#("focal", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityrequest_insurance_decoder() -> Decoder(CoverageeligibilityrequestInsurance) {use business_arrangement <- decode.optional_field("businessArrangement", None, decode.optional(decode.string))
use coverage <- decode.field("coverage",reference_decoder())
use focal <- decode.optional_field("focal", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityrequestInsurance(business_arrangement:,coverage:,focal:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityrequest_supportinginfo_to_json(coverageeligibilityrequest_supportinginfo: CoverageeligibilityrequestSupportinginfo) -> Json {
    let CoverageeligibilityrequestSupportinginfo(applies_to_all:,information:,sequence:,modifier_extension:,extension:,id:,) = coverageeligibilityrequest_supportinginfo
    let fields = [#("information", reference_to_json(information)),#("sequence", json.int(sequence)),]
let fields = case applies_to_all {
                          Some(v) -> [#("appliesToAll", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityrequest_supportinginfo_decoder() -> Decoder(CoverageeligibilityrequestSupportinginfo) {use applies_to_all <- decode.optional_field("appliesToAll", None, decode.optional(decode.bool))
use information <- decode.field("information",reference_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityrequestSupportinginfo(applies_to_all:,information:,sequence:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityrequest_to_json(coverageeligibilityrequest: Coverageeligibilityrequest) -> Json {
    let Coverageeligibilityrequest(item:,insurance:,supporting_info:,facility:,insurer:,provider:,enterer:,created:,serviced:,patient:,purpose:,priority:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = coverageeligibilityrequest
    let fields = [#("insurer", reference_to_json(insurer)),#("created", json.string(created)),#("patient", reference_to_json(patient)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,coverageeligibilityrequest_item_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,coverageeligibilityrequest_insurance_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,coverageeligibilityrequest_supportinginfo_to_json)), ..fields]
                          }
let fields = case facility {
                          Some(v) -> [#("facility", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case provider {
                          Some(v) -> [#("provider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enterer {
                          Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", coverageeligibilityrequest_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                        [] -> fields
                        _ -> [#("purpose", json.array(purpose,r4valuesets.eligibilityrequestpurpose_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityrequest_decoder() -> Decoder(Coverageeligibilityrequest) {use item <- decode.optional_field("item", [], decode.list(coverageeligibilityrequest_item_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(coverageeligibilityrequest_insurance_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(coverageeligibilityrequest_supportinginfo_decoder()))
use facility <- decode.optional_field("facility", None, decode.optional(reference_decoder()))
use insurer <- decode.field("insurer",reference_decoder())
use provider <- decode.optional_field("provider", None, decode.optional(reference_decoder()))
use enterer <- decode.optional_field("enterer", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use serviced <- decode.then(none_if_omitted(coverageeligibilityrequest_serviced_decoder()))
use patient <- decode.field("patient",reference_decoder())
use purpose <- decode.optional_field("purpose", [], decode.list(r4valuesets.eligibilityrequestpurpose_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Coverageeligibilityrequest(item:,insurance:,supporting_info:,facility:,insurer:,provider:,enterer:,created:,serviced:,patient:,purpose:,priority:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type Coverageeligibilityresponse
{
Coverageeligibilityresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
purpose: List(r4valuesets.Eligibilityresponsepurpose),
patient: Reference,
serviced: Option(CoverageeligibilityresponseServiced),
created: String,
requestor: Option(Reference),
request: Reference,
outcome: r4valuesets.Remittanceoutcome,
disposition: Option(String),
insurer: Reference,
insurance: List(CoverageeligibilityresponseInsurance),
pre_auth_ref: Option(String),
form: Option(Codeableconcept),
error: List(CoverageeligibilityresponseError),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseServiced{
CoverageeligibilityresponseServicedDate(serviced: String)
CoverageeligibilityresponseServicedPeriod(serviced: Period)}
pub fn coverageeligibilityresponse_serviced_to_json(elt: CoverageeligibilityresponseServiced) -> Json {case elt{CoverageeligibilityresponseServicedDate(v) -> json.string(v)
CoverageeligibilityresponseServicedPeriod(v) -> period_to_json(v)
}}
pub fn coverageeligibilityresponse_serviced_decoder() -> Decoder(CoverageeligibilityresponseServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(CoverageeligibilityresponseServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(CoverageeligibilityresponseServicedPeriod),])}
pub fn coverageeligibilityresponse_new(insurer insurer: Reference,outcome outcome: r4valuesets.Remittanceoutcome,request request: Reference,created created: String,patient patient: Reference,status status: r4valuesets.Fmstatus,) ->Coverageeligibilityresponse{Coverageeligibilityresponse(error: [],form: None,pre_auth_ref: None,insurance: [],insurer:,disposition: None,outcome:,request:,requestor: None,created:,serviced: None,patient:,purpose: [],status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsurance
{
CoverageeligibilityresponseInsurance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
coverage: Reference,
inforce: Option(Bool),
benefit_period: Option(Period),
item: List(CoverageeligibilityresponseInsuranceItem),
)
}

pub fn coverageeligibilityresponse_insurance_new(coverage coverage: Reference,) ->CoverageeligibilityresponseInsurance{CoverageeligibilityresponseInsurance(item: [],benefit_period: None,inforce: None,coverage:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItem
{
CoverageeligibilityresponseInsuranceItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Option(Codeableconcept),
product_or_service: Option(Codeableconcept),
modifier: List(Codeableconcept),
provider: Option(Reference),
excluded: Option(Bool),
name: Option(String),
description: Option(String),
network: Option(Codeableconcept),
unit: Option(Codeableconcept),
term: Option(Codeableconcept),
benefit: List(CoverageeligibilityresponseInsuranceItemBenefit),
authorization_required: Option(Bool),
authorization_supporting: List(Codeableconcept),
authorization_url: Option(String),
)
}

pub fn coverageeligibilityresponse_insurance_item_new() ->CoverageeligibilityresponseInsuranceItem{CoverageeligibilityresponseInsuranceItem(authorization_url: None,authorization_supporting: [],authorization_required: None,benefit: [],term: None,unit: None,network: None,description: None,name: None,excluded: None,provider: None,modifier: [],product_or_service: None,category: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefit
{
CoverageeligibilityresponseInsuranceItemBenefit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
allowed: Option(CoverageeligibilityresponseInsuranceItemBenefitAllowed),
used: Option(CoverageeligibilityresponseInsuranceItemBenefitUsed),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitAllowed{
CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(allowed: Int)
CoverageeligibilityresponseInsuranceItemBenefitAllowedString(allowed: String)
CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(allowed: Money)}
pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(elt: CoverageeligibilityresponseInsuranceItemBenefitAllowed) -> Json {case elt{CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(v) -> json.int(v)
CoverageeligibilityresponseInsuranceItemBenefitAllowedString(v) -> json.string(v)
CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(v) -> money_to_json(v)
}}
pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_decoder() -> Decoder(CoverageeligibilityresponseInsuranceItemBenefitAllowed){decode.one_of(decode.field("allowedUnsignedInt", decode.int, decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint),[decode.field("allowedString", decode.string, decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitAllowedString),decode.field("allowedMoney", money_decoder(), decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney),])}

///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitUsed{
CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(used: Int)
CoverageeligibilityresponseInsuranceItemBenefitUsedString(used: String)
CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(used: Money)}
pub fn coverageeligibilityresponse_insurance_item_benefit_used_to_json(elt: CoverageeligibilityresponseInsuranceItemBenefitUsed) -> Json {case elt{CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(v) -> json.int(v)
CoverageeligibilityresponseInsuranceItemBenefitUsedString(v) -> json.string(v)
CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(v) -> money_to_json(v)
}}
pub fn coverageeligibilityresponse_insurance_item_benefit_used_decoder() -> Decoder(CoverageeligibilityresponseInsuranceItemBenefitUsed){decode.one_of(decode.field("usedUnsignedInt", decode.int, decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint),[decode.field("usedString", decode.string, decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedString),decode.field("usedMoney", money_decoder(), decode.success) |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedMoney),])}
pub fn coverageeligibilityresponse_insurance_item_benefit_new(type_ type_: Codeableconcept,) ->CoverageeligibilityresponseInsuranceItemBenefit{CoverageeligibilityresponseInsuranceItemBenefit(used: None,allowed: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseError
{
CoverageeligibilityresponseError(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
)
}

pub fn coverageeligibilityresponse_error_new(code code: Codeableconcept,) ->CoverageeligibilityresponseError{CoverageeligibilityresponseError(code:,modifier_extension: [],extension: [],id: None,)
}

pub fn coverageeligibilityresponse_error_to_json(coverageeligibilityresponse_error: CoverageeligibilityresponseError) -> Json {
    let CoverageeligibilityresponseError(code:,modifier_extension:,extension:,id:,) = coverageeligibilityresponse_error
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityresponse_error_decoder() -> Decoder(CoverageeligibilityresponseError) {use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityresponseError(code:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityresponse_insurance_item_benefit_to_json(coverageeligibilityresponse_insurance_item_benefit: CoverageeligibilityresponseInsuranceItemBenefit) -> Json {
    let CoverageeligibilityresponseInsuranceItemBenefit(used:,allowed:,type_:,modifier_extension:,extension:,id:,) = coverageeligibilityresponse_insurance_item_benefit
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case used {
                          Some(v) -> [#("used", coverageeligibilityresponse_insurance_item_benefit_used_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case allowed {
                          Some(v) -> [#("allowed", coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityresponse_insurance_item_benefit_decoder() -> Decoder(CoverageeligibilityresponseInsuranceItemBenefit) {use used <- decode.then(none_if_omitted(coverageeligibilityresponse_insurance_item_benefit_used_decoder()))
use allowed <- decode.then(none_if_omitted(coverageeligibilityresponse_insurance_item_benefit_allowed_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityresponseInsuranceItemBenefit(used:,allowed:,type_:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityresponse_insurance_item_to_json(coverageeligibilityresponse_insurance_item: CoverageeligibilityresponseInsuranceItem) -> Json {
    let CoverageeligibilityresponseInsuranceItem(authorization_url:,authorization_supporting:,authorization_required:,benefit:,term:,unit:,network:,description:,name:,excluded:,provider:,modifier:,product_or_service:,category:,modifier_extension:,extension:,id:,) = coverageeligibilityresponse_insurance_item
    let fields = []
let fields = case authorization_url {
                          Some(v) -> [#("authorizationUrl", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case authorization_supporting {
                        [] -> fields
                        _ -> [#("authorizationSupporting", json.array(authorization_supporting,codeableconcept_to_json)), ..fields]
                          }
let fields = case authorization_required {
                          Some(v) -> [#("authorizationRequired", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case benefit {
                        [] -> fields
                        _ -> [#("benefit", json.array(benefit,coverageeligibilityresponse_insurance_item_benefit_to_json)), ..fields]
                          }
let fields = case term {
                          Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case network {
                          Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case excluded {
                          Some(v) -> [#("excluded", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case provider {
                          Some(v) -> [#("provider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case product_or_service {
                          Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityresponse_insurance_item_decoder() -> Decoder(CoverageeligibilityresponseInsuranceItem) {use authorization_url <- decode.optional_field("authorizationUrl", None, decode.optional(decode.string))
use authorization_supporting <- decode.optional_field("authorizationSupporting", [], decode.list(codeableconcept_decoder()))
use authorization_required <- decode.optional_field("authorizationRequired", None, decode.optional(decode.bool))
use benefit <- decode.optional_field("benefit", [], decode.list(coverageeligibilityresponse_insurance_item_benefit_decoder()))
use term <- decode.optional_field("term", None, decode.optional(codeableconcept_decoder()))
use unit <- decode.optional_field("unit", None, decode.optional(codeableconcept_decoder()))
use network <- decode.optional_field("network", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use excluded <- decode.optional_field("excluded", None, decode.optional(decode.bool))
use provider <- decode.optional_field("provider", None, decode.optional(reference_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.optional_field("productOrService", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityresponseInsuranceItem(authorization_url:,authorization_supporting:,authorization_required:,benefit:,term:,unit:,network:,description:,name:,excluded:,provider:,modifier:,product_or_service:,category:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityresponse_insurance_to_json(coverageeligibilityresponse_insurance: CoverageeligibilityresponseInsurance) -> Json {
    let CoverageeligibilityresponseInsurance(item:,benefit_period:,inforce:,coverage:,modifier_extension:,extension:,id:,) = coverageeligibilityresponse_insurance
    let fields = [#("coverage", reference_to_json(coverage)),]
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,coverageeligibilityresponse_insurance_item_to_json)), ..fields]
                          }
let fields = case benefit_period {
                          Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case inforce {
                          Some(v) -> [#("inforce", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityresponse_insurance_decoder() -> Decoder(CoverageeligibilityresponseInsurance) {use item <- decode.optional_field("item", [], decode.list(coverageeligibilityresponse_insurance_item_decoder()))
use benefit_period <- decode.optional_field("benefitPeriod", None, decode.optional(period_decoder()))
use inforce <- decode.optional_field("inforce", None, decode.optional(decode.bool))
use coverage <- decode.field("coverage",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(CoverageeligibilityresponseInsurance(item:,benefit_period:,inforce:,coverage:,modifier_extension:,extension:,id:,))}
pub fn coverageeligibilityresponse_to_json(coverageeligibilityresponse: Coverageeligibilityresponse) -> Json {
    let Coverageeligibilityresponse(error:,form:,pre_auth_ref:,insurance:,insurer:,disposition:,outcome:,request:,requestor:,created:,serviced:,patient:,purpose:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = coverageeligibilityresponse
    let fields = [#("insurer", reference_to_json(insurer)),#("outcome", r4valuesets.remittanceoutcome_to_json(outcome)),#("request", reference_to_json(request)),#("created", json.string(created)),#("patient", reference_to_json(patient)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case error {
                        [] -> fields
                        _ -> [#("error", json.array(error,coverageeligibilityresponse_error_to_json)), ..fields]
                          }
let fields = case form {
                          Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_auth_ref {
                          Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,coverageeligibilityresponse_insurance_to_json)), ..fields]
                          }
let fields = case disposition {
                          Some(v) -> [#("disposition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case requestor {
                          Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", coverageeligibilityresponse_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                        [] -> fields
                        _ -> [#("purpose", json.array(purpose,r4valuesets.eligibilityresponsepurpose_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn coverageeligibilityresponse_decoder() -> Decoder(Coverageeligibilityresponse) {use error <- decode.optional_field("error", [], decode.list(coverageeligibilityresponse_error_decoder()))
use form <- decode.optional_field("form", None, decode.optional(codeableconcept_decoder()))
use pre_auth_ref <- decode.optional_field("preAuthRef", None, decode.optional(decode.string))
use insurance <- decode.optional_field("insurance", [], decode.list(coverageeligibilityresponse_insurance_decoder()))
use insurer <- decode.field("insurer",reference_decoder())
use disposition <- decode.optional_field("disposition", None, decode.optional(decode.string))
use outcome <- decode.field("outcome",r4valuesets.remittanceoutcome_decoder())
use request <- decode.field("request",reference_decoder())
use requestor <- decode.optional_field("requestor", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use serviced <- decode.then(none_if_omitted(coverageeligibilityresponse_serviced_decoder()))
use patient <- decode.field("patient",reference_decoder())
use purpose <- decode.optional_field("purpose", [], decode.list(r4valuesets.eligibilityresponsepurpose_decoder()))
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Coverageeligibilityresponse(error:,form:,pre_auth_ref:,insurance:,insurer:,disposition:,outcome:,request:,requestor:,created:,serviced:,patient:,purpose:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DetectedIssue#resource
pub type Detectedissue
{
Detectedissue(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Observationstatus,
code: Option(Codeableconcept),
severity: Option(r4valuesets.Detectedissueseverity),
patient: Option(Reference),
identified: Option(DetectedissueIdentified),
author: Option(Reference),
implicated: List(Reference),
evidence: List(DetectedissueEvidence),
detail: Option(String),
reference: Option(String),
mitigation: List(DetectedissueMitigation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DetectedIssue#resource
pub type DetectedissueIdentified{
DetectedissueIdentifiedDatetime(identified: String)
DetectedissueIdentifiedPeriod(identified: Period)}
pub fn detectedissue_identified_to_json(elt: DetectedissueIdentified) -> Json {case elt{DetectedissueIdentifiedDatetime(v) -> json.string(v)
DetectedissueIdentifiedPeriod(v) -> period_to_json(v)
}}
pub fn detectedissue_identified_decoder() -> Decoder(DetectedissueIdentified){decode.one_of(decode.field("identifiedDateTime", decode.string, decode.success) |> decode.map(DetectedissueIdentifiedDatetime),[decode.field("identifiedPeriod", period_decoder(), decode.success) |> decode.map(DetectedissueIdentifiedPeriod),])}
pub fn detectedissue_new(status status: r4valuesets.Observationstatus,) ->Detectedissue{Detectedissue(mitigation: [],reference: None,detail: None,evidence: [],implicated: [],author: None,identified: None,patient: None,severity: None,code: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DetectedIssue#resource
pub type DetectedissueEvidence
{
DetectedissueEvidence(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: List(Codeableconcept),
detail: List(Reference),
)
}

pub fn detectedissue_evidence_new() ->DetectedissueEvidence{DetectedissueEvidence(detail: [],code: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DetectedIssue#resource
pub type DetectedissueMitigation
{
DetectedissueMitigation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: Codeableconcept,
date: Option(String),
author: Option(Reference),
)
}

pub fn detectedissue_mitigation_new(action action: Codeableconcept,) ->DetectedissueMitigation{DetectedissueMitigation(author: None,date: None,action:,modifier_extension: [],extension: [],id: None,)
}

pub fn detectedissue_mitigation_to_json(detectedissue_mitigation: DetectedissueMitigation) -> Json {
    let DetectedissueMitigation(author:,date:,action:,modifier_extension:,extension:,id:,) = detectedissue_mitigation
    let fields = [#("action", codeableconcept_to_json(action)),]
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn detectedissue_mitigation_decoder() -> Decoder(DetectedissueMitigation) {use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use action <- decode.field("action",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DetectedissueMitigation(author:,date:,action:,modifier_extension:,extension:,id:,))}
pub fn detectedissue_evidence_to_json(detectedissue_evidence: DetectedissueEvidence) -> Json {
    let DetectedissueEvidence(detail:,code:,modifier_extension:,extension:,id:,) = detectedissue_evidence
    let fields = []
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,reference_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn detectedissue_evidence_decoder() -> Decoder(DetectedissueEvidence) {use detail <- decode.optional_field("detail", [], decode.list(reference_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DetectedissueEvidence(detail:,code:,modifier_extension:,extension:,id:,))}
pub fn detectedissue_to_json(detectedissue: Detectedissue) -> Json {
    let Detectedissue(mitigation:,reference:,detail:,evidence:,implicated:,author:,identified:,patient:,severity:,code:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = detectedissue
    let fields = [#("status", r4valuesets.observationstatus_to_json(status)),]
let fields = case mitigation {
                        [] -> fields
                        _ -> [#("mitigation", json.array(mitigation,detectedissue_mitigation_to_json)), ..fields]
                          }
let fields = case reference {
                          Some(v) -> [#("reference", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case detail {
                          Some(v) -> [#("detail", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case evidence {
                        [] -> fields
                        _ -> [#("evidence", json.array(evidence,detectedissue_evidence_to_json)), ..fields]
                          }
let fields = case implicated {
                        [] -> fields
                        _ -> [#("implicated", json.array(implicated,reference_to_json)), ..fields]
                          }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identified {
                          Some(v) -> [#("identified", detectedissue_identified_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case patient {
                          Some(v) -> [#("patient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case severity {
                          Some(v) -> [#("severity", r4valuesets.detectedissueseverity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn detectedissue_decoder() -> Decoder(Detectedissue) {use mitigation <- decode.optional_field("mitigation", [], decode.list(detectedissue_mitigation_decoder()))
use reference <- decode.optional_field("reference", None, decode.optional(decode.string))
use detail <- decode.optional_field("detail", None, decode.optional(decode.string))
use evidence <- decode.optional_field("evidence", [], decode.list(detectedissue_evidence_decoder()))
use implicated <- decode.optional_field("implicated", [], decode.list(reference_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use identified <- decode.then(none_if_omitted(detectedissue_identified_decoder()))
use patient <- decode.optional_field("patient", None, decode.optional(reference_decoder()))
use severity <- decode.optional_field("severity", None, decode.optional(r4valuesets.detectedissueseverity_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.observationstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Detectedissue(mitigation:,reference:,detail:,evidence:,implicated:,author:,identified:,patient:,severity:,code:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type Device
{
Device(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
definition: Option(Reference),
udi_carrier: List(DeviceUdicarrier),
status: Option(r4valuesets.Devicestatus),
status_reason: List(Codeableconcept),
distinct_identifier: Option(String),
manufacturer: Option(String),
manufacture_date: Option(String),
expiration_date: Option(String),
lot_number: Option(String),
serial_number: Option(String),
device_name: List(DeviceDevicename),
model_number: Option(String),
part_number: Option(String),
type_: Option(Codeableconcept),
specialization: List(DeviceSpecialization),
version: List(DeviceVersion),
property: List(DeviceProperty),
patient: Option(Reference),
owner: Option(Reference),
contact: List(Contactpoint),
location: Option(Reference),
url: Option(String),
note: List(Annotation),
safety: List(Codeableconcept),
parent: Option(Reference),
)
}

pub fn device_new() ->Device{Device(parent: None,safety: [],note: [],url: None,location: None,contact: [],owner: None,patient: None,property: [],version: [],specialization: [],type_: None,part_number: None,model_number: None,device_name: [],serial_number: None,lot_number: None,expiration_date: None,manufacture_date: None,manufacturer: None,distinct_identifier: None,status_reason: [],status: None,udi_carrier: [],definition: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type DeviceUdicarrier
{
DeviceUdicarrier(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
device_identifier: Option(String),
issuer: Option(String),
jurisdiction: Option(String),
carrier_aidc: Option(String),
carrier_hrf: Option(String),
entry_type: Option(r4valuesets.Udientrytype),
)
}

pub fn device_udicarrier_new() ->DeviceUdicarrier{DeviceUdicarrier(entry_type: None,carrier_hrf: None,carrier_aidc: None,jurisdiction: None,issuer: None,device_identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type DeviceDevicename
{
DeviceDevicename(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
type_: r4valuesets.Devicenametype,
)
}

pub fn device_devicename_new(type_ type_: r4valuesets.Devicenametype,name name: String,) ->DeviceDevicename{DeviceDevicename(type_:,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type DeviceSpecialization
{
DeviceSpecialization(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
system_type: Codeableconcept,
version: Option(String),
)
}

pub fn device_specialization_new(system_type system_type: Codeableconcept,) ->DeviceSpecialization{DeviceSpecialization(version: None,system_type:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type DeviceVersion
{
DeviceVersion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
component: Option(Identifier),
value: String,
)
}

pub fn device_version_new(value value: String,) ->DeviceVersion{DeviceVersion(value:,component: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Device#resource
pub type DeviceProperty
{
DeviceProperty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
value_quantity: List(Quantity),
value_code: List(Codeableconcept),
)
}

pub fn device_property_new(type_ type_: Codeableconcept,) ->DeviceProperty{DeviceProperty(value_code: [],value_quantity: [],type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn device_property_to_json(device_property: DeviceProperty) -> Json {
    let DeviceProperty(value_code:,value_quantity:,type_:,modifier_extension:,extension:,id:,) = device_property
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case value_code {
                        [] -> fields
                        _ -> [#("valueCode", json.array(value_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case value_quantity {
                        [] -> fields
                        _ -> [#("valueQuantity", json.array(value_quantity,quantity_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_property_decoder() -> Decoder(DeviceProperty) {use value_code <- decode.optional_field("valueCode", [], decode.list(codeableconcept_decoder()))
use value_quantity <- decode.optional_field("valueQuantity", [], decode.list(quantity_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DeviceProperty(value_code:,value_quantity:,type_:,modifier_extension:,extension:,id:,))}
pub fn device_version_to_json(device_version: DeviceVersion) -> Json {
    let DeviceVersion(value:,component:,type_:,modifier_extension:,extension:,id:,) = device_version
    let fields = [#("value", json.string(value)),]
let fields = case component {
                          Some(v) -> [#("component", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_version_decoder() -> Decoder(DeviceVersion) {use value <- decode.field("value",decode.string)
use component <- decode.optional_field("component", None, decode.optional(identifier_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DeviceVersion(value:,component:,type_:,modifier_extension:,extension:,id:,))}
pub fn device_specialization_to_json(device_specialization: DeviceSpecialization) -> Json {
    let DeviceSpecialization(version:,system_type:,modifier_extension:,extension:,id:,) = device_specialization
    let fields = [#("systemType", codeableconcept_to_json(system_type)),]
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_specialization_decoder() -> Decoder(DeviceSpecialization) {use version <- decode.optional_field("version", None, decode.optional(decode.string))
use system_type <- decode.field("systemType",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DeviceSpecialization(version:,system_type:,modifier_extension:,extension:,id:,))}
pub fn device_devicename_to_json(device_devicename: DeviceDevicename) -> Json {
    let DeviceDevicename(type_:,name:,modifier_extension:,extension:,id:,) = device_devicename
    let fields = [#("type", r4valuesets.devicenametype_to_json(type_)),#("name", json.string(name)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_devicename_decoder() -> Decoder(DeviceDevicename) {use type_ <- decode.field("type",r4valuesets.devicenametype_decoder())
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DeviceDevicename(type_:,name:,modifier_extension:,extension:,id:,))}
pub fn device_udicarrier_to_json(device_udicarrier: DeviceUdicarrier) -> Json {
    let DeviceUdicarrier(entry_type:,carrier_hrf:,carrier_aidc:,jurisdiction:,issuer:,device_identifier:,modifier_extension:,extension:,id:,) = device_udicarrier
    let fields = []
let fields = case entry_type {
                          Some(v) -> [#("entryType", r4valuesets.udientrytype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case carrier_hrf {
                          Some(v) -> [#("carrierHRF", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case carrier_aidc {
                          Some(v) -> [#("carrierAIDC", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                          Some(v) -> [#("jurisdiction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case issuer {
                          Some(v) -> [#("issuer", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case device_identifier {
                          Some(v) -> [#("deviceIdentifier", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_udicarrier_decoder() -> Decoder(DeviceUdicarrier) {use entry_type <- decode.optional_field("entryType", None, decode.optional(r4valuesets.udientrytype_decoder()))
use carrier_hrf <- decode.optional_field("carrierHRF", None, decode.optional(decode.string))
use carrier_aidc <- decode.optional_field("carrierAIDC", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", None, decode.optional(decode.string))
use issuer <- decode.optional_field("issuer", None, decode.optional(decode.string))
use device_identifier <- decode.optional_field("deviceIdentifier", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DeviceUdicarrier(entry_type:,carrier_hrf:,carrier_aidc:,jurisdiction:,issuer:,device_identifier:,modifier_extension:,extension:,id:,))}
pub fn device_to_json(device: Device) -> Json {
    let Device(parent:,safety:,note:,url:,location:,contact:,owner:,patient:,property:,version:,specialization:,type_:,part_number:,model_number:,device_name:,serial_number:,lot_number:,expiration_date:,manufacture_date:,manufacturer:,distinct_identifier:,status_reason:,status:,udi_carrier:,definition:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = device
    let fields = []
let fields = case parent {
                          Some(v) -> [#("parent", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case safety {
                        [] -> fields
                        _ -> [#("safety", json.array(safety,codeableconcept_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactpoint_to_json)), ..fields]
                          }
let fields = case owner {
                          Some(v) -> [#("owner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case patient {
                          Some(v) -> [#("patient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,device_property_to_json)), ..fields]
                          }
let fields = case version {
                        [] -> fields
                        _ -> [#("version", json.array(version,device_version_to_json)), ..fields]
                          }
let fields = case specialization {
                        [] -> fields
                        _ -> [#("specialization", json.array(specialization,device_specialization_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_number {
                          Some(v) -> [#("partNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case model_number {
                          Some(v) -> [#("modelNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case device_name {
                        [] -> fields
                        _ -> [#("deviceName", json.array(device_name,device_devicename_to_json)), ..fields]
                          }
let fields = case serial_number {
                          Some(v) -> [#("serialNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case lot_number {
                          Some(v) -> [#("lotNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expiration_date {
                          Some(v) -> [#("expirationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacture_date {
                          Some(v) -> [#("manufactureDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacturer {
                          Some(v) -> [#("manufacturer", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case distinct_identifier {
                          Some(v) -> [#("distinctIdentifier", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                        [] -> fields
                        _ -> [#("statusReason", json.array(status_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.devicestatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case udi_carrier {
                        [] -> fields
                        _ -> [#("udiCarrier", json.array(udi_carrier,device_udicarrier_to_json)), ..fields]
                          }
let fields = case definition {
                          Some(v) -> [#("definition", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn device_decoder() -> Decoder(Device) {use parent <- decode.optional_field("parent", None, decode.optional(reference_decoder()))
use safety <- decode.optional_field("safety", [], decode.list(codeableconcept_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(contactpoint_decoder()))
use owner <- decode.optional_field("owner", None, decode.optional(reference_decoder()))
use patient <- decode.optional_field("patient", None, decode.optional(reference_decoder()))
use property <- decode.optional_field("property", [], decode.list(device_property_decoder()))
use version <- decode.optional_field("version", [], decode.list(device_version_decoder()))
use specialization <- decode.optional_field("specialization", [], decode.list(device_specialization_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use part_number <- decode.optional_field("partNumber", None, decode.optional(decode.string))
use model_number <- decode.optional_field("modelNumber", None, decode.optional(decode.string))
use device_name <- decode.optional_field("deviceName", [], decode.list(device_devicename_decoder()))
use serial_number <- decode.optional_field("serialNumber", None, decode.optional(decode.string))
use lot_number <- decode.optional_field("lotNumber", None, decode.optional(decode.string))
use expiration_date <- decode.optional_field("expirationDate", None, decode.optional(decode.string))
use manufacture_date <- decode.optional_field("manufactureDate", None, decode.optional(decode.string))
use manufacturer <- decode.optional_field("manufacturer", None, decode.optional(decode.string))
use distinct_identifier <- decode.optional_field("distinctIdentifier", None, decode.optional(decode.string))
use status_reason <- decode.optional_field("statusReason", [], decode.list(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.devicestatus_decoder()))
use udi_carrier <- decode.optional_field("udiCarrier", [], decode.list(device_udicarrier_decoder()))
use definition <- decode.optional_field("definition", None, decode.optional(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Device(parent:,safety:,note:,url:,location:,contact:,owner:,patient:,property:,version:,specialization:,type_:,part_number:,model_number:,device_name:,serial_number:,lot_number:,expiration_date:,manufacture_date:,manufacturer:,distinct_identifier:,status_reason:,status:,udi_carrier:,definition:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type Devicedefinition
{
Devicedefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
udi_device_identifier: List(DevicedefinitionUdideviceidentifier),
manufacturer: Option(DevicedefinitionManufacturer),
device_name: List(DevicedefinitionDevicename),
model_number: Option(String),
type_: Option(Codeableconcept),
specialization: List(DevicedefinitionSpecialization),
version: List(String),
safety: List(Codeableconcept),
shelf_life_storage: List(Productshelflife),
physical_characteristics: Option(Prodcharacteristic),
language_code: List(Codeableconcept),
capability: List(DevicedefinitionCapability),
property: List(DevicedefinitionProperty),
owner: Option(Reference),
contact: List(Contactpoint),
url: Option(String),
online_information: Option(String),
note: List(Annotation),
quantity: Option(Quantity),
parent_device: Option(Reference),
material: List(DevicedefinitionMaterial),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionManufacturer{
DevicedefinitionManufacturerString(manufacturer: String)
DevicedefinitionManufacturerReference(manufacturer: Reference)}
pub fn devicedefinition_manufacturer_to_json(elt: DevicedefinitionManufacturer) -> Json {case elt{DevicedefinitionManufacturerString(v) -> json.string(v)
DevicedefinitionManufacturerReference(v) -> reference_to_json(v)
}}
pub fn devicedefinition_manufacturer_decoder() -> Decoder(DevicedefinitionManufacturer){decode.one_of(decode.field("manufacturerString", decode.string, decode.success) |> decode.map(DevicedefinitionManufacturerString),[decode.field("manufacturerReference", reference_decoder(), decode.success) |> decode.map(DevicedefinitionManufacturerReference),])}
pub fn devicedefinition_new() ->Devicedefinition{Devicedefinition(material: [],parent_device: None,quantity: None,note: [],online_information: None,url: None,contact: [],owner: None,property: [],capability: [],language_code: [],physical_characteristics: None,shelf_life_storage: [],safety: [],version: [],specialization: [],type_: None,model_number: None,device_name: [],manufacturer: None,udi_device_identifier: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionUdideviceidentifier
{
DevicedefinitionUdideviceidentifier(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
device_identifier: String,
issuer: String,
jurisdiction: String,
)
}

pub fn devicedefinition_udideviceidentifier_new(jurisdiction jurisdiction: String,issuer issuer: String,device_identifier device_identifier: String,) ->DevicedefinitionUdideviceidentifier{DevicedefinitionUdideviceidentifier(jurisdiction:,issuer:,device_identifier:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionDevicename
{
DevicedefinitionDevicename(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
type_: r4valuesets.Devicenametype,
)
}

pub fn devicedefinition_devicename_new(type_ type_: r4valuesets.Devicenametype,name name: String,) ->DevicedefinitionDevicename{DevicedefinitionDevicename(type_:,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionSpecialization
{
DevicedefinitionSpecialization(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
system_type: String,
version: Option(String),
)
}

pub fn devicedefinition_specialization_new(system_type system_type: String,) ->DevicedefinitionSpecialization{DevicedefinitionSpecialization(version: None,system_type:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionCapability
{
DevicedefinitionCapability(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
description: List(Codeableconcept),
)
}

pub fn devicedefinition_capability_new(type_ type_: Codeableconcept,) ->DevicedefinitionCapability{DevicedefinitionCapability(description: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionProperty
{
DevicedefinitionProperty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
value_quantity: List(Quantity),
value_code: List(Codeableconcept),
)
}

pub fn devicedefinition_property_new(type_ type_: Codeableconcept,) ->DevicedefinitionProperty{DevicedefinitionProperty(value_code: [],value_quantity: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionMaterial
{
DevicedefinitionMaterial(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
substance: Codeableconcept,
alternate: Option(Bool),
allergenic_indicator: Option(Bool),
)
}

pub fn devicedefinition_material_new(substance substance: Codeableconcept,) ->DevicedefinitionMaterial{DevicedefinitionMaterial(allergenic_indicator: None,alternate: None,substance:,modifier_extension: [],extension: [],id: None,)
}

pub fn devicedefinition_material_to_json(devicedefinition_material: DevicedefinitionMaterial) -> Json {
    let DevicedefinitionMaterial(allergenic_indicator:,alternate:,substance:,modifier_extension:,extension:,id:,) = devicedefinition_material
    let fields = [#("substance", codeableconcept_to_json(substance)),]
let fields = case allergenic_indicator {
                          Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case alternate {
                          Some(v) -> [#("alternate", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_material_decoder() -> Decoder(DevicedefinitionMaterial) {use allergenic_indicator <- decode.optional_field("allergenicIndicator", None, decode.optional(decode.bool))
use alternate <- decode.optional_field("alternate", None, decode.optional(decode.bool))
use substance <- decode.field("substance",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionMaterial(allergenic_indicator:,alternate:,substance:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_property_to_json(devicedefinition_property: DevicedefinitionProperty) -> Json {
    let DevicedefinitionProperty(value_code:,value_quantity:,type_:,modifier_extension:,extension:,id:,) = devicedefinition_property
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case value_code {
                        [] -> fields
                        _ -> [#("valueCode", json.array(value_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case value_quantity {
                        [] -> fields
                        _ -> [#("valueQuantity", json.array(value_quantity,quantity_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_property_decoder() -> Decoder(DevicedefinitionProperty) {use value_code <- decode.optional_field("valueCode", [], decode.list(codeableconcept_decoder()))
use value_quantity <- decode.optional_field("valueQuantity", [], decode.list(quantity_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionProperty(value_code:,value_quantity:,type_:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_capability_to_json(devicedefinition_capability: DevicedefinitionCapability) -> Json {
    let DevicedefinitionCapability(description:,type_:,modifier_extension:,extension:,id:,) = devicedefinition_capability
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case description {
                        [] -> fields
                        _ -> [#("description", json.array(description,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_capability_decoder() -> Decoder(DevicedefinitionCapability) {use description <- decode.optional_field("description", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionCapability(description:,type_:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_specialization_to_json(devicedefinition_specialization: DevicedefinitionSpecialization) -> Json {
    let DevicedefinitionSpecialization(version:,system_type:,modifier_extension:,extension:,id:,) = devicedefinition_specialization
    let fields = [#("systemType", json.string(system_type)),]
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_specialization_decoder() -> Decoder(DevicedefinitionSpecialization) {use version <- decode.optional_field("version", None, decode.optional(decode.string))
use system_type <- decode.field("systemType",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionSpecialization(version:,system_type:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_devicename_to_json(devicedefinition_devicename: DevicedefinitionDevicename) -> Json {
    let DevicedefinitionDevicename(type_:,name:,modifier_extension:,extension:,id:,) = devicedefinition_devicename
    let fields = [#("type", r4valuesets.devicenametype_to_json(type_)),#("name", json.string(name)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_devicename_decoder() -> Decoder(DevicedefinitionDevicename) {use type_ <- decode.field("type",r4valuesets.devicenametype_decoder())
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionDevicename(type_:,name:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_udideviceidentifier_to_json(devicedefinition_udideviceidentifier: DevicedefinitionUdideviceidentifier) -> Json {
    let DevicedefinitionUdideviceidentifier(jurisdiction:,issuer:,device_identifier:,modifier_extension:,extension:,id:,) = devicedefinition_udideviceidentifier
    let fields = [#("jurisdiction", json.string(jurisdiction)),#("issuer", json.string(issuer)),#("deviceIdentifier", json.string(device_identifier)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_udideviceidentifier_decoder() -> Decoder(DevicedefinitionUdideviceidentifier) {use jurisdiction <- decode.field("jurisdiction",decode.string)
use issuer <- decode.field("issuer",decode.string)
use device_identifier <- decode.field("deviceIdentifier",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicedefinitionUdideviceidentifier(jurisdiction:,issuer:,device_identifier:,modifier_extension:,extension:,id:,))}
pub fn devicedefinition_to_json(devicedefinition: Devicedefinition) -> Json {
    let Devicedefinition(material:,parent_device:,quantity:,note:,online_information:,url:,contact:,owner:,property:,capability:,language_code:,physical_characteristics:,shelf_life_storage:,safety:,version:,specialization:,type_:,model_number:,device_name:,manufacturer:,udi_device_identifier:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = devicedefinition
    let fields = []
let fields = case material {
                        [] -> fields
                        _ -> [#("material", json.array(material,devicedefinition_material_to_json)), ..fields]
                          }
let fields = case parent_device {
                          Some(v) -> [#("parentDevice", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case online_information {
                          Some(v) -> [#("onlineInformation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactpoint_to_json)), ..fields]
                          }
let fields = case owner {
                          Some(v) -> [#("owner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,devicedefinition_property_to_json)), ..fields]
                          }
let fields = case capability {
                        [] -> fields
                        _ -> [#("capability", json.array(capability,devicedefinition_capability_to_json)), ..fields]
                          }
let fields = case language_code {
                        [] -> fields
                        _ -> [#("languageCode", json.array(language_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case physical_characteristics {
                          Some(v) -> [#("physicalCharacteristics", prodcharacteristic_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case shelf_life_storage {
                        [] -> fields
                        _ -> [#("shelfLifeStorage", json.array(shelf_life_storage,productshelflife_to_json)), ..fields]
                          }
let fields = case safety {
                        [] -> fields
                        _ -> [#("safety", json.array(safety,codeableconcept_to_json)), ..fields]
                          }
let fields = case version {
                        [] -> fields
                        _ -> [#("version", json.array(version,json.string)), ..fields]
                          }
let fields = case specialization {
                        [] -> fields
                        _ -> [#("specialization", json.array(specialization,devicedefinition_specialization_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case model_number {
                          Some(v) -> [#("modelNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case device_name {
                        [] -> fields
                        _ -> [#("deviceName", json.array(device_name,devicedefinition_devicename_to_json)), ..fields]
                          }
let fields = case manufacturer {
                          Some(v) -> [#("manufacturer", devicedefinition_manufacturer_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case udi_device_identifier {
                        [] -> fields
                        _ -> [#("udiDeviceIdentifier", json.array(udi_device_identifier,devicedefinition_udideviceidentifier_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicedefinition_decoder() -> Decoder(Devicedefinition) {use material <- decode.optional_field("material", [], decode.list(devicedefinition_material_decoder()))
use parent_device <- decode.optional_field("parentDevice", None, decode.optional(reference_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use online_information <- decode.optional_field("onlineInformation", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactpoint_decoder()))
use owner <- decode.optional_field("owner", None, decode.optional(reference_decoder()))
use property <- decode.optional_field("property", [], decode.list(devicedefinition_property_decoder()))
use capability <- decode.optional_field("capability", [], decode.list(devicedefinition_capability_decoder()))
use language_code <- decode.optional_field("languageCode", [], decode.list(codeableconcept_decoder()))
use physical_characteristics <- decode.optional_field("physicalCharacteristics", None, decode.optional(prodcharacteristic_decoder()))
use shelf_life_storage <- decode.optional_field("shelfLifeStorage", [], decode.list(productshelflife_decoder()))
use safety <- decode.optional_field("safety", [], decode.list(codeableconcept_decoder()))
use version <- decode.optional_field("version", [], decode.list(decode.string))
use specialization <- decode.optional_field("specialization", [], decode.list(devicedefinition_specialization_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use model_number <- decode.optional_field("modelNumber", None, decode.optional(decode.string))
use device_name <- decode.optional_field("deviceName", [], decode.list(devicedefinition_devicename_decoder()))
use manufacturer <- decode.then(none_if_omitted(devicedefinition_manufacturer_decoder()))
use udi_device_identifier <- decode.optional_field("udiDeviceIdentifier", [], decode.list(devicedefinition_udideviceidentifier_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Devicedefinition(material:,parent_device:,quantity:,note:,online_information:,url:,contact:,owner:,property:,capability:,language_code:,physical_characteristics:,shelf_life_storage:,safety:,version:,specialization:,type_:,model_number:,device_name:,manufacturer:,udi_device_identifier:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceMetric#resource
pub type Devicemetric
{
Devicemetric(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Codeableconcept,
unit: Option(Codeableconcept),
source: Option(Reference),
parent: Option(Reference),
operational_status: Option(r4valuesets.Metricoperationalstatus),
color: Option(r4valuesets.Metriccolor),
category: r4valuesets.Metriccategory,
measurement_period: Option(Timing),
calibration: List(DevicemetricCalibration),
)
}

pub fn devicemetric_new(category category: r4valuesets.Metriccategory,type_ type_: Codeableconcept,) ->Devicemetric{Devicemetric(calibration: [],measurement_period: None,category:,color: None,operational_status: None,parent: None,source: None,unit: None,type_:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceMetric#resource
pub type DevicemetricCalibration
{
DevicemetricCalibration(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(r4valuesets.Metriccalibrationtype),
state: Option(r4valuesets.Metriccalibrationstate),
time: Option(String),
)
}

pub fn devicemetric_calibration_new() ->DevicemetricCalibration{DevicemetricCalibration(time: None,state: None,type_: None,modifier_extension: [],extension: [],id: None,)
}

pub fn devicemetric_calibration_to_json(devicemetric_calibration: DevicemetricCalibration) -> Json {
    let DevicemetricCalibration(time:,state:,type_:,modifier_extension:,extension:,id:,) = devicemetric_calibration
    let fields = []
let fields = case time {
                          Some(v) -> [#("time", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case state {
                          Some(v) -> [#("state", r4valuesets.metriccalibrationstate_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.metriccalibrationtype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicemetric_calibration_decoder() -> Decoder(DevicemetricCalibration) {use time <- decode.optional_field("time", None, decode.optional(decode.string))
use state <- decode.optional_field("state", None, decode.optional(r4valuesets.metriccalibrationstate_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.metriccalibrationtype_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicemetricCalibration(time:,state:,type_:,modifier_extension:,extension:,id:,))}
pub fn devicemetric_to_json(devicemetric: Devicemetric) -> Json {
    let Devicemetric(calibration:,measurement_period:,category:,color:,operational_status:,parent:,source:,unit:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = devicemetric
    let fields = [#("category", r4valuesets.metriccategory_to_json(category)),#("type", codeableconcept_to_json(type_)),]
let fields = case calibration {
                        [] -> fields
                        _ -> [#("calibration", json.array(calibration,devicemetric_calibration_to_json)), ..fields]
                          }
let fields = case measurement_period {
                          Some(v) -> [#("measurementPeriod", timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case color {
                          Some(v) -> [#("color", r4valuesets.metriccolor_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case operational_status {
                          Some(v) -> [#("operationalStatus", r4valuesets.metricoperationalstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parent {
                          Some(v) -> [#("parent", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicemetric_decoder() -> Decoder(Devicemetric) {use calibration <- decode.optional_field("calibration", [], decode.list(devicemetric_calibration_decoder()))
use measurement_period <- decode.optional_field("measurementPeriod", None, decode.optional(timing_decoder()))
use category <- decode.field("category",r4valuesets.metriccategory_decoder())
use color <- decode.optional_field("color", None, decode.optional(r4valuesets.metriccolor_decoder()))
use operational_status <- decode.optional_field("operationalStatus", None, decode.optional(r4valuesets.metricoperationalstatus_decoder()))
use parent <- decode.optional_field("parent", None, decode.optional(reference_decoder()))
use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use unit <- decode.optional_field("unit", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Devicemetric(calibration:,measurement_period:,category:,color:,operational_status:,parent:,source:,unit:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceRequest#resource
pub type Devicerequest
{
Devicerequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
prior_request: List(Reference),
group_identifier: Option(Identifier),
status: Option(r4valuesets.Requeststatus),
intent: r4valuesets.Requestintent,
priority: Option(r4valuesets.Requestpriority),
code: DevicerequestCode,
parameter: List(DevicerequestParameter),
subject: Reference,
encounter: Option(Reference),
occurrence: Option(DevicerequestOccurrence),
authored_on: Option(String),
requester: Option(Reference),
performer_type: Option(Codeableconcept),
performer: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
insurance: List(Reference),
supporting_info: List(Reference),
note: List(Annotation),
relevant_history: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DeviceRequest#resource
pub type DevicerequestCode{
DevicerequestCodeReference(code: Reference)
DevicerequestCodeCodeableconcept(code: Codeableconcept)}
pub fn devicerequest_code_to_json(elt: DevicerequestCode) -> Json {case elt{DevicerequestCodeReference(v) -> reference_to_json(v)
DevicerequestCodeCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn devicerequest_code_decoder() -> Decoder(DevicerequestCode){decode.one_of(decode.field("codeReference", reference_decoder(), decode.success) |> decode.map(DevicerequestCodeReference),[decode.field("codeCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(DevicerequestCodeCodeableconcept),])}

///http://hl7.org/fhir/r4/StructureDefinition/DeviceRequest#resource
pub type DevicerequestOccurrence{
DevicerequestOccurrenceDatetime(occurrence: String)
DevicerequestOccurrencePeriod(occurrence: Period)
DevicerequestOccurrenceTiming(occurrence: Timing)}
pub fn devicerequest_occurrence_to_json(elt: DevicerequestOccurrence) -> Json {case elt{DevicerequestOccurrenceDatetime(v) -> json.string(v)
DevicerequestOccurrencePeriod(v) -> period_to_json(v)
DevicerequestOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn devicerequest_occurrence_decoder() -> Decoder(DevicerequestOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(DevicerequestOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(DevicerequestOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(DevicerequestOccurrenceTiming),])}
pub fn devicerequest_new(subject subject: Reference,code code: DevicerequestCode,intent intent: r4valuesets.Requestintent,) ->Devicerequest{Devicerequest(relevant_history: [],note: [],supporting_info: [],insurance: [],reason_reference: [],reason_code: [],performer: None,performer_type: None,requester: None,authored_on: None,occurrence: None,encounter: None,subject:,parameter: [],code:,priority: None,intent:,status: None,group_identifier: None,prior_request: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameter
{
DevicerequestParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
value: Option(DevicerequestParameterValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameterValue{
DevicerequestParameterValueCodeableconcept(value: Codeableconcept)
DevicerequestParameterValueQuantity(value: Quantity)
DevicerequestParameterValueRange(value: Range)
DevicerequestParameterValueBoolean(value: Bool)}
pub fn devicerequest_parameter_value_to_json(elt: DevicerequestParameterValue) -> Json {case elt{DevicerequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
DevicerequestParameterValueQuantity(v) -> quantity_to_json(v)
DevicerequestParameterValueRange(v) -> range_to_json(v)
DevicerequestParameterValueBoolean(v) -> json.bool(v)
}}
pub fn devicerequest_parameter_value_decoder() -> Decoder(DevicerequestParameterValue){decode.one_of(decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(DevicerequestParameterValueCodeableconcept),[decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(DevicerequestParameterValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(DevicerequestParameterValueRange),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(DevicerequestParameterValueBoolean),])}
pub fn devicerequest_parameter_new() ->DevicerequestParameter{DevicerequestParameter(value: None,code: None,modifier_extension: [],extension: [],id: None,)
}

pub fn devicerequest_parameter_to_json(devicerequest_parameter: DevicerequestParameter) -> Json {
    let DevicerequestParameter(value:,code:,modifier_extension:,extension:,id:,) = devicerequest_parameter
    let fields = []
let fields = case value {
                          Some(v) -> [#("value", devicerequest_parameter_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicerequest_parameter_decoder() -> Decoder(DevicerequestParameter) {use value <- decode.then(none_if_omitted(devicerequest_parameter_value_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DevicerequestParameter(value:,code:,modifier_extension:,extension:,id:,))}
pub fn devicerequest_to_json(devicerequest: Devicerequest) -> Json {
    let Devicerequest(relevant_history:,note:,supporting_info:,insurance:,reason_reference:,reason_code:,performer:,performer_type:,requester:,authored_on:,occurrence:,encounter:,subject:,parameter:,code:,priority:,intent:,status:,group_identifier:,prior_request:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = devicerequest
    let fields = [#("subject", reference_to_json(subject)),#("code", devicerequest_code_to_json(code)),#("intent", r4valuesets.requestintent_to_json(intent)),]
let fields = case relevant_history {
                        [] -> fields
                        _ -> [#("relevantHistory", json.array(relevant_history,reference_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,reference_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer_type {
                          Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", devicerequest_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,devicerequest_parameter_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.requeststatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case group_identifier {
                          Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case prior_request {
                        [] -> fields
                        _ -> [#("priorRequest", json.array(prior_request,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn devicerequest_decoder() -> Decoder(Devicerequest) {use relevant_history <- decode.optional_field("relevantHistory", [], decode.list(reference_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(reference_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use performer_type <- decode.optional_field("performerType", None, decode.optional(codeableconcept_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use occurrence <- decode.then(none_if_omitted(devicerequest_occurrence_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use parameter <- decode.optional_field("parameter", [], decode.list(devicerequest_parameter_decoder()))
use code <- decode.then(devicerequest_code_decoder())
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use intent <- decode.field("intent",r4valuesets.requestintent_decoder())
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.requeststatus_decoder()))
use group_identifier <- decode.optional_field("groupIdentifier", None, decode.optional(identifier_decoder()))
use prior_request <- decode.optional_field("priorRequest", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Devicerequest(relevant_history:,note:,supporting_info:,insurance:,reason_reference:,reason_code:,performer:,performer_type:,requester:,authored_on:,occurrence:,encounter:,subject:,parameter:,code:,priority:,intent:,status:,group_identifier:,prior_request:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DeviceUseStatement#resource
pub type Deviceusestatement
{
Deviceusestatement(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
status: r4valuesets.Devicestatementstatus,
subject: Reference,
derived_from: List(Reference),
timing: Option(DeviceusestatementTiming),
recorded_on: Option(String),
source: Option(Reference),
device: Reference,
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
body_site: Option(Codeableconcept),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DeviceUseStatement#resource
pub type DeviceusestatementTiming{
DeviceusestatementTimingTiming(timing: Timing)
DeviceusestatementTimingPeriod(timing: Period)
DeviceusestatementTimingDatetime(timing: String)}
pub fn deviceusestatement_timing_to_json(elt: DeviceusestatementTiming) -> Json {case elt{DeviceusestatementTimingTiming(v) -> timing_to_json(v)
DeviceusestatementTimingPeriod(v) -> period_to_json(v)
DeviceusestatementTimingDatetime(v) -> json.string(v)
}}
pub fn deviceusestatement_timing_decoder() -> Decoder(DeviceusestatementTiming){decode.one_of(decode.field("timingTiming", timing_decoder(), decode.success) |> decode.map(DeviceusestatementTimingTiming),[decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(DeviceusestatementTimingPeriod),decode.field("timingDateTime", decode.string, decode.success) |> decode.map(DeviceusestatementTimingDatetime),])}
pub fn deviceusestatement_new(device device: Reference,subject subject: Reference,status status: r4valuesets.Devicestatementstatus,) ->Deviceusestatement{Deviceusestatement(note: [],body_site: None,reason_reference: [],reason_code: [],device:,source: None,recorded_on: None,timing: None,derived_from: [],subject:,status:,based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn deviceusestatement_to_json(deviceusestatement: Deviceusestatement) -> Json {
    let Deviceusestatement(note:,body_site:,reason_reference:,reason_code:,device:,source:,recorded_on:,timing:,derived_from:,subject:,status:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = deviceusestatement
    let fields = [#("device", reference_to_json(device)),#("subject", reference_to_json(subject)),#("status", r4valuesets.devicestatementstatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorded_on {
                          Some(v) -> [#("recordedOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case timing {
                          Some(v) -> [#("timing", deviceusestatement_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case derived_from {
                        [] -> fields
                        _ -> [#("derivedFrom", json.array(derived_from,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn deviceusestatement_decoder() -> Decoder(Deviceusestatement) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use device <- decode.field("device",reference_decoder())
use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use recorded_on <- decode.optional_field("recordedOn", None, decode.optional(decode.string))
use timing <- decode.then(none_if_omitted(deviceusestatement_timing_decoder()))
use derived_from <- decode.optional_field("derivedFrom", [], decode.list(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use status <- decode.field("status",r4valuesets.devicestatementstatus_decoder())
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Deviceusestatement(note:,body_site:,reason_reference:,reason_code:,device:,source:,recorded_on:,timing:,derived_from:,subject:,status:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DiagnosticReport#resource
pub type Diagnosticreport
{
Diagnosticreport(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
status: r4valuesets.Diagnosticreportstatus,
category: List(Codeableconcept),
code: Codeableconcept,
subject: Option(Reference),
encounter: Option(Reference),
effective: Option(DiagnosticreportEffective),
issued: Option(String),
performer: List(Reference),
results_interpreter: List(Reference),
specimen: List(Reference),
result: List(Reference),
imaging_study: List(Reference),
media: List(DiagnosticreportMedia),
conclusion: Option(String),
conclusion_code: List(Codeableconcept),
presented_form: List(Attachment),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportEffective{
DiagnosticreportEffectiveDatetime(effective: String)
DiagnosticreportEffectivePeriod(effective: Period)}
pub fn diagnosticreport_effective_to_json(elt: DiagnosticreportEffective) -> Json {case elt{DiagnosticreportEffectiveDatetime(v) -> json.string(v)
DiagnosticreportEffectivePeriod(v) -> period_to_json(v)
}}
pub fn diagnosticreport_effective_decoder() -> Decoder(DiagnosticreportEffective){decode.one_of(decode.field("effectiveDateTime", decode.string, decode.success) |> decode.map(DiagnosticreportEffectiveDatetime),[decode.field("effectivePeriod", period_decoder(), decode.success) |> decode.map(DiagnosticreportEffectivePeriod),])}
pub fn diagnosticreport_new(code code: Codeableconcept,status status: r4valuesets.Diagnosticreportstatus,) ->Diagnosticreport{Diagnosticreport(presented_form: [],conclusion_code: [],conclusion: None,media: [],imaging_study: [],result: [],specimen: [],results_interpreter: [],performer: [],issued: None,effective: None,encounter: None,subject: None,code:,category: [],status:,based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportMedia
{
DiagnosticreportMedia(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
comment: Option(String),
link: Reference,
)
}

pub fn diagnosticreport_media_new(link link: Reference,) ->DiagnosticreportMedia{DiagnosticreportMedia(link:,comment: None,modifier_extension: [],extension: [],id: None,)
}

pub fn diagnosticreport_media_to_json(diagnosticreport_media: DiagnosticreportMedia) -> Json {
    let DiagnosticreportMedia(link:,comment:,modifier_extension:,extension:,id:,) = diagnosticreport_media
    let fields = [#("link", reference_to_json(link)),]
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn diagnosticreport_media_decoder() -> Decoder(DiagnosticreportMedia) {use link <- decode.field("link",reference_decoder())
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DiagnosticreportMedia(link:,comment:,modifier_extension:,extension:,id:,))}
pub fn diagnosticreport_to_json(diagnosticreport: Diagnosticreport) -> Json {
    let Diagnosticreport(presented_form:,conclusion_code:,conclusion:,media:,imaging_study:,result:,specimen:,results_interpreter:,performer:,issued:,effective:,encounter:,subject:,code:,category:,status:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = diagnosticreport
    let fields = [#("code", codeableconcept_to_json(code)),#("status", r4valuesets.diagnosticreportstatus_to_json(status)),]
let fields = case presented_form {
                        [] -> fields
                        _ -> [#("presentedForm", json.array(presented_form,attachment_to_json)), ..fields]
                          }
let fields = case conclusion_code {
                        [] -> fields
                        _ -> [#("conclusionCode", json.array(conclusion_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case conclusion {
                          Some(v) -> [#("conclusion", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case media {
                        [] -> fields
                        _ -> [#("media", json.array(media,diagnosticreport_media_to_json)), ..fields]
                          }
let fields = case imaging_study {
                        [] -> fields
                        _ -> [#("imagingStudy", json.array(imaging_study,reference_to_json)), ..fields]
                          }
let fields = case result {
                        [] -> fields
                        _ -> [#("result", json.array(result,reference_to_json)), ..fields]
                          }
let fields = case specimen {
                        [] -> fields
                        _ -> [#("specimen", json.array(specimen,reference_to_json)), ..fields]
                          }
let fields = case results_interpreter {
                        [] -> fields
                        _ -> [#("resultsInterpreter", json.array(results_interpreter,reference_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,reference_to_json)), ..fields]
                          }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case effective {
                          Some(v) -> [#("effective", diagnosticreport_effective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn diagnosticreport_decoder() -> Decoder(Diagnosticreport) {use presented_form <- decode.optional_field("presentedForm", [], decode.list(attachment_decoder()))
use conclusion_code <- decode.optional_field("conclusionCode", [], decode.list(codeableconcept_decoder()))
use conclusion <- decode.optional_field("conclusion", None, decode.optional(decode.string))
use media <- decode.optional_field("media", [], decode.list(diagnosticreport_media_decoder()))
use imaging_study <- decode.optional_field("imagingStudy", [], decode.list(reference_decoder()))
use result <- decode.optional_field("result", [], decode.list(reference_decoder()))
use specimen <- decode.optional_field("specimen", [], decode.list(reference_decoder()))
use results_interpreter <- decode.optional_field("resultsInterpreter", [], decode.list(reference_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(reference_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use effective <- decode.then(none_if_omitted(diagnosticreport_effective_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.diagnosticreportstatus_decoder())
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Diagnosticreport(presented_form:,conclusion_code:,conclusion:,media:,imaging_study:,result:,specimen:,results_interpreter:,performer:,issued:,effective:,encounter:,subject:,code:,category:,status:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentManifest#resource
pub type Documentmanifest
{
Documentmanifest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
master_identifier: Option(Identifier),
identifier: List(Identifier),
status: r4valuesets.Documentreferencestatus,
type_: Option(Codeableconcept),
subject: Option(Reference),
created: Option(String),
author: List(Reference),
recipient: List(Reference),
source: Option(String),
description: Option(String),
content: List(Reference),
related: List(DocumentmanifestRelated),
)
}

pub fn documentmanifest_new(status status: r4valuesets.Documentreferencestatus,) ->Documentmanifest{Documentmanifest(related: [],content: [],description: None,source: None,recipient: [],author: [],created: None,subject: None,type_: None,status:,identifier: [],master_identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentManifest#resource
pub type DocumentmanifestRelated
{
DocumentmanifestRelated(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
ref: Option(Reference),
)
}

pub fn documentmanifest_related_new() ->DocumentmanifestRelated{DocumentmanifestRelated(ref: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}

pub fn documentmanifest_related_to_json(documentmanifest_related: DocumentmanifestRelated) -> Json {
    let DocumentmanifestRelated(ref:,identifier:,modifier_extension:,extension:,id:,) = documentmanifest_related
    let fields = []
let fields = case ref {
                          Some(v) -> [#("ref", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentmanifest_related_decoder() -> Decoder(DocumentmanifestRelated) {use ref <- decode.optional_field("ref", None, decode.optional(reference_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DocumentmanifestRelated(ref:,identifier:,modifier_extension:,extension:,id:,))}
pub fn documentmanifest_to_json(documentmanifest: Documentmanifest) -> Json {
    let Documentmanifest(related:,content:,description:,source:,recipient:,author:,created:,subject:,type_:,status:,identifier:,master_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = documentmanifest
    let fields = [#("status", r4valuesets.documentreferencestatus_to_json(status)),]
let fields = case related {
                        [] -> fields
                        _ -> [#("related", json.array(related,documentmanifest_related_to_json)), ..fields]
                          }
let fields = case content {
                        [] -> fields
                        _ -> [#("content", json.array(content,reference_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case recipient {
                        [] -> fields
                        _ -> [#("recipient", json.array(recipient,reference_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,reference_to_json)), ..fields]
                          }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case master_identifier {
                          Some(v) -> [#("masterIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentmanifest_decoder() -> Decoder(Documentmanifest) {use related <- decode.optional_field("related", [], decode.list(documentmanifest_related_decoder()))
use content <- decode.optional_field("content", [], decode.list(reference_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use source <- decode.optional_field("source", None, decode.optional(decode.string))
use recipient <- decode.optional_field("recipient", [], decode.list(reference_decoder()))
use author <- decode.optional_field("author", [], decode.list(reference_decoder()))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.documentreferencestatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use master_identifier <- decode.optional_field("masterIdentifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Documentmanifest(related:,content:,description:,source:,recipient:,author:,created:,subject:,type_:,status:,identifier:,master_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentReference#resource
pub type Documentreference
{
Documentreference(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
master_identifier: Option(Identifier),
identifier: List(Identifier),
status: r4valuesets.Documentreferencestatus,
doc_status: Option(r4valuesets.Compositionstatus),
type_: Option(Codeableconcept),
category: List(Codeableconcept),
subject: Option(Reference),
date: Option(String),
author: List(Reference),
authenticator: Option(Reference),
custodian: Option(Reference),
relates_to: List(DocumentreferenceRelatesto),
description: Option(String),
security_label: List(Codeableconcept),
content: List(DocumentreferenceContent),
context: Option(DocumentreferenceContext),
)
}

pub fn documentreference_new(status status: r4valuesets.Documentreferencestatus,) ->Documentreference{Documentreference(context: None,content: [],security_label: [],description: None,relates_to: [],custodian: None,authenticator: None,author: [],date: None,subject: None,category: [],type_: None,doc_status: None,status:,identifier: [],master_identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceRelatesto
{
DocumentreferenceRelatesto(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Documentrelationshiptype,
target: Reference,
)
}

pub fn documentreference_relatesto_new(target target: Reference,code code: r4valuesets.Documentrelationshiptype,) ->DocumentreferenceRelatesto{DocumentreferenceRelatesto(target:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContent
{
DocumentreferenceContent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
attachment: Attachment,
format: Option(Coding),
)
}

pub fn documentreference_content_new(attachment attachment: Attachment,) ->DocumentreferenceContent{DocumentreferenceContent(format: None,attachment:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContext
{
DocumentreferenceContext(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
encounter: List(Reference),
event: List(Codeableconcept),
period: Option(Period),
facility_type: Option(Codeableconcept),
practice_setting: Option(Codeableconcept),
source_patient_info: Option(Reference),
related: List(Reference),
)
}

pub fn documentreference_context_new() ->DocumentreferenceContext{DocumentreferenceContext(related: [],source_patient_info: None,practice_setting: None,facility_type: None,period: None,event: [],encounter: [],modifier_extension: [],extension: [],id: None,)
}

pub fn documentreference_context_to_json(documentreference_context: DocumentreferenceContext) -> Json {
    let DocumentreferenceContext(related:,source_patient_info:,practice_setting:,facility_type:,period:,event:,encounter:,modifier_extension:,extension:,id:,) = documentreference_context
    let fields = []
let fields = case related {
                        [] -> fields
                        _ -> [#("related", json.array(related,reference_to_json)), ..fields]
                          }
let fields = case source_patient_info {
                          Some(v) -> [#("sourcePatientInfo", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case practice_setting {
                          Some(v) -> [#("practiceSetting", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case facility_type {
                          Some(v) -> [#("facilityType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case event {
                        [] -> fields
                        _ -> [#("event", json.array(event,codeableconcept_to_json)), ..fields]
                          }
let fields = case encounter {
                        [] -> fields
                        _ -> [#("encounter", json.array(encounter,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentreference_context_decoder() -> Decoder(DocumentreferenceContext) {use related <- decode.optional_field("related", [], decode.list(reference_decoder()))
use source_patient_info <- decode.optional_field("sourcePatientInfo", None, decode.optional(reference_decoder()))
use practice_setting <- decode.optional_field("practiceSetting", None, decode.optional(codeableconcept_decoder()))
use facility_type <- decode.optional_field("facilityType", None, decode.optional(codeableconcept_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use event <- decode.optional_field("event", [], decode.list(codeableconcept_decoder()))
use encounter <- decode.optional_field("encounter", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DocumentreferenceContext(related:,source_patient_info:,practice_setting:,facility_type:,period:,event:,encounter:,modifier_extension:,extension:,id:,))}
pub fn documentreference_content_to_json(documentreference_content: DocumentreferenceContent) -> Json {
    let DocumentreferenceContent(format:,attachment:,modifier_extension:,extension:,id:,) = documentreference_content
    let fields = [#("attachment", attachment_to_json(attachment)),]
let fields = case format {
                          Some(v) -> [#("format", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentreference_content_decoder() -> Decoder(DocumentreferenceContent) {use format <- decode.optional_field("format", None, decode.optional(coding_decoder()))
use attachment <- decode.field("attachment",attachment_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DocumentreferenceContent(format:,attachment:,modifier_extension:,extension:,id:,))}
pub fn documentreference_relatesto_to_json(documentreference_relatesto: DocumentreferenceRelatesto) -> Json {
    let DocumentreferenceRelatesto(target:,code:,modifier_extension:,extension:,id:,) = documentreference_relatesto
    let fields = [#("target", reference_to_json(target)),#("code", r4valuesets.documentrelationshiptype_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentreference_relatesto_decoder() -> Decoder(DocumentreferenceRelatesto) {use target <- decode.field("target",reference_decoder())
use code <- decode.field("code",r4valuesets.documentrelationshiptype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(DocumentreferenceRelatesto(target:,code:,modifier_extension:,extension:,id:,))}
pub fn documentreference_to_json(documentreference: Documentreference) -> Json {
    let Documentreference(context:,content:,security_label:,description:,relates_to:,custodian:,authenticator:,author:,date:,subject:,category:,type_:,doc_status:,status:,identifier:,master_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = documentreference
    let fields = [#("status", r4valuesets.documentreferencestatus_to_json(status)),]
let fields = case context {
                          Some(v) -> [#("context", documentreference_context_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case content {
                        [] -> fields
                        _ -> [#("content", json.array(content,documentreference_content_to_json)), ..fields]
                          }
let fields = case security_label {
                        [] -> fields
                        _ -> [#("securityLabel", json.array(security_label,codeableconcept_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case relates_to {
                        [] -> fields
                        _ -> [#("relatesTo", json.array(relates_to,documentreference_relatesto_to_json)), ..fields]
                          }
let fields = case custodian {
                          Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authenticator {
                          Some(v) -> [#("authenticator", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,reference_to_json)), ..fields]
                          }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case doc_status {
                          Some(v) -> [#("docStatus", r4valuesets.compositionstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case master_identifier {
                          Some(v) -> [#("masterIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn documentreference_decoder() -> Decoder(Documentreference) {use context <- decode.optional_field("context", None, decode.optional(documentreference_context_decoder()))
use content <- decode.optional_field("content", [], decode.list(documentreference_content_decoder()))
use security_label <- decode.optional_field("securityLabel", [], decode.list(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use relates_to <- decode.optional_field("relatesTo", [], decode.list(documentreference_relatesto_decoder()))
use custodian <- decode.optional_field("custodian", None, decode.optional(reference_decoder()))
use authenticator <- decode.optional_field("authenticator", None, decode.optional(reference_decoder()))
use author <- decode.optional_field("author", [], decode.list(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use doc_status <- decode.optional_field("docStatus", None, decode.optional(r4valuesets.compositionstatus_decoder()))
use status <- decode.field("status",r4valuesets.documentreferencestatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use master_identifier <- decode.optional_field("masterIdentifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Documentreference(context:,content:,security_label:,description:,relates_to:,custodian:,authenticator:,author:,date:,subject:,category:,type_:,doc_status:,status:,identifier:,master_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/DomainResource#resource
pub type Domainresource
{
Domainresource(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
)
}

pub fn domainresource_new() ->Domainresource{Domainresource(modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn domainresource_to_json(domainresource: Domainresource) -> Json {
    let Domainresource(modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = domainresource
    let fields = []
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn domainresource_decoder() -> Decoder(Domainresource) {use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Domainresource(modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type Effectevidencesynthesis
{
Effectevidencesynthesis(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
note: List(Annotation),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
synthesis_type: Option(Codeableconcept),
study_type: Option(Codeableconcept),
population: Reference,
exposure: Reference,
exposure_alternative: Reference,
outcome: Reference,
sample_size: Option(EffectevidencesynthesisSamplesize),
results_by_exposure: List(EffectevidencesynthesisResultsbyexposure),
effect_estimate: List(EffectevidencesynthesisEffectestimate),
certainty: List(EffectevidencesynthesisCertainty),
)
}

pub fn effectevidencesynthesis_new(outcome outcome: Reference,exposure_alternative exposure_alternative: Reference,exposure exposure: Reference,population population: Reference,status status: r4valuesets.Publicationstatus,) ->Effectevidencesynthesis{Effectevidencesynthesis(certainty: [],effect_estimate: [],results_by_exposure: [],sample_size: None,outcome:,exposure_alternative:,exposure:,population:,study_type: None,synthesis_type: None,related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,jurisdiction: [],use_context: [],note: [],description: None,contact: [],publisher: None,date: None,status:,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisSamplesize
{
EffectevidencesynthesisSamplesize(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
number_of_studies: Option(Int),
number_of_participants: Option(Int),
)
}

pub fn effectevidencesynthesis_samplesize_new() ->EffectevidencesynthesisSamplesize{EffectevidencesynthesisSamplesize(number_of_participants: None,number_of_studies: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisResultsbyexposure
{
EffectevidencesynthesisResultsbyexposure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
exposure_state: Option(r4valuesets.Exposurestate),
variant_state: Option(Codeableconcept),
risk_evidence_synthesis: Reference,
)
}

pub fn effectevidencesynthesis_resultsbyexposure_new(risk_evidence_synthesis risk_evidence_synthesis: Reference,) ->EffectevidencesynthesisResultsbyexposure{EffectevidencesynthesisResultsbyexposure(risk_evidence_synthesis:,variant_state: None,exposure_state: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisEffectestimate
{
EffectevidencesynthesisEffectestimate(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
type_: Option(Codeableconcept),
variant_state: Option(Codeableconcept),
value: Option(Float),
unit_of_measure: Option(Codeableconcept),
precision_estimate: List(EffectevidencesynthesisEffectestimatePrecisionestimate),
)
}

pub fn effectevidencesynthesis_effectestimate_new() ->EffectevidencesynthesisEffectestimate{EffectevidencesynthesisEffectestimate(precision_estimate: [],unit_of_measure: None,value: None,variant_state: None,type_: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisEffectestimatePrecisionestimate
{
EffectevidencesynthesisEffectestimatePrecisionestimate(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
level: Option(Float),
from: Option(Float),
to: Option(Float),
)
}

pub fn effectevidencesynthesis_effectestimate_precisionestimate_new() ->EffectevidencesynthesisEffectestimatePrecisionestimate{EffectevidencesynthesisEffectestimatePrecisionestimate(to: None,from: None,level: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisCertainty
{
EffectevidencesynthesisCertainty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
rating: List(Codeableconcept),
note: List(Annotation),
certainty_subcomponent: List(EffectevidencesynthesisCertaintyCertaintysubcomponent),
)
}

pub fn effectevidencesynthesis_certainty_new() ->EffectevidencesynthesisCertainty{EffectevidencesynthesisCertainty(certainty_subcomponent: [],note: [],rating: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EffectEvidenceSynthesis#resource
pub type EffectevidencesynthesisCertaintyCertaintysubcomponent
{
EffectevidencesynthesisCertaintyCertaintysubcomponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
rating: List(Codeableconcept),
note: List(Annotation),
)
}

pub fn effectevidencesynthesis_certainty_certaintysubcomponent_new() ->EffectevidencesynthesisCertaintyCertaintysubcomponent{EffectevidencesynthesisCertaintyCertaintysubcomponent(note: [],rating: [],type_: None,modifier_extension: [],extension: [],id: None,)
}

pub fn effectevidencesynthesis_certainty_certaintysubcomponent_to_json(effectevidencesynthesis_certainty_certaintysubcomponent: EffectevidencesynthesisCertaintyCertaintysubcomponent) -> Json {
    let EffectevidencesynthesisCertaintyCertaintysubcomponent(note:,rating:,type_:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_certainty_certaintysubcomponent
    let fields = []
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case rating {
                        [] -> fields
                        _ -> [#("rating", json.array(rating,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_certainty_certaintysubcomponent_decoder() -> Decoder(EffectevidencesynthesisCertaintyCertaintysubcomponent) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use rating <- decode.optional_field("rating", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisCertaintyCertaintysubcomponent(note:,rating:,type_:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_certainty_to_json(effectevidencesynthesis_certainty: EffectevidencesynthesisCertainty) -> Json {
    let EffectevidencesynthesisCertainty(certainty_subcomponent:,note:,rating:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_certainty
    let fields = []
let fields = case certainty_subcomponent {
                        [] -> fields
                        _ -> [#("certaintySubcomponent", json.array(certainty_subcomponent,effectevidencesynthesis_certainty_certaintysubcomponent_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case rating {
                        [] -> fields
                        _ -> [#("rating", json.array(rating,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_certainty_decoder() -> Decoder(EffectevidencesynthesisCertainty) {use certainty_subcomponent <- decode.optional_field("certaintySubcomponent", [], decode.list(effectevidencesynthesis_certainty_certaintysubcomponent_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use rating <- decode.optional_field("rating", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisCertainty(certainty_subcomponent:,note:,rating:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_effectestimate_precisionestimate_to_json(effectevidencesynthesis_effectestimate_precisionestimate: EffectevidencesynthesisEffectestimatePrecisionestimate) -> Json {
    let EffectevidencesynthesisEffectestimatePrecisionestimate(to:,from:,level:,type_:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_effectestimate_precisionestimate
    let fields = []
let fields = case to {
                          Some(v) -> [#("to", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case from {
                          Some(v) -> [#("from", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case level {
                          Some(v) -> [#("level", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_effectestimate_precisionestimate_decoder() -> Decoder(EffectevidencesynthesisEffectestimatePrecisionestimate) {use to <- decode.optional_field("to", None, decode.optional(decode.float))
use from <- decode.optional_field("from", None, decode.optional(decode.float))
use level <- decode.optional_field("level", None, decode.optional(decode.float))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisEffectestimatePrecisionestimate(to:,from:,level:,type_:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_effectestimate_to_json(effectevidencesynthesis_effectestimate: EffectevidencesynthesisEffectestimate) -> Json {
    let EffectevidencesynthesisEffectestimate(precision_estimate:,unit_of_measure:,value:,variant_state:,type_:,description:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_effectestimate
    let fields = []
let fields = case precision_estimate {
                        [] -> fields
                        _ -> [#("precisionEstimate", json.array(precision_estimate,effectevidencesynthesis_effectestimate_precisionestimate_to_json)), ..fields]
                          }
let fields = case unit_of_measure {
                          Some(v) -> [#("unitOfMeasure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case variant_state {
                          Some(v) -> [#("variantState", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_effectestimate_decoder() -> Decoder(EffectevidencesynthesisEffectestimate) {use precision_estimate <- decode.optional_field("precisionEstimate", [], decode.list(effectevidencesynthesis_effectestimate_precisionestimate_decoder()))
use unit_of_measure <- decode.optional_field("unitOfMeasure", None, decode.optional(codeableconcept_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use variant_state <- decode.optional_field("variantState", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisEffectestimate(precision_estimate:,unit_of_measure:,value:,variant_state:,type_:,description:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_resultsbyexposure_to_json(effectevidencesynthesis_resultsbyexposure: EffectevidencesynthesisResultsbyexposure) -> Json {
    let EffectevidencesynthesisResultsbyexposure(risk_evidence_synthesis:,variant_state:,exposure_state:,description:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_resultsbyexposure
    let fields = [#("riskEvidenceSynthesis", reference_to_json(risk_evidence_synthesis)),]
let fields = case variant_state {
                          Some(v) -> [#("variantState", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exposure_state {
                          Some(v) -> [#("exposureState", r4valuesets.exposurestate_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_resultsbyexposure_decoder() -> Decoder(EffectevidencesynthesisResultsbyexposure) {use risk_evidence_synthesis <- decode.field("riskEvidenceSynthesis",reference_decoder())
use variant_state <- decode.optional_field("variantState", None, decode.optional(codeableconcept_decoder()))
use exposure_state <- decode.optional_field("exposureState", None, decode.optional(r4valuesets.exposurestate_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisResultsbyexposure(risk_evidence_synthesis:,variant_state:,exposure_state:,description:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_samplesize_to_json(effectevidencesynthesis_samplesize: EffectevidencesynthesisSamplesize) -> Json {
    let EffectevidencesynthesisSamplesize(number_of_participants:,number_of_studies:,description:,modifier_extension:,extension:,id:,) = effectevidencesynthesis_samplesize
    let fields = []
let fields = case number_of_participants {
                          Some(v) -> [#("numberOfParticipants", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_studies {
                          Some(v) -> [#("numberOfStudies", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_samplesize_decoder() -> Decoder(EffectevidencesynthesisSamplesize) {use number_of_participants <- decode.optional_field("numberOfParticipants", None, decode.optional(decode.int))
use number_of_studies <- decode.optional_field("numberOfStudies", None, decode.optional(decode.int))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EffectevidencesynthesisSamplesize(number_of_participants:,number_of_studies:,description:,modifier_extension:,extension:,id:,))}
pub fn effectevidencesynthesis_to_json(effectevidencesynthesis: Effectevidencesynthesis) -> Json {
    let Effectevidencesynthesis(certainty:,effect_estimate:,results_by_exposure:,sample_size:,outcome:,exposure_alternative:,exposure:,population:,study_type:,synthesis_type:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = effectevidencesynthesis
    let fields = [#("outcome", reference_to_json(outcome)),#("exposureAlternative", reference_to_json(exposure_alternative)),#("exposure", reference_to_json(exposure)),#("population", reference_to_json(population)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case certainty {
                        [] -> fields
                        _ -> [#("certainty", json.array(certainty,effectevidencesynthesis_certainty_to_json)), ..fields]
                          }
let fields = case effect_estimate {
                        [] -> fields
                        _ -> [#("effectEstimate", json.array(effect_estimate,effectevidencesynthesis_effectestimate_to_json)), ..fields]
                          }
let fields = case results_by_exposure {
                        [] -> fields
                        _ -> [#("resultsByExposure", json.array(results_by_exposure,effectevidencesynthesis_resultsbyexposure_to_json)), ..fields]
                          }
let fields = case sample_size {
                          Some(v) -> [#("sampleSize", effectevidencesynthesis_samplesize_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case study_type {
                          Some(v) -> [#("studyType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case synthesis_type {
                          Some(v) -> [#("synthesisType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn effectevidencesynthesis_decoder() -> Decoder(Effectevidencesynthesis) {use certainty <- decode.optional_field("certainty", [], decode.list(effectevidencesynthesis_certainty_decoder()))
use effect_estimate <- decode.optional_field("effectEstimate", [], decode.list(effectevidencesynthesis_effectestimate_decoder()))
use results_by_exposure <- decode.optional_field("resultsByExposure", [], decode.list(effectevidencesynthesis_resultsbyexposure_decoder()))
use sample_size <- decode.optional_field("sampleSize", None, decode.optional(effectevidencesynthesis_samplesize_decoder()))
use outcome <- decode.field("outcome",reference_decoder())
use exposure_alternative <- decode.field("exposureAlternative",reference_decoder())
use exposure <- decode.field("exposure",reference_decoder())
use population <- decode.field("population",reference_decoder())
use study_type <- decode.optional_field("studyType", None, decode.optional(codeableconcept_decoder()))
use synthesis_type <- decode.optional_field("synthesisType", None, decode.optional(codeableconcept_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Effectevidencesynthesis(certainty:,effect_estimate:,results_by_exposure:,sample_size:,outcome:,exposure_alternative:,exposure:,population:,study_type:,synthesis_type:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type Encounter
{
Encounter(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Encounterstatus,
status_history: List(EncounterStatushistory),
class: Coding,
class_history: List(EncounterClasshistory),
type_: List(Codeableconcept),
service_type: Option(Codeableconcept),
priority: Option(Codeableconcept),
subject: Option(Reference),
episode_of_care: List(Reference),
based_on: List(Reference),
participant: List(EncounterParticipant),
appointment: List(Reference),
period: Option(Period),
length: Option(Duration),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
diagnosis: List(EncounterDiagnosis),
account: List(Reference),
hospitalization: Option(EncounterHospitalization),
location: List(EncounterLocation),
service_provider: Option(Reference),
part_of: Option(Reference),
)
}

pub fn encounter_new(class class: Coding,status status: r4valuesets.Encounterstatus,) ->Encounter{Encounter(part_of: None,service_provider: None,location: [],hospitalization: None,account: [],diagnosis: [],reason_reference: [],reason_code: [],length: None,period: None,appointment: [],participant: [],based_on: [],episode_of_care: [],subject: None,priority: None,service_type: None,type_: [],class_history: [],class:,status_history: [],status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterStatushistory
{
EncounterStatushistory(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
status: r4valuesets.Encounterstatus,
period: Period,
)
}

pub fn encounter_statushistory_new(period period: Period,status status: r4valuesets.Encounterstatus,) ->EncounterStatushistory{EncounterStatushistory(period:,status:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterClasshistory
{
EncounterClasshistory(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
class: Coding,
period: Period,
)
}

pub fn encounter_classhistory_new(period period: Period,class class: Coding,) ->EncounterClasshistory{EncounterClasshistory(period:,class:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterParticipant
{
EncounterParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: List(Codeableconcept),
period: Option(Period),
individual: Option(Reference),
)
}

pub fn encounter_participant_new() ->EncounterParticipant{EncounterParticipant(individual: None,period: None,type_: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterDiagnosis
{
EncounterDiagnosis(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
condition: Reference,
use_: Option(Codeableconcept),
rank: Option(Int),
)
}

pub fn encounter_diagnosis_new(condition condition: Reference,) ->EncounterDiagnosis{EncounterDiagnosis(rank: None,use_: None,condition:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterHospitalization
{
EncounterHospitalization(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
pre_admission_identifier: Option(Identifier),
origin: Option(Reference),
admit_source: Option(Codeableconcept),
re_admission: Option(Codeableconcept),
diet_preference: List(Codeableconcept),
special_courtesy: List(Codeableconcept),
special_arrangement: List(Codeableconcept),
destination: Option(Reference),
discharge_disposition: Option(Codeableconcept),
)
}

pub fn encounter_hospitalization_new() ->EncounterHospitalization{EncounterHospitalization(discharge_disposition: None,destination: None,special_arrangement: [],special_courtesy: [],diet_preference: [],re_admission: None,admit_source: None,origin: None,pre_admission_identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Encounter#resource
pub type EncounterLocation
{
EncounterLocation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
location: Reference,
status: Option(r4valuesets.Encounterlocationstatus),
physical_type: Option(Codeableconcept),
period: Option(Period),
)
}

pub fn encounter_location_new(location location: Reference,) ->EncounterLocation{EncounterLocation(period: None,physical_type: None,status: None,location:,modifier_extension: [],extension: [],id: None,)
}

pub fn encounter_location_to_json(encounter_location: EncounterLocation) -> Json {
    let EncounterLocation(period:,physical_type:,status:,location:,modifier_extension:,extension:,id:,) = encounter_location
    let fields = [#("location", reference_to_json(location)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case physical_type {
                          Some(v) -> [#("physicalType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.encounterlocationstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_location_decoder() -> Decoder(EncounterLocation) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use physical_type <- decode.optional_field("physicalType", None, decode.optional(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.encounterlocationstatus_decoder()))
use location <- decode.field("location",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterLocation(period:,physical_type:,status:,location:,modifier_extension:,extension:,id:,))}
pub fn encounter_hospitalization_to_json(encounter_hospitalization: EncounterHospitalization) -> Json {
    let EncounterHospitalization(discharge_disposition:,destination:,special_arrangement:,special_courtesy:,diet_preference:,re_admission:,admit_source:,origin:,pre_admission_identifier:,modifier_extension:,extension:,id:,) = encounter_hospitalization
    let fields = []
let fields = case discharge_disposition {
                          Some(v) -> [#("dischargeDisposition", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case destination {
                          Some(v) -> [#("destination", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case special_arrangement {
                        [] -> fields
                        _ -> [#("specialArrangement", json.array(special_arrangement,codeableconcept_to_json)), ..fields]
                          }
let fields = case special_courtesy {
                        [] -> fields
                        _ -> [#("specialCourtesy", json.array(special_courtesy,codeableconcept_to_json)), ..fields]
                          }
let fields = case diet_preference {
                        [] -> fields
                        _ -> [#("dietPreference", json.array(diet_preference,codeableconcept_to_json)), ..fields]
                          }
let fields = case re_admission {
                          Some(v) -> [#("reAdmission", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case admit_source {
                          Some(v) -> [#("admitSource", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case origin {
                          Some(v) -> [#("origin", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_admission_identifier {
                          Some(v) -> [#("preAdmissionIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_hospitalization_decoder() -> Decoder(EncounterHospitalization) {use discharge_disposition <- decode.optional_field("dischargeDisposition", None, decode.optional(codeableconcept_decoder()))
use destination <- decode.optional_field("destination", None, decode.optional(reference_decoder()))
use special_arrangement <- decode.optional_field("specialArrangement", [], decode.list(codeableconcept_decoder()))
use special_courtesy <- decode.optional_field("specialCourtesy", [], decode.list(codeableconcept_decoder()))
use diet_preference <- decode.optional_field("dietPreference", [], decode.list(codeableconcept_decoder()))
use re_admission <- decode.optional_field("reAdmission", None, decode.optional(codeableconcept_decoder()))
use admit_source <- decode.optional_field("admitSource", None, decode.optional(codeableconcept_decoder()))
use origin <- decode.optional_field("origin", None, decode.optional(reference_decoder()))
use pre_admission_identifier <- decode.optional_field("preAdmissionIdentifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterHospitalization(discharge_disposition:,destination:,special_arrangement:,special_courtesy:,diet_preference:,re_admission:,admit_source:,origin:,pre_admission_identifier:,modifier_extension:,extension:,id:,))}
pub fn encounter_diagnosis_to_json(encounter_diagnosis: EncounterDiagnosis) -> Json {
    let EncounterDiagnosis(rank:,use_:,condition:,modifier_extension:,extension:,id:,) = encounter_diagnosis
    let fields = [#("condition", reference_to_json(condition)),]
let fields = case rank {
                          Some(v) -> [#("rank", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case use_ {
                          Some(v) -> [#("use", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_diagnosis_decoder() -> Decoder(EncounterDiagnosis) {use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
use use_ <- decode.optional_field("use", None, decode.optional(codeableconcept_decoder()))
use condition <- decode.field("condition",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterDiagnosis(rank:,use_:,condition:,modifier_extension:,extension:,id:,))}
pub fn encounter_participant_to_json(encounter_participant: EncounterParticipant) -> Json {
    let EncounterParticipant(individual:,period:,type_:,modifier_extension:,extension:,id:,) = encounter_participant
    let fields = []
let fields = case individual {
                          Some(v) -> [#("individual", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_participant_decoder() -> Decoder(EncounterParticipant) {use individual <- decode.optional_field("individual", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterParticipant(individual:,period:,type_:,modifier_extension:,extension:,id:,))}
pub fn encounter_classhistory_to_json(encounter_classhistory: EncounterClasshistory) -> Json {
    let EncounterClasshistory(period:,class:,modifier_extension:,extension:,id:,) = encounter_classhistory
    let fields = [#("period", period_to_json(period)),#("class", coding_to_json(class)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_classhistory_decoder() -> Decoder(EncounterClasshistory) {use period <- decode.field("period",period_decoder())
use class <- decode.field("class",coding_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterClasshistory(period:,class:,modifier_extension:,extension:,id:,))}
pub fn encounter_statushistory_to_json(encounter_statushistory: EncounterStatushistory) -> Json {
    let EncounterStatushistory(period:,status:,modifier_extension:,extension:,id:,) = encounter_statushistory
    let fields = [#("period", period_to_json(period)),#("status", r4valuesets.encounterstatus_to_json(status)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_statushistory_decoder() -> Decoder(EncounterStatushistory) {use period <- decode.field("period",period_decoder())
use status <- decode.field("status",r4valuesets.encounterstatus_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EncounterStatushistory(period:,status:,modifier_extension:,extension:,id:,))}
pub fn encounter_to_json(encounter: Encounter) -> Json {
    let Encounter(part_of:,service_provider:,location:,hospitalization:,account:,diagnosis:,reason_reference:,reason_code:,length:,period:,appointment:,participant:,based_on:,episode_of_care:,subject:,priority:,service_type:,type_:,class_history:,class:,status_history:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = encounter
    let fields = [#("class", coding_to_json(class)),#("status", r4valuesets.encounterstatus_to_json(status)),]
let fields = case part_of {
                          Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case service_provider {
                          Some(v) -> [#("serviceProvider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,encounter_location_to_json)), ..fields]
                          }
let fields = case hospitalization {
                          Some(v) -> [#("hospitalization", encounter_hospitalization_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case account {
                        [] -> fields
                        _ -> [#("account", json.array(account,reference_to_json)), ..fields]
                          }
let fields = case diagnosis {
                        [] -> fields
                        _ -> [#("diagnosis", json.array(diagnosis,encounter_diagnosis_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case length {
                          Some(v) -> [#("length", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case appointment {
                        [] -> fields
                        _ -> [#("appointment", json.array(appointment,reference_to_json)), ..fields]
                          }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,encounter_participant_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case episode_of_care {
                        [] -> fields
                        _ -> [#("episodeOfCare", json.array(episode_of_care,reference_to_json)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case service_type {
                          Some(v) -> [#("serviceType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case class_history {
                        [] -> fields
                        _ -> [#("classHistory", json.array(class_history,encounter_classhistory_to_json)), ..fields]
                          }
let fields = case status_history {
                        [] -> fields
                        _ -> [#("statusHistory", json.array(status_history,encounter_statushistory_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn encounter_decoder() -> Decoder(Encounter) {use part_of <- decode.optional_field("partOf", None, decode.optional(reference_decoder()))
use service_provider <- decode.optional_field("serviceProvider", None, decode.optional(reference_decoder()))
use location <- decode.optional_field("location", [], decode.list(encounter_location_decoder()))
use hospitalization <- decode.optional_field("hospitalization", None, decode.optional(encounter_hospitalization_decoder()))
use account <- decode.optional_field("account", [], decode.list(reference_decoder()))
use diagnosis <- decode.optional_field("diagnosis", [], decode.list(encounter_diagnosis_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use length <- decode.optional_field("length", None, decode.optional(duration_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use appointment <- decode.optional_field("appointment", [], decode.list(reference_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(encounter_participant_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use episode_of_care <- decode.optional_field("episodeOfCare", [], decode.list(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(codeableconcept_decoder()))
use service_type <- decode.optional_field("serviceType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use class_history <- decode.optional_field("classHistory", [], decode.list(encounter_classhistory_decoder()))
use class <- decode.field("class",coding_decoder())
use status_history <- decode.optional_field("statusHistory", [], decode.list(encounter_statushistory_decoder()))
use status <- decode.field("status",r4valuesets.encounterstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Encounter(part_of:,service_provider:,location:,hospitalization:,account:,diagnosis:,reason_reference:,reason_code:,length:,period:,appointment:,participant:,based_on:,episode_of_care:,subject:,priority:,service_type:,type_:,class_history:,class:,status_history:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Endpoint#resource
pub type Endpoint
{
Endpoint(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Endpointstatus,
connection_type: Coding,
name: Option(String),
managing_organization: Option(Reference),
contact: List(Contactpoint),
period: Option(Period),
payload_type: List(Codeableconcept),
payload_mime_type: List(String),
address: String,
header: List(String),
)
}

pub fn endpoint_new(address address: String,connection_type connection_type: Coding,status status: r4valuesets.Endpointstatus,) ->Endpoint{Endpoint(header: [],address:,payload_mime_type: [],payload_type: [],period: None,contact: [],managing_organization: None,name: None,connection_type:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn endpoint_to_json(endpoint: Endpoint) -> Json {
    let Endpoint(header:,address:,payload_mime_type:,payload_type:,period:,contact:,managing_organization:,name:,connection_type:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = endpoint
    let fields = [#("address", json.string(address)),#("connectionType", coding_to_json(connection_type)),#("status", r4valuesets.endpointstatus_to_json(status)),]
let fields = case header {
                        [] -> fields
                        _ -> [#("header", json.array(header,json.string)), ..fields]
                          }
let fields = case payload_mime_type {
                        [] -> fields
                        _ -> [#("payloadMimeType", json.array(payload_mime_type,json.string)), ..fields]
                          }
let fields = case payload_type {
                        [] -> fields
                        _ -> [#("payloadType", json.array(payload_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactpoint_to_json)), ..fields]
                          }
let fields = case managing_organization {
                          Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn endpoint_decoder() -> Decoder(Endpoint) {use header <- decode.optional_field("header", [], decode.list(decode.string))
use address <- decode.field("address",decode.string)
use payload_mime_type <- decode.optional_field("payloadMimeType", [], decode.list(decode.string))
use payload_type <- decode.optional_field("payloadType", [], decode.list(codeableconcept_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(contactpoint_decoder()))
use managing_organization <- decode.optional_field("managingOrganization", None, decode.optional(reference_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use connection_type <- decode.field("connectionType",coding_decoder())
use status <- decode.field("status",r4valuesets.endpointstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Endpoint(header:,address:,payload_mime_type:,payload_type:,period:,contact:,managing_organization:,name:,connection_type:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EnrollmentRequest#resource
pub type Enrollmentrequest
{
Enrollmentrequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Fmstatus),
created: Option(String),
insurer: Option(Reference),
provider: Option(Reference),
candidate: Option(Reference),
coverage: Option(Reference),
)
}

pub fn enrollmentrequest_new() ->Enrollmentrequest{Enrollmentrequest(coverage: None,candidate: None,provider: None,insurer: None,created: None,status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn enrollmentrequest_to_json(enrollmentrequest: Enrollmentrequest) -> Json {
    let Enrollmentrequest(coverage:,candidate:,provider:,insurer:,created:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = enrollmentrequest
    let fields = []
let fields = case coverage {
                          Some(v) -> [#("coverage", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case candidate {
                          Some(v) -> [#("candidate", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case provider {
                          Some(v) -> [#("provider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case insurer {
                          Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.fmstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn enrollmentrequest_decoder() -> Decoder(Enrollmentrequest) {use coverage <- decode.optional_field("coverage", None, decode.optional(reference_decoder()))
use candidate <- decode.optional_field("candidate", None, decode.optional(reference_decoder()))
use provider <- decode.optional_field("provider", None, decode.optional(reference_decoder()))
use insurer <- decode.optional_field("insurer", None, decode.optional(reference_decoder()))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.fmstatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Enrollmentrequest(coverage:,candidate:,provider:,insurer:,created:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EnrollmentResponse#resource
pub type Enrollmentresponse
{
Enrollmentresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Fmstatus),
request: Option(Reference),
outcome: Option(r4valuesets.Remittanceoutcome),
disposition: Option(String),
created: Option(String),
organization: Option(Reference),
request_provider: Option(Reference),
)
}

pub fn enrollmentresponse_new() ->Enrollmentresponse{Enrollmentresponse(request_provider: None,organization: None,created: None,disposition: None,outcome: None,request: None,status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn enrollmentresponse_to_json(enrollmentresponse: Enrollmentresponse) -> Json {
    let Enrollmentresponse(request_provider:,organization:,created:,disposition:,outcome:,request:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = enrollmentresponse
    let fields = []
let fields = case request_provider {
                          Some(v) -> [#("requestProvider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organization {
                          Some(v) -> [#("organization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case disposition {
                          Some(v) -> [#("disposition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", r4valuesets.remittanceoutcome_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.fmstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn enrollmentresponse_decoder() -> Decoder(Enrollmentresponse) {use request_provider <- decode.optional_field("requestProvider", None, decode.optional(reference_decoder()))
use organization <- decode.optional_field("organization", None, decode.optional(reference_decoder()))
use created <- decode.optional_field("created", None, decode.optional(decode.string))
use disposition <- decode.optional_field("disposition", None, decode.optional(decode.string))
use outcome <- decode.optional_field("outcome", None, decode.optional(r4valuesets.remittanceoutcome_decoder()))
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.fmstatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Enrollmentresponse(request_provider:,organization:,created:,disposition:,outcome:,request:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EpisodeOfCare#resource
pub type Episodeofcare
{
Episodeofcare(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Episodeofcarestatus,
status_history: List(EpisodeofcareStatushistory),
type_: List(Codeableconcept),
diagnosis: List(EpisodeofcareDiagnosis),
patient: Reference,
managing_organization: Option(Reference),
period: Option(Period),
referral_request: List(Reference),
care_manager: Option(Reference),
team: List(Reference),
account: List(Reference),
)
}

pub fn episodeofcare_new(patient patient: Reference,status status: r4valuesets.Episodeofcarestatus,) ->Episodeofcare{Episodeofcare(account: [],team: [],care_manager: None,referral_request: [],period: None,managing_organization: None,patient:,diagnosis: [],type_: [],status_history: [],status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareStatushistory
{
EpisodeofcareStatushistory(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
status: r4valuesets.Episodeofcarestatus,
period: Period,
)
}

pub fn episodeofcare_statushistory_new(period period: Period,status status: r4valuesets.Episodeofcarestatus,) ->EpisodeofcareStatushistory{EpisodeofcareStatushistory(period:,status:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareDiagnosis
{
EpisodeofcareDiagnosis(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
condition: Reference,
role: Option(Codeableconcept),
rank: Option(Int),
)
}

pub fn episodeofcare_diagnosis_new(condition condition: Reference,) ->EpisodeofcareDiagnosis{EpisodeofcareDiagnosis(rank: None,role: None,condition:,modifier_extension: [],extension: [],id: None,)
}

pub fn episodeofcare_diagnosis_to_json(episodeofcare_diagnosis: EpisodeofcareDiagnosis) -> Json {
    let EpisodeofcareDiagnosis(rank:,role:,condition:,modifier_extension:,extension:,id:,) = episodeofcare_diagnosis
    let fields = [#("condition", reference_to_json(condition)),]
let fields = case rank {
                          Some(v) -> [#("rank", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn episodeofcare_diagnosis_decoder() -> Decoder(EpisodeofcareDiagnosis) {use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use condition <- decode.field("condition",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EpisodeofcareDiagnosis(rank:,role:,condition:,modifier_extension:,extension:,id:,))}
pub fn episodeofcare_statushistory_to_json(episodeofcare_statushistory: EpisodeofcareStatushistory) -> Json {
    let EpisodeofcareStatushistory(period:,status:,modifier_extension:,extension:,id:,) = episodeofcare_statushistory
    let fields = [#("period", period_to_json(period)),#("status", r4valuesets.episodeofcarestatus_to_json(status)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn episodeofcare_statushistory_decoder() -> Decoder(EpisodeofcareStatushistory) {use period <- decode.field("period",period_decoder())
use status <- decode.field("status",r4valuesets.episodeofcarestatus_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EpisodeofcareStatushistory(period:,status:,modifier_extension:,extension:,id:,))}
pub fn episodeofcare_to_json(episodeofcare: Episodeofcare) -> Json {
    let Episodeofcare(account:,team:,care_manager:,referral_request:,period:,managing_organization:,patient:,diagnosis:,type_:,status_history:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = episodeofcare
    let fields = [#("patient", reference_to_json(patient)),#("status", r4valuesets.episodeofcarestatus_to_json(status)),]
let fields = case account {
                        [] -> fields
                        _ -> [#("account", json.array(account,reference_to_json)), ..fields]
                          }
let fields = case team {
                        [] -> fields
                        _ -> [#("team", json.array(team,reference_to_json)), ..fields]
                          }
let fields = case care_manager {
                          Some(v) -> [#("careManager", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case referral_request {
                        [] -> fields
                        _ -> [#("referralRequest", json.array(referral_request,reference_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case managing_organization {
                          Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case diagnosis {
                        [] -> fields
                        _ -> [#("diagnosis", json.array(diagnosis,episodeofcare_diagnosis_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case status_history {
                        [] -> fields
                        _ -> [#("statusHistory", json.array(status_history,episodeofcare_statushistory_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn episodeofcare_decoder() -> Decoder(Episodeofcare) {use account <- decode.optional_field("account", [], decode.list(reference_decoder()))
use team <- decode.optional_field("team", [], decode.list(reference_decoder()))
use care_manager <- decode.optional_field("careManager", None, decode.optional(reference_decoder()))
use referral_request <- decode.optional_field("referralRequest", [], decode.list(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use managing_organization <- decode.optional_field("managingOrganization", None, decode.optional(reference_decoder()))
use patient <- decode.field("patient",reference_decoder())
use diagnosis <- decode.optional_field("diagnosis", [], decode.list(episodeofcare_diagnosis_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use status_history <- decode.optional_field("statusHistory", [], decode.list(episodeofcare_statushistory_decoder()))
use status <- decode.field("status",r4valuesets.episodeofcarestatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Episodeofcare(account:,team:,care_manager:,referral_request:,period:,managing_organization:,patient:,diagnosis:,type_:,status_history:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EventDefinition#resource
pub type Eventdefinition
{
Eventdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(EventdefinitionSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
trigger: List(Triggerdefinition),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/EventDefinition#resource
pub type EventdefinitionSubject{
EventdefinitionSubjectCodeableconcept(subject: Codeableconcept)
EventdefinitionSubjectReference(subject: Reference)}
pub fn eventdefinition_subject_to_json(elt: EventdefinitionSubject) -> Json {case elt{EventdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
EventdefinitionSubjectReference(v) -> reference_to_json(v)
}}
pub fn eventdefinition_subject_decoder() -> Decoder(EventdefinitionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(EventdefinitionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(EventdefinitionSubjectReference),])}
pub fn eventdefinition_new(status status: r4valuesets.Publicationstatus,) ->Eventdefinition{Eventdefinition(trigger: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,subtitle: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn eventdefinition_to_json(eventdefinition: Eventdefinition) -> Json {
    let Eventdefinition(trigger:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = eventdefinition
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case trigger {
                        [] -> fields
                        _ -> [#("trigger", json.array(trigger,triggerdefinition_to_json)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", eventdefinition_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn eventdefinition_decoder() -> Decoder(Eventdefinition) {use trigger <- decode.optional_field("trigger", [], decode.list(triggerdefinition_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(eventdefinition_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Eventdefinition(trigger:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Evidence#resource
pub type Evidence
{
Evidence(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
short_title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
note: List(Annotation),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
exposure_background: Reference,
exposure_variant: List(Reference),
outcome: List(Reference),
)
}

pub fn evidence_new(exposure_background exposure_background: Reference,status status: r4valuesets.Publicationstatus,) ->Evidence{Evidence(outcome: [],exposure_variant: [],exposure_background:,related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,jurisdiction: [],use_context: [],note: [],description: None,contact: [],publisher: None,date: None,status:,subtitle: None,short_title: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn evidence_to_json(evidence: Evidence) -> Json {
    let Evidence(outcome:,exposure_variant:,exposure_background:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = evidence
    let fields = [#("exposureBackground", reference_to_json(exposure_background)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case outcome {
                        [] -> fields
                        _ -> [#("outcome", json.array(outcome,reference_to_json)), ..fields]
                          }
let fields = case exposure_variant {
                        [] -> fields
                        _ -> [#("exposureVariant", json.array(exposure_variant,reference_to_json)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case short_title {
                          Some(v) -> [#("shortTitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn evidence_decoder() -> Decoder(Evidence) {use outcome <- decode.optional_field("outcome", [], decode.list(reference_decoder()))
use exposure_variant <- decode.optional_field("exposureVariant", [], decode.list(reference_decoder()))
use exposure_background <- decode.field("exposureBackground",reference_decoder())
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use short_title <- decode.optional_field("shortTitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Evidence(outcome:,exposure_variant:,exposure_background:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/EvidenceVariable#resource
pub type Evidencevariable
{
Evidencevariable(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
short_title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
note: List(Annotation),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
type_: Option(r4valuesets.Variabletype),
characteristic: List(EvidencevariableCharacteristic),
)
}

pub fn evidencevariable_new(status status: r4valuesets.Publicationstatus,) ->Evidencevariable{Evidencevariable(characteristic: [],type_: None,related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,jurisdiction: [],use_context: [],note: [],description: None,contact: [],publisher: None,date: None,status:,subtitle: None,short_title: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristic
{
EvidencevariableCharacteristic(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
definition: EvidencevariableCharacteristicDefinition,
usage_context: List(Usagecontext),
exclude: Option(Bool),
participant_effective: Option(EvidencevariableCharacteristicParticipanteffective),
time_from_start: Option(Duration),
group_measure: Option(r4valuesets.Groupmeasure),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDefinition{
EvidencevariableCharacteristicDefinitionReference(definition: Reference)
EvidencevariableCharacteristicDefinitionCanonical(definition: String)
EvidencevariableCharacteristicDefinitionCodeableconcept(definition: Codeableconcept)
EvidencevariableCharacteristicDefinitionExpression(definition: Expression)
EvidencevariableCharacteristicDefinitionDatarequirement(definition: Datarequirement)
EvidencevariableCharacteristicDefinitionTriggerdefinition(definition: Triggerdefinition)}
pub fn evidencevariable_characteristic_definition_to_json(elt: EvidencevariableCharacteristicDefinition) -> Json {case elt{EvidencevariableCharacteristicDefinitionReference(v) -> reference_to_json(v)
EvidencevariableCharacteristicDefinitionCanonical(v) -> json.string(v)
EvidencevariableCharacteristicDefinitionCodeableconcept(v) -> codeableconcept_to_json(v)
EvidencevariableCharacteristicDefinitionExpression(v) -> expression_to_json(v)
EvidencevariableCharacteristicDefinitionDatarequirement(v) -> datarequirement_to_json(v)
EvidencevariableCharacteristicDefinitionTriggerdefinition(v) -> triggerdefinition_to_json(v)
}}
pub fn evidencevariable_characteristic_definition_decoder() -> Decoder(EvidencevariableCharacteristicDefinition){decode.one_of(decode.field("definitionReference", reference_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionReference),[decode.field("definitionCanonical", decode.string, decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionCanonical),decode.field("definitionCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionCodeableconcept),decode.field("definitionExpression", expression_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionExpression),decode.field("definitionDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionDatarequirement),decode.field("definitionTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicDefinitionTriggerdefinition),])}

///http://hl7.org/fhir/r4/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicParticipanteffective{
EvidencevariableCharacteristicParticipanteffectiveDatetime(participant_effective: String)
EvidencevariableCharacteristicParticipanteffectivePeriod(participant_effective: Period)
EvidencevariableCharacteristicParticipanteffectiveDuration(participant_effective: Duration)
EvidencevariableCharacteristicParticipanteffectiveTiming(participant_effective: Timing)}
pub fn evidencevariable_characteristic_participanteffective_to_json(elt: EvidencevariableCharacteristicParticipanteffective) -> Json {case elt{EvidencevariableCharacteristicParticipanteffectiveDatetime(v) -> json.string(v)
EvidencevariableCharacteristicParticipanteffectivePeriod(v) -> period_to_json(v)
EvidencevariableCharacteristicParticipanteffectiveDuration(v) -> duration_to_json(v)
EvidencevariableCharacteristicParticipanteffectiveTiming(v) -> timing_to_json(v)
}}
pub fn evidencevariable_characteristic_participanteffective_decoder() -> Decoder(EvidencevariableCharacteristicParticipanteffective){decode.one_of(decode.field("participantEffectiveDateTime", decode.string, decode.success) |> decode.map(EvidencevariableCharacteristicParticipanteffectiveDatetime),[decode.field("participantEffectivePeriod", period_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicParticipanteffectivePeriod),decode.field("participantEffectiveDuration", duration_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicParticipanteffectiveDuration),decode.field("participantEffectiveTiming", timing_decoder(), decode.success) |> decode.map(EvidencevariableCharacteristicParticipanteffectiveTiming),])}
pub fn evidencevariable_characteristic_new(definition definition: EvidencevariableCharacteristicDefinition,) ->EvidencevariableCharacteristic{EvidencevariableCharacteristic(group_measure: None,time_from_start: None,participant_effective: None,exclude: None,usage_context: [],definition:,description: None,modifier_extension: [],extension: [],id: None,)
}

pub fn evidencevariable_characteristic_to_json(evidencevariable_characteristic: EvidencevariableCharacteristic) -> Json {
    let EvidencevariableCharacteristic(group_measure:,time_from_start:,participant_effective:,exclude:,usage_context:,definition:,description:,modifier_extension:,extension:,id:,) = evidencevariable_characteristic
    let fields = [#("definition", evidencevariable_characteristic_definition_to_json(definition)),]
let fields = case group_measure {
                          Some(v) -> [#("groupMeasure", r4valuesets.groupmeasure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case time_from_start {
                          Some(v) -> [#("timeFromStart", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant_effective {
                          Some(v) -> [#("participantEffective", evidencevariable_characteristic_participanteffective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exclude {
                          Some(v) -> [#("exclude", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case usage_context {
                        [] -> fields
                        _ -> [#("usageContext", json.array(usage_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn evidencevariable_characteristic_decoder() -> Decoder(EvidencevariableCharacteristic) {use group_measure <- decode.optional_field("groupMeasure", None, decode.optional(r4valuesets.groupmeasure_decoder()))
use time_from_start <- decode.optional_field("timeFromStart", None, decode.optional(duration_decoder()))
use participant_effective <- decode.then(none_if_omitted(evidencevariable_characteristic_participanteffective_decoder()))
use exclude <- decode.optional_field("exclude", None, decode.optional(decode.bool))
use usage_context <- decode.optional_field("usageContext", [], decode.list(usagecontext_decoder()))
use definition <- decode.then(evidencevariable_characteristic_definition_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(EvidencevariableCharacteristic(group_measure:,time_from_start:,participant_effective:,exclude:,usage_context:,definition:,description:,modifier_extension:,extension:,id:,))}
pub fn evidencevariable_to_json(evidencevariable: Evidencevariable) -> Json {
    let Evidencevariable(characteristic:,type_:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = evidencevariable
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case characteristic {
                        [] -> fields
                        _ -> [#("characteristic", json.array(characteristic,evidencevariable_characteristic_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.variabletype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case short_title {
                          Some(v) -> [#("shortTitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn evidencevariable_decoder() -> Decoder(Evidencevariable) {use characteristic <- decode.optional_field("characteristic", [], decode.list(evidencevariable_characteristic_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.variabletype_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use short_title <- decode.optional_field("shortTitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Evidencevariable(characteristic:,type_:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type Examplescenario
{
Examplescenario(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
purpose: Option(String),
actor: List(ExamplescenarioActor),
instance: List(ExamplescenarioInstance),
process: List(ExamplescenarioProcess),
workflow: List(String),
)
}

pub fn examplescenario_new(status status: r4valuesets.Publicationstatus,) ->Examplescenario{Examplescenario(workflow: [],process: [],instance: [],actor: [],purpose: None,copyright: None,jurisdiction: [],use_context: [],contact: [],publisher: None,date: None,experimental: None,status:,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioActor
{
ExamplescenarioActor(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
actor_id: String,
type_: r4valuesets.Examplescenarioactortype,
name: Option(String),
description: Option(String),
)
}

pub fn examplescenario_actor_new(type_ type_: r4valuesets.Examplescenarioactortype,actor_id actor_id: String,) ->ExamplescenarioActor{ExamplescenarioActor(description: None,name: None,type_:,actor_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstance
{
ExamplescenarioInstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
resource_id: String,
resource_type: r4valuesets.Resourcetypes,
name: Option(String),
description: Option(String),
version: List(ExamplescenarioInstanceVersion),
contained_instance: List(ExamplescenarioInstanceContainedinstance),
)
}

pub fn examplescenario_instance_new(resource_type resource_type: r4valuesets.Resourcetypes,resource_id resource_id: String,) ->ExamplescenarioInstance{ExamplescenarioInstance(contained_instance: [],version: [],description: None,name: None,resource_type:,resource_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceVersion
{
ExamplescenarioInstanceVersion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
version_id: String,
description: String,
)
}

pub fn examplescenario_instance_version_new(description description: String,version_id version_id: String,) ->ExamplescenarioInstanceVersion{ExamplescenarioInstanceVersion(description:,version_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceContainedinstance
{
ExamplescenarioInstanceContainedinstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
resource_id: String,
version_id: Option(String),
)
}

pub fn examplescenario_instance_containedinstance_new(resource_id resource_id: String,) ->ExamplescenarioInstanceContainedinstance{ExamplescenarioInstanceContainedinstance(version_id: None,resource_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcess
{
ExamplescenarioProcess(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
title: String,
description: Option(String),
pre_conditions: Option(String),
post_conditions: Option(String),
step: List(ExamplescenarioProcessStep),
)
}

pub fn examplescenario_process_new(title title: String,) ->ExamplescenarioProcess{ExamplescenarioProcess(step: [],post_conditions: None,pre_conditions: None,description: None,title:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStep
{
ExamplescenarioProcessStep(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
pause: Option(Bool),
operation: Option(ExamplescenarioProcessStepOperation),
alternative: List(ExamplescenarioProcessStepAlternative),
)
}

pub fn examplescenario_process_step_new() ->ExamplescenarioProcessStep{ExamplescenarioProcessStep(alternative: [],operation: None,pause: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepOperation
{
ExamplescenarioProcessStepOperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
number: String,
type_: Option(String),
name: Option(String),
initiator: Option(String),
receiver: Option(String),
description: Option(String),
initiator_active: Option(Bool),
receiver_active: Option(Bool),
)
}

pub fn examplescenario_process_step_operation_new(number number: String,) ->ExamplescenarioProcessStepOperation{ExamplescenarioProcessStepOperation(receiver_active: None,initiator_active: None,description: None,receiver: None,initiator: None,name: None,type_: None,number:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepAlternative
{
ExamplescenarioProcessStepAlternative(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
title: String,
description: Option(String),
)
}

pub fn examplescenario_process_step_alternative_new(title title: String,) ->ExamplescenarioProcessStepAlternative{ExamplescenarioProcessStepAlternative(description: None,title:,modifier_extension: [],extension: [],id: None,)
}

pub fn examplescenario_process_step_alternative_to_json(examplescenario_process_step_alternative: ExamplescenarioProcessStepAlternative) -> Json {
    let ExamplescenarioProcessStepAlternative(description:,title:,modifier_extension:,extension:,id:,) = examplescenario_process_step_alternative
    let fields = [#("title", json.string(title)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_process_step_alternative_decoder() -> Decoder(ExamplescenarioProcessStepAlternative) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use title <- decode.field("title",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioProcessStepAlternative(description:,title:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_process_step_operation_to_json(examplescenario_process_step_operation: ExamplescenarioProcessStepOperation) -> Json {
    let ExamplescenarioProcessStepOperation(receiver_active:,initiator_active:,description:,receiver:,initiator:,name:,type_:,number:,modifier_extension:,extension:,id:,) = examplescenario_process_step_operation
    let fields = [#("number", json.string(number)),]
let fields = case receiver_active {
                          Some(v) -> [#("receiverActive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case initiator_active {
                          Some(v) -> [#("initiatorActive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case receiver {
                          Some(v) -> [#("receiver", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case initiator {
                          Some(v) -> [#("initiator", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_process_step_operation_decoder() -> Decoder(ExamplescenarioProcessStepOperation) {use receiver_active <- decode.optional_field("receiverActive", None, decode.optional(decode.bool))
use initiator_active <- decode.optional_field("initiatorActive", None, decode.optional(decode.bool))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use receiver <- decode.optional_field("receiver", None, decode.optional(decode.string))
use initiator <- decode.optional_field("initiator", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(decode.string))
use number <- decode.field("number",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioProcessStepOperation(receiver_active:,initiator_active:,description:,receiver:,initiator:,name:,type_:,number:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_process_step_to_json(examplescenario_process_step: ExamplescenarioProcessStep) -> Json {
    let ExamplescenarioProcessStep(alternative:,operation:,pause:,modifier_extension:,extension:,id:,) = examplescenario_process_step
    let fields = []
let fields = case alternative {
                        [] -> fields
                        _ -> [#("alternative", json.array(alternative,examplescenario_process_step_alternative_to_json)), ..fields]
                          }
let fields = case operation {
                          Some(v) -> [#("operation", examplescenario_process_step_operation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case pause {
                          Some(v) -> [#("pause", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_process_step_decoder() -> Decoder(ExamplescenarioProcessStep) {use alternative <- decode.optional_field("alternative", [], decode.list(examplescenario_process_step_alternative_decoder()))
use operation <- decode.optional_field("operation", None, decode.optional(examplescenario_process_step_operation_decoder()))
use pause <- decode.optional_field("pause", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioProcessStep(alternative:,operation:,pause:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_process_to_json(examplescenario_process: ExamplescenarioProcess) -> Json {
    let ExamplescenarioProcess(step:,post_conditions:,pre_conditions:,description:,title:,modifier_extension:,extension:,id:,) = examplescenario_process
    let fields = [#("title", json.string(title)),]
let fields = case step {
                        [] -> fields
                        _ -> [#("step", json.array(step,examplescenario_process_step_to_json)), ..fields]
                          }
let fields = case post_conditions {
                          Some(v) -> [#("postConditions", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case pre_conditions {
                          Some(v) -> [#("preConditions", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_process_decoder() -> Decoder(ExamplescenarioProcess) {use step <- decode.optional_field("step", [], decode.list(examplescenario_process_step_decoder()))
use post_conditions <- decode.optional_field("postConditions", None, decode.optional(decode.string))
use pre_conditions <- decode.optional_field("preConditions", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use title <- decode.field("title",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioProcess(step:,post_conditions:,pre_conditions:,description:,title:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_instance_containedinstance_to_json(examplescenario_instance_containedinstance: ExamplescenarioInstanceContainedinstance) -> Json {
    let ExamplescenarioInstanceContainedinstance(version_id:,resource_id:,modifier_extension:,extension:,id:,) = examplescenario_instance_containedinstance
    let fields = [#("resourceId", json.string(resource_id)),]
let fields = case version_id {
                          Some(v) -> [#("versionId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_instance_containedinstance_decoder() -> Decoder(ExamplescenarioInstanceContainedinstance) {use version_id <- decode.optional_field("versionId", None, decode.optional(decode.string))
use resource_id <- decode.field("resourceId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioInstanceContainedinstance(version_id:,resource_id:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_instance_version_to_json(examplescenario_instance_version: ExamplescenarioInstanceVersion) -> Json {
    let ExamplescenarioInstanceVersion(description:,version_id:,modifier_extension:,extension:,id:,) = examplescenario_instance_version
    let fields = [#("description", json.string(description)),#("versionId", json.string(version_id)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_instance_version_decoder() -> Decoder(ExamplescenarioInstanceVersion) {use description <- decode.field("description",decode.string)
use version_id <- decode.field("versionId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioInstanceVersion(description:,version_id:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_instance_to_json(examplescenario_instance: ExamplescenarioInstance) -> Json {
    let ExamplescenarioInstance(contained_instance:,version:,description:,name:,resource_type:,resource_id:,modifier_extension:,extension:,id:,) = examplescenario_instance
    let fields = [#("resourceType", r4valuesets.resourcetypes_to_json(resource_type)),#("resourceId", json.string(resource_id)),]
let fields = case contained_instance {
                        [] -> fields
                        _ -> [#("containedInstance", json.array(contained_instance,examplescenario_instance_containedinstance_to_json)), ..fields]
                          }
let fields = case version {
                        [] -> fields
                        _ -> [#("version", json.array(version,examplescenario_instance_version_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_instance_decoder() -> Decoder(ExamplescenarioInstance) {use contained_instance <- decode.optional_field("containedInstance", [], decode.list(examplescenario_instance_containedinstance_decoder()))
use version <- decode.optional_field("version", [], decode.list(examplescenario_instance_version_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use resource_type <- decode.field("resourceType",r4valuesets.resourcetypes_decoder())
use resource_id <- decode.field("resourceId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioInstance(contained_instance:,version:,description:,name:,resource_type:,resource_id:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_actor_to_json(examplescenario_actor: ExamplescenarioActor) -> Json {
    let ExamplescenarioActor(description:,name:,type_:,actor_id:,modifier_extension:,extension:,id:,) = examplescenario_actor
    let fields = [#("type", r4valuesets.examplescenarioactortype_to_json(type_)),#("actorId", json.string(actor_id)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_actor_decoder() -> Decoder(ExamplescenarioActor) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.examplescenarioactortype_decoder())
use actor_id <- decode.field("actorId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExamplescenarioActor(description:,name:,type_:,actor_id:,modifier_extension:,extension:,id:,))}
pub fn examplescenario_to_json(examplescenario: Examplescenario) -> Json {
    let Examplescenario(workflow:,process:,instance:,actor:,purpose:,copyright:,jurisdiction:,use_context:,contact:,publisher:,date:,experimental:,status:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = examplescenario
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case workflow {
                        [] -> fields
                        _ -> [#("workflow", json.array(workflow,json.string)), ..fields]
                          }
let fields = case process {
                        [] -> fields
                        _ -> [#("process", json.array(process,examplescenario_process_to_json)), ..fields]
                          }
let fields = case instance {
                        [] -> fields
                        _ -> [#("instance", json.array(instance,examplescenario_instance_to_json)), ..fields]
                          }
let fields = case actor {
                        [] -> fields
                        _ -> [#("actor", json.array(actor,examplescenario_actor_to_json)), ..fields]
                          }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn examplescenario_decoder() -> Decoder(Examplescenario) {use workflow <- decode.optional_field("workflow", [], decode.list(decode.string))
use process <- decode.optional_field("process", [], decode.list(examplescenario_process_decoder()))
use instance <- decode.optional_field("instance", [], decode.list(examplescenario_instance_decoder()))
use actor <- decode.optional_field("actor", [], decode.list(examplescenario_actor_decoder()))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Examplescenario(workflow:,process:,instance:,actor:,purpose:,copyright:,jurisdiction:,use_context:,contact:,publisher:,date:,experimental:,status:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type Explanationofbenefit
{
Explanationofbenefit(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Explanationofbenefitstatus,
type_: Codeableconcept,
sub_type: Option(Codeableconcept),
use_: r4valuesets.Claimuse,
patient: Reference,
billable_period: Option(Period),
created: String,
enterer: Option(Reference),
insurer: Reference,
provider: Reference,
priority: Option(Codeableconcept),
funds_reserve_requested: Option(Codeableconcept),
funds_reserve: Option(Codeableconcept),
related: List(ExplanationofbenefitRelated),
prescription: Option(Reference),
original_prescription: Option(Reference),
payee: Option(ExplanationofbenefitPayee),
referral: Option(Reference),
facility: Option(Reference),
claim: Option(Reference),
claim_response: Option(Reference),
outcome: r4valuesets.Remittanceoutcome,
disposition: Option(String),
pre_auth_ref: List(String),
pre_auth_ref_period: List(Period),
care_team: List(ExplanationofbenefitCareteam),
supporting_info: List(ExplanationofbenefitSupportinginfo),
diagnosis: List(ExplanationofbenefitDiagnosis),
procedure: List(ExplanationofbenefitProcedure),
precedence: Option(Int),
insurance: List(ExplanationofbenefitInsurance),
accident: Option(ExplanationofbenefitAccident),
item: List(ExplanationofbenefitItem),
add_item: List(ExplanationofbenefitAdditem),
total: List(ExplanationofbenefitTotal),
payment: Option(ExplanationofbenefitPayment),
form_code: Option(Codeableconcept),
form: Option(Attachment),
process_note: List(ExplanationofbenefitProcessnote),
benefit_period: Option(Period),
benefit_balance: List(ExplanationofbenefitBenefitbalance),
)
}

pub fn explanationofbenefit_new(outcome outcome: r4valuesets.Remittanceoutcome,provider provider: Reference,insurer insurer: Reference,created created: String,patient patient: Reference,use_ use_: r4valuesets.Claimuse,type_ type_: Codeableconcept,status status: r4valuesets.Explanationofbenefitstatus,) ->Explanationofbenefit{Explanationofbenefit(benefit_balance: [],benefit_period: None,process_note: [],form: None,form_code: None,payment: None,total: [],add_item: [],item: [],accident: None,insurance: [],precedence: None,procedure: [],diagnosis: [],supporting_info: [],care_team: [],pre_auth_ref_period: [],pre_auth_ref: [],disposition: None,outcome:,claim_response: None,claim: None,facility: None,referral: None,payee: None,original_prescription: None,prescription: None,related: [],funds_reserve: None,funds_reserve_requested: None,priority: None,provider:,insurer:,enterer: None,created:,billable_period: None,patient:,use_:,sub_type: None,type_:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitRelated
{
ExplanationofbenefitRelated(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
claim: Option(Reference),
relationship: Option(Codeableconcept),
reference: Option(Identifier),
)
}

pub fn explanationofbenefit_related_new() ->ExplanationofbenefitRelated{ExplanationofbenefitRelated(reference: None,relationship: None,claim: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayee
{
ExplanationofbenefitPayee(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
party: Option(Reference),
)
}

pub fn explanationofbenefit_payee_new() ->ExplanationofbenefitPayee{ExplanationofbenefitPayee(party: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitCareteam
{
ExplanationofbenefitCareteam(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
provider: Reference,
responsible: Option(Bool),
role: Option(Codeableconcept),
qualification: Option(Codeableconcept),
)
}

pub fn explanationofbenefit_careteam_new(provider provider: Reference,sequence sequence: Int,) ->ExplanationofbenefitCareteam{ExplanationofbenefitCareteam(qualification: None,role: None,responsible: None,provider:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfo
{
ExplanationofbenefitSupportinginfo(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
category: Codeableconcept,
code: Option(Codeableconcept),
timing: Option(ExplanationofbenefitSupportinginfoTiming),
value: Option(ExplanationofbenefitSupportinginfoValue),
reason: Option(Coding),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoTiming{
ExplanationofbenefitSupportinginfoTimingDate(timing: String)
ExplanationofbenefitSupportinginfoTimingPeriod(timing: Period)}
pub fn explanationofbenefit_supportinginfo_timing_to_json(elt: ExplanationofbenefitSupportinginfoTiming) -> Json {case elt{ExplanationofbenefitSupportinginfoTimingDate(v) -> json.string(v)
ExplanationofbenefitSupportinginfoTimingPeriod(v) -> period_to_json(v)
}}
pub fn explanationofbenefit_supportinginfo_timing_decoder() -> Decoder(ExplanationofbenefitSupportinginfoTiming){decode.one_of(decode.field("timingDate", decode.string, decode.success) |> decode.map(ExplanationofbenefitSupportinginfoTimingDate),[decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(ExplanationofbenefitSupportinginfoTimingPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoValue{
ExplanationofbenefitSupportinginfoValueBoolean(value: Bool)
ExplanationofbenefitSupportinginfoValueString(value: String)
ExplanationofbenefitSupportinginfoValueQuantity(value: Quantity)
ExplanationofbenefitSupportinginfoValueAttachment(value: Attachment)
ExplanationofbenefitSupportinginfoValueReference(value: Reference)}
pub fn explanationofbenefit_supportinginfo_value_to_json(elt: ExplanationofbenefitSupportinginfoValue) -> Json {case elt{ExplanationofbenefitSupportinginfoValueBoolean(v) -> json.bool(v)
ExplanationofbenefitSupportinginfoValueString(v) -> json.string(v)
ExplanationofbenefitSupportinginfoValueQuantity(v) -> quantity_to_json(v)
ExplanationofbenefitSupportinginfoValueAttachment(v) -> attachment_to_json(v)
ExplanationofbenefitSupportinginfoValueReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_supportinginfo_value_decoder() -> Decoder(ExplanationofbenefitSupportinginfoValue){decode.one_of(decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ExplanationofbenefitSupportinginfoValueBoolean),[decode.field("valueString", decode.string, decode.success) |> decode.map(ExplanationofbenefitSupportinginfoValueString),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ExplanationofbenefitSupportinginfoValueQuantity),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(ExplanationofbenefitSupportinginfoValueAttachment),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitSupportinginfoValueReference),])}
pub fn explanationofbenefit_supportinginfo_new(category category: Codeableconcept,sequence sequence: Int,) ->ExplanationofbenefitSupportinginfo{ExplanationofbenefitSupportinginfo(reason: None,value: None,timing: None,code: None,category:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosis
{
ExplanationofbenefitDiagnosis(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
diagnosis: ExplanationofbenefitDiagnosisDiagnosis,
type_: List(Codeableconcept),
on_admission: Option(Codeableconcept),
package_code: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosisDiagnosis{
ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(diagnosis: Codeableconcept)
ExplanationofbenefitDiagnosisDiagnosisReference(diagnosis: Reference)}
pub fn explanationofbenefit_diagnosis_diagnosis_to_json(elt: ExplanationofbenefitDiagnosisDiagnosis) -> Json {case elt{ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(v) -> codeableconcept_to_json(v)
ExplanationofbenefitDiagnosisDiagnosisReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_diagnosis_diagnosis_decoder() -> Decoder(ExplanationofbenefitDiagnosisDiagnosis){decode.one_of(decode.field("diagnosisCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ExplanationofbenefitDiagnosisDiagnosisCodeableconcept),[decode.field("diagnosisReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitDiagnosisDiagnosisReference),])}
pub fn explanationofbenefit_diagnosis_new(diagnosis diagnosis: ExplanationofbenefitDiagnosisDiagnosis,sequence sequence: Int,) ->ExplanationofbenefitDiagnosis{ExplanationofbenefitDiagnosis(package_code: None,on_admission: None,type_: [],diagnosis:,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedure
{
ExplanationofbenefitProcedure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
type_: List(Codeableconcept),
date: Option(String),
procedure: ExplanationofbenefitProcedureProcedure,
udi: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedureProcedure{
ExplanationofbenefitProcedureProcedureCodeableconcept(procedure: Codeableconcept)
ExplanationofbenefitProcedureProcedureReference(procedure: Reference)}
pub fn explanationofbenefit_procedure_procedure_to_json(elt: ExplanationofbenefitProcedureProcedure) -> Json {case elt{ExplanationofbenefitProcedureProcedureCodeableconcept(v) -> codeableconcept_to_json(v)
ExplanationofbenefitProcedureProcedureReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_procedure_procedure_decoder() -> Decoder(ExplanationofbenefitProcedureProcedure){decode.one_of(decode.field("procedureCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ExplanationofbenefitProcedureProcedureCodeableconcept),[decode.field("procedureReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitProcedureProcedureReference),])}
pub fn explanationofbenefit_procedure_new(procedure procedure: ExplanationofbenefitProcedureProcedure,sequence sequence: Int,) ->ExplanationofbenefitProcedure{ExplanationofbenefitProcedure(udi: [],procedure:,date: None,type_: [],sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitInsurance
{
ExplanationofbenefitInsurance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
focal: Bool,
coverage: Reference,
pre_auth_ref: List(String),
)
}

pub fn explanationofbenefit_insurance_new(coverage coverage: Reference,focal focal: Bool,) ->ExplanationofbenefitInsurance{ExplanationofbenefitInsurance(pre_auth_ref: [],coverage:,focal:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccident
{
ExplanationofbenefitAccident(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
date: Option(String),
type_: Option(Codeableconcept),
location: Option(ExplanationofbenefitAccidentLocation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccidentLocation{
ExplanationofbenefitAccidentLocationAddress(location: Address)
ExplanationofbenefitAccidentLocationReference(location: Reference)}
pub fn explanationofbenefit_accident_location_to_json(elt: ExplanationofbenefitAccidentLocation) -> Json {case elt{ExplanationofbenefitAccidentLocationAddress(v) -> address_to_json(v)
ExplanationofbenefitAccidentLocationReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_accident_location_decoder() -> Decoder(ExplanationofbenefitAccidentLocation){decode.one_of(decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ExplanationofbenefitAccidentLocationAddress),[decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitAccidentLocationReference),])}
pub fn explanationofbenefit_accident_new() ->ExplanationofbenefitAccident{ExplanationofbenefitAccident(location: None,type_: None,date: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItem
{
ExplanationofbenefitItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
care_team_sequence: List(Int),
diagnosis_sequence: List(Int),
procedure_sequence: List(Int),
information_sequence: List(Int),
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
serviced: Option(ExplanationofbenefitItemServiced),
location: Option(ExplanationofbenefitItemLocation),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
body_site: Option(Codeableconcept),
sub_site: List(Codeableconcept),
encounter: List(Reference),
note_number: List(Int),
adjudication: List(ExplanationofbenefitItemAdjudication),
detail: List(ExplanationofbenefitItemDetail),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemServiced{
ExplanationofbenefitItemServicedDate(serviced: String)
ExplanationofbenefitItemServicedPeriod(serviced: Period)}
pub fn explanationofbenefit_item_serviced_to_json(elt: ExplanationofbenefitItemServiced) -> Json {case elt{ExplanationofbenefitItemServicedDate(v) -> json.string(v)
ExplanationofbenefitItemServicedPeriod(v) -> period_to_json(v)
}}
pub fn explanationofbenefit_item_serviced_decoder() -> Decoder(ExplanationofbenefitItemServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(ExplanationofbenefitItemServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(ExplanationofbenefitItemServicedPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemLocation{
ExplanationofbenefitItemLocationCodeableconcept(location: Codeableconcept)
ExplanationofbenefitItemLocationAddress(location: Address)
ExplanationofbenefitItemLocationReference(location: Reference)}
pub fn explanationofbenefit_item_location_to_json(elt: ExplanationofbenefitItemLocation) -> Json {case elt{ExplanationofbenefitItemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
ExplanationofbenefitItemLocationAddress(v) -> address_to_json(v)
ExplanationofbenefitItemLocationReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_item_location_decoder() -> Decoder(ExplanationofbenefitItemLocation){decode.one_of(decode.field("locationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ExplanationofbenefitItemLocationCodeableconcept),[decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ExplanationofbenefitItemLocationAddress),decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitItemLocationReference),])}
pub fn explanationofbenefit_item_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ExplanationofbenefitItem{ExplanationofbenefitItem(detail: [],adjudication: [],note_number: [],encounter: [],sub_site: [],body_site: None,udi: [],net: None,factor: None,unit_price: None,quantity: None,location: None,serviced: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,information_sequence: [],procedure_sequence: [],diagnosis_sequence: [],care_team_sequence: [],sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemAdjudication
{
ExplanationofbenefitItemAdjudication(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
reason: Option(Codeableconcept),
amount: Option(Money),
value: Option(Float),
)
}

pub fn explanationofbenefit_item_adjudication_new(category category: Codeableconcept,) ->ExplanationofbenefitItemAdjudication{ExplanationofbenefitItemAdjudication(value: None,amount: None,reason: None,category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetail
{
ExplanationofbenefitItemDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
note_number: List(Int),
sub_detail: List(ExplanationofbenefitItemDetailSubdetail),
)
}

pub fn explanationofbenefit_item_detail_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ExplanationofbenefitItemDetail{ExplanationofbenefitItemDetail(sub_detail: [],note_number: [],udi: [],net: None,factor: None,unit_price: None,quantity: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetailSubdetail
{
ExplanationofbenefitItemDetailSubdetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Int,
revenue: Option(Codeableconcept),
category: Option(Codeableconcept),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
udi: List(Reference),
note_number: List(Int),
)
}

pub fn explanationofbenefit_item_detail_subdetail_new(product_or_service product_or_service: Codeableconcept,sequence sequence: Int,) ->ExplanationofbenefitItemDetailSubdetail{ExplanationofbenefitItemDetailSubdetail(note_number: [],udi: [],net: None,factor: None,unit_price: None,quantity: None,program_code: [],modifier: [],product_or_service:,category: None,revenue: None,sequence:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditem
{
ExplanationofbenefitAdditem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item_sequence: List(Int),
detail_sequence: List(Int),
sub_detail_sequence: List(Int),
provider: List(Reference),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
program_code: List(Codeableconcept),
serviced: Option(ExplanationofbenefitAdditemServiced),
location: Option(ExplanationofbenefitAdditemLocation),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
body_site: Option(Codeableconcept),
sub_site: List(Codeableconcept),
note_number: List(Int),
detail: List(ExplanationofbenefitAdditemDetail),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemServiced{
ExplanationofbenefitAdditemServicedDate(serviced: String)
ExplanationofbenefitAdditemServicedPeriod(serviced: Period)}
pub fn explanationofbenefit_additem_serviced_to_json(elt: ExplanationofbenefitAdditemServiced) -> Json {case elt{ExplanationofbenefitAdditemServicedDate(v) -> json.string(v)
ExplanationofbenefitAdditemServicedPeriod(v) -> period_to_json(v)
}}
pub fn explanationofbenefit_additem_serviced_decoder() -> Decoder(ExplanationofbenefitAdditemServiced){decode.one_of(decode.field("servicedDate", decode.string, decode.success) |> decode.map(ExplanationofbenefitAdditemServicedDate),[decode.field("servicedPeriod", period_decoder(), decode.success) |> decode.map(ExplanationofbenefitAdditemServicedPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemLocation{
ExplanationofbenefitAdditemLocationCodeableconcept(location: Codeableconcept)
ExplanationofbenefitAdditemLocationAddress(location: Address)
ExplanationofbenefitAdditemLocationReference(location: Reference)}
pub fn explanationofbenefit_additem_location_to_json(elt: ExplanationofbenefitAdditemLocation) -> Json {case elt{ExplanationofbenefitAdditemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
ExplanationofbenefitAdditemLocationAddress(v) -> address_to_json(v)
ExplanationofbenefitAdditemLocationReference(v) -> reference_to_json(v)
}}
pub fn explanationofbenefit_additem_location_decoder() -> Decoder(ExplanationofbenefitAdditemLocation){decode.one_of(decode.field("locationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ExplanationofbenefitAdditemLocationCodeableconcept),[decode.field("locationAddress", address_decoder(), decode.success) |> decode.map(ExplanationofbenefitAdditemLocationAddress),decode.field("locationReference", reference_decoder(), decode.success) |> decode.map(ExplanationofbenefitAdditemLocationReference),])}
pub fn explanationofbenefit_additem_new(product_or_service product_or_service: Codeableconcept,) ->ExplanationofbenefitAdditem{ExplanationofbenefitAdditem(detail: [],note_number: [],sub_site: [],body_site: None,net: None,factor: None,unit_price: None,quantity: None,location: None,serviced: None,program_code: [],modifier: [],product_or_service:,provider: [],sub_detail_sequence: [],detail_sequence: [],item_sequence: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetail
{
ExplanationofbenefitAdditemDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
note_number: List(Int),
sub_detail: List(ExplanationofbenefitAdditemDetailSubdetail),
)
}

pub fn explanationofbenefit_additem_detail_new(product_or_service product_or_service: Codeableconcept,) ->ExplanationofbenefitAdditemDetail{ExplanationofbenefitAdditemDetail(sub_detail: [],note_number: [],net: None,factor: None,unit_price: None,quantity: None,modifier: [],product_or_service:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetailSubdetail
{
ExplanationofbenefitAdditemDetailSubdetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product_or_service: Codeableconcept,
modifier: List(Codeableconcept),
quantity: Option(Quantity),
unit_price: Option(Money),
factor: Option(Float),
net: Option(Money),
note_number: List(Int),
)
}

pub fn explanationofbenefit_additem_detail_subdetail_new(product_or_service product_or_service: Codeableconcept,) ->ExplanationofbenefitAdditemDetailSubdetail{ExplanationofbenefitAdditemDetailSubdetail(note_number: [],net: None,factor: None,unit_price: None,quantity: None,modifier: [],product_or_service:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitTotal
{
ExplanationofbenefitTotal(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
amount: Money,
)
}

pub fn explanationofbenefit_total_new(amount amount: Money,category category: Codeableconcept,) ->ExplanationofbenefitTotal{ExplanationofbenefitTotal(amount:,category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayment
{
ExplanationofbenefitPayment(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
adjustment: Option(Money),
adjustment_reason: Option(Codeableconcept),
date: Option(String),
amount: Option(Money),
identifier: Option(Identifier),
)
}

pub fn explanationofbenefit_payment_new() ->ExplanationofbenefitPayment{ExplanationofbenefitPayment(identifier: None,amount: None,date: None,adjustment_reason: None,adjustment: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcessnote
{
ExplanationofbenefitProcessnote(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
number: Option(Int),
type_: Option(r4valuesets.Notetype),
text: Option(String),
language: Option(Codeableconcept),
)
}

pub fn explanationofbenefit_processnote_new() ->ExplanationofbenefitProcessnote{ExplanationofbenefitProcessnote(language: None,text: None,type_: None,number: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalance
{
ExplanationofbenefitBenefitbalance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
excluded: Option(Bool),
name: Option(String),
description: Option(String),
network: Option(Codeableconcept),
unit: Option(Codeableconcept),
term: Option(Codeableconcept),
financial: List(ExplanationofbenefitBenefitbalanceFinancial),
)
}

pub fn explanationofbenefit_benefitbalance_new(category category: Codeableconcept,) ->ExplanationofbenefitBenefitbalance{ExplanationofbenefitBenefitbalance(financial: [],term: None,unit: None,network: None,description: None,name: None,excluded: None,category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancial
{
ExplanationofbenefitBenefitbalanceFinancial(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
allowed: Option(ExplanationofbenefitBenefitbalanceFinancialAllowed),
used: Option(ExplanationofbenefitBenefitbalanceFinancialUsed),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialAllowed{
ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(allowed: Int)
ExplanationofbenefitBenefitbalanceFinancialAllowedString(allowed: String)
ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(allowed: Money)}
pub fn explanationofbenefit_benefitbalance_financial_allowed_to_json(elt: ExplanationofbenefitBenefitbalanceFinancialAllowed) -> Json {case elt{ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(v) -> json.int(v)
ExplanationofbenefitBenefitbalanceFinancialAllowedString(v) -> json.string(v)
ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(v) -> money_to_json(v)
}}
pub fn explanationofbenefit_benefitbalance_financial_allowed_decoder() -> Decoder(ExplanationofbenefitBenefitbalanceFinancialAllowed){decode.one_of(decode.field("allowedUnsignedInt", decode.int, decode.success) |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint),[decode.field("allowedString", decode.string, decode.success) |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedString),decode.field("allowedMoney", money_decoder(), decode.success) |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedMoney),])}

///http://hl7.org/fhir/r4/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialUsed{
ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(used: Int)
ExplanationofbenefitBenefitbalanceFinancialUsedMoney(used: Money)}
pub fn explanationofbenefit_benefitbalance_financial_used_to_json(elt: ExplanationofbenefitBenefitbalanceFinancialUsed) -> Json {case elt{ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(v) -> json.int(v)
ExplanationofbenefitBenefitbalanceFinancialUsedMoney(v) -> money_to_json(v)
}}
pub fn explanationofbenefit_benefitbalance_financial_used_decoder() -> Decoder(ExplanationofbenefitBenefitbalanceFinancialUsed){decode.one_of(decode.field("usedUnsignedInt", decode.int, decode.success) |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint),[decode.field("usedMoney", money_decoder(), decode.success) |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedMoney),])}
pub fn explanationofbenefit_benefitbalance_financial_new(type_ type_: Codeableconcept,) ->ExplanationofbenefitBenefitbalanceFinancial{ExplanationofbenefitBenefitbalanceFinancial(used: None,allowed: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn explanationofbenefit_benefitbalance_financial_to_json(explanationofbenefit_benefitbalance_financial: ExplanationofbenefitBenefitbalanceFinancial) -> Json {
    let ExplanationofbenefitBenefitbalanceFinancial(used:,allowed:,type_:,modifier_extension:,extension:,id:,) = explanationofbenefit_benefitbalance_financial
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case used {
                          Some(v) -> [#("used", explanationofbenefit_benefitbalance_financial_used_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case allowed {
                          Some(v) -> [#("allowed", explanationofbenefit_benefitbalance_financial_allowed_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_benefitbalance_financial_decoder() -> Decoder(ExplanationofbenefitBenefitbalanceFinancial) {use used <- decode.then(none_if_omitted(explanationofbenefit_benefitbalance_financial_used_decoder()))
use allowed <- decode.then(none_if_omitted(explanationofbenefit_benefitbalance_financial_allowed_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitBenefitbalanceFinancial(used:,allowed:,type_:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_benefitbalance_to_json(explanationofbenefit_benefitbalance: ExplanationofbenefitBenefitbalance) -> Json {
    let ExplanationofbenefitBenefitbalance(financial:,term:,unit:,network:,description:,name:,excluded:,category:,modifier_extension:,extension:,id:,) = explanationofbenefit_benefitbalance
    let fields = [#("category", codeableconcept_to_json(category)),]
let fields = case financial {
                        [] -> fields
                        _ -> [#("financial", json.array(financial,explanationofbenefit_benefitbalance_financial_to_json)), ..fields]
                          }
let fields = case term {
                          Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case network {
                          Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case excluded {
                          Some(v) -> [#("excluded", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_benefitbalance_decoder() -> Decoder(ExplanationofbenefitBenefitbalance) {use financial <- decode.optional_field("financial", [], decode.list(explanationofbenefit_benefitbalance_financial_decoder()))
use term <- decode.optional_field("term", None, decode.optional(codeableconcept_decoder()))
use unit <- decode.optional_field("unit", None, decode.optional(codeableconcept_decoder()))
use network <- decode.optional_field("network", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use excluded <- decode.optional_field("excluded", None, decode.optional(decode.bool))
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitBenefitbalance(financial:,term:,unit:,network:,description:,name:,excluded:,category:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_processnote_to_json(explanationofbenefit_processnote: ExplanationofbenefitProcessnote) -> Json {
    let ExplanationofbenefitProcessnote(language:,text:,type_:,number:,modifier_extension:,extension:,id:,) = explanationofbenefit_processnote
    let fields = []
let fields = case language {
                          Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.notetype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case number {
                          Some(v) -> [#("number", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_processnote_decoder() -> Decoder(ExplanationofbenefitProcessnote) {use language <- decode.optional_field("language", None, decode.optional(codeableconcept_decoder()))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.notetype_decoder()))
use number <- decode.optional_field("number", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitProcessnote(language:,text:,type_:,number:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_payment_to_json(explanationofbenefit_payment: ExplanationofbenefitPayment) -> Json {
    let ExplanationofbenefitPayment(identifier:,amount:,date:,adjustment_reason:,adjustment:,type_:,modifier_extension:,extension:,id:,) = explanationofbenefit_payment
    let fields = []
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case adjustment_reason {
                          Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case adjustment {
                          Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_payment_decoder() -> Decoder(ExplanationofbenefitPayment) {use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use adjustment_reason <- decode.optional_field("adjustmentReason", None, decode.optional(codeableconcept_decoder()))
use adjustment <- decode.optional_field("adjustment", None, decode.optional(money_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitPayment(identifier:,amount:,date:,adjustment_reason:,adjustment:,type_:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_total_to_json(explanationofbenefit_total: ExplanationofbenefitTotal) -> Json {
    let ExplanationofbenefitTotal(amount:,category:,modifier_extension:,extension:,id:,) = explanationofbenefit_total
    let fields = [#("amount", money_to_json(amount)),#("category", codeableconcept_to_json(category)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_total_decoder() -> Decoder(ExplanationofbenefitTotal) {use amount <- decode.field("amount",money_decoder())
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitTotal(amount:,category:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_additem_detail_subdetail_to_json(explanationofbenefit_additem_detail_subdetail: ExplanationofbenefitAdditemDetailSubdetail) -> Json {
    let ExplanationofbenefitAdditemDetailSubdetail(note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,) = explanationofbenefit_additem_detail_subdetail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_additem_detail_subdetail_decoder() -> Decoder(ExplanationofbenefitAdditemDetailSubdetail) {use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitAdditemDetailSubdetail(note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_additem_detail_to_json(explanationofbenefit_additem_detail: ExplanationofbenefitAdditemDetail) -> Json {
    let ExplanationofbenefitAdditemDetail(sub_detail:,note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,) = explanationofbenefit_additem_detail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case sub_detail {
                        [] -> fields
                        _ -> [#("subDetail", json.array(sub_detail,explanationofbenefit_additem_detail_subdetail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_additem_detail_decoder() -> Decoder(ExplanationofbenefitAdditemDetail) {use sub_detail <- decode.optional_field("subDetail", [], decode.list(explanationofbenefit_additem_detail_subdetail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitAdditemDetail(sub_detail:,note_number:,net:,factor:,unit_price:,quantity:,modifier:,product_or_service:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_additem_to_json(explanationofbenefit_additem: ExplanationofbenefitAdditem) -> Json {
    let ExplanationofbenefitAdditem(detail:,note_number:,sub_site:,body_site:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,provider:,sub_detail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_additem
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),]
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,explanationofbenefit_additem_detail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case sub_site {
                        [] -> fields
                        _ -> [#("subSite", json.array(sub_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", explanationofbenefit_additem_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", explanationofbenefit_additem_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case provider {
                        [] -> fields
                        _ -> [#("provider", json.array(provider,reference_to_json)), ..fields]
                          }
let fields = case sub_detail_sequence {
                        [] -> fields
                        _ -> [#("subDetailSequence", json.array(sub_detail_sequence,json.int)), ..fields]
                          }
let fields = case detail_sequence {
                        [] -> fields
                        _ -> [#("detailSequence", json.array(detail_sequence,json.int)), ..fields]
                          }
let fields = case item_sequence {
                        [] -> fields
                        _ -> [#("itemSequence", json.array(item_sequence,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_additem_decoder() -> Decoder(ExplanationofbenefitAdditem) {use detail <- decode.optional_field("detail", [], decode.list(explanationofbenefit_additem_detail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use sub_site <- decode.optional_field("subSite", [], decode.list(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use location <- decode.then(none_if_omitted(explanationofbenefit_additem_location_decoder()))
use serviced <- decode.then(none_if_omitted(explanationofbenefit_additem_serviced_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use provider <- decode.optional_field("provider", [], decode.list(reference_decoder()))
use sub_detail_sequence <- decode.optional_field("subDetailSequence", [], decode.list(decode.int))
use detail_sequence <- decode.optional_field("detailSequence", [], decode.list(decode.int))
use item_sequence <- decode.optional_field("itemSequence", [], decode.list(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitAdditem(detail:,note_number:,sub_site:,body_site:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,provider:,sub_detail_sequence:,detail_sequence:,item_sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_item_detail_subdetail_to_json(explanationofbenefit_item_detail_subdetail: ExplanationofbenefitItemDetailSubdetail) -> Json {
    let ExplanationofbenefitItemDetailSubdetail(note_number:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_item_detail_subdetail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_item_detail_subdetail_decoder() -> Decoder(ExplanationofbenefitItemDetailSubdetail) {use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitItemDetailSubdetail(note_number:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_item_detail_to_json(explanationofbenefit_item_detail: ExplanationofbenefitItemDetail) -> Json {
    let ExplanationofbenefitItemDetail(sub_detail:,note_number:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_item_detail
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case sub_detail {
                        [] -> fields
                        _ -> [#("subDetail", json.array(sub_detail,explanationofbenefit_item_detail_subdetail_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_item_detail_decoder() -> Decoder(ExplanationofbenefitItemDetail) {use sub_detail <- decode.optional_field("subDetail", [], decode.list(explanationofbenefit_item_detail_subdetail_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitItemDetail(sub_detail:,note_number:,udi:,net:,factor:,unit_price:,quantity:,program_code:,modifier:,product_or_service:,category:,revenue:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_item_adjudication_to_json(explanationofbenefit_item_adjudication: ExplanationofbenefitItemAdjudication) -> Json {
    let ExplanationofbenefitItemAdjudication(value:,amount:,reason:,category:,modifier_extension:,extension:,id:,) = explanationofbenefit_item_adjudication
    let fields = [#("category", codeableconcept_to_json(category)),]
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason {
                          Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_item_adjudication_decoder() -> Decoder(ExplanationofbenefitItemAdjudication) {use value <- decode.optional_field("value", None, decode.optional(decode.float))
use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use reason <- decode.optional_field("reason", None, decode.optional(codeableconcept_decoder()))
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitItemAdjudication(value:,amount:,reason:,category:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_item_to_json(explanationofbenefit_item: ExplanationofbenefitItem) -> Json {
    let ExplanationofbenefitItem(detail:,adjudication:,note_number:,encounter:,sub_site:,body_site:,udi:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,category:,revenue:,information_sequence:,procedure_sequence:,diagnosis_sequence:,care_team_sequence:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_item
    let fields = [#("productOrService", codeableconcept_to_json(product_or_service)),#("sequence", json.int(sequence)),]
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,explanationofbenefit_item_detail_to_json)), ..fields]
                          }
let fields = case adjudication {
                        [] -> fields
                        _ -> [#("adjudication", json.array(adjudication,explanationofbenefit_item_adjudication_to_json)), ..fields]
                          }
let fields = case note_number {
                        [] -> fields
                        _ -> [#("noteNumber", json.array(note_number,json.int)), ..fields]
                          }
let fields = case encounter {
                        [] -> fields
                        _ -> [#("encounter", json.array(encounter,reference_to_json)), ..fields]
                          }
let fields = case sub_site {
                        [] -> fields
                        _ -> [#("subSite", json.array(sub_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case net {
                          Some(v) -> [#("net", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_price {
                          Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", explanationofbenefit_item_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case serviced {
                          Some(v) -> [#("serviced", explanationofbenefit_item_serviced_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_code {
                        [] -> fields
                        _ -> [#("programCode", json.array(program_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case revenue {
                          Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case information_sequence {
                        [] -> fields
                        _ -> [#("informationSequence", json.array(information_sequence,json.int)), ..fields]
                          }
let fields = case procedure_sequence {
                        [] -> fields
                        _ -> [#("procedureSequence", json.array(procedure_sequence,json.int)), ..fields]
                          }
let fields = case diagnosis_sequence {
                        [] -> fields
                        _ -> [#("diagnosisSequence", json.array(diagnosis_sequence,json.int)), ..fields]
                          }
let fields = case care_team_sequence {
                        [] -> fields
                        _ -> [#("careTeamSequence", json.array(care_team_sequence,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_item_decoder() -> Decoder(ExplanationofbenefitItem) {use detail <- decode.optional_field("detail", [], decode.list(explanationofbenefit_item_detail_decoder()))
use adjudication <- decode.optional_field("adjudication", [], decode.list(explanationofbenefit_item_adjudication_decoder()))
use note_number <- decode.optional_field("noteNumber", [], decode.list(decode.int))
use encounter <- decode.optional_field("encounter", [], decode.list(reference_decoder()))
use sub_site <- decode.optional_field("subSite", [], decode.list(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use net <- decode.optional_field("net", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use unit_price <- decode.optional_field("unitPrice", None, decode.optional(money_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use location <- decode.then(none_if_omitted(explanationofbenefit_item_location_decoder()))
use serviced <- decode.then(none_if_omitted(explanationofbenefit_item_serviced_decoder()))
use program_code <- decode.optional_field("programCode", [], decode.list(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", [], decode.list(codeableconcept_decoder()))
use product_or_service <- decode.field("productOrService",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use revenue <- decode.optional_field("revenue", None, decode.optional(codeableconcept_decoder()))
use information_sequence <- decode.optional_field("informationSequence", [], decode.list(decode.int))
use procedure_sequence <- decode.optional_field("procedureSequence", [], decode.list(decode.int))
use diagnosis_sequence <- decode.optional_field("diagnosisSequence", [], decode.list(decode.int))
use care_team_sequence <- decode.optional_field("careTeamSequence", [], decode.list(decode.int))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitItem(detail:,adjudication:,note_number:,encounter:,sub_site:,body_site:,udi:,net:,factor:,unit_price:,quantity:,location:,serviced:,program_code:,modifier:,product_or_service:,category:,revenue:,information_sequence:,procedure_sequence:,diagnosis_sequence:,care_team_sequence:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_accident_to_json(explanationofbenefit_accident: ExplanationofbenefitAccident) -> Json {
    let ExplanationofbenefitAccident(location:,type_:,date:,modifier_extension:,extension:,id:,) = explanationofbenefit_accident
    let fields = []
let fields = case location {
                          Some(v) -> [#("location", explanationofbenefit_accident_location_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_accident_decoder() -> Decoder(ExplanationofbenefitAccident) {use location <- decode.then(none_if_omitted(explanationofbenefit_accident_location_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitAccident(location:,type_:,date:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_insurance_to_json(explanationofbenefit_insurance: ExplanationofbenefitInsurance) -> Json {
    let ExplanationofbenefitInsurance(pre_auth_ref:,coverage:,focal:,modifier_extension:,extension:,id:,) = explanationofbenefit_insurance
    let fields = [#("coverage", reference_to_json(coverage)),#("focal", json.bool(focal)),]
let fields = case pre_auth_ref {
                        [] -> fields
                        _ -> [#("preAuthRef", json.array(pre_auth_ref,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_insurance_decoder() -> Decoder(ExplanationofbenefitInsurance) {use pre_auth_ref <- decode.optional_field("preAuthRef", [], decode.list(decode.string))
use coverage <- decode.field("coverage",reference_decoder())
use focal <- decode.field("focal",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitInsurance(pre_auth_ref:,coverage:,focal:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_procedure_to_json(explanationofbenefit_procedure: ExplanationofbenefitProcedure) -> Json {
    let ExplanationofbenefitProcedure(udi:,procedure:,date:,type_:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_procedure
    let fields = [#("procedure", explanationofbenefit_procedure_procedure_to_json(procedure)),#("sequence", json.int(sequence)),]
let fields = case udi {
                        [] -> fields
                        _ -> [#("udi", json.array(udi,reference_to_json)), ..fields]
                          }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_procedure_decoder() -> Decoder(ExplanationofbenefitProcedure) {use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
use procedure <- decode.then(explanationofbenefit_procedure_procedure_decoder())
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitProcedure(udi:,procedure:,date:,type_:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_diagnosis_to_json(explanationofbenefit_diagnosis: ExplanationofbenefitDiagnosis) -> Json {
    let ExplanationofbenefitDiagnosis(package_code:,on_admission:,type_:,diagnosis:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_diagnosis
    let fields = [#("diagnosis", explanationofbenefit_diagnosis_diagnosis_to_json(diagnosis)),#("sequence", json.int(sequence)),]
let fields = case package_code {
                          Some(v) -> [#("packageCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case on_admission {
                          Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_diagnosis_decoder() -> Decoder(ExplanationofbenefitDiagnosis) {use package_code <- decode.optional_field("packageCode", None, decode.optional(codeableconcept_decoder()))
use on_admission <- decode.optional_field("onAdmission", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use diagnosis <- decode.then(explanationofbenefit_diagnosis_diagnosis_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitDiagnosis(package_code:,on_admission:,type_:,diagnosis:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_supportinginfo_to_json(explanationofbenefit_supportinginfo: ExplanationofbenefitSupportinginfo) -> Json {
    let ExplanationofbenefitSupportinginfo(reason:,value:,timing:,code:,category:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_supportinginfo
    let fields = [#("category", codeableconcept_to_json(category)),#("sequence", json.int(sequence)),]
let fields = case reason {
                          Some(v) -> [#("reason", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", explanationofbenefit_supportinginfo_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case timing {
                          Some(v) -> [#("timing", explanationofbenefit_supportinginfo_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_supportinginfo_decoder() -> Decoder(ExplanationofbenefitSupportinginfo) {use reason <- decode.optional_field("reason", None, decode.optional(coding_decoder()))
use value <- decode.then(none_if_omitted(explanationofbenefit_supportinginfo_value_decoder()))
use timing <- decode.then(none_if_omitted(explanationofbenefit_supportinginfo_timing_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use category <- decode.field("category",codeableconcept_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitSupportinginfo(reason:,value:,timing:,code:,category:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_careteam_to_json(explanationofbenefit_careteam: ExplanationofbenefitCareteam) -> Json {
    let ExplanationofbenefitCareteam(qualification:,role:,responsible:,provider:,sequence:,modifier_extension:,extension:,id:,) = explanationofbenefit_careteam
    let fields = [#("provider", reference_to_json(provider)),#("sequence", json.int(sequence)),]
let fields = case qualification {
                          Some(v) -> [#("qualification", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_careteam_decoder() -> Decoder(ExplanationofbenefitCareteam) {use qualification <- decode.optional_field("qualification", None, decode.optional(codeableconcept_decoder()))
use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(decode.bool))
use provider <- decode.field("provider",reference_decoder())
use sequence <- decode.field("sequence",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitCareteam(qualification:,role:,responsible:,provider:,sequence:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_payee_to_json(explanationofbenefit_payee: ExplanationofbenefitPayee) -> Json {
    let ExplanationofbenefitPayee(party:,type_:,modifier_extension:,extension:,id:,) = explanationofbenefit_payee
    let fields = []
let fields = case party {
                          Some(v) -> [#("party", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_payee_decoder() -> Decoder(ExplanationofbenefitPayee) {use party <- decode.optional_field("party", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitPayee(party:,type_:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_related_to_json(explanationofbenefit_related: ExplanationofbenefitRelated) -> Json {
    let ExplanationofbenefitRelated(reference:,relationship:,claim:,modifier_extension:,extension:,id:,) = explanationofbenefit_related
    let fields = []
let fields = case reference {
                          Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                          Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case claim {
                          Some(v) -> [#("claim", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_related_decoder() -> Decoder(ExplanationofbenefitRelated) {use reference <- decode.optional_field("reference", None, decode.optional(identifier_decoder()))
use relationship <- decode.optional_field("relationship", None, decode.optional(codeableconcept_decoder()))
use claim <- decode.optional_field("claim", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ExplanationofbenefitRelated(reference:,relationship:,claim:,modifier_extension:,extension:,id:,))}
pub fn explanationofbenefit_to_json(explanationofbenefit: Explanationofbenefit) -> Json {
    let Explanationofbenefit(benefit_balance:,benefit_period:,process_note:,form:,form_code:,payment:,total:,add_item:,item:,accident:,insurance:,precedence:,procedure:,diagnosis:,supporting_info:,care_team:,pre_auth_ref_period:,pre_auth_ref:,disposition:,outcome:,claim_response:,claim:,facility:,referral:,payee:,original_prescription:,prescription:,related:,funds_reserve:,funds_reserve_requested:,priority:,provider:,insurer:,enterer:,created:,billable_period:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = explanationofbenefit
    let fields = [#("outcome", r4valuesets.remittanceoutcome_to_json(outcome)),#("provider", reference_to_json(provider)),#("insurer", reference_to_json(insurer)),#("created", json.string(created)),#("patient", reference_to_json(patient)),#("use", r4valuesets.claimuse_to_json(use_)),#("type", codeableconcept_to_json(type_)),#("status", r4valuesets.explanationofbenefitstatus_to_json(status)),]
let fields = case benefit_balance {
                        [] -> fields
                        _ -> [#("benefitBalance", json.array(benefit_balance,explanationofbenefit_benefitbalance_to_json)), ..fields]
                          }
let fields = case benefit_period {
                          Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case process_note {
                        [] -> fields
                        _ -> [#("processNote", json.array(process_note,explanationofbenefit_processnote_to_json)), ..fields]
                          }
let fields = case form {
                          Some(v) -> [#("form", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case form_code {
                          Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payment {
                          Some(v) -> [#("payment", explanationofbenefit_payment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case total {
                        [] -> fields
                        _ -> [#("total", json.array(total,explanationofbenefit_total_to_json)), ..fields]
                          }
let fields = case add_item {
                        [] -> fields
                        _ -> [#("addItem", json.array(add_item,explanationofbenefit_additem_to_json)), ..fields]
                          }
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,explanationofbenefit_item_to_json)), ..fields]
                          }
let fields = case accident {
                          Some(v) -> [#("accident", explanationofbenefit_accident_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,explanationofbenefit_insurance_to_json)), ..fields]
                          }
let fields = case precedence {
                          Some(v) -> [#("precedence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case procedure {
                        [] -> fields
                        _ -> [#("procedure", json.array(procedure,explanationofbenefit_procedure_to_json)), ..fields]
                          }
let fields = case diagnosis {
                        [] -> fields
                        _ -> [#("diagnosis", json.array(diagnosis,explanationofbenefit_diagnosis_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,explanationofbenefit_supportinginfo_to_json)), ..fields]
                          }
let fields = case care_team {
                        [] -> fields
                        _ -> [#("careTeam", json.array(care_team,explanationofbenefit_careteam_to_json)), ..fields]
                          }
let fields = case pre_auth_ref_period {
                        [] -> fields
                        _ -> [#("preAuthRefPeriod", json.array(pre_auth_ref_period,period_to_json)), ..fields]
                          }
let fields = case pre_auth_ref {
                        [] -> fields
                        _ -> [#("preAuthRef", json.array(pre_auth_ref,json.string)), ..fields]
                          }
let fields = case disposition {
                          Some(v) -> [#("disposition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case claim_response {
                          Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case claim {
                          Some(v) -> [#("claim", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case facility {
                          Some(v) -> [#("facility", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case referral {
                          Some(v) -> [#("referral", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payee {
                          Some(v) -> [#("payee", explanationofbenefit_payee_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case original_prescription {
                          Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case prescription {
                          Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related {
                        [] -> fields
                        _ -> [#("related", json.array(related,explanationofbenefit_related_to_json)), ..fields]
                          }
let fields = case funds_reserve {
                          Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case funds_reserve_requested {
                          Some(v) -> [#("fundsReserveRequested", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enterer {
                          Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case billable_period {
                          Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sub_type {
                          Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn explanationofbenefit_decoder() -> Decoder(Explanationofbenefit) {use benefit_balance <- decode.optional_field("benefitBalance", [], decode.list(explanationofbenefit_benefitbalance_decoder()))
use benefit_period <- decode.optional_field("benefitPeriod", None, decode.optional(period_decoder()))
use process_note <- decode.optional_field("processNote", [], decode.list(explanationofbenefit_processnote_decoder()))
use form <- decode.optional_field("form", None, decode.optional(attachment_decoder()))
use form_code <- decode.optional_field("formCode", None, decode.optional(codeableconcept_decoder()))
use payment <- decode.optional_field("payment", None, decode.optional(explanationofbenefit_payment_decoder()))
use total <- decode.optional_field("total", [], decode.list(explanationofbenefit_total_decoder()))
use add_item <- decode.optional_field("addItem", [], decode.list(explanationofbenefit_additem_decoder()))
use item <- decode.optional_field("item", [], decode.list(explanationofbenefit_item_decoder()))
use accident <- decode.optional_field("accident", None, decode.optional(explanationofbenefit_accident_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(explanationofbenefit_insurance_decoder()))
use precedence <- decode.optional_field("precedence", None, decode.optional(decode.int))
use procedure <- decode.optional_field("procedure", [], decode.list(explanationofbenefit_procedure_decoder()))
use diagnosis <- decode.optional_field("diagnosis", [], decode.list(explanationofbenefit_diagnosis_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(explanationofbenefit_supportinginfo_decoder()))
use care_team <- decode.optional_field("careTeam", [], decode.list(explanationofbenefit_careteam_decoder()))
use pre_auth_ref_period <- decode.optional_field("preAuthRefPeriod", [], decode.list(period_decoder()))
use pre_auth_ref <- decode.optional_field("preAuthRef", [], decode.list(decode.string))
use disposition <- decode.optional_field("disposition", None, decode.optional(decode.string))
use outcome <- decode.field("outcome",r4valuesets.remittanceoutcome_decoder())
use claim_response <- decode.optional_field("claimResponse", None, decode.optional(reference_decoder()))
use claim <- decode.optional_field("claim", None, decode.optional(reference_decoder()))
use facility <- decode.optional_field("facility", None, decode.optional(reference_decoder()))
use referral <- decode.optional_field("referral", None, decode.optional(reference_decoder()))
use payee <- decode.optional_field("payee", None, decode.optional(explanationofbenefit_payee_decoder()))
use original_prescription <- decode.optional_field("originalPrescription", None, decode.optional(reference_decoder()))
use prescription <- decode.optional_field("prescription", None, decode.optional(reference_decoder()))
use related <- decode.optional_field("related", [], decode.list(explanationofbenefit_related_decoder()))
use funds_reserve <- decode.optional_field("fundsReserve", None, decode.optional(codeableconcept_decoder()))
use funds_reserve_requested <- decode.optional_field("fundsReserveRequested", None, decode.optional(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(codeableconcept_decoder()))
use provider <- decode.field("provider",reference_decoder())
use insurer <- decode.field("insurer",reference_decoder())
use enterer <- decode.optional_field("enterer", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use billable_period <- decode.optional_field("billablePeriod", None, decode.optional(period_decoder()))
use patient <- decode.field("patient",reference_decoder())
use use_ <- decode.field("use",r4valuesets.claimuse_decoder())
use sub_type <- decode.optional_field("subType", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use status <- decode.field("status",r4valuesets.explanationofbenefitstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Explanationofbenefit(benefit_balance:,benefit_period:,process_note:,form:,form_code:,payment:,total:,add_item:,item:,accident:,insurance:,precedence:,procedure:,diagnosis:,supporting_info:,care_team:,pre_auth_ref_period:,pre_auth_ref:,disposition:,outcome:,claim_response:,claim:,facility:,referral:,payee:,original_prescription:,prescription:,related:,funds_reserve:,funds_reserve_requested:,priority:,provider:,insurer:,enterer:,created:,billable_period:,patient:,use_:,sub_type:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type Familymemberhistory
{
Familymemberhistory(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
status: r4valuesets.Historystatus,
data_absent_reason: Option(Codeableconcept),
patient: Reference,
date: Option(String),
name: Option(String),
relationship: Codeableconcept,
sex: Option(Codeableconcept),
born: Option(FamilymemberhistoryBorn),
age: Option(FamilymemberhistoryAge),
estimated_age: Option(Bool),
deceased: Option(FamilymemberhistoryDeceased),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
condition: List(FamilymemberhistoryCondition),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryBorn{
FamilymemberhistoryBornPeriod(born: Period)
FamilymemberhistoryBornDate(born: String)
FamilymemberhistoryBornString(born: String)}
pub fn familymemberhistory_born_to_json(elt: FamilymemberhistoryBorn) -> Json {case elt{FamilymemberhistoryBornPeriod(v) -> period_to_json(v)
FamilymemberhistoryBornDate(v) -> json.string(v)
FamilymemberhistoryBornString(v) -> json.string(v)
}}
pub fn familymemberhistory_born_decoder() -> Decoder(FamilymemberhistoryBorn){decode.one_of(decode.field("bornPeriod", period_decoder(), decode.success) |> decode.map(FamilymemberhistoryBornPeriod),[decode.field("bornDate", decode.string, decode.success) |> decode.map(FamilymemberhistoryBornDate),decode.field("bornString", decode.string, decode.success) |> decode.map(FamilymemberhistoryBornString),])}

///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryAge{
FamilymemberhistoryAgeAge(age: Age)
FamilymemberhistoryAgeRange(age: Range)
FamilymemberhistoryAgeString(age: String)}
pub fn familymemberhistory_age_to_json(elt: FamilymemberhistoryAge) -> Json {case elt{FamilymemberhistoryAgeAge(v) -> age_to_json(v)
FamilymemberhistoryAgeRange(v) -> range_to_json(v)
FamilymemberhistoryAgeString(v) -> json.string(v)
}}
pub fn familymemberhistory_age_decoder() -> Decoder(FamilymemberhistoryAge){decode.one_of(decode.field("ageAge", age_decoder(), decode.success) |> decode.map(FamilymemberhistoryAgeAge),[decode.field("ageRange", range_decoder(), decode.success) |> decode.map(FamilymemberhistoryAgeRange),decode.field("ageString", decode.string, decode.success) |> decode.map(FamilymemberhistoryAgeString),])}

///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryDeceased{
FamilymemberhistoryDeceasedBoolean(deceased: Bool)
FamilymemberhistoryDeceasedAge(deceased: Age)
FamilymemberhistoryDeceasedRange(deceased: Range)
FamilymemberhistoryDeceasedDate(deceased: String)
FamilymemberhistoryDeceasedString(deceased: String)}
pub fn familymemberhistory_deceased_to_json(elt: FamilymemberhistoryDeceased) -> Json {case elt{FamilymemberhistoryDeceasedBoolean(v) -> json.bool(v)
FamilymemberhistoryDeceasedAge(v) -> age_to_json(v)
FamilymemberhistoryDeceasedRange(v) -> range_to_json(v)
FamilymemberhistoryDeceasedDate(v) -> json.string(v)
FamilymemberhistoryDeceasedString(v) -> json.string(v)
}}
pub fn familymemberhistory_deceased_decoder() -> Decoder(FamilymemberhistoryDeceased){decode.one_of(decode.field("deceasedBoolean", decode.bool, decode.success) |> decode.map(FamilymemberhistoryDeceasedBoolean),[decode.field("deceasedAge", age_decoder(), decode.success) |> decode.map(FamilymemberhistoryDeceasedAge),decode.field("deceasedRange", range_decoder(), decode.success) |> decode.map(FamilymemberhistoryDeceasedRange),decode.field("deceasedDate", decode.string, decode.success) |> decode.map(FamilymemberhistoryDeceasedDate),decode.field("deceasedString", decode.string, decode.success) |> decode.map(FamilymemberhistoryDeceasedString),])}
pub fn familymemberhistory_new(relationship relationship: Codeableconcept,patient patient: Reference,status status: r4valuesets.Historystatus,) ->Familymemberhistory{Familymemberhistory(condition: [],note: [],reason_reference: [],reason_code: [],deceased: None,estimated_age: None,age: None,born: None,sex: None,relationship:,name: None,date: None,patient:,data_absent_reason: None,status:,instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryCondition
{
FamilymemberhistoryCondition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
outcome: Option(Codeableconcept),
contributed_to_death: Option(Bool),
onset: Option(FamilymemberhistoryConditionOnset),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryConditionOnset{
FamilymemberhistoryConditionOnsetAge(onset: Age)
FamilymemberhistoryConditionOnsetRange(onset: Range)
FamilymemberhistoryConditionOnsetPeriod(onset: Period)
FamilymemberhistoryConditionOnsetString(onset: String)}
pub fn familymemberhistory_condition_onset_to_json(elt: FamilymemberhistoryConditionOnset) -> Json {case elt{FamilymemberhistoryConditionOnsetAge(v) -> age_to_json(v)
FamilymemberhistoryConditionOnsetRange(v) -> range_to_json(v)
FamilymemberhistoryConditionOnsetPeriod(v) -> period_to_json(v)
FamilymemberhistoryConditionOnsetString(v) -> json.string(v)
}}
pub fn familymemberhistory_condition_onset_decoder() -> Decoder(FamilymemberhistoryConditionOnset){decode.one_of(decode.field("onsetAge", age_decoder(), decode.success) |> decode.map(FamilymemberhistoryConditionOnsetAge),[decode.field("onsetRange", range_decoder(), decode.success) |> decode.map(FamilymemberhistoryConditionOnsetRange),decode.field("onsetPeriod", period_decoder(), decode.success) |> decode.map(FamilymemberhistoryConditionOnsetPeriod),decode.field("onsetString", decode.string, decode.success) |> decode.map(FamilymemberhistoryConditionOnsetString),])}
pub fn familymemberhistory_condition_new(code code: Codeableconcept,) ->FamilymemberhistoryCondition{FamilymemberhistoryCondition(note: [],onset: None,contributed_to_death: None,outcome: None,code:,modifier_extension: [],extension: [],id: None,)
}

pub fn familymemberhistory_condition_to_json(familymemberhistory_condition: FamilymemberhistoryCondition) -> Json {
    let FamilymemberhistoryCondition(note:,onset:,contributed_to_death:,outcome:,code:,modifier_extension:,extension:,id:,) = familymemberhistory_condition
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case onset {
                          Some(v) -> [#("onset", familymemberhistory_condition_onset_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case contributed_to_death {
                          Some(v) -> [#("contributedToDeath", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn familymemberhistory_condition_decoder() -> Decoder(FamilymemberhistoryCondition) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use onset <- decode.then(none_if_omitted(familymemberhistory_condition_onset_decoder()))
use contributed_to_death <- decode.optional_field("contributedToDeath", None, decode.optional(decode.bool))
use outcome <- decode.optional_field("outcome", None, decode.optional(codeableconcept_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(FamilymemberhistoryCondition(note:,onset:,contributed_to_death:,outcome:,code:,modifier_extension:,extension:,id:,))}
pub fn familymemberhistory_to_json(familymemberhistory: Familymemberhistory) -> Json {
    let Familymemberhistory(condition:,note:,reason_reference:,reason_code:,deceased:,estimated_age:,age:,born:,sex:,relationship:,name:,date:,patient:,data_absent_reason:,status:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = familymemberhistory
    let fields = [#("relationship", codeableconcept_to_json(relationship)),#("patient", reference_to_json(patient)),#("status", r4valuesets.historystatus_to_json(status)),]
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,familymemberhistory_condition_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case deceased {
                          Some(v) -> [#("deceased", familymemberhistory_deceased_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case estimated_age {
                          Some(v) -> [#("estimatedAge", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case age {
                          Some(v) -> [#("age", familymemberhistory_age_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case born {
                          Some(v) -> [#("born", familymemberhistory_born_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sex {
                          Some(v) -> [#("sex", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case data_absent_reason {
                          Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn familymemberhistory_decoder() -> Decoder(Familymemberhistory) {use condition <- decode.optional_field("condition", [], decode.list(familymemberhistory_condition_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use deceased <- decode.then(none_if_omitted(familymemberhistory_deceased_decoder()))
use estimated_age <- decode.optional_field("estimatedAge", None, decode.optional(decode.bool))
use age <- decode.then(none_if_omitted(familymemberhistory_age_decoder()))
use born <- decode.then(none_if_omitted(familymemberhistory_born_decoder()))
use sex <- decode.optional_field("sex", None, decode.optional(codeableconcept_decoder()))
use relationship <- decode.field("relationship",codeableconcept_decoder())
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use patient <- decode.field("patient",reference_decoder())
use data_absent_reason <- decode.optional_field("dataAbsentReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.historystatus_decoder())
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Familymemberhistory(condition:,note:,reason_reference:,reason_code:,deceased:,estimated_age:,age:,born:,sex:,relationship:,name:,date:,patient:,data_absent_reason:,status:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Flag#resource
pub type Flag
{
Flag(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Flagstatus,
category: List(Codeableconcept),
code: Codeableconcept,
subject: Reference,
period: Option(Period),
encounter: Option(Reference),
author: Option(Reference),
)
}

pub fn flag_new(subject subject: Reference,code code: Codeableconcept,status status: r4valuesets.Flagstatus,) ->Flag{Flag(author: None,encounter: None,period: None,subject:,code:,category: [],status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn flag_to_json(flag: Flag) -> Json {
    let Flag(author:,encounter:,period:,subject:,code:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = flag
    let fields = [#("subject", reference_to_json(subject)),#("code", codeableconcept_to_json(code)),#("status", r4valuesets.flagstatus_to_json(status)),]
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn flag_decoder() -> Decoder(Flag) {use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use subject <- decode.field("subject",reference_decoder())
use code <- decode.field("code",codeableconcept_decoder())
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.flagstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Flag(author:,encounter:,period:,subject:,code:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Goal#resource
pub type Goal
{
Goal(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
lifecycle_status: r4valuesets.Goalstatus,
achievement_status: Option(Codeableconcept),
category: List(Codeableconcept),
priority: Option(Codeableconcept),
description: Codeableconcept,
subject: Reference,
start: Option(GoalStart),
target: List(GoalTarget),
status_date: Option(String),
status_reason: Option(String),
expressed_by: Option(Reference),
addresses: List(Reference),
note: List(Annotation),
outcome_code: List(Codeableconcept),
outcome_reference: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Goal#resource
pub type GoalStart{
GoalStartDate(start: String)
GoalStartCodeableconcept(start: Codeableconcept)}
pub fn goal_start_to_json(elt: GoalStart) -> Json {case elt{GoalStartDate(v) -> json.string(v)
GoalStartCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn goal_start_decoder() -> Decoder(GoalStart){decode.one_of(decode.field("startDate", decode.string, decode.success) |> decode.map(GoalStartDate),[decode.field("startCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(GoalStartCodeableconcept),])}
pub fn goal_new(subject subject: Reference,description description: Codeableconcept,lifecycle_status lifecycle_status: r4valuesets.Goalstatus,) ->Goal{Goal(outcome_reference: [],outcome_code: [],note: [],addresses: [],expressed_by: None,status_reason: None,status_date: None,target: [],start: None,subject:,description:,priority: None,category: [],achievement_status: None,lifecycle_status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Goal#resource
pub type GoalTarget
{
GoalTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
measure: Option(Codeableconcept),
detail: Option(GoalTargetDetail),
due: Option(GoalTargetDue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Goal#resource
pub type GoalTargetDetail{
GoalTargetDetailQuantity(detail: Quantity)
GoalTargetDetailRange(detail: Range)
GoalTargetDetailCodeableconcept(detail: Codeableconcept)
GoalTargetDetailString(detail: String)
GoalTargetDetailBoolean(detail: Bool)
GoalTargetDetailInteger(detail: Int)
GoalTargetDetailRatio(detail: Ratio)}
pub fn goal_target_detail_to_json(elt: GoalTargetDetail) -> Json {case elt{GoalTargetDetailQuantity(v) -> quantity_to_json(v)
GoalTargetDetailRange(v) -> range_to_json(v)
GoalTargetDetailCodeableconcept(v) -> codeableconcept_to_json(v)
GoalTargetDetailString(v) -> json.string(v)
GoalTargetDetailBoolean(v) -> json.bool(v)
GoalTargetDetailInteger(v) -> json.int(v)
GoalTargetDetailRatio(v) -> ratio_to_json(v)
}}
pub fn goal_target_detail_decoder() -> Decoder(GoalTargetDetail){decode.one_of(decode.field("detailQuantity", quantity_decoder(), decode.success) |> decode.map(GoalTargetDetailQuantity),[decode.field("detailRange", range_decoder(), decode.success) |> decode.map(GoalTargetDetailRange),decode.field("detailCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(GoalTargetDetailCodeableconcept),decode.field("detailString", decode.string, decode.success) |> decode.map(GoalTargetDetailString),decode.field("detailBoolean", decode.bool, decode.success) |> decode.map(GoalTargetDetailBoolean),decode.field("detailInteger", decode.int, decode.success) |> decode.map(GoalTargetDetailInteger),decode.field("detailRatio", ratio_decoder(), decode.success) |> decode.map(GoalTargetDetailRatio),])}

///http://hl7.org/fhir/r4/StructureDefinition/Goal#resource
pub type GoalTargetDue{
GoalTargetDueDate(due: String)
GoalTargetDueDuration(due: Duration)}
pub fn goal_target_due_to_json(elt: GoalTargetDue) -> Json {case elt{GoalTargetDueDate(v) -> json.string(v)
GoalTargetDueDuration(v) -> duration_to_json(v)
}}
pub fn goal_target_due_decoder() -> Decoder(GoalTargetDue){decode.one_of(decode.field("dueDate", decode.string, decode.success) |> decode.map(GoalTargetDueDate),[decode.field("dueDuration", duration_decoder(), decode.success) |> decode.map(GoalTargetDueDuration),])}
pub fn goal_target_new() ->GoalTarget{GoalTarget(due: None,detail: None,measure: None,modifier_extension: [],extension: [],id: None,)
}

pub fn goal_target_to_json(goal_target: GoalTarget) -> Json {
    let GoalTarget(due:,detail:,measure:,modifier_extension:,extension:,id:,) = goal_target
    let fields = []
let fields = case due {
                          Some(v) -> [#("due", goal_target_due_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case detail {
                          Some(v) -> [#("detail", goal_target_detail_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case measure {
                          Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn goal_target_decoder() -> Decoder(GoalTarget) {use due <- decode.then(none_if_omitted(goal_target_due_decoder()))
use detail <- decode.then(none_if_omitted(goal_target_detail_decoder()))
use measure <- decode.optional_field("measure", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GoalTarget(due:,detail:,measure:,modifier_extension:,extension:,id:,))}
pub fn goal_to_json(goal: Goal) -> Json {
    let Goal(outcome_reference:,outcome_code:,note:,addresses:,expressed_by:,status_reason:,status_date:,target:,start:,subject:,description:,priority:,category:,achievement_status:,lifecycle_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = goal
    let fields = [#("subject", reference_to_json(subject)),#("description", codeableconcept_to_json(description)),#("lifecycleStatus", r4valuesets.goalstatus_to_json(lifecycle_status)),]
let fields = case outcome_reference {
                        [] -> fields
                        _ -> [#("outcomeReference", json.array(outcome_reference,reference_to_json)), ..fields]
                          }
let fields = case outcome_code {
                        [] -> fields
                        _ -> [#("outcomeCode", json.array(outcome_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case addresses {
                        [] -> fields
                        _ -> [#("addresses", json.array(addresses,reference_to_json)), ..fields]
                          }
let fields = case expressed_by {
                          Some(v) -> [#("expressedBy", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status_date {
                          Some(v) -> [#("statusDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,goal_target_to_json)), ..fields]
                          }
let fields = case start {
                          Some(v) -> [#("start", goal_start_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case achievement_status {
                          Some(v) -> [#("achievementStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn goal_decoder() -> Decoder(Goal) {use outcome_reference <- decode.optional_field("outcomeReference", [], decode.list(reference_decoder()))
use outcome_code <- decode.optional_field("outcomeCode", [], decode.list(codeableconcept_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use addresses <- decode.optional_field("addresses", [], decode.list(reference_decoder()))
use expressed_by <- decode.optional_field("expressedBy", None, decode.optional(reference_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(decode.string))
use status_date <- decode.optional_field("statusDate", None, decode.optional(decode.string))
use target <- decode.optional_field("target", [], decode.list(goal_target_decoder()))
use start <- decode.then(none_if_omitted(goal_start_decoder()))
use subject <- decode.field("subject",reference_decoder())
use description <- decode.field("description",codeableconcept_decoder())
use priority <- decode.optional_field("priority", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use achievement_status <- decode.optional_field("achievementStatus", None, decode.optional(codeableconcept_decoder()))
use lifecycle_status <- decode.field("lifecycleStatus",r4valuesets.goalstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Goal(outcome_reference:,outcome_code:,note:,addresses:,expressed_by:,status_reason:,status_date:,target:,start:,subject:,description:,priority:,category:,achievement_status:,lifecycle_status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/GraphDefinition#resource
pub type Graphdefinition
{
Graphdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
version: Option(String),
name: String,
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
start: r4valuesets.Resourcetypes,
profile: Option(String),
link: List(GraphdefinitionLink),
)
}

pub fn graphdefinition_new(start start: r4valuesets.Resourcetypes,status status: r4valuesets.Publicationstatus,name name: String,) ->Graphdefinition{Graphdefinition(link: [],profile: None,start:,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,name:,version: None,url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLink
{
GraphdefinitionLink(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
path: Option(String),
slice_name: Option(String),
min: Option(Int),
max: Option(String),
description: Option(String),
target: List(GraphdefinitionLinkTarget),
)
}

pub fn graphdefinition_link_new() ->GraphdefinitionLink{GraphdefinitionLink(target: [],description: None,max: None,min: None,slice_name: None,path: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLinkTarget
{
GraphdefinitionLinkTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Resourcetypes,
params: Option(String),
profile: Option(String),
compartment: List(GraphdefinitionLinkTargetCompartment),
)
}

pub fn graphdefinition_link_target_new(type_ type_: r4valuesets.Resourcetypes,) ->GraphdefinitionLinkTarget{GraphdefinitionLinkTarget(compartment: [],profile: None,params: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLinkTargetCompartment
{
GraphdefinitionLinkTargetCompartment(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
use_: r4valuesets.Graphcompartmentuse,
code: r4valuesets.Compartmenttype,
rule: r4valuesets.Graphcompartmentrule,
expression: Option(String),
description: Option(String),
)
}

pub fn graphdefinition_link_target_compartment_new(rule rule: r4valuesets.Graphcompartmentrule,code code: r4valuesets.Compartmenttype,use_ use_: r4valuesets.Graphcompartmentuse,) ->GraphdefinitionLinkTargetCompartment{GraphdefinitionLinkTargetCompartment(description: None,expression: None,rule:,code:,use_:,modifier_extension: [],extension: [],id: None,)
}

pub fn graphdefinition_link_target_compartment_to_json(graphdefinition_link_target_compartment: GraphdefinitionLinkTargetCompartment) -> Json {
    let GraphdefinitionLinkTargetCompartment(description:,expression:,rule:,code:,use_:,modifier_extension:,extension:,id:,) = graphdefinition_link_target_compartment
    let fields = [#("rule", r4valuesets.graphcompartmentrule_to_json(rule)),#("code", r4valuesets.compartmenttype_to_json(code)),#("use", r4valuesets.graphcompartmentuse_to_json(use_)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn graphdefinition_link_target_compartment_decoder() -> Decoder(GraphdefinitionLinkTargetCompartment) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use rule <- decode.field("rule",r4valuesets.graphcompartmentrule_decoder())
use code <- decode.field("code",r4valuesets.compartmenttype_decoder())
use use_ <- decode.field("use",r4valuesets.graphcompartmentuse_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GraphdefinitionLinkTargetCompartment(description:,expression:,rule:,code:,use_:,modifier_extension:,extension:,id:,))}
pub fn graphdefinition_link_target_to_json(graphdefinition_link_target: GraphdefinitionLinkTarget) -> Json {
    let GraphdefinitionLinkTarget(compartment:,profile:,params:,type_:,modifier_extension:,extension:,id:,) = graphdefinition_link_target
    let fields = [#("type", r4valuesets.resourcetypes_to_json(type_)),]
let fields = case compartment {
                        [] -> fields
                        _ -> [#("compartment", json.array(compartment,graphdefinition_link_target_compartment_to_json)), ..fields]
                          }
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case params {
                          Some(v) -> [#("params", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn graphdefinition_link_target_decoder() -> Decoder(GraphdefinitionLinkTarget) {use compartment <- decode.optional_field("compartment", [], decode.list(graphdefinition_link_target_compartment_decoder()))
use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use params <- decode.optional_field("params", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.resourcetypes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GraphdefinitionLinkTarget(compartment:,profile:,params:,type_:,modifier_extension:,extension:,id:,))}
pub fn graphdefinition_link_to_json(graphdefinition_link: GraphdefinitionLink) -> Json {
    let GraphdefinitionLink(target:,description:,max:,min:,slice_name:,path:,modifier_extension:,extension:,id:,) = graphdefinition_link
    let fields = []
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,graphdefinition_link_target_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max {
                          Some(v) -> [#("max", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case min {
                          Some(v) -> [#("min", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case slice_name {
                          Some(v) -> [#("sliceName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case path {
                          Some(v) -> [#("path", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn graphdefinition_link_decoder() -> Decoder(GraphdefinitionLink) {use target <- decode.optional_field("target", [], decode.list(graphdefinition_link_target_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use max <- decode.optional_field("max", None, decode.optional(decode.string))
use min <- decode.optional_field("min", None, decode.optional(decode.int))
use slice_name <- decode.optional_field("sliceName", None, decode.optional(decode.string))
use path <- decode.optional_field("path", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GraphdefinitionLink(target:,description:,max:,min:,slice_name:,path:,modifier_extension:,extension:,id:,))}
pub fn graphdefinition_to_json(graphdefinition: Graphdefinition) -> Json {
    let Graphdefinition(link:,profile:,start:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = graphdefinition
    let fields = [#("start", r4valuesets.resourcetypes_to_json(start)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),]
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,graphdefinition_link_to_json)), ..fields]
                          }
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn graphdefinition_decoder() -> Decoder(Graphdefinition) {use link <- decode.optional_field("link", [], decode.list(graphdefinition_link_decoder()))
use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use start <- decode.field("start",r4valuesets.resourcetypes_decoder())
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Graphdefinition(link:,profile:,start:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Group#resource
pub type Group
{
Group(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
type_: r4valuesets.Grouptype,
actual: Bool,
code: Option(Codeableconcept),
name: Option(String),
quantity: Option(Int),
managing_entity: Option(Reference),
characteristic: List(GroupCharacteristic),
member: List(GroupMember),
)
}

pub fn group_new(actual actual: Bool,type_ type_: r4valuesets.Grouptype,) ->Group{Group(member: [],characteristic: [],managing_entity: None,quantity: None,name: None,code: None,actual:,type_:,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Group#resource
pub type GroupCharacteristic
{
GroupCharacteristic(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
value: GroupCharacteristicValue,
exclude: Bool,
period: Option(Period),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Group#resource
pub type GroupCharacteristicValue{
GroupCharacteristicValueCodeableconcept(value: Codeableconcept)
GroupCharacteristicValueBoolean(value: Bool)
GroupCharacteristicValueQuantity(value: Quantity)
GroupCharacteristicValueRange(value: Range)
GroupCharacteristicValueReference(value: Reference)}
pub fn group_characteristic_value_to_json(elt: GroupCharacteristicValue) -> Json {case elt{GroupCharacteristicValueCodeableconcept(v) -> codeableconcept_to_json(v)
GroupCharacteristicValueBoolean(v) -> json.bool(v)
GroupCharacteristicValueQuantity(v) -> quantity_to_json(v)
GroupCharacteristicValueRange(v) -> range_to_json(v)
GroupCharacteristicValueReference(v) -> reference_to_json(v)
}}
pub fn group_characteristic_value_decoder() -> Decoder(GroupCharacteristicValue){decode.one_of(decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(GroupCharacteristicValueCodeableconcept),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(GroupCharacteristicValueBoolean),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(GroupCharacteristicValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(GroupCharacteristicValueRange),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(GroupCharacteristicValueReference),])}
pub fn group_characteristic_new(exclude exclude: Bool,value value: GroupCharacteristicValue,code code: Codeableconcept,) ->GroupCharacteristic{GroupCharacteristic(period: None,exclude:,value:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Group#resource
pub type GroupMember
{
GroupMember(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
entity: Reference,
period: Option(Period),
inactive: Option(Bool),
)
}

pub fn group_member_new(entity entity: Reference,) ->GroupMember{GroupMember(inactive: None,period: None,entity:,modifier_extension: [],extension: [],id: None,)
}

pub fn group_member_to_json(group_member: GroupMember) -> Json {
    let GroupMember(inactive:,period:,entity:,modifier_extension:,extension:,id:,) = group_member
    let fields = [#("entity", reference_to_json(entity)),]
let fields = case inactive {
                          Some(v) -> [#("inactive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn group_member_decoder() -> Decoder(GroupMember) {use inactive <- decode.optional_field("inactive", None, decode.optional(decode.bool))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use entity <- decode.field("entity",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GroupMember(inactive:,period:,entity:,modifier_extension:,extension:,id:,))}
pub fn group_characteristic_to_json(group_characteristic: GroupCharacteristic) -> Json {
    let GroupCharacteristic(period:,exclude:,value:,code:,modifier_extension:,extension:,id:,) = group_characteristic
    let fields = [#("exclude", json.bool(exclude)),#("value", group_characteristic_value_to_json(value)),#("code", codeableconcept_to_json(code)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn group_characteristic_decoder() -> Decoder(GroupCharacteristic) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use exclude <- decode.field("exclude",decode.bool)
use value <- decode.then(group_characteristic_value_decoder())
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(GroupCharacteristic(period:,exclude:,value:,code:,modifier_extension:,extension:,id:,))}
pub fn group_to_json(group: Group) -> Json {
    let Group(member:,characteristic:,managing_entity:,quantity:,name:,code:,actual:,type_:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = group
    let fields = [#("actual", json.bool(actual)),#("type", r4valuesets.grouptype_to_json(type_)),]
let fields = case member {
                        [] -> fields
                        _ -> [#("member", json.array(member,group_member_to_json)), ..fields]
                          }
let fields = case characteristic {
                        [] -> fields
                        _ -> [#("characteristic", json.array(characteristic,group_characteristic_to_json)), ..fields]
                          }
let fields = case managing_entity {
                          Some(v) -> [#("managingEntity", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn group_decoder() -> Decoder(Group) {use member <- decode.optional_field("member", [], decode.list(group_member_decoder()))
use characteristic <- decode.optional_field("characteristic", [], decode.list(group_characteristic_decoder()))
use managing_entity <- decode.optional_field("managingEntity", None, decode.optional(reference_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(decode.int))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use actual <- decode.field("actual",decode.bool)
use type_ <- decode.field("type",r4valuesets.grouptype_decoder())
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Group(member:,characteristic:,managing_entity:,quantity:,name:,code:,actual:,type_:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/GuidanceResponse#resource
pub type Guidanceresponse
{
Guidanceresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
request_identifier: Option(Identifier),
identifier: List(Identifier),
module: GuidanceresponseModule,
status: r4valuesets.Guidanceresponsestatus,
subject: Option(Reference),
encounter: Option(Reference),
occurrence_date_time: Option(String),
performer: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
evaluation_message: List(Reference),
output_parameters: Option(Reference),
result: Option(Reference),
data_requirement: List(Datarequirement),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/GuidanceResponse#resource
pub type GuidanceresponseModule{
GuidanceresponseModuleUri(module: String)
GuidanceresponseModuleCanonical(module: String)
GuidanceresponseModuleCodeableconcept(module: Codeableconcept)}
pub fn guidanceresponse_module_to_json(elt: GuidanceresponseModule) -> Json {case elt{GuidanceresponseModuleUri(v) -> json.string(v)
GuidanceresponseModuleCanonical(v) -> json.string(v)
GuidanceresponseModuleCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn guidanceresponse_module_decoder() -> Decoder(GuidanceresponseModule){decode.one_of(decode.field("moduleUri", decode.string, decode.success) |> decode.map(GuidanceresponseModuleUri),[decode.field("moduleCanonical", decode.string, decode.success) |> decode.map(GuidanceresponseModuleCanonical),decode.field("moduleCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(GuidanceresponseModuleCodeableconcept),])}
pub fn guidanceresponse_new(status status: r4valuesets.Guidanceresponsestatus,module module: GuidanceresponseModule,) ->Guidanceresponse{Guidanceresponse(data_requirement: [],result: None,output_parameters: None,evaluation_message: [],note: [],reason_reference: [],reason_code: [],performer: None,occurrence_date_time: None,encounter: None,subject: None,status:,module:,identifier: [],request_identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn guidanceresponse_to_json(guidanceresponse: Guidanceresponse) -> Json {
    let Guidanceresponse(data_requirement:,result:,output_parameters:,evaluation_message:,note:,reason_reference:,reason_code:,performer:,occurrence_date_time:,encounter:,subject:,status:,module:,identifier:,request_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = guidanceresponse
    let fields = [#("status", r4valuesets.guidanceresponsestatus_to_json(status)),#("module", guidanceresponse_module_to_json(module)),]
let fields = case data_requirement {
                        [] -> fields
                        _ -> [#("dataRequirement", json.array(data_requirement,datarequirement_to_json)), ..fields]
                          }
let fields = case result {
                          Some(v) -> [#("result", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case output_parameters {
                          Some(v) -> [#("outputParameters", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case evaluation_message {
                        [] -> fields
                        _ -> [#("evaluationMessage", json.array(evaluation_message,reference_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence_date_time {
                          Some(v) -> [#("occurrenceDateTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case request_identifier {
                          Some(v) -> [#("requestIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn guidanceresponse_decoder() -> Decoder(Guidanceresponse) {use data_requirement <- decode.optional_field("dataRequirement", [], decode.list(datarequirement_decoder()))
use result <- decode.optional_field("result", None, decode.optional(reference_decoder()))
use output_parameters <- decode.optional_field("outputParameters", None, decode.optional(reference_decoder()))
use evaluation_message <- decode.optional_field("evaluationMessage", [], decode.list(reference_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use occurrence_date_time <- decode.optional_field("occurrenceDateTime", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use status <- decode.field("status",r4valuesets.guidanceresponsestatus_decoder())
use module <- decode.then(guidanceresponse_module_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use request_identifier <- decode.optional_field("requestIdentifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Guidanceresponse(data_requirement:,result:,output_parameters:,evaluation_message:,note:,reason_reference:,reason_code:,performer:,occurrence_date_time:,encounter:,subject:,status:,module:,identifier:,request_identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/HealthcareService#resource
pub type Healthcareservice
{
Healthcareservice(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
provided_by: Option(Reference),
category: List(Codeableconcept),
type_: List(Codeableconcept),
specialty: List(Codeableconcept),
location: List(Reference),
name: Option(String),
comment: Option(String),
extra_details: Option(String),
photo: Option(Attachment),
telecom: List(Contactpoint),
coverage_area: List(Reference),
service_provision_code: List(Codeableconcept),
eligibility: List(HealthcareserviceEligibility),
program: List(Codeableconcept),
characteristic: List(Codeableconcept),
communication: List(Codeableconcept),
referral_method: List(Codeableconcept),
appointment_required: Option(Bool),
available_time: List(HealthcareserviceAvailabletime),
not_available: List(HealthcareserviceNotavailable),
availability_exceptions: Option(String),
endpoint: List(Reference),
)
}

pub fn healthcareservice_new() ->Healthcareservice{Healthcareservice(endpoint: [],availability_exceptions: None,not_available: [],available_time: [],appointment_required: None,referral_method: [],communication: [],characteristic: [],program: [],eligibility: [],service_provision_code: [],coverage_area: [],telecom: [],photo: None,extra_details: None,comment: None,name: None,location: [],specialty: [],type_: [],category: [],provided_by: None,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceEligibility
{
HealthcareserviceEligibility(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
comment: Option(String),
)
}

pub fn healthcareservice_eligibility_new() ->HealthcareserviceEligibility{HealthcareserviceEligibility(comment: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceAvailabletime
{
HealthcareserviceAvailabletime(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
days_of_week: List(r4valuesets.Daysofweek),
all_day: Option(Bool),
available_start_time: Option(String),
available_end_time: Option(String),
)
}

pub fn healthcareservice_availabletime_new() ->HealthcareserviceAvailabletime{HealthcareserviceAvailabletime(available_end_time: None,available_start_time: None,all_day: None,days_of_week: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceNotavailable
{
HealthcareserviceNotavailable(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: String,
during: Option(Period),
)
}

pub fn healthcareservice_notavailable_new(description description: String,) ->HealthcareserviceNotavailable{HealthcareserviceNotavailable(during: None,description:,modifier_extension: [],extension: [],id: None,)
}

pub fn healthcareservice_notavailable_to_json(healthcareservice_notavailable: HealthcareserviceNotavailable) -> Json {
    let HealthcareserviceNotavailable(during:,description:,modifier_extension:,extension:,id:,) = healthcareservice_notavailable
    let fields = [#("description", json.string(description)),]
let fields = case during {
                          Some(v) -> [#("during", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn healthcareservice_notavailable_decoder() -> Decoder(HealthcareserviceNotavailable) {use during <- decode.optional_field("during", None, decode.optional(period_decoder()))
use description <- decode.field("description",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(HealthcareserviceNotavailable(during:,description:,modifier_extension:,extension:,id:,))}
pub fn healthcareservice_availabletime_to_json(healthcareservice_availabletime: HealthcareserviceAvailabletime) -> Json {
    let HealthcareserviceAvailabletime(available_end_time:,available_start_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,) = healthcareservice_availabletime
    let fields = []
let fields = case available_end_time {
                          Some(v) -> [#("availableEndTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case available_start_time {
                          Some(v) -> [#("availableStartTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case all_day {
                          Some(v) -> [#("allDay", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case days_of_week {
                        [] -> fields
                        _ -> [#("daysOfWeek", json.array(days_of_week,r4valuesets.daysofweek_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn healthcareservice_availabletime_decoder() -> Decoder(HealthcareserviceAvailabletime) {use available_end_time <- decode.optional_field("availableEndTime", None, decode.optional(decode.string))
use available_start_time <- decode.optional_field("availableStartTime", None, decode.optional(decode.string))
use all_day <- decode.optional_field("allDay", None, decode.optional(decode.bool))
use days_of_week <- decode.optional_field("daysOfWeek", [], decode.list(r4valuesets.daysofweek_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(HealthcareserviceAvailabletime(available_end_time:,available_start_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,))}
pub fn healthcareservice_eligibility_to_json(healthcareservice_eligibility: HealthcareserviceEligibility) -> Json {
    let HealthcareserviceEligibility(comment:,code:,modifier_extension:,extension:,id:,) = healthcareservice_eligibility
    let fields = []
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn healthcareservice_eligibility_decoder() -> Decoder(HealthcareserviceEligibility) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(HealthcareserviceEligibility(comment:,code:,modifier_extension:,extension:,id:,))}
pub fn healthcareservice_to_json(healthcareservice: Healthcareservice) -> Json {
    let Healthcareservice(endpoint:,availability_exceptions:,not_available:,available_time:,appointment_required:,referral_method:,communication:,characteristic:,program:,eligibility:,service_provision_code:,coverage_area:,telecom:,photo:,extra_details:,comment:,name:,location:,specialty:,type_:,category:,provided_by:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = healthcareservice
    let fields = []
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case availability_exceptions {
                          Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case not_available {
                        [] -> fields
                        _ -> [#("notAvailable", json.array(not_available,healthcareservice_notavailable_to_json)), ..fields]
                          }
let fields = case available_time {
                        [] -> fields
                        _ -> [#("availableTime", json.array(available_time,healthcareservice_availabletime_to_json)), ..fields]
                          }
let fields = case appointment_required {
                          Some(v) -> [#("appointmentRequired", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case referral_method {
                        [] -> fields
                        _ -> [#("referralMethod", json.array(referral_method,codeableconcept_to_json)), ..fields]
                          }
let fields = case communication {
                        [] -> fields
                        _ -> [#("communication", json.array(communication,codeableconcept_to_json)), ..fields]
                          }
let fields = case characteristic {
                        [] -> fields
                        _ -> [#("characteristic", json.array(characteristic,codeableconcept_to_json)), ..fields]
                          }
let fields = case program {
                        [] -> fields
                        _ -> [#("program", json.array(program,codeableconcept_to_json)), ..fields]
                          }
let fields = case eligibility {
                        [] -> fields
                        _ -> [#("eligibility", json.array(eligibility,healthcareservice_eligibility_to_json)), ..fields]
                          }
let fields = case service_provision_code {
                        [] -> fields
                        _ -> [#("serviceProvisionCode", json.array(service_provision_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case coverage_area {
                        [] -> fields
                        _ -> [#("coverageArea", json.array(coverage_area,reference_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case photo {
                          Some(v) -> [#("photo", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case extra_details {
                          Some(v) -> [#("extraDetails", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,reference_to_json)), ..fields]
                          }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case provided_by {
                          Some(v) -> [#("providedBy", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn healthcareservice_decoder() -> Decoder(Healthcareservice) {use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use availability_exceptions <- decode.optional_field("availabilityExceptions", None, decode.optional(decode.string))
use not_available <- decode.optional_field("notAvailable", [], decode.list(healthcareservice_notavailable_decoder()))
use available_time <- decode.optional_field("availableTime", [], decode.list(healthcareservice_availabletime_decoder()))
use appointment_required <- decode.optional_field("appointmentRequired", None, decode.optional(decode.bool))
use referral_method <- decode.optional_field("referralMethod", [], decode.list(codeableconcept_decoder()))
use communication <- decode.optional_field("communication", [], decode.list(codeableconcept_decoder()))
use characteristic <- decode.optional_field("characteristic", [], decode.list(codeableconcept_decoder()))
use program <- decode.optional_field("program", [], decode.list(codeableconcept_decoder()))
use eligibility <- decode.optional_field("eligibility", [], decode.list(healthcareservice_eligibility_decoder()))
use service_provision_code <- decode.optional_field("serviceProvisionCode", [], decode.list(codeableconcept_decoder()))
use coverage_area <- decode.optional_field("coverageArea", [], decode.list(reference_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use photo <- decode.optional_field("photo", None, decode.optional(attachment_decoder()))
use extra_details <- decode.optional_field("extraDetails", None, decode.optional(decode.string))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use location <- decode.optional_field("location", [], decode.list(reference_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use provided_by <- decode.optional_field("providedBy", None, decode.optional(reference_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Healthcareservice(endpoint:,availability_exceptions:,not_available:,available_time:,appointment_required:,referral_method:,communication:,characteristic:,program:,eligibility:,service_provision_code:,coverage_area:,telecom:,photo:,extra_details:,comment:,name:,location:,specialty:,type_:,category:,provided_by:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ImagingStudy#resource
pub type Imagingstudy
{
Imagingstudy(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Imagingstudystatus,
modality: List(Coding),
subject: Reference,
encounter: Option(Reference),
started: Option(String),
based_on: List(Reference),
referrer: Option(Reference),
interpreter: List(Reference),
endpoint: List(Reference),
number_of_series: Option(Int),
number_of_instances: Option(Int),
procedure_reference: Option(Reference),
procedure_code: List(Codeableconcept),
location: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
description: Option(String),
series: List(ImagingstudySeries),
)
}

pub fn imagingstudy_new(subject subject: Reference,status status: r4valuesets.Imagingstudystatus,) ->Imagingstudy{Imagingstudy(series: [],description: None,note: [],reason_reference: [],reason_code: [],location: None,procedure_code: [],procedure_reference: None,number_of_instances: None,number_of_series: None,endpoint: [],interpreter: [],referrer: None,based_on: [],started: None,encounter: None,subject:,modality: [],status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeries
{
ImagingstudySeries(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
uid: String,
number: Option(Int),
modality: Coding,
description: Option(String),
number_of_instances: Option(Int),
endpoint: List(Reference),
body_site: Option(Coding),
laterality: Option(Coding),
specimen: List(Reference),
started: Option(String),
performer: List(ImagingstudySeriesPerformer),
instance: List(ImagingstudySeriesInstance),
)
}

pub fn imagingstudy_series_new(modality modality: Coding,uid uid: String,) ->ImagingstudySeries{ImagingstudySeries(instance: [],performer: [],started: None,specimen: [],laterality: None,body_site: None,endpoint: [],number_of_instances: None,description: None,modality:,number: None,uid:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesPerformer
{
ImagingstudySeriesPerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
)
}

pub fn imagingstudy_series_performer_new(actor actor: Reference,) ->ImagingstudySeriesPerformer{ImagingstudySeriesPerformer(actor:,function: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesInstance
{
ImagingstudySeriesInstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
uid: String,
sop_class: Coding,
number: Option(Int),
title: Option(String),
)
}

pub fn imagingstudy_series_instance_new(sop_class sop_class: Coding,uid uid: String,) ->ImagingstudySeriesInstance{ImagingstudySeriesInstance(title: None,number: None,sop_class:,uid:,modifier_extension: [],extension: [],id: None,)
}

pub fn imagingstudy_series_instance_to_json(imagingstudy_series_instance: ImagingstudySeriesInstance) -> Json {
    let ImagingstudySeriesInstance(title:,number:,sop_class:,uid:,modifier_extension:,extension:,id:,) = imagingstudy_series_instance
    let fields = [#("sopClass", coding_to_json(sop_class)),#("uid", json.string(uid)),]
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case number {
                          Some(v) -> [#("number", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn imagingstudy_series_instance_decoder() -> Decoder(ImagingstudySeriesInstance) {use title <- decode.optional_field("title", None, decode.optional(decode.string))
use number <- decode.optional_field("number", None, decode.optional(decode.int))
use sop_class <- decode.field("sopClass",coding_decoder())
use uid <- decode.field("uid",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImagingstudySeriesInstance(title:,number:,sop_class:,uid:,modifier_extension:,extension:,id:,))}
pub fn imagingstudy_series_performer_to_json(imagingstudy_series_performer: ImagingstudySeriesPerformer) -> Json {
    let ImagingstudySeriesPerformer(actor:,function:,modifier_extension:,extension:,id:,) = imagingstudy_series_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn imagingstudy_series_performer_decoder() -> Decoder(ImagingstudySeriesPerformer) {use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImagingstudySeriesPerformer(actor:,function:,modifier_extension:,extension:,id:,))}
pub fn imagingstudy_series_to_json(imagingstudy_series: ImagingstudySeries) -> Json {
    let ImagingstudySeries(instance:,performer:,started:,specimen:,laterality:,body_site:,endpoint:,number_of_instances:,description:,modality:,number:,uid:,modifier_extension:,extension:,id:,) = imagingstudy_series
    let fields = [#("modality", coding_to_json(modality)),#("uid", json.string(uid)),]
let fields = case instance {
                        [] -> fields
                        _ -> [#("instance", json.array(instance,imagingstudy_series_instance_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,imagingstudy_series_performer_to_json)), ..fields]
                          }
let fields = case started {
                          Some(v) -> [#("started", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case specimen {
                        [] -> fields
                        _ -> [#("specimen", json.array(specimen,reference_to_json)), ..fields]
                          }
let fields = case laterality {
                          Some(v) -> [#("laterality", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                          Some(v) -> [#("bodySite", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case number_of_instances {
                          Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case number {
                          Some(v) -> [#("number", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn imagingstudy_series_decoder() -> Decoder(ImagingstudySeries) {use instance <- decode.optional_field("instance", [], decode.list(imagingstudy_series_instance_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(imagingstudy_series_performer_decoder()))
use started <- decode.optional_field("started", None, decode.optional(decode.string))
use specimen <- decode.optional_field("specimen", [], decode.list(reference_decoder()))
use laterality <- decode.optional_field("laterality", None, decode.optional(coding_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(coding_decoder()))
use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use number_of_instances <- decode.optional_field("numberOfInstances", None, decode.optional(decode.int))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modality <- decode.field("modality",coding_decoder())
use number <- decode.optional_field("number", None, decode.optional(decode.int))
use uid <- decode.field("uid",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImagingstudySeries(instance:,performer:,started:,specimen:,laterality:,body_site:,endpoint:,number_of_instances:,description:,modality:,number:,uid:,modifier_extension:,extension:,id:,))}
pub fn imagingstudy_to_json(imagingstudy: Imagingstudy) -> Json {
    let Imagingstudy(series:,description:,note:,reason_reference:,reason_code:,location:,procedure_code:,procedure_reference:,number_of_instances:,number_of_series:,endpoint:,interpreter:,referrer:,based_on:,started:,encounter:,subject:,modality:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = imagingstudy
    let fields = [#("subject", reference_to_json(subject)),#("status", r4valuesets.imagingstudystatus_to_json(status)),]
let fields = case series {
                        [] -> fields
                        _ -> [#("series", json.array(series,imagingstudy_series_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case procedure_code {
                        [] -> fields
                        _ -> [#("procedureCode", json.array(procedure_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case procedure_reference {
                          Some(v) -> [#("procedureReference", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_instances {
                          Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_series {
                          Some(v) -> [#("numberOfSeries", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case interpreter {
                        [] -> fields
                        _ -> [#("interpreter", json.array(interpreter,reference_to_json)), ..fields]
                          }
let fields = case referrer {
                          Some(v) -> [#("referrer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case started {
                          Some(v) -> [#("started", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modality {
                        [] -> fields
                        _ -> [#("modality", json.array(modality,coding_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn imagingstudy_decoder() -> Decoder(Imagingstudy) {use series <- decode.optional_field("series", [], decode.list(imagingstudy_series_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use procedure_code <- decode.optional_field("procedureCode", [], decode.list(codeableconcept_decoder()))
use procedure_reference <- decode.optional_field("procedureReference", None, decode.optional(reference_decoder()))
use number_of_instances <- decode.optional_field("numberOfInstances", None, decode.optional(decode.int))
use number_of_series <- decode.optional_field("numberOfSeries", None, decode.optional(decode.int))
use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use interpreter <- decode.optional_field("interpreter", [], decode.list(reference_decoder()))
use referrer <- decode.optional_field("referrer", None, decode.optional(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use started <- decode.optional_field("started", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use modality <- decode.optional_field("modality", [], decode.list(coding_decoder()))
use status <- decode.field("status",r4valuesets.imagingstudystatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Imagingstudy(series:,description:,note:,reason_reference:,reason_code:,location:,procedure_code:,procedure_reference:,number_of_instances:,number_of_series:,endpoint:,interpreter:,referrer:,based_on:,started:,encounter:,subject:,modality:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type Immunization
{
Immunization(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Immunizationstatus,
status_reason: Option(Codeableconcept),
vaccine_code: Codeableconcept,
patient: Reference,
encounter: Option(Reference),
occurrence: ImmunizationOccurrence,
recorded: Option(String),
primary_source: Option(Bool),
report_origin: Option(Codeableconcept),
location: Option(Reference),
manufacturer: Option(Reference),
lot_number: Option(String),
expiration_date: Option(String),
site: Option(Codeableconcept),
route: Option(Codeableconcept),
dose_quantity: Option(Quantity),
performer: List(ImmunizationPerformer),
note: List(Annotation),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
is_subpotent: Option(Bool),
subpotent_reason: List(Codeableconcept),
education: List(ImmunizationEducation),
program_eligibility: List(Codeableconcept),
funding_source: Option(Codeableconcept),
reaction: List(ImmunizationReaction),
protocol_applied: List(ImmunizationProtocolapplied),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationOccurrence{
ImmunizationOccurrenceDatetime(occurrence: String)
ImmunizationOccurrenceString(occurrence: String)}
pub fn immunization_occurrence_to_json(elt: ImmunizationOccurrence) -> Json {case elt{ImmunizationOccurrenceDatetime(v) -> json.string(v)
ImmunizationOccurrenceString(v) -> json.string(v)
}}
pub fn immunization_occurrence_decoder() -> Decoder(ImmunizationOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(ImmunizationOccurrenceDatetime),[decode.field("occurrenceString", decode.string, decode.success) |> decode.map(ImmunizationOccurrenceString),])}
pub fn immunization_new(occurrence occurrence: ImmunizationOccurrence,patient patient: Reference,vaccine_code vaccine_code: Codeableconcept,status status: r4valuesets.Immunizationstatus,) ->Immunization{Immunization(protocol_applied: [],reaction: [],funding_source: None,program_eligibility: [],education: [],subpotent_reason: [],is_subpotent: None,reason_reference: [],reason_code: [],note: [],performer: [],dose_quantity: None,route: None,site: None,expiration_date: None,lot_number: None,manufacturer: None,location: None,report_origin: None,primary_source: None,recorded: None,occurrence:,encounter: None,patient:,vaccine_code:,status_reason: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationPerformer
{
ImmunizationPerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
)
}

pub fn immunization_performer_new(actor actor: Reference,) ->ImmunizationPerformer{ImmunizationPerformer(actor:,function: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationEducation
{
ImmunizationEducation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
document_type: Option(String),
reference: Option(String),
publication_date: Option(String),
presentation_date: Option(String),
)
}

pub fn immunization_education_new() ->ImmunizationEducation{ImmunizationEducation(presentation_date: None,publication_date: None,reference: None,document_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationReaction
{
ImmunizationReaction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
date: Option(String),
detail: Option(Reference),
reported: Option(Bool),
)
}

pub fn immunization_reaction_new() ->ImmunizationReaction{ImmunizationReaction(reported: None,detail: None,date: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolapplied
{
ImmunizationProtocolapplied(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
series: Option(String),
authority: Option(Reference),
target_disease: List(Codeableconcept),
dose_number: ImmunizationProtocolappliedDosenumber,
series_doses: Option(ImmunizationProtocolappliedSeriesdoses),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolappliedDosenumber{
ImmunizationProtocolappliedDosenumberPositiveint(dose_number: Int)
ImmunizationProtocolappliedDosenumberString(dose_number: String)}
pub fn immunization_protocolapplied_dosenumber_to_json(elt: ImmunizationProtocolappliedDosenumber) -> Json {case elt{ImmunizationProtocolappliedDosenumberPositiveint(v) -> json.int(v)
ImmunizationProtocolappliedDosenumberString(v) -> json.string(v)
}}
pub fn immunization_protocolapplied_dosenumber_decoder() -> Decoder(ImmunizationProtocolappliedDosenumber){decode.one_of(decode.field("doseNumberPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationProtocolappliedDosenumberPositiveint),[decode.field("doseNumberString", decode.string, decode.success) |> decode.map(ImmunizationProtocolappliedDosenumberString),])}

///http://hl7.org/fhir/r4/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolappliedSeriesdoses{
ImmunizationProtocolappliedSeriesdosesPositiveint(series_doses: Int)
ImmunizationProtocolappliedSeriesdosesString(series_doses: String)}
pub fn immunization_protocolapplied_seriesdoses_to_json(elt: ImmunizationProtocolappliedSeriesdoses) -> Json {case elt{ImmunizationProtocolappliedSeriesdosesPositiveint(v) -> json.int(v)
ImmunizationProtocolappliedSeriesdosesString(v) -> json.string(v)
}}
pub fn immunization_protocolapplied_seriesdoses_decoder() -> Decoder(ImmunizationProtocolappliedSeriesdoses){decode.one_of(decode.field("seriesDosesPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationProtocolappliedSeriesdosesPositiveint),[decode.field("seriesDosesString", decode.string, decode.success) |> decode.map(ImmunizationProtocolappliedSeriesdosesString),])}
pub fn immunization_protocolapplied_new(dose_number dose_number: ImmunizationProtocolappliedDosenumber,) ->ImmunizationProtocolapplied{ImmunizationProtocolapplied(series_doses: None,dose_number:,target_disease: [],authority: None,series: None,modifier_extension: [],extension: [],id: None,)
}

pub fn immunization_protocolapplied_to_json(immunization_protocolapplied: ImmunizationProtocolapplied) -> Json {
    let ImmunizationProtocolapplied(series_doses:,dose_number:,target_disease:,authority:,series:,modifier_extension:,extension:,id:,) = immunization_protocolapplied
    let fields = [#("doseNumber", immunization_protocolapplied_dosenumber_to_json(dose_number)),]
let fields = case series_doses {
                          Some(v) -> [#("seriesDoses", immunization_protocolapplied_seriesdoses_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target_disease {
                        [] -> fields
                        _ -> [#("targetDisease", json.array(target_disease,codeableconcept_to_json)), ..fields]
                          }
let fields = case authority {
                          Some(v) -> [#("authority", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case series {
                          Some(v) -> [#("series", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunization_protocolapplied_decoder() -> Decoder(ImmunizationProtocolapplied) {use series_doses <- decode.then(none_if_omitted(immunization_protocolapplied_seriesdoses_decoder()))
use dose_number <- decode.then(immunization_protocolapplied_dosenumber_decoder())
use target_disease <- decode.optional_field("targetDisease", [], decode.list(codeableconcept_decoder()))
use authority <- decode.optional_field("authority", None, decode.optional(reference_decoder()))
use series <- decode.optional_field("series", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationProtocolapplied(series_doses:,dose_number:,target_disease:,authority:,series:,modifier_extension:,extension:,id:,))}
pub fn immunization_reaction_to_json(immunization_reaction: ImmunizationReaction) -> Json {
    let ImmunizationReaction(reported:,detail:,date:,modifier_extension:,extension:,id:,) = immunization_reaction
    let fields = []
let fields = case reported {
                          Some(v) -> [#("reported", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case detail {
                          Some(v) -> [#("detail", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunization_reaction_decoder() -> Decoder(ImmunizationReaction) {use reported <- decode.optional_field("reported", None, decode.optional(decode.bool))
use detail <- decode.optional_field("detail", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationReaction(reported:,detail:,date:,modifier_extension:,extension:,id:,))}
pub fn immunization_education_to_json(immunization_education: ImmunizationEducation) -> Json {
    let ImmunizationEducation(presentation_date:,publication_date:,reference:,document_type:,modifier_extension:,extension:,id:,) = immunization_education
    let fields = []
let fields = case presentation_date {
                          Some(v) -> [#("presentationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case publication_date {
                          Some(v) -> [#("publicationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case reference {
                          Some(v) -> [#("reference", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case document_type {
                          Some(v) -> [#("documentType", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunization_education_decoder() -> Decoder(ImmunizationEducation) {use presentation_date <- decode.optional_field("presentationDate", None, decode.optional(decode.string))
use publication_date <- decode.optional_field("publicationDate", None, decode.optional(decode.string))
use reference <- decode.optional_field("reference", None, decode.optional(decode.string))
use document_type <- decode.optional_field("documentType", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationEducation(presentation_date:,publication_date:,reference:,document_type:,modifier_extension:,extension:,id:,))}
pub fn immunization_performer_to_json(immunization_performer: ImmunizationPerformer) -> Json {
    let ImmunizationPerformer(actor:,function:,modifier_extension:,extension:,id:,) = immunization_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunization_performer_decoder() -> Decoder(ImmunizationPerformer) {use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationPerformer(actor:,function:,modifier_extension:,extension:,id:,))}
pub fn immunization_to_json(immunization: Immunization) -> Json {
    let Immunization(protocol_applied:,reaction:,funding_source:,program_eligibility:,education:,subpotent_reason:,is_subpotent:,reason_reference:,reason_code:,note:,performer:,dose_quantity:,route:,site:,expiration_date:,lot_number:,manufacturer:,location:,report_origin:,primary_source:,recorded:,occurrence:,encounter:,patient:,vaccine_code:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = immunization
    let fields = [#("occurrence", immunization_occurrence_to_json(occurrence)),#("patient", reference_to_json(patient)),#("vaccineCode", codeableconcept_to_json(vaccine_code)),#("status", r4valuesets.immunizationstatus_to_json(status)),]
let fields = case protocol_applied {
                        [] -> fields
                        _ -> [#("protocolApplied", json.array(protocol_applied,immunization_protocolapplied_to_json)), ..fields]
                          }
let fields = case reaction {
                        [] -> fields
                        _ -> [#("reaction", json.array(reaction,immunization_reaction_to_json)), ..fields]
                          }
let fields = case funding_source {
                          Some(v) -> [#("fundingSource", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case program_eligibility {
                        [] -> fields
                        _ -> [#("programEligibility", json.array(program_eligibility,codeableconcept_to_json)), ..fields]
                          }
let fields = case education {
                        [] -> fields
                        _ -> [#("education", json.array(education,immunization_education_to_json)), ..fields]
                          }
let fields = case subpotent_reason {
                        [] -> fields
                        _ -> [#("subpotentReason", json.array(subpotent_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case is_subpotent {
                          Some(v) -> [#("isSubpotent", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,immunization_performer_to_json)), ..fields]
                          }
let fields = case dose_quantity {
                          Some(v) -> [#("doseQuantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case route {
                          Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case site {
                          Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case expiration_date {
                          Some(v) -> [#("expirationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case lot_number {
                          Some(v) -> [#("lotNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacturer {
                          Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case report_origin {
                          Some(v) -> [#("reportOrigin", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case primary_source {
                          Some(v) -> [#("primarySource", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case recorded {
                          Some(v) -> [#("recorded", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunization_decoder() -> Decoder(Immunization) {use protocol_applied <- decode.optional_field("protocolApplied", [], decode.list(immunization_protocolapplied_decoder()))
use reaction <- decode.optional_field("reaction", [], decode.list(immunization_reaction_decoder()))
use funding_source <- decode.optional_field("fundingSource", None, decode.optional(codeableconcept_decoder()))
use program_eligibility <- decode.optional_field("programEligibility", [], decode.list(codeableconcept_decoder()))
use education <- decode.optional_field("education", [], decode.list(immunization_education_decoder()))
use subpotent_reason <- decode.optional_field("subpotentReason", [], decode.list(codeableconcept_decoder()))
use is_subpotent <- decode.optional_field("isSubpotent", None, decode.optional(decode.bool))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(immunization_performer_decoder()))
use dose_quantity <- decode.optional_field("doseQuantity", None, decode.optional(quantity_decoder()))
use route <- decode.optional_field("route", None, decode.optional(codeableconcept_decoder()))
use site <- decode.optional_field("site", None, decode.optional(codeableconcept_decoder()))
use expiration_date <- decode.optional_field("expirationDate", None, decode.optional(decode.string))
use lot_number <- decode.optional_field("lotNumber", None, decode.optional(decode.string))
use manufacturer <- decode.optional_field("manufacturer", None, decode.optional(reference_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use report_origin <- decode.optional_field("reportOrigin", None, decode.optional(codeableconcept_decoder()))
use primary_source <- decode.optional_field("primarySource", None, decode.optional(decode.bool))
use recorded <- decode.optional_field("recorded", None, decode.optional(decode.string))
use occurrence <- decode.then(immunization_occurrence_decoder())
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use patient <- decode.field("patient",reference_decoder())
use vaccine_code <- decode.field("vaccineCode",codeableconcept_decoder())
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.immunizationstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Immunization(protocol_applied:,reaction:,funding_source:,program_eligibility:,education:,subpotent_reason:,is_subpotent:,reason_reference:,reason_code:,note:,performer:,dose_quantity:,route:,site:,expiration_date:,lot_number:,manufacturer:,location:,report_origin:,primary_source:,recorded:,occurrence:,encounter:,patient:,vaccine_code:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationEvaluation#resource
pub type Immunizationevaluation
{
Immunizationevaluation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Immunizationevaluationstatus,
patient: Reference,
date: Option(String),
authority: Option(Reference),
target_disease: Codeableconcept,
immunization_event: Reference,
dose_status: Codeableconcept,
dose_status_reason: List(Codeableconcept),
description: Option(String),
series: Option(String),
dose_number: Option(ImmunizationevaluationDosenumber),
series_doses: Option(ImmunizationevaluationSeriesdoses),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationEvaluation#resource
pub type ImmunizationevaluationDosenumber{
ImmunizationevaluationDosenumberPositiveint(dose_number: Int)
ImmunizationevaluationDosenumberString(dose_number: String)}
pub fn immunizationevaluation_dosenumber_to_json(elt: ImmunizationevaluationDosenumber) -> Json {case elt{ImmunizationevaluationDosenumberPositiveint(v) -> json.int(v)
ImmunizationevaluationDosenumberString(v) -> json.string(v)
}}
pub fn immunizationevaluation_dosenumber_decoder() -> Decoder(ImmunizationevaluationDosenumber){decode.one_of(decode.field("doseNumberPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationevaluationDosenumberPositiveint),[decode.field("doseNumberString", decode.string, decode.success) |> decode.map(ImmunizationevaluationDosenumberString),])}

///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationEvaluation#resource
pub type ImmunizationevaluationSeriesdoses{
ImmunizationevaluationSeriesdosesPositiveint(series_doses: Int)
ImmunizationevaluationSeriesdosesString(series_doses: String)}
pub fn immunizationevaluation_seriesdoses_to_json(elt: ImmunizationevaluationSeriesdoses) -> Json {case elt{ImmunizationevaluationSeriesdosesPositiveint(v) -> json.int(v)
ImmunizationevaluationSeriesdosesString(v) -> json.string(v)
}}
pub fn immunizationevaluation_seriesdoses_decoder() -> Decoder(ImmunizationevaluationSeriesdoses){decode.one_of(decode.field("seriesDosesPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationevaluationSeriesdosesPositiveint),[decode.field("seriesDosesString", decode.string, decode.success) |> decode.map(ImmunizationevaluationSeriesdosesString),])}
pub fn immunizationevaluation_new(dose_status dose_status: Codeableconcept,immunization_event immunization_event: Reference,target_disease target_disease: Codeableconcept,patient patient: Reference,status status: r4valuesets.Immunizationevaluationstatus,) ->Immunizationevaluation{Immunizationevaluation(series_doses: None,dose_number: None,series: None,description: None,dose_status_reason: [],dose_status:,immunization_event:,target_disease:,authority: None,date: None,patient:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn immunizationevaluation_to_json(immunizationevaluation: Immunizationevaluation) -> Json {
    let Immunizationevaluation(series_doses:,dose_number:,series:,description:,dose_status_reason:,dose_status:,immunization_event:,target_disease:,authority:,date:,patient:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = immunizationevaluation
    let fields = [#("doseStatus", codeableconcept_to_json(dose_status)),#("immunizationEvent", reference_to_json(immunization_event)),#("targetDisease", codeableconcept_to_json(target_disease)),#("patient", reference_to_json(patient)),#("status", r4valuesets.immunizationevaluationstatus_to_json(status)),]
let fields = case series_doses {
                          Some(v) -> [#("seriesDoses", immunizationevaluation_seriesdoses_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dose_number {
                          Some(v) -> [#("doseNumber", immunizationevaluation_dosenumber_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case series {
                          Some(v) -> [#("series", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case dose_status_reason {
                        [] -> fields
                        _ -> [#("doseStatusReason", json.array(dose_status_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case authority {
                          Some(v) -> [#("authority", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunizationevaluation_decoder() -> Decoder(Immunizationevaluation) {use series_doses <- decode.then(none_if_omitted(immunizationevaluation_seriesdoses_decoder()))
use dose_number <- decode.then(none_if_omitted(immunizationevaluation_dosenumber_decoder()))
use series <- decode.optional_field("series", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use dose_status_reason <- decode.optional_field("doseStatusReason", [], decode.list(codeableconcept_decoder()))
use dose_status <- decode.field("doseStatus",codeableconcept_decoder())
use immunization_event <- decode.field("immunizationEvent",reference_decoder())
use target_disease <- decode.field("targetDisease",codeableconcept_decoder())
use authority <- decode.optional_field("authority", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use patient <- decode.field("patient",reference_decoder())
use status <- decode.field("status",r4valuesets.immunizationevaluationstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Immunizationevaluation(series_doses:,dose_number:,series:,description:,dose_status_reason:,dose_status:,immunization_event:,target_disease:,authority:,date:,patient:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationRecommendation#resource
pub type Immunizationrecommendation
{
Immunizationrecommendation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
patient: Reference,
date: String,
authority: Option(Reference),
recommendation: List(ImmunizationrecommendationRecommendation),
)
}

pub fn immunizationrecommendation_new(date date: String,patient patient: Reference,) ->Immunizationrecommendation{Immunizationrecommendation(recommendation: [],authority: None,date:,patient:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendation
{
ImmunizationrecommendationRecommendation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
vaccine_code: List(Codeableconcept),
target_disease: Option(Codeableconcept),
contraindicated_vaccine_code: List(Codeableconcept),
forecast_status: Codeableconcept,
forecast_reason: List(Codeableconcept),
date_criterion: List(ImmunizationrecommendationRecommendationDatecriterion),
description: Option(String),
series: Option(String),
dose_number: Option(ImmunizationrecommendationRecommendationDosenumber),
series_doses: Option(ImmunizationrecommendationRecommendationSeriesdoses),
supporting_immunization: List(Reference),
supporting_patient_information: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationDosenumber{
ImmunizationrecommendationRecommendationDosenumberPositiveint(dose_number: Int)
ImmunizationrecommendationRecommendationDosenumberString(dose_number: String)}
pub fn immunizationrecommendation_recommendation_dosenumber_to_json(elt: ImmunizationrecommendationRecommendationDosenumber) -> Json {case elt{ImmunizationrecommendationRecommendationDosenumberPositiveint(v) -> json.int(v)
ImmunizationrecommendationRecommendationDosenumberString(v) -> json.string(v)
}}
pub fn immunizationrecommendation_recommendation_dosenumber_decoder() -> Decoder(ImmunizationrecommendationRecommendationDosenumber){decode.one_of(decode.field("doseNumberPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationrecommendationRecommendationDosenumberPositiveint),[decode.field("doseNumberString", decode.string, decode.success) |> decode.map(ImmunizationrecommendationRecommendationDosenumberString),])}

///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationSeriesdoses{
ImmunizationrecommendationRecommendationSeriesdosesPositiveint(series_doses: Int)
ImmunizationrecommendationRecommendationSeriesdosesString(series_doses: String)}
pub fn immunizationrecommendation_recommendation_seriesdoses_to_json(elt: ImmunizationrecommendationRecommendationSeriesdoses) -> Json {case elt{ImmunizationrecommendationRecommendationSeriesdosesPositiveint(v) -> json.int(v)
ImmunizationrecommendationRecommendationSeriesdosesString(v) -> json.string(v)
}}
pub fn immunizationrecommendation_recommendation_seriesdoses_decoder() -> Decoder(ImmunizationrecommendationRecommendationSeriesdoses){decode.one_of(decode.field("seriesDosesPositiveInt", decode.int, decode.success) |> decode.map(ImmunizationrecommendationRecommendationSeriesdosesPositiveint),[decode.field("seriesDosesString", decode.string, decode.success) |> decode.map(ImmunizationrecommendationRecommendationSeriesdosesString),])}
pub fn immunizationrecommendation_recommendation_new(forecast_status forecast_status: Codeableconcept,) ->ImmunizationrecommendationRecommendation{ImmunizationrecommendationRecommendation(supporting_patient_information: [],supporting_immunization: [],series_doses: None,dose_number: None,series: None,description: None,date_criterion: [],forecast_reason: [],forecast_status:,contraindicated_vaccine_code: [],target_disease: None,vaccine_code: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationDatecriterion
{
ImmunizationrecommendationRecommendationDatecriterion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
value: String,
)
}

pub fn immunizationrecommendation_recommendation_datecriterion_new(value value: String,code code: Codeableconcept,) ->ImmunizationrecommendationRecommendationDatecriterion{ImmunizationrecommendationRecommendationDatecriterion(value:,code:,modifier_extension: [],extension: [],id: None,)
}

pub fn immunizationrecommendation_recommendation_datecriterion_to_json(immunizationrecommendation_recommendation_datecriterion: ImmunizationrecommendationRecommendationDatecriterion) -> Json {
    let ImmunizationrecommendationRecommendationDatecriterion(value:,code:,modifier_extension:,extension:,id:,) = immunizationrecommendation_recommendation_datecriterion
    let fields = [#("value", json.string(value)),#("code", codeableconcept_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunizationrecommendation_recommendation_datecriterion_decoder() -> Decoder(ImmunizationrecommendationRecommendationDatecriterion) {use value <- decode.field("value",decode.string)
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationrecommendationRecommendationDatecriterion(value:,code:,modifier_extension:,extension:,id:,))}
pub fn immunizationrecommendation_recommendation_to_json(immunizationrecommendation_recommendation: ImmunizationrecommendationRecommendation) -> Json {
    let ImmunizationrecommendationRecommendation(supporting_patient_information:,supporting_immunization:,series_doses:,dose_number:,series:,description:,date_criterion:,forecast_reason:,forecast_status:,contraindicated_vaccine_code:,target_disease:,vaccine_code:,modifier_extension:,extension:,id:,) = immunizationrecommendation_recommendation
    let fields = [#("forecastStatus", codeableconcept_to_json(forecast_status)),]
let fields = case supporting_patient_information {
                        [] -> fields
                        _ -> [#("supportingPatientInformation", json.array(supporting_patient_information,reference_to_json)), ..fields]
                          }
let fields = case supporting_immunization {
                        [] -> fields
                        _ -> [#("supportingImmunization", json.array(supporting_immunization,reference_to_json)), ..fields]
                          }
let fields = case series_doses {
                          Some(v) -> [#("seriesDoses", immunizationrecommendation_recommendation_seriesdoses_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dose_number {
                          Some(v) -> [#("doseNumber", immunizationrecommendation_recommendation_dosenumber_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case series {
                          Some(v) -> [#("series", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date_criterion {
                        [] -> fields
                        _ -> [#("dateCriterion", json.array(date_criterion,immunizationrecommendation_recommendation_datecriterion_to_json)), ..fields]
                          }
let fields = case forecast_reason {
                        [] -> fields
                        _ -> [#("forecastReason", json.array(forecast_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case contraindicated_vaccine_code {
                        [] -> fields
                        _ -> [#("contraindicatedVaccineCode", json.array(contraindicated_vaccine_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case target_disease {
                          Some(v) -> [#("targetDisease", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case vaccine_code {
                        [] -> fields
                        _ -> [#("vaccineCode", json.array(vaccine_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunizationrecommendation_recommendation_decoder() -> Decoder(ImmunizationrecommendationRecommendation) {use supporting_patient_information <- decode.optional_field("supportingPatientInformation", [], decode.list(reference_decoder()))
use supporting_immunization <- decode.optional_field("supportingImmunization", [], decode.list(reference_decoder()))
use series_doses <- decode.then(none_if_omitted(immunizationrecommendation_recommendation_seriesdoses_decoder()))
use dose_number <- decode.then(none_if_omitted(immunizationrecommendation_recommendation_dosenumber_decoder()))
use series <- decode.optional_field("series", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use date_criterion <- decode.optional_field("dateCriterion", [], decode.list(immunizationrecommendation_recommendation_datecriterion_decoder()))
use forecast_reason <- decode.optional_field("forecastReason", [], decode.list(codeableconcept_decoder()))
use forecast_status <- decode.field("forecastStatus",codeableconcept_decoder())
use contraindicated_vaccine_code <- decode.optional_field("contraindicatedVaccineCode", [], decode.list(codeableconcept_decoder()))
use target_disease <- decode.optional_field("targetDisease", None, decode.optional(codeableconcept_decoder()))
use vaccine_code <- decode.optional_field("vaccineCode", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImmunizationrecommendationRecommendation(supporting_patient_information:,supporting_immunization:,series_doses:,dose_number:,series:,description:,date_criterion:,forecast_reason:,forecast_status:,contraindicated_vaccine_code:,target_disease:,vaccine_code:,modifier_extension:,extension:,id:,))}
pub fn immunizationrecommendation_to_json(immunizationrecommendation: Immunizationrecommendation) -> Json {
    let Immunizationrecommendation(recommendation:,authority:,date:,patient:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = immunizationrecommendation
    let fields = [#("date", json.string(date)),#("patient", reference_to_json(patient)),]
let fields = case recommendation {
                        [] -> fields
                        _ -> [#("recommendation", json.array(recommendation,immunizationrecommendation_recommendation_to_json)), ..fields]
                          }
let fields = case authority {
                          Some(v) -> [#("authority", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn immunizationrecommendation_decoder() -> Decoder(Immunizationrecommendation) {use recommendation <- decode.optional_field("recommendation", [], decode.list(immunizationrecommendation_recommendation_decoder()))
use authority <- decode.optional_field("authority", None, decode.optional(reference_decoder()))
use date <- decode.field("date",decode.string)
use patient <- decode.field("patient",reference_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Immunizationrecommendation(recommendation:,authority:,date:,patient:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type Implementationguide
{
Implementationguide(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
version: Option(String),
name: String,
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
package_id: String,
license: Option(r4valuesets.Spdxlicense),
fhir_version: List(r4valuesets.Fhirversion),
depends_on: List(ImplementationguideDependson),
global: List(ImplementationguideGlobal),
definition: Option(ImplementationguideDefinition),
manifest: Option(ImplementationguideManifest),
)
}

pub fn implementationguide_new(package_id package_id: String,status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Implementationguide{Implementationguide(manifest: None,definition: None,global: [],depends_on: [],fhir_version: [],license: None,package_id:,copyright: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name:,version: None,url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDependson
{
ImplementationguideDependson(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
uri: String,
package_id: Option(String),
version: Option(String),
)
}

pub fn implementationguide_dependson_new(uri uri: String,) ->ImplementationguideDependson{ImplementationguideDependson(version: None,package_id: None,uri:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideGlobal
{
ImplementationguideGlobal(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Resourcetypes,
profile: String,
)
}

pub fn implementationguide_global_new(profile profile: String,type_ type_: r4valuesets.Resourcetypes,) ->ImplementationguideGlobal{ImplementationguideGlobal(profile:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinition
{
ImplementationguideDefinition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
grouping: List(ImplementationguideDefinitionGrouping),
resource: List(ImplementationguideDefinitionResource),
page: Option(ImplementationguideDefinitionPage),
parameter: List(ImplementationguideDefinitionParameter),
template: List(ImplementationguideDefinitionTemplate),
)
}

pub fn implementationguide_definition_new() ->ImplementationguideDefinition{ImplementationguideDefinition(template: [],parameter: [],page: None,resource: [],grouping: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionGrouping
{
ImplementationguideDefinitionGrouping(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
description: Option(String),
)
}

pub fn implementationguide_definition_grouping_new(name name: String,) ->ImplementationguideDefinitionGrouping{ImplementationguideDefinitionGrouping(description: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionResource
{
ImplementationguideDefinitionResource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
reference: Reference,
fhir_version: List(r4valuesets.Fhirversion),
name: Option(String),
description: Option(String),
example: Option(ImplementationguideDefinitionResourceExample),
grouping_id: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionResourceExample{
ImplementationguideDefinitionResourceExampleBoolean(example: Bool)
ImplementationguideDefinitionResourceExampleCanonical(example: String)}
pub fn implementationguide_definition_resource_example_to_json(elt: ImplementationguideDefinitionResourceExample) -> Json {case elt{ImplementationguideDefinitionResourceExampleBoolean(v) -> json.bool(v)
ImplementationguideDefinitionResourceExampleCanonical(v) -> json.string(v)
}}
pub fn implementationguide_definition_resource_example_decoder() -> Decoder(ImplementationguideDefinitionResourceExample){decode.one_of(decode.field("exampleBoolean", decode.bool, decode.success) |> decode.map(ImplementationguideDefinitionResourceExampleBoolean),[decode.field("exampleCanonical", decode.string, decode.success) |> decode.map(ImplementationguideDefinitionResourceExampleCanonical),])}
pub fn implementationguide_definition_resource_new(reference reference: Reference,) ->ImplementationguideDefinitionResource{ImplementationguideDefinitionResource(grouping_id: None,example: None,description: None,name: None,fhir_version: [],reference:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPage
{
ImplementationguideDefinitionPage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: ImplementationguideDefinitionPageName,
title: String,
generation: r4valuesets.Guidepagegeneration,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPageName{
ImplementationguideDefinitionPageNameUrl(name: String)
ImplementationguideDefinitionPageNameReference(name: Reference)}
pub fn implementationguide_definition_page_name_to_json(elt: ImplementationguideDefinitionPageName) -> Json {case elt{ImplementationguideDefinitionPageNameUrl(v) -> json.string(v)
ImplementationguideDefinitionPageNameReference(v) -> reference_to_json(v)
}}
pub fn implementationguide_definition_page_name_decoder() -> Decoder(ImplementationguideDefinitionPageName){decode.one_of(decode.field("nameUrl", decode.string, decode.success) |> decode.map(ImplementationguideDefinitionPageNameUrl),[decode.field("nameReference", reference_decoder(), decode.success) |> decode.map(ImplementationguideDefinitionPageNameReference),])}
pub fn implementationguide_definition_page_new(generation generation: r4valuesets.Guidepagegeneration,title title: String,name name: ImplementationguideDefinitionPageName,) ->ImplementationguideDefinitionPage{ImplementationguideDefinitionPage(generation:,title:,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionParameter
{
ImplementationguideDefinitionParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Guideparametercode,
value: String,
)
}

pub fn implementationguide_definition_parameter_new(value value: String,code code: r4valuesets.Guideparametercode,) ->ImplementationguideDefinitionParameter{ImplementationguideDefinitionParameter(value:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionTemplate
{
ImplementationguideDefinitionTemplate(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
source: String,
scope: Option(String),
)
}

pub fn implementationguide_definition_template_new(source source: String,code code: String,) ->ImplementationguideDefinitionTemplate{ImplementationguideDefinitionTemplate(scope: None,source:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifest
{
ImplementationguideManifest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
rendering: Option(String),
resource: List(ImplementationguideManifestResource),
page: List(ImplementationguideManifestPage),
image: List(String),
other: List(String),
)
}

pub fn implementationguide_manifest_new() ->ImplementationguideManifest{ImplementationguideManifest(other: [],image: [],page: [],resource: [],rendering: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestResource
{
ImplementationguideManifestResource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
reference: Reference,
example: Option(ImplementationguideManifestResourceExample),
relative_path: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestResourceExample{
ImplementationguideManifestResourceExampleBoolean(example: Bool)
ImplementationguideManifestResourceExampleCanonical(example: String)}
pub fn implementationguide_manifest_resource_example_to_json(elt: ImplementationguideManifestResourceExample) -> Json {case elt{ImplementationguideManifestResourceExampleBoolean(v) -> json.bool(v)
ImplementationguideManifestResourceExampleCanonical(v) -> json.string(v)
}}
pub fn implementationguide_manifest_resource_example_decoder() -> Decoder(ImplementationguideManifestResourceExample){decode.one_of(decode.field("exampleBoolean", decode.bool, decode.success) |> decode.map(ImplementationguideManifestResourceExampleBoolean),[decode.field("exampleCanonical", decode.string, decode.success) |> decode.map(ImplementationguideManifestResourceExampleCanonical),])}
pub fn implementationguide_manifest_resource_new(reference reference: Reference,) ->ImplementationguideManifestResource{ImplementationguideManifestResource(relative_path: None,example: None,reference:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestPage
{
ImplementationguideManifestPage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
title: Option(String),
anchor: List(String),
)
}

pub fn implementationguide_manifest_page_new(name name: String,) ->ImplementationguideManifestPage{ImplementationguideManifestPage(anchor: [],title: None,name:,modifier_extension: [],extension: [],id: None,)
}

pub fn implementationguide_manifest_page_to_json(implementationguide_manifest_page: ImplementationguideManifestPage) -> Json {
    let ImplementationguideManifestPage(anchor:,title:,name:,modifier_extension:,extension:,id:,) = implementationguide_manifest_page
    let fields = [#("name", json.string(name)),]
let fields = case anchor {
                        [] -> fields
                        _ -> [#("anchor", json.array(anchor,json.string)), ..fields]
                          }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_manifest_page_decoder() -> Decoder(ImplementationguideManifestPage) {use anchor <- decode.optional_field("anchor", [], decode.list(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideManifestPage(anchor:,title:,name:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_manifest_resource_to_json(implementationguide_manifest_resource: ImplementationguideManifestResource) -> Json {
    let ImplementationguideManifestResource(relative_path:,example:,reference:,modifier_extension:,extension:,id:,) = implementationguide_manifest_resource
    let fields = [#("reference", reference_to_json(reference)),]
let fields = case relative_path {
                          Some(v) -> [#("relativePath", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case example {
                          Some(v) -> [#("example", implementationguide_manifest_resource_example_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_manifest_resource_decoder() -> Decoder(ImplementationguideManifestResource) {use relative_path <- decode.optional_field("relativePath", None, decode.optional(decode.string))
use example <- decode.then(none_if_omitted(implementationguide_manifest_resource_example_decoder()))
use reference <- decode.field("reference",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideManifestResource(relative_path:,example:,reference:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_manifest_to_json(implementationguide_manifest: ImplementationguideManifest) -> Json {
    let ImplementationguideManifest(other:,image:,page:,resource:,rendering:,modifier_extension:,extension:,id:,) = implementationguide_manifest
    let fields = []
let fields = case other {
                        [] -> fields
                        _ -> [#("other", json.array(other,json.string)), ..fields]
                          }
let fields = case image {
                        [] -> fields
                        _ -> [#("image", json.array(image,json.string)), ..fields]
                          }
let fields = case page {
                        [] -> fields
                        _ -> [#("page", json.array(page,implementationguide_manifest_page_to_json)), ..fields]
                          }
let fields = case resource {
                        [] -> fields
                        _ -> [#("resource", json.array(resource,implementationguide_manifest_resource_to_json)), ..fields]
                          }
let fields = case rendering {
                          Some(v) -> [#("rendering", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_manifest_decoder() -> Decoder(ImplementationguideManifest) {use other <- decode.optional_field("other", [], decode.list(decode.string))
use image <- decode.optional_field("image", [], decode.list(decode.string))
use page <- decode.optional_field("page", [], decode.list(implementationguide_manifest_page_decoder()))
use resource <- decode.optional_field("resource", [], decode.list(implementationguide_manifest_resource_decoder()))
use rendering <- decode.optional_field("rendering", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideManifest(other:,image:,page:,resource:,rendering:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_template_to_json(implementationguide_definition_template: ImplementationguideDefinitionTemplate) -> Json {
    let ImplementationguideDefinitionTemplate(scope:,source:,code:,modifier_extension:,extension:,id:,) = implementationguide_definition_template
    let fields = [#("source", json.string(source)),#("code", json.string(code)),]
let fields = case scope {
                          Some(v) -> [#("scope", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_template_decoder() -> Decoder(ImplementationguideDefinitionTemplate) {use scope <- decode.optional_field("scope", None, decode.optional(decode.string))
use source <- decode.field("source",decode.string)
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinitionTemplate(scope:,source:,code:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_parameter_to_json(implementationguide_definition_parameter: ImplementationguideDefinitionParameter) -> Json {
    let ImplementationguideDefinitionParameter(value:,code:,modifier_extension:,extension:,id:,) = implementationguide_definition_parameter
    let fields = [#("value", json.string(value)),#("code", r4valuesets.guideparametercode_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_parameter_decoder() -> Decoder(ImplementationguideDefinitionParameter) {use value <- decode.field("value",decode.string)
use code <- decode.field("code",r4valuesets.guideparametercode_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinitionParameter(value:,code:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_page_to_json(implementationguide_definition_page: ImplementationguideDefinitionPage) -> Json {
    let ImplementationguideDefinitionPage(generation:,title:,name:,modifier_extension:,extension:,id:,) = implementationguide_definition_page
    let fields = [#("generation", r4valuesets.guidepagegeneration_to_json(generation)),#("title", json.string(title)),#("name", implementationguide_definition_page_name_to_json(name)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_page_decoder() -> Decoder(ImplementationguideDefinitionPage) {use generation <- decode.field("generation",r4valuesets.guidepagegeneration_decoder())
use title <- decode.field("title",decode.string)
use name <- decode.then(implementationguide_definition_page_name_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinitionPage(generation:,title:,name:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_resource_to_json(implementationguide_definition_resource: ImplementationguideDefinitionResource) -> Json {
    let ImplementationguideDefinitionResource(grouping_id:,example:,description:,name:,fhir_version:,reference:,modifier_extension:,extension:,id:,) = implementationguide_definition_resource
    let fields = [#("reference", reference_to_json(reference)),]
let fields = case grouping_id {
                          Some(v) -> [#("groupingId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case example {
                          Some(v) -> [#("example", implementationguide_definition_resource_example_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case fhir_version {
                        [] -> fields
                        _ -> [#("fhirVersion", json.array(fhir_version,r4valuesets.fhirversion_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_resource_decoder() -> Decoder(ImplementationguideDefinitionResource) {use grouping_id <- decode.optional_field("groupingId", None, decode.optional(decode.string))
use example <- decode.then(none_if_omitted(implementationguide_definition_resource_example_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use fhir_version <- decode.optional_field("fhirVersion", [], decode.list(r4valuesets.fhirversion_decoder()))
use reference <- decode.field("reference",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinitionResource(grouping_id:,example:,description:,name:,fhir_version:,reference:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_grouping_to_json(implementationguide_definition_grouping: ImplementationguideDefinitionGrouping) -> Json {
    let ImplementationguideDefinitionGrouping(description:,name:,modifier_extension:,extension:,id:,) = implementationguide_definition_grouping
    let fields = [#("name", json.string(name)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_grouping_decoder() -> Decoder(ImplementationguideDefinitionGrouping) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinitionGrouping(description:,name:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_definition_to_json(implementationguide_definition: ImplementationguideDefinition) -> Json {
    let ImplementationguideDefinition(template:,parameter:,page:,resource:,grouping:,modifier_extension:,extension:,id:,) = implementationguide_definition
    let fields = []
let fields = case template {
                        [] -> fields
                        _ -> [#("template", json.array(template,implementationguide_definition_template_to_json)), ..fields]
                          }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,implementationguide_definition_parameter_to_json)), ..fields]
                          }
let fields = case page {
                          Some(v) -> [#("page", implementationguide_definition_page_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case resource {
                        [] -> fields
                        _ -> [#("resource", json.array(resource,implementationguide_definition_resource_to_json)), ..fields]
                          }
let fields = case grouping {
                        [] -> fields
                        _ -> [#("grouping", json.array(grouping,implementationguide_definition_grouping_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_definition_decoder() -> Decoder(ImplementationguideDefinition) {use template <- decode.optional_field("template", [], decode.list(implementationguide_definition_template_decoder()))
use parameter <- decode.optional_field("parameter", [], decode.list(implementationguide_definition_parameter_decoder()))
use page <- decode.optional_field("page", None, decode.optional(implementationguide_definition_page_decoder()))
use resource <- decode.optional_field("resource", [], decode.list(implementationguide_definition_resource_decoder()))
use grouping <- decode.optional_field("grouping", [], decode.list(implementationguide_definition_grouping_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDefinition(template:,parameter:,page:,resource:,grouping:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_global_to_json(implementationguide_global: ImplementationguideGlobal) -> Json {
    let ImplementationguideGlobal(profile:,type_:,modifier_extension:,extension:,id:,) = implementationguide_global
    let fields = [#("profile", json.string(profile)),#("type", r4valuesets.resourcetypes_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_global_decoder() -> Decoder(ImplementationguideGlobal) {use profile <- decode.field("profile",decode.string)
use type_ <- decode.field("type",r4valuesets.resourcetypes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideGlobal(profile:,type_:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_dependson_to_json(implementationguide_dependson: ImplementationguideDependson) -> Json {
    let ImplementationguideDependson(version:,package_id:,uri:,modifier_extension:,extension:,id:,) = implementationguide_dependson
    let fields = [#("uri", json.string(uri)),]
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case package_id {
                          Some(v) -> [#("packageId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_dependson_decoder() -> Decoder(ImplementationguideDependson) {use version <- decode.optional_field("version", None, decode.optional(decode.string))
use package_id <- decode.optional_field("packageId", None, decode.optional(decode.string))
use uri <- decode.field("uri",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ImplementationguideDependson(version:,package_id:,uri:,modifier_extension:,extension:,id:,))}
pub fn implementationguide_to_json(implementationguide: Implementationguide) -> Json {
    let Implementationguide(manifest:,definition:,global:,depends_on:,fhir_version:,license:,package_id:,copyright:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = implementationguide
    let fields = [#("packageId", json.string(package_id)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case manifest {
                          Some(v) -> [#("manifest", implementationguide_manifest_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                          Some(v) -> [#("definition", implementationguide_definition_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case global {
                        [] -> fields
                        _ -> [#("global", json.array(global,implementationguide_global_to_json)), ..fields]
                          }
let fields = case depends_on {
                        [] -> fields
                        _ -> [#("dependsOn", json.array(depends_on,implementationguide_dependson_to_json)), ..fields]
                          }
let fields = case fhir_version {
                        [] -> fields
                        _ -> [#("fhirVersion", json.array(fhir_version,r4valuesets.fhirversion_to_json)), ..fields]
                          }
let fields = case license {
                          Some(v) -> [#("license", r4valuesets.spdxlicense_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn implementationguide_decoder() -> Decoder(Implementationguide) {use manifest <- decode.optional_field("manifest", None, decode.optional(implementationguide_manifest_decoder()))
use definition <- decode.optional_field("definition", None, decode.optional(implementationguide_definition_decoder()))
use global <- decode.optional_field("global", [], decode.list(implementationguide_global_decoder()))
use depends_on <- decode.optional_field("dependsOn", [], decode.list(implementationguide_dependson_decoder()))
use fhir_version <- decode.optional_field("fhirVersion", [], decode.list(r4valuesets.fhirversion_decoder()))
use license <- decode.optional_field("license", None, decode.optional(r4valuesets.spdxlicense_decoder()))
use package_id <- decode.field("packageId",decode.string)
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Implementationguide(manifest:,definition:,global:,depends_on:,fhir_version:,license:,package_id:,copyright:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type Insuranceplan
{
Insuranceplan(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Publicationstatus),
type_: List(Codeableconcept),
name: Option(String),
alias: List(String),
period: Option(Period),
owned_by: Option(Reference),
administered_by: Option(Reference),
coverage_area: List(Reference),
contact: List(InsuranceplanContact),
endpoint: List(Reference),
network: List(Reference),
coverage: List(InsuranceplanCoverage),
plan: List(InsuranceplanPlan),
)
}

pub fn insuranceplan_new() ->Insuranceplan{Insuranceplan(plan: [],coverage: [],network: [],endpoint: [],contact: [],coverage_area: [],administered_by: None,owned_by: None,period: None,alias: [],name: None,type_: [],status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanContact
{
InsuranceplanContact(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
purpose: Option(Codeableconcept),
name: Option(Humanname),
telecom: List(Contactpoint),
address: Option(Address),
)
}

pub fn insuranceplan_contact_new() ->InsuranceplanContact{InsuranceplanContact(address: None,telecom: [],name: None,purpose: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverage
{
InsuranceplanCoverage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
network: List(Reference),
benefit: List(InsuranceplanCoverageBenefit),
)
}

pub fn insuranceplan_coverage_new(type_ type_: Codeableconcept,) ->InsuranceplanCoverage{InsuranceplanCoverage(benefit: [],network: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefit
{
InsuranceplanCoverageBenefit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
requirement: Option(String),
limit: List(InsuranceplanCoverageBenefitLimit),
)
}

pub fn insuranceplan_coverage_benefit_new(type_ type_: Codeableconcept,) ->InsuranceplanCoverageBenefit{InsuranceplanCoverageBenefit(limit: [],requirement: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefitLimit
{
InsuranceplanCoverageBenefitLimit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: Option(Quantity),
code: Option(Codeableconcept),
)
}

pub fn insuranceplan_coverage_benefit_limit_new() ->InsuranceplanCoverageBenefitLimit{InsuranceplanCoverageBenefitLimit(code: None,value: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlan
{
InsuranceplanPlan(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Option(Codeableconcept),
coverage_area: List(Reference),
network: List(Reference),
general_cost: List(InsuranceplanPlanGeneralcost),
specific_cost: List(InsuranceplanPlanSpecificcost),
)
}

pub fn insuranceplan_plan_new() ->InsuranceplanPlan{InsuranceplanPlan(specific_cost: [],general_cost: [],network: [],coverage_area: [],type_: None,identifier: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanGeneralcost
{
InsuranceplanPlanGeneralcost(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
group_size: Option(Int),
cost: Option(Money),
comment: Option(String),
)
}

pub fn insuranceplan_plan_generalcost_new() ->InsuranceplanPlanGeneralcost{InsuranceplanPlanGeneralcost(comment: None,cost: None,group_size: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcost
{
InsuranceplanPlanSpecificcost(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Codeableconcept,
benefit: List(InsuranceplanPlanSpecificcostBenefit),
)
}

pub fn insuranceplan_plan_specificcost_new(category category: Codeableconcept,) ->InsuranceplanPlanSpecificcost{InsuranceplanPlanSpecificcost(benefit: [],category:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefit
{
InsuranceplanPlanSpecificcostBenefit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
cost: List(InsuranceplanPlanSpecificcostBenefitCost),
)
}

pub fn insuranceplan_plan_specificcost_benefit_new(type_ type_: Codeableconcept,) ->InsuranceplanPlanSpecificcostBenefit{InsuranceplanPlanSpecificcostBenefit(cost: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefitCost
{
InsuranceplanPlanSpecificcostBenefitCost(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
applicability: Option(Codeableconcept),
qualifiers: List(Codeableconcept),
value: Option(Quantity),
)
}

pub fn insuranceplan_plan_specificcost_benefit_cost_new(type_ type_: Codeableconcept,) ->InsuranceplanPlanSpecificcostBenefitCost{InsuranceplanPlanSpecificcostBenefitCost(value: None,qualifiers: [],applicability: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn insuranceplan_plan_specificcost_benefit_cost_to_json(insuranceplan_plan_specificcost_benefit_cost: InsuranceplanPlanSpecificcostBenefitCost) -> Json {
    let InsuranceplanPlanSpecificcostBenefitCost(value:,qualifiers:,applicability:,type_:,modifier_extension:,extension:,id:,) = insuranceplan_plan_specificcost_benefit_cost
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case value {
                          Some(v) -> [#("value", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case qualifiers {
                        [] -> fields
                        _ -> [#("qualifiers", json.array(qualifiers,codeableconcept_to_json)), ..fields]
                          }
let fields = case applicability {
                          Some(v) -> [#("applicability", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_plan_specificcost_benefit_cost_decoder() -> Decoder(InsuranceplanPlanSpecificcostBenefitCost) {use value <- decode.optional_field("value", None, decode.optional(quantity_decoder()))
use qualifiers <- decode.optional_field("qualifiers", [], decode.list(codeableconcept_decoder()))
use applicability <- decode.optional_field("applicability", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanPlanSpecificcostBenefitCost(value:,qualifiers:,applicability:,type_:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_plan_specificcost_benefit_to_json(insuranceplan_plan_specificcost_benefit: InsuranceplanPlanSpecificcostBenefit) -> Json {
    let InsuranceplanPlanSpecificcostBenefit(cost:,type_:,modifier_extension:,extension:,id:,) = insuranceplan_plan_specificcost_benefit
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case cost {
                        [] -> fields
                        _ -> [#("cost", json.array(cost,insuranceplan_plan_specificcost_benefit_cost_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_plan_specificcost_benefit_decoder() -> Decoder(InsuranceplanPlanSpecificcostBenefit) {use cost <- decode.optional_field("cost", [], decode.list(insuranceplan_plan_specificcost_benefit_cost_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanPlanSpecificcostBenefit(cost:,type_:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_plan_specificcost_to_json(insuranceplan_plan_specificcost: InsuranceplanPlanSpecificcost) -> Json {
    let InsuranceplanPlanSpecificcost(benefit:,category:,modifier_extension:,extension:,id:,) = insuranceplan_plan_specificcost
    let fields = [#("category", codeableconcept_to_json(category)),]
let fields = case benefit {
                        [] -> fields
                        _ -> [#("benefit", json.array(benefit,insuranceplan_plan_specificcost_benefit_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_plan_specificcost_decoder() -> Decoder(InsuranceplanPlanSpecificcost) {use benefit <- decode.optional_field("benefit", [], decode.list(insuranceplan_plan_specificcost_benefit_decoder()))
use category <- decode.field("category",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanPlanSpecificcost(benefit:,category:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_plan_generalcost_to_json(insuranceplan_plan_generalcost: InsuranceplanPlanGeneralcost) -> Json {
    let InsuranceplanPlanGeneralcost(comment:,cost:,group_size:,type_:,modifier_extension:,extension:,id:,) = insuranceplan_plan_generalcost
    let fields = []
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case cost {
                          Some(v) -> [#("cost", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case group_size {
                          Some(v) -> [#("groupSize", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_plan_generalcost_decoder() -> Decoder(InsuranceplanPlanGeneralcost) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use cost <- decode.optional_field("cost", None, decode.optional(money_decoder()))
use group_size <- decode.optional_field("groupSize", None, decode.optional(decode.int))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanPlanGeneralcost(comment:,cost:,group_size:,type_:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_plan_to_json(insuranceplan_plan: InsuranceplanPlan) -> Json {
    let InsuranceplanPlan(specific_cost:,general_cost:,network:,coverage_area:,type_:,identifier:,modifier_extension:,extension:,id:,) = insuranceplan_plan
    let fields = []
let fields = case specific_cost {
                        [] -> fields
                        _ -> [#("specificCost", json.array(specific_cost,insuranceplan_plan_specificcost_to_json)), ..fields]
                          }
let fields = case general_cost {
                        [] -> fields
                        _ -> [#("generalCost", json.array(general_cost,insuranceplan_plan_generalcost_to_json)), ..fields]
                          }
let fields = case network {
                        [] -> fields
                        _ -> [#("network", json.array(network,reference_to_json)), ..fields]
                          }
let fields = case coverage_area {
                        [] -> fields
                        _ -> [#("coverageArea", json.array(coverage_area,reference_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_plan_decoder() -> Decoder(InsuranceplanPlan) {use specific_cost <- decode.optional_field("specificCost", [], decode.list(insuranceplan_plan_specificcost_decoder()))
use general_cost <- decode.optional_field("generalCost", [], decode.list(insuranceplan_plan_generalcost_decoder()))
use network <- decode.optional_field("network", [], decode.list(reference_decoder()))
use coverage_area <- decode.optional_field("coverageArea", [], decode.list(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanPlan(specific_cost:,general_cost:,network:,coverage_area:,type_:,identifier:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_coverage_benefit_limit_to_json(insuranceplan_coverage_benefit_limit: InsuranceplanCoverageBenefitLimit) -> Json {
    let InsuranceplanCoverageBenefitLimit(code:,value:,modifier_extension:,extension:,id:,) = insuranceplan_coverage_benefit_limit
    let fields = []
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_coverage_benefit_limit_decoder() -> Decoder(InsuranceplanCoverageBenefitLimit) {use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use value <- decode.optional_field("value", None, decode.optional(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanCoverageBenefitLimit(code:,value:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_coverage_benefit_to_json(insuranceplan_coverage_benefit: InsuranceplanCoverageBenefit) -> Json {
    let InsuranceplanCoverageBenefit(limit:,requirement:,type_:,modifier_extension:,extension:,id:,) = insuranceplan_coverage_benefit
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case limit {
                        [] -> fields
                        _ -> [#("limit", json.array(limit,insuranceplan_coverage_benefit_limit_to_json)), ..fields]
                          }
let fields = case requirement {
                          Some(v) -> [#("requirement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_coverage_benefit_decoder() -> Decoder(InsuranceplanCoverageBenefit) {use limit <- decode.optional_field("limit", [], decode.list(insuranceplan_coverage_benefit_limit_decoder()))
use requirement <- decode.optional_field("requirement", None, decode.optional(decode.string))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanCoverageBenefit(limit:,requirement:,type_:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_coverage_to_json(insuranceplan_coverage: InsuranceplanCoverage) -> Json {
    let InsuranceplanCoverage(benefit:,network:,type_:,modifier_extension:,extension:,id:,) = insuranceplan_coverage
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case benefit {
                        [] -> fields
                        _ -> [#("benefit", json.array(benefit,insuranceplan_coverage_benefit_to_json)), ..fields]
                          }
let fields = case network {
                        [] -> fields
                        _ -> [#("network", json.array(network,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_coverage_decoder() -> Decoder(InsuranceplanCoverage) {use benefit <- decode.optional_field("benefit", [], decode.list(insuranceplan_coverage_benefit_decoder()))
use network <- decode.optional_field("network", [], decode.list(reference_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanCoverage(benefit:,network:,type_:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_contact_to_json(insuranceplan_contact: InsuranceplanContact) -> Json {
    let InsuranceplanContact(address:,telecom:,name:,purpose:,modifier_extension:,extension:,id:,) = insuranceplan_contact
    let fields = []
let fields = case address {
                          Some(v) -> [#("address", address_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", humanname_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_contact_decoder() -> Decoder(InsuranceplanContact) {use address <- decode.optional_field("address", None, decode.optional(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", None, decode.optional(humanname_decoder()))
use purpose <- decode.optional_field("purpose", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InsuranceplanContact(address:,telecom:,name:,purpose:,modifier_extension:,extension:,id:,))}
pub fn insuranceplan_to_json(insuranceplan: Insuranceplan) -> Json {
    let Insuranceplan(plan:,coverage:,network:,endpoint:,contact:,coverage_area:,administered_by:,owned_by:,period:,alias:,name:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = insuranceplan
    let fields = []
let fields = case plan {
                        [] -> fields
                        _ -> [#("plan", json.array(plan,insuranceplan_plan_to_json)), ..fields]
                          }
let fields = case coverage {
                        [] -> fields
                        _ -> [#("coverage", json.array(coverage,insuranceplan_coverage_to_json)), ..fields]
                          }
let fields = case network {
                        [] -> fields
                        _ -> [#("network", json.array(network,reference_to_json)), ..fields]
                          }
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,insuranceplan_contact_to_json)), ..fields]
                          }
let fields = case coverage_area {
                        [] -> fields
                        _ -> [#("coverageArea", json.array(coverage_area,reference_to_json)), ..fields]
                          }
let fields = case administered_by {
                          Some(v) -> [#("administeredBy", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case owned_by {
                          Some(v) -> [#("ownedBy", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case alias {
                        [] -> fields
                        _ -> [#("alias", json.array(alias,json.string)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.publicationstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn insuranceplan_decoder() -> Decoder(Insuranceplan) {use plan <- decode.optional_field("plan", [], decode.list(insuranceplan_plan_decoder()))
use coverage <- decode.optional_field("coverage", [], decode.list(insuranceplan_coverage_decoder()))
use network <- decode.optional_field("network", [], decode.list(reference_decoder()))
use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(insuranceplan_contact_decoder()))
use coverage_area <- decode.optional_field("coverageArea", [], decode.list(reference_decoder()))
use administered_by <- decode.optional_field("administeredBy", None, decode.optional(reference_decoder()))
use owned_by <- decode.optional_field("ownedBy", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use alias <- decode.optional_field("alias", [], decode.list(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.publicationstatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Insuranceplan(plan:,coverage:,network:,endpoint:,contact:,coverage_area:,administered_by:,owned_by:,period:,alias:,name:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Invoice#resource
pub type Invoice
{
Invoice(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Invoicestatus,
cancelled_reason: Option(String),
type_: Option(Codeableconcept),
subject: Option(Reference),
recipient: Option(Reference),
date: Option(String),
participant: List(InvoiceParticipant),
issuer: Option(Reference),
account: Option(Reference),
line_item: List(InvoiceLineitem),
total_net: Option(Money),
total_gross: Option(Money),
payment_terms: Option(String),
note: List(Annotation),
)
}

pub fn invoice_new(status status: r4valuesets.Invoicestatus,) ->Invoice{Invoice(note: [],payment_terms: None,total_gross: None,total_net: None,line_item: [],account: None,issuer: None,participant: [],date: None,recipient: None,subject: None,type_: None,cancelled_reason: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Invoice#resource
pub type InvoiceParticipant
{
InvoiceParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
role: Option(Codeableconcept),
actor: Reference,
)
}

pub fn invoice_participant_new(actor actor: Reference,) ->InvoiceParticipant{InvoiceParticipant(actor:,role: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Invoice#resource
pub type InvoiceLineitem
{
InvoiceLineitem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
sequence: Option(Int),
charge_item: InvoiceLineitemChargeitem,
price_component: List(InvoiceLineitemPricecomponent),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Invoice#resource
pub type InvoiceLineitemChargeitem{
InvoiceLineitemChargeitemReference(charge_item: Reference)
InvoiceLineitemChargeitemCodeableconcept(charge_item: Codeableconcept)}
pub fn invoice_lineitem_chargeitem_to_json(elt: InvoiceLineitemChargeitem) -> Json {case elt{InvoiceLineitemChargeitemReference(v) -> reference_to_json(v)
InvoiceLineitemChargeitemCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn invoice_lineitem_chargeitem_decoder() -> Decoder(InvoiceLineitemChargeitem){decode.one_of(decode.field("chargeItemReference", reference_decoder(), decode.success) |> decode.map(InvoiceLineitemChargeitemReference),[decode.field("chargeItemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(InvoiceLineitemChargeitemCodeableconcept),])}
pub fn invoice_lineitem_new(charge_item charge_item: InvoiceLineitemChargeitem,) ->InvoiceLineitem{InvoiceLineitem(price_component: [],charge_item:,sequence: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Invoice#resource
pub type InvoiceLineitemPricecomponent
{
InvoiceLineitemPricecomponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Invoicepricecomponenttype,
code: Option(Codeableconcept),
factor: Option(Float),
amount: Option(Money),
)
}

pub fn invoice_lineitem_pricecomponent_new(type_ type_: r4valuesets.Invoicepricecomponenttype,) ->InvoiceLineitemPricecomponent{InvoiceLineitemPricecomponent(amount: None,factor: None,code: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn invoice_lineitem_pricecomponent_to_json(invoice_lineitem_pricecomponent: InvoiceLineitemPricecomponent) -> Json {
    let InvoiceLineitemPricecomponent(amount:,factor:,code:,type_:,modifier_extension:,extension:,id:,) = invoice_lineitem_pricecomponent
    let fields = [#("type", r4valuesets.invoicepricecomponenttype_to_json(type_)),]
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case factor {
                          Some(v) -> [#("factor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn invoice_lineitem_pricecomponent_decoder() -> Decoder(InvoiceLineitemPricecomponent) {use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use factor <- decode.optional_field("factor", None, decode.optional(decode.float))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",r4valuesets.invoicepricecomponenttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InvoiceLineitemPricecomponent(amount:,factor:,code:,type_:,modifier_extension:,extension:,id:,))}
pub fn invoice_lineitem_to_json(invoice_lineitem: InvoiceLineitem) -> Json {
    let InvoiceLineitem(price_component:,charge_item:,sequence:,modifier_extension:,extension:,id:,) = invoice_lineitem
    let fields = [#("chargeItem", invoice_lineitem_chargeitem_to_json(charge_item)),]
let fields = case price_component {
                        [] -> fields
                        _ -> [#("priceComponent", json.array(price_component,invoice_lineitem_pricecomponent_to_json)), ..fields]
                          }
let fields = case sequence {
                          Some(v) -> [#("sequence", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn invoice_lineitem_decoder() -> Decoder(InvoiceLineitem) {use price_component <- decode.optional_field("priceComponent", [], decode.list(invoice_lineitem_pricecomponent_decoder()))
use charge_item <- decode.then(invoice_lineitem_chargeitem_decoder())
use sequence <- decode.optional_field("sequence", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InvoiceLineitem(price_component:,charge_item:,sequence:,modifier_extension:,extension:,id:,))}
pub fn invoice_participant_to_json(invoice_participant: InvoiceParticipant) -> Json {
    let InvoiceParticipant(actor:,role:,modifier_extension:,extension:,id:,) = invoice_participant
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn invoice_participant_decoder() -> Decoder(InvoiceParticipant) {use actor <- decode.field("actor",reference_decoder())
use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(InvoiceParticipant(actor:,role:,modifier_extension:,extension:,id:,))}
pub fn invoice_to_json(invoice: Invoice) -> Json {
    let Invoice(note:,payment_terms:,total_gross:,total_net:,line_item:,account:,issuer:,participant:,date:,recipient:,subject:,type_:,cancelled_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = invoice
    let fields = [#("status", r4valuesets.invoicestatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case payment_terms {
                          Some(v) -> [#("paymentTerms", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case total_gross {
                          Some(v) -> [#("totalGross", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case total_net {
                          Some(v) -> [#("totalNet", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case line_item {
                        [] -> fields
                        _ -> [#("lineItem", json.array(line_item,invoice_lineitem_to_json)), ..fields]
                          }
let fields = case account {
                          Some(v) -> [#("account", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case issuer {
                          Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,invoice_participant_to_json)), ..fields]
                          }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case recipient {
                          Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case cancelled_reason {
                          Some(v) -> [#("cancelledReason", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn invoice_decoder() -> Decoder(Invoice) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use payment_terms <- decode.optional_field("paymentTerms", None, decode.optional(decode.string))
use total_gross <- decode.optional_field("totalGross", None, decode.optional(money_decoder()))
use total_net <- decode.optional_field("totalNet", None, decode.optional(money_decoder()))
use line_item <- decode.optional_field("lineItem", [], decode.list(invoice_lineitem_decoder()))
use account <- decode.optional_field("account", None, decode.optional(reference_decoder()))
use issuer <- decode.optional_field("issuer", None, decode.optional(reference_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(invoice_participant_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use recipient <- decode.optional_field("recipient", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use cancelled_reason <- decode.optional_field("cancelledReason", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.invoicestatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Invoice(note:,payment_terms:,total_gross:,total_net:,line_item:,account:,issuer:,participant:,date:,recipient:,subject:,type_:,cancelled_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Library#resource
pub type Library
{
Library(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
type_: Codeableconcept,
subject: Option(LibrarySubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
parameter: List(Parameterdefinition),
data_requirement: List(Datarequirement),
content: List(Attachment),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Library#resource
pub type LibrarySubject{
LibrarySubjectCodeableconcept(subject: Codeableconcept)
LibrarySubjectReference(subject: Reference)}
pub fn library_subject_to_json(elt: LibrarySubject) -> Json {case elt{LibrarySubjectCodeableconcept(v) -> codeableconcept_to_json(v)
LibrarySubjectReference(v) -> reference_to_json(v)
}}
pub fn library_subject_decoder() -> Decoder(LibrarySubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(LibrarySubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(LibrarySubjectReference),])}
pub fn library_new(type_ type_: Codeableconcept,status status: r4valuesets.Publicationstatus,) ->Library{Library(content: [],data_requirement: [],parameter: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject: None,type_:,experimental: None,status:,subtitle: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn library_to_json(library: Library) -> Json {
    let Library(content:,data_requirement:,parameter:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,type_:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = library
    let fields = [#("type", codeableconcept_to_json(type_)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case content {
                        [] -> fields
                        _ -> [#("content", json.array(content,attachment_to_json)), ..fields]
                          }
let fields = case data_requirement {
                        [] -> fields
                        _ -> [#("dataRequirement", json.array(data_requirement,datarequirement_to_json)), ..fields]
                          }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,parameterdefinition_to_json)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", library_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn library_decoder() -> Decoder(Library) {use content <- decode.optional_field("content", [], decode.list(attachment_decoder()))
use data_requirement <- decode.optional_field("dataRequirement", [], decode.list(datarequirement_decoder()))
use parameter <- decode.optional_field("parameter", [], decode.list(parameterdefinition_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(library_subject_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Library(content:,data_requirement:,parameter:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,type_:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Linkage#resource
pub type Linkage
{
Linkage(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
active: Option(Bool),
author: Option(Reference),
item: List(LinkageItem),
)
}

pub fn linkage_new() ->Linkage{Linkage(item: [],author: None,active: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Linkage#resource
pub type LinkageItem
{
LinkageItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Linkagetype,
resource: Reference,
)
}

pub fn linkage_item_new(resource resource: Reference,type_ type_: r4valuesets.Linkagetype,) ->LinkageItem{LinkageItem(resource:,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn linkage_item_to_json(linkage_item: LinkageItem) -> Json {
    let LinkageItem(resource:,type_:,modifier_extension:,extension:,id:,) = linkage_item
    let fields = [#("resource", reference_to_json(resource)),#("type", r4valuesets.linkagetype_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn linkage_item_decoder() -> Decoder(LinkageItem) {use resource <- decode.field("resource",reference_decoder())
use type_ <- decode.field("type",r4valuesets.linkagetype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(LinkageItem(resource:,type_:,modifier_extension:,extension:,id:,))}
pub fn linkage_to_json(linkage: Linkage) -> Json {
    let Linkage(item:,author:,active:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = linkage
    let fields = []
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,linkage_item_to_json)), ..fields]
                          }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn linkage_decoder() -> Decoder(Linkage) {use item <- decode.optional_field("item", [], decode.list(linkage_item_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Linkage(item:,author:,active:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/List#resource
pub type FhirList
{
FhirList(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Liststatus,
mode: r4valuesets.Listmode,
title: Option(String),
code: Option(Codeableconcept),
subject: Option(Reference),
encounter: Option(Reference),
date: Option(String),
source: Option(Reference),
ordered_by: Option(Codeableconcept),
note: List(Annotation),
entry: List(ListEntry),
empty_reason: Option(Codeableconcept),
)
}

pub fn fhir_list_new(mode mode: r4valuesets.Listmode,status status: r4valuesets.Liststatus,) ->FhirList{FhirList(empty_reason: None,entry: [],note: [],ordered_by: None,source: None,date: None,encounter: None,subject: None,code: None,title: None,mode:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/List#resource
pub type ListEntry
{
ListEntry(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
flag: Option(Codeableconcept),
deleted: Option(Bool),
date: Option(String),
item: Reference,
)
}

pub fn list_entry_new(item item: Reference,) ->ListEntry{ListEntry(item:,date: None,deleted: None,flag: None,modifier_extension: [],extension: [],id: None,)
}

pub fn list_entry_to_json(list_entry: ListEntry) -> Json {
    let ListEntry(item:,date:,deleted:,flag:,modifier_extension:,extension:,id:,) = list_entry
    let fields = [#("item", reference_to_json(item)),]
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case deleted {
                          Some(v) -> [#("deleted", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case flag {
                          Some(v) -> [#("flag", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn list_entry_decoder() -> Decoder(ListEntry) {use item <- decode.field("item",reference_decoder())
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use deleted <- decode.optional_field("deleted", None, decode.optional(decode.bool))
use flag <- decode.optional_field("flag", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ListEntry(item:,date:,deleted:,flag:,modifier_extension:,extension:,id:,))}
pub fn fhir_list_to_json(fhir_list: FhirList) -> Json {
    let FhirList(empty_reason:,entry:,note:,ordered_by:,source:,date:,encounter:,subject:,code:,title:,mode:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = fhir_list
    let fields = [#("mode", r4valuesets.listmode_to_json(mode)),#("status", r4valuesets.liststatus_to_json(status)),]
let fields = case empty_reason {
                          Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case entry {
                        [] -> fields
                        _ -> [#("entry", json.array(entry,list_entry_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case ordered_by {
                          Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn fhir_list_decoder() -> Decoder(FhirList) {use empty_reason <- decode.optional_field("emptyReason", None, decode.optional(codeableconcept_decoder()))
use entry <- decode.optional_field("entry", [], decode.list(list_entry_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use ordered_by <- decode.optional_field("orderedBy", None, decode.optional(codeableconcept_decoder()))
use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.listmode_decoder())
use status <- decode.field("status",r4valuesets.liststatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(FhirList(empty_reason:,entry:,note:,ordered_by:,source:,date:,encounter:,subject:,code:,title:,mode:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Location#resource
pub type Location
{
Location(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Locationstatus),
operational_status: Option(Coding),
name: Option(String),
alias: List(String),
description: Option(String),
mode: Option(r4valuesets.Locationmode),
type_: List(Codeableconcept),
telecom: List(Contactpoint),
address: Option(Address),
physical_type: Option(Codeableconcept),
position: Option(LocationPosition),
managing_organization: Option(Reference),
part_of: Option(Reference),
hours_of_operation: List(LocationHoursofoperation),
availability_exceptions: Option(String),
endpoint: List(Reference),
)
}

pub fn location_new() ->Location{Location(endpoint: [],availability_exceptions: None,hours_of_operation: [],part_of: None,managing_organization: None,position: None,physical_type: None,address: None,telecom: [],type_: [],mode: None,description: None,alias: [],name: None,operational_status: None,status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Location#resource
pub type LocationPosition
{
LocationPosition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
longitude: Float,
latitude: Float,
altitude: Option(Float),
)
}

pub fn location_position_new(latitude latitude: Float,longitude longitude: Float,) ->LocationPosition{LocationPosition(altitude: None,latitude:,longitude:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Location#resource
pub type LocationHoursofoperation
{
LocationHoursofoperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
days_of_week: List(r4valuesets.Daysofweek),
all_day: Option(Bool),
opening_time: Option(String),
closing_time: Option(String),
)
}

pub fn location_hoursofoperation_new() ->LocationHoursofoperation{LocationHoursofoperation(closing_time: None,opening_time: None,all_day: None,days_of_week: [],modifier_extension: [],extension: [],id: None,)
}

pub fn location_hoursofoperation_to_json(location_hoursofoperation: LocationHoursofoperation) -> Json {
    let LocationHoursofoperation(closing_time:,opening_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,) = location_hoursofoperation
    let fields = []
let fields = case closing_time {
                          Some(v) -> [#("closingTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case opening_time {
                          Some(v) -> [#("openingTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case all_day {
                          Some(v) -> [#("allDay", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case days_of_week {
                        [] -> fields
                        _ -> [#("daysOfWeek", json.array(days_of_week,r4valuesets.daysofweek_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn location_hoursofoperation_decoder() -> Decoder(LocationHoursofoperation) {use closing_time <- decode.optional_field("closingTime", None, decode.optional(decode.string))
use opening_time <- decode.optional_field("openingTime", None, decode.optional(decode.string))
use all_day <- decode.optional_field("allDay", None, decode.optional(decode.bool))
use days_of_week <- decode.optional_field("daysOfWeek", [], decode.list(r4valuesets.daysofweek_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(LocationHoursofoperation(closing_time:,opening_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,))}
pub fn location_position_to_json(location_position: LocationPosition) -> Json {
    let LocationPosition(altitude:,latitude:,longitude:,modifier_extension:,extension:,id:,) = location_position
    let fields = [#("latitude", json.float(latitude)),#("longitude", json.float(longitude)),]
let fields = case altitude {
                          Some(v) -> [#("altitude", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn location_position_decoder() -> Decoder(LocationPosition) {use altitude <- decode.optional_field("altitude", None, decode.optional(decode.float))
use latitude <- decode.field("latitude",decode.float)
use longitude <- decode.field("longitude",decode.float)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(LocationPosition(altitude:,latitude:,longitude:,modifier_extension:,extension:,id:,))}
pub fn location_to_json(location: Location) -> Json {
    let Location(endpoint:,availability_exceptions:,hours_of_operation:,part_of:,managing_organization:,position:,physical_type:,address:,telecom:,type_:,mode:,description:,alias:,name:,operational_status:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = location
    let fields = []
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case availability_exceptions {
                          Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case hours_of_operation {
                        [] -> fields
                        _ -> [#("hoursOfOperation", json.array(hours_of_operation,location_hoursofoperation_to_json)), ..fields]
                          }
let fields = case part_of {
                          Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case managing_organization {
                          Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case position {
                          Some(v) -> [#("position", location_position_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case physical_type {
                          Some(v) -> [#("physicalType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                          Some(v) -> [#("address", address_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case mode {
                          Some(v) -> [#("mode", r4valuesets.locationmode_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case alias {
                        [] -> fields
                        _ -> [#("alias", json.array(alias,json.string)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case operational_status {
                          Some(v) -> [#("operationalStatus", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.locationstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn location_decoder() -> Decoder(Location) {use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use availability_exceptions <- decode.optional_field("availabilityExceptions", None, decode.optional(decode.string))
use hours_of_operation <- decode.optional_field("hoursOfOperation", [], decode.list(location_hoursofoperation_decoder()))
use part_of <- decode.optional_field("partOf", None, decode.optional(reference_decoder()))
use managing_organization <- decode.optional_field("managingOrganization", None, decode.optional(reference_decoder()))
use position <- decode.optional_field("position", None, decode.optional(location_position_decoder()))
use physical_type <- decode.optional_field("physicalType", None, decode.optional(codeableconcept_decoder()))
use address <- decode.optional_field("address", None, decode.optional(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use mode <- decode.optional_field("mode", None, decode.optional(r4valuesets.locationmode_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use alias <- decode.optional_field("alias", [], decode.list(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use operational_status <- decode.optional_field("operationalStatus", None, decode.optional(coding_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.locationstatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Location(endpoint:,availability_exceptions:,hours_of_operation:,part_of:,managing_organization:,position:,physical_type:,address:,telecom:,type_:,mode:,description:,alias:,name:,operational_status:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type Measure
{
Measure(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(MeasureSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
library: List(String),
disclaimer: Option(String),
scoring: Option(Codeableconcept),
composite_scoring: Option(Codeableconcept),
type_: List(Codeableconcept),
risk_adjustment: Option(String),
rate_aggregation: Option(String),
rationale: Option(String),
clinical_recommendation_statement: Option(String),
improvement_notation: Option(Codeableconcept),
definition: List(String),
guidance: Option(String),
group: List(MeasureGroup),
supplemental_data: List(MeasureSupplementaldata),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureSubject{
MeasureSubjectCodeableconcept(subject: Codeableconcept)
MeasureSubjectReference(subject: Reference)}
pub fn measure_subject_to_json(elt: MeasureSubject) -> Json {case elt{MeasureSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
MeasureSubjectReference(v) -> reference_to_json(v)
}}
pub fn measure_subject_decoder() -> Decoder(MeasureSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MeasureSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(MeasureSubjectReference),])}
pub fn measure_new(status status: r4valuesets.Publicationstatus,) ->Measure{Measure(supplemental_data: [],group: [],guidance: None,definition: [],improvement_notation: None,clinical_recommendation_statement: None,rationale: None,rate_aggregation: None,risk_adjustment: None,type_: [],composite_scoring: None,scoring: None,disclaimer: None,library: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,subtitle: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureGroup
{
MeasureGroup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
description: Option(String),
population: List(MeasureGroupPopulation),
stratifier: List(MeasureGroupStratifier),
)
}

pub fn measure_group_new() ->MeasureGroup{MeasureGroup(stratifier: [],population: [],description: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureGroupPopulation
{
MeasureGroupPopulation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
description: Option(String),
criteria: Expression,
)
}

pub fn measure_group_population_new(criteria criteria: Expression,) ->MeasureGroupPopulation{MeasureGroupPopulation(criteria:,description: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureGroupStratifier
{
MeasureGroupStratifier(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
description: Option(String),
criteria: Option(Expression),
component: List(MeasureGroupStratifierComponent),
)
}

pub fn measure_group_stratifier_new() ->MeasureGroupStratifier{MeasureGroupStratifier(component: [],criteria: None,description: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureGroupStratifierComponent
{
MeasureGroupStratifierComponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
description: Option(String),
criteria: Expression,
)
}

pub fn measure_group_stratifier_component_new(criteria criteria: Expression,) ->MeasureGroupStratifierComponent{MeasureGroupStratifierComponent(criteria:,description: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Measure#resource
pub type MeasureSupplementaldata
{
MeasureSupplementaldata(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
usage: List(Codeableconcept),
description: Option(String),
criteria: Expression,
)
}

pub fn measure_supplementaldata_new(criteria criteria: Expression,) ->MeasureSupplementaldata{MeasureSupplementaldata(criteria:,description: None,usage: [],code: None,modifier_extension: [],extension: [],id: None,)
}

pub fn measure_supplementaldata_to_json(measure_supplementaldata: MeasureSupplementaldata) -> Json {
    let MeasureSupplementaldata(criteria:,description:,usage:,code:,modifier_extension:,extension:,id:,) = measure_supplementaldata
    let fields = [#("criteria", expression_to_json(criteria)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                        [] -> fields
                        _ -> [#("usage", json.array(usage,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_supplementaldata_decoder() -> Decoder(MeasureSupplementaldata) {use criteria <- decode.field("criteria",expression_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasureSupplementaldata(criteria:,description:,usage:,code:,modifier_extension:,extension:,id:,))}
pub fn measure_group_stratifier_component_to_json(measure_group_stratifier_component: MeasureGroupStratifierComponent) -> Json {
    let MeasureGroupStratifierComponent(criteria:,description:,code:,modifier_extension:,extension:,id:,) = measure_group_stratifier_component
    let fields = [#("criteria", expression_to_json(criteria)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_group_stratifier_component_decoder() -> Decoder(MeasureGroupStratifierComponent) {use criteria <- decode.field("criteria",expression_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasureGroupStratifierComponent(criteria:,description:,code:,modifier_extension:,extension:,id:,))}
pub fn measure_group_stratifier_to_json(measure_group_stratifier: MeasureGroupStratifier) -> Json {
    let MeasureGroupStratifier(component:,criteria:,description:,code:,modifier_extension:,extension:,id:,) = measure_group_stratifier
    let fields = []
let fields = case component {
                        [] -> fields
                        _ -> [#("component", json.array(component,measure_group_stratifier_component_to_json)), ..fields]
                          }
let fields = case criteria {
                          Some(v) -> [#("criteria", expression_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_group_stratifier_decoder() -> Decoder(MeasureGroupStratifier) {use component <- decode.optional_field("component", [], decode.list(measure_group_stratifier_component_decoder()))
use criteria <- decode.optional_field("criteria", None, decode.optional(expression_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasureGroupStratifier(component:,criteria:,description:,code:,modifier_extension:,extension:,id:,))}
pub fn measure_group_population_to_json(measure_group_population: MeasureGroupPopulation) -> Json {
    let MeasureGroupPopulation(criteria:,description:,code:,modifier_extension:,extension:,id:,) = measure_group_population
    let fields = [#("criteria", expression_to_json(criteria)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_group_population_decoder() -> Decoder(MeasureGroupPopulation) {use criteria <- decode.field("criteria",expression_decoder())
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasureGroupPopulation(criteria:,description:,code:,modifier_extension:,extension:,id:,))}
pub fn measure_group_to_json(measure_group: MeasureGroup) -> Json {
    let MeasureGroup(stratifier:,population:,description:,code:,modifier_extension:,extension:,id:,) = measure_group
    let fields = []
let fields = case stratifier {
                        [] -> fields
                        _ -> [#("stratifier", json.array(stratifier,measure_group_stratifier_to_json)), ..fields]
                          }
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,measure_group_population_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_group_decoder() -> Decoder(MeasureGroup) {use stratifier <- decode.optional_field("stratifier", [], decode.list(measure_group_stratifier_decoder()))
use population <- decode.optional_field("population", [], decode.list(measure_group_population_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasureGroup(stratifier:,population:,description:,code:,modifier_extension:,extension:,id:,))}
pub fn measure_to_json(measure: Measure) -> Json {
    let Measure(supplemental_data:,group:,guidance:,definition:,improvement_notation:,clinical_recommendation_statement:,rationale:,rate_aggregation:,risk_adjustment:,type_:,composite_scoring:,scoring:,disclaimer:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = measure
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case supplemental_data {
                        [] -> fields
                        _ -> [#("supplementalData", json.array(supplemental_data,measure_supplementaldata_to_json)), ..fields]
                          }
let fields = case group {
                        [] -> fields
                        _ -> [#("group", json.array(group,measure_group_to_json)), ..fields]
                          }
let fields = case guidance {
                          Some(v) -> [#("guidance", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                        [] -> fields
                        _ -> [#("definition", json.array(definition,json.string)), ..fields]
                          }
let fields = case improvement_notation {
                          Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case clinical_recommendation_statement {
                          Some(v) -> [#("clinicalRecommendationStatement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case rationale {
                          Some(v) -> [#("rationale", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case rate_aggregation {
                          Some(v) -> [#("rateAggregation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case risk_adjustment {
                          Some(v) -> [#("riskAdjustment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case composite_scoring {
                          Some(v) -> [#("compositeScoring", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case scoring {
                          Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case disclaimer {
                          Some(v) -> [#("disclaimer", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case library {
                        [] -> fields
                        _ -> [#("library", json.array(library,json.string)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", measure_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measure_decoder() -> Decoder(Measure) {use supplemental_data <- decode.optional_field("supplementalData", [], decode.list(measure_supplementaldata_decoder()))
use group <- decode.optional_field("group", [], decode.list(measure_group_decoder()))
use guidance <- decode.optional_field("guidance", None, decode.optional(decode.string))
use definition <- decode.optional_field("definition", [], decode.list(decode.string))
use improvement_notation <- decode.optional_field("improvementNotation", None, decode.optional(codeableconcept_decoder()))
use clinical_recommendation_statement <- decode.optional_field("clinicalRecommendationStatement", None, decode.optional(decode.string))
use rationale <- decode.optional_field("rationale", None, decode.optional(decode.string))
use rate_aggregation <- decode.optional_field("rateAggregation", None, decode.optional(decode.string))
use risk_adjustment <- decode.optional_field("riskAdjustment", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use composite_scoring <- decode.optional_field("compositeScoring", None, decode.optional(codeableconcept_decoder()))
use scoring <- decode.optional_field("scoring", None, decode.optional(codeableconcept_decoder()))
use disclaimer <- decode.optional_field("disclaimer", None, decode.optional(decode.string))
use library <- decode.optional_field("library", [], decode.list(decode.string))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(measure_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Measure(supplemental_data:,group:,guidance:,definition:,improvement_notation:,clinical_recommendation_statement:,rationale:,rate_aggregation:,risk_adjustment:,type_:,composite_scoring:,scoring:,disclaimer:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type Measurereport
{
Measurereport(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Measurereportstatus,
type_: r4valuesets.Measurereporttype,
measure: String,
subject: Option(Reference),
date: Option(String),
reporter: Option(Reference),
period: Period,
improvement_notation: Option(Codeableconcept),
group: List(MeasurereportGroup),
evaluated_resource: List(Reference),
)
}

pub fn measurereport_new(period period: Period,measure measure: String,type_ type_: r4valuesets.Measurereporttype,status status: r4valuesets.Measurereportstatus,) ->Measurereport{Measurereport(evaluated_resource: [],group: [],improvement_notation: None,period:,reporter: None,date: None,subject: None,measure:,type_:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroup
{
MeasurereportGroup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
population: List(MeasurereportGroupPopulation),
measure_score: Option(Quantity),
stratifier: List(MeasurereportGroupStratifier),
)
}

pub fn measurereport_group_new() ->MeasurereportGroup{MeasurereportGroup(stratifier: [],measure_score: None,population: [],code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupPopulation
{
MeasurereportGroupPopulation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
count: Option(Int),
subject_results: Option(Reference),
)
}

pub fn measurereport_group_population_new() ->MeasurereportGroupPopulation{MeasurereportGroupPopulation(subject_results: None,count: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifier
{
MeasurereportGroupStratifier(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: List(Codeableconcept),
stratum: List(MeasurereportGroupStratifierStratum),
)
}

pub fn measurereport_group_stratifier_new() ->MeasurereportGroupStratifier{MeasurereportGroupStratifier(stratum: [],code: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratum
{
MeasurereportGroupStratifierStratum(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: Option(Codeableconcept),
component: List(MeasurereportGroupStratifierStratumComponent),
population: List(MeasurereportGroupStratifierStratumPopulation),
measure_score: Option(Quantity),
)
}

pub fn measurereport_group_stratifier_stratum_new() ->MeasurereportGroupStratifierStratum{MeasurereportGroupStratifierStratum(measure_score: None,population: [],component: [],value: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumComponent
{
MeasurereportGroupStratifierStratumComponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
value: Codeableconcept,
)
}

pub fn measurereport_group_stratifier_stratum_component_new(value value: Codeableconcept,code code: Codeableconcept,) ->MeasurereportGroupStratifierStratumComponent{MeasurereportGroupStratifierStratumComponent(value:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumPopulation
{
MeasurereportGroupStratifierStratumPopulation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
count: Option(Int),
subject_results: Option(Reference),
)
}

pub fn measurereport_group_stratifier_stratum_population_new() ->MeasurereportGroupStratifierStratumPopulation{MeasurereportGroupStratifierStratumPopulation(subject_results: None,count: None,code: None,modifier_extension: [],extension: [],id: None,)
}

pub fn measurereport_group_stratifier_stratum_population_to_json(measurereport_group_stratifier_stratum_population: MeasurereportGroupStratifierStratumPopulation) -> Json {
    let MeasurereportGroupStratifierStratumPopulation(subject_results:,count:,code:,modifier_extension:,extension:,id:,) = measurereport_group_stratifier_stratum_population
    let fields = []
let fields = case subject_results {
                          Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case count {
                          Some(v) -> [#("count", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_stratifier_stratum_population_decoder() -> Decoder(MeasurereportGroupStratifierStratumPopulation) {use subject_results <- decode.optional_field("subjectResults", None, decode.optional(reference_decoder()))
use count <- decode.optional_field("count", None, decode.optional(decode.int))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroupStratifierStratumPopulation(subject_results:,count:,code:,modifier_extension:,extension:,id:,))}
pub fn measurereport_group_stratifier_stratum_component_to_json(measurereport_group_stratifier_stratum_component: MeasurereportGroupStratifierStratumComponent) -> Json {
    let MeasurereportGroupStratifierStratumComponent(value:,code:,modifier_extension:,extension:,id:,) = measurereport_group_stratifier_stratum_component
    let fields = [#("value", codeableconcept_to_json(value)),#("code", codeableconcept_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_stratifier_stratum_component_decoder() -> Decoder(MeasurereportGroupStratifierStratumComponent) {use value <- decode.field("value",codeableconcept_decoder())
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroupStratifierStratumComponent(value:,code:,modifier_extension:,extension:,id:,))}
pub fn measurereport_group_stratifier_stratum_to_json(measurereport_group_stratifier_stratum: MeasurereportGroupStratifierStratum) -> Json {
    let MeasurereportGroupStratifierStratum(measure_score:,population:,component:,value:,modifier_extension:,extension:,id:,) = measurereport_group_stratifier_stratum
    let fields = []
let fields = case measure_score {
                          Some(v) -> [#("measureScore", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,measurereport_group_stratifier_stratum_population_to_json)), ..fields]
                          }
let fields = case component {
                        [] -> fields
                        _ -> [#("component", json.array(component,measurereport_group_stratifier_stratum_component_to_json)), ..fields]
                          }
let fields = case value {
                          Some(v) -> [#("value", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_stratifier_stratum_decoder() -> Decoder(MeasurereportGroupStratifierStratum) {use measure_score <- decode.optional_field("measureScore", None, decode.optional(quantity_decoder()))
use population <- decode.optional_field("population", [], decode.list(measurereport_group_stratifier_stratum_population_decoder()))
use component <- decode.optional_field("component", [], decode.list(measurereport_group_stratifier_stratum_component_decoder()))
use value <- decode.optional_field("value", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroupStratifierStratum(measure_score:,population:,component:,value:,modifier_extension:,extension:,id:,))}
pub fn measurereport_group_stratifier_to_json(measurereport_group_stratifier: MeasurereportGroupStratifier) -> Json {
    let MeasurereportGroupStratifier(stratum:,code:,modifier_extension:,extension:,id:,) = measurereport_group_stratifier
    let fields = []
let fields = case stratum {
                        [] -> fields
                        _ -> [#("stratum", json.array(stratum,measurereport_group_stratifier_stratum_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_stratifier_decoder() -> Decoder(MeasurereportGroupStratifier) {use stratum <- decode.optional_field("stratum", [], decode.list(measurereport_group_stratifier_stratum_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroupStratifier(stratum:,code:,modifier_extension:,extension:,id:,))}
pub fn measurereport_group_population_to_json(measurereport_group_population: MeasurereportGroupPopulation) -> Json {
    let MeasurereportGroupPopulation(subject_results:,count:,code:,modifier_extension:,extension:,id:,) = measurereport_group_population
    let fields = []
let fields = case subject_results {
                          Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case count {
                          Some(v) -> [#("count", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_population_decoder() -> Decoder(MeasurereportGroupPopulation) {use subject_results <- decode.optional_field("subjectResults", None, decode.optional(reference_decoder()))
use count <- decode.optional_field("count", None, decode.optional(decode.int))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroupPopulation(subject_results:,count:,code:,modifier_extension:,extension:,id:,))}
pub fn measurereport_group_to_json(measurereport_group: MeasurereportGroup) -> Json {
    let MeasurereportGroup(stratifier:,measure_score:,population:,code:,modifier_extension:,extension:,id:,) = measurereport_group
    let fields = []
let fields = case stratifier {
                        [] -> fields
                        _ -> [#("stratifier", json.array(stratifier,measurereport_group_stratifier_to_json)), ..fields]
                          }
let fields = case measure_score {
                          Some(v) -> [#("measureScore", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,measurereport_group_population_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_group_decoder() -> Decoder(MeasurereportGroup) {use stratifier <- decode.optional_field("stratifier", [], decode.list(measurereport_group_stratifier_decoder()))
use measure_score <- decode.optional_field("measureScore", None, decode.optional(quantity_decoder()))
use population <- decode.optional_field("population", [], decode.list(measurereport_group_population_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MeasurereportGroup(stratifier:,measure_score:,population:,code:,modifier_extension:,extension:,id:,))}
pub fn measurereport_to_json(measurereport: Measurereport) -> Json {
    let Measurereport(evaluated_resource:,group:,improvement_notation:,period:,reporter:,date:,subject:,measure:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = measurereport
    let fields = [#("period", period_to_json(period)),#("measure", json.string(measure)),#("type", r4valuesets.measurereporttype_to_json(type_)),#("status", r4valuesets.measurereportstatus_to_json(status)),]
let fields = case evaluated_resource {
                        [] -> fields
                        _ -> [#("evaluatedResource", json.array(evaluated_resource,reference_to_json)), ..fields]
                          }
let fields = case group {
                        [] -> fields
                        _ -> [#("group", json.array(group,measurereport_group_to_json)), ..fields]
                          }
let fields = case improvement_notation {
                          Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reporter {
                          Some(v) -> [#("reporter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn measurereport_decoder() -> Decoder(Measurereport) {use evaluated_resource <- decode.optional_field("evaluatedResource", [], decode.list(reference_decoder()))
use group <- decode.optional_field("group", [], decode.list(measurereport_group_decoder()))
use improvement_notation <- decode.optional_field("improvementNotation", None, decode.optional(codeableconcept_decoder()))
use period <- decode.field("period",period_decoder())
use reporter <- decode.optional_field("reporter", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use measure <- decode.field("measure",decode.string)
use type_ <- decode.field("type",r4valuesets.measurereporttype_decoder())
use status <- decode.field("status",r4valuesets.measurereportstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Measurereport(evaluated_resource:,group:,improvement_notation:,period:,reporter:,date:,subject:,measure:,type_:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Media#resource
pub type Media
{
Media(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
part_of: List(Reference),
status: r4valuesets.Eventstatus,
type_: Option(Codeableconcept),
modality: Option(Codeableconcept),
view: Option(Codeableconcept),
subject: Option(Reference),
encounter: Option(Reference),
created: Option(MediaCreated),
issued: Option(String),
operator: Option(Reference),
reason_code: List(Codeableconcept),
body_site: Option(Codeableconcept),
device_name: Option(String),
device: Option(Reference),
height: Option(Int),
width: Option(Int),
frames: Option(Int),
duration: Option(Float),
content: Attachment,
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Media#resource
pub type MediaCreated{
MediaCreatedDatetime(created: String)
MediaCreatedPeriod(created: Period)}
pub fn media_created_to_json(elt: MediaCreated) -> Json {case elt{MediaCreatedDatetime(v) -> json.string(v)
MediaCreatedPeriod(v) -> period_to_json(v)
}}
pub fn media_created_decoder() -> Decoder(MediaCreated){decode.one_of(decode.field("createdDateTime", decode.string, decode.success) |> decode.map(MediaCreatedDatetime),[decode.field("createdPeriod", period_decoder(), decode.success) |> decode.map(MediaCreatedPeriod),])}
pub fn media_new(content content: Attachment,status status: r4valuesets.Eventstatus,) ->Media{Media(note: [],content:,duration: None,frames: None,width: None,height: None,device: None,device_name: None,body_site: None,reason_code: [],operator: None,issued: None,created: None,encounter: None,subject: None,view: None,modality: None,type_: None,status:,part_of: [],based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn media_to_json(media: Media) -> Json {
    let Media(note:,content:,duration:,frames:,width:,height:,device:,device_name:,body_site:,reason_code:,operator:,issued:,created:,encounter:,subject:,view:,modality:,type_:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = media
    let fields = [#("content", attachment_to_json(content)),#("status", r4valuesets.eventstatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case duration {
                          Some(v) -> [#("duration", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case frames {
                          Some(v) -> [#("frames", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case width {
                          Some(v) -> [#("width", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case height {
                          Some(v) -> [#("height", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case device {
                          Some(v) -> [#("device", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case device_name {
                          Some(v) -> [#("deviceName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case operator {
                          Some(v) -> [#("operator", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case created {
                          Some(v) -> [#("created", media_created_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case view {
                          Some(v) -> [#("view", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modality {
                          Some(v) -> [#("modality", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn media_decoder() -> Decoder(Media) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use content <- decode.field("content",attachment_decoder())
use duration <- decode.optional_field("duration", None, decode.optional(decode.float))
use frames <- decode.optional_field("frames", None, decode.optional(decode.int))
use width <- decode.optional_field("width", None, decode.optional(decode.int))
use height <- decode.optional_field("height", None, decode.optional(decode.int))
use device <- decode.optional_field("device", None, decode.optional(reference_decoder()))
use device_name <- decode.optional_field("deviceName", None, decode.optional(decode.string))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use operator <- decode.optional_field("operator", None, decode.optional(reference_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use created <- decode.then(none_if_omitted(media_created_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use view <- decode.optional_field("view", None, decode.optional(codeableconcept_decoder()))
use modality <- decode.optional_field("modality", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.eventstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Media(note:,content:,duration:,frames:,width:,height:,device:,device_name:,body_site:,reason_code:,operator:,issued:,created:,encounter:,subject:,view:,modality:,type_:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Medication#resource
pub type Medication
{
Medication(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
code: Option(Codeableconcept),
status: Option(r4valuesets.Medicationstatus),
manufacturer: Option(Reference),
form: Option(Codeableconcept),
amount: Option(Ratio),
ingredient: List(MedicationIngredient),
batch: Option(MedicationBatch),
)
}

pub fn medication_new() ->Medication{Medication(batch: None,ingredient: [],amount: None,form: None,manufacturer: None,status: None,code: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Medication#resource
pub type MedicationIngredient
{
MedicationIngredient(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item: MedicationIngredientItem,
is_active: Option(Bool),
strength: Option(Ratio),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Medication#resource
pub type MedicationIngredientItem{
MedicationIngredientItemCodeableconcept(item: Codeableconcept)
MedicationIngredientItemReference(item: Reference)}
pub fn medication_ingredient_item_to_json(elt: MedicationIngredientItem) -> Json {case elt{MedicationIngredientItemCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationIngredientItemReference(v) -> reference_to_json(v)
}}
pub fn medication_ingredient_item_decoder() -> Decoder(MedicationIngredientItem){decode.one_of(decode.field("itemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationIngredientItemCodeableconcept),[decode.field("itemReference", reference_decoder(), decode.success) |> decode.map(MedicationIngredientItemReference),])}
pub fn medication_ingredient_new(item item: MedicationIngredientItem,) ->MedicationIngredient{MedicationIngredient(strength: None,is_active: None,item:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Medication#resource
pub type MedicationBatch
{
MedicationBatch(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
lot_number: Option(String),
expiration_date: Option(String),
)
}

pub fn medication_batch_new() ->MedicationBatch{MedicationBatch(expiration_date: None,lot_number: None,modifier_extension: [],extension: [],id: None,)
}

pub fn medication_batch_to_json(medication_batch: MedicationBatch) -> Json {
    let MedicationBatch(expiration_date:,lot_number:,modifier_extension:,extension:,id:,) = medication_batch
    let fields = []
let fields = case expiration_date {
                          Some(v) -> [#("expirationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case lot_number {
                          Some(v) -> [#("lotNumber", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medication_batch_decoder() -> Decoder(MedicationBatch) {use expiration_date <- decode.optional_field("expirationDate", None, decode.optional(decode.string))
use lot_number <- decode.optional_field("lotNumber", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationBatch(expiration_date:,lot_number:,modifier_extension:,extension:,id:,))}
pub fn medication_ingredient_to_json(medication_ingredient: MedicationIngredient) -> Json {
    let MedicationIngredient(strength:,is_active:,item:,modifier_extension:,extension:,id:,) = medication_ingredient
    let fields = [#("item", medication_ingredient_item_to_json(item)),]
let fields = case strength {
                          Some(v) -> [#("strength", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_active {
                          Some(v) -> [#("isActive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medication_ingredient_decoder() -> Decoder(MedicationIngredient) {use strength <- decode.optional_field("strength", None, decode.optional(ratio_decoder()))
use is_active <- decode.optional_field("isActive", None, decode.optional(decode.bool))
use item <- decode.then(medication_ingredient_item_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationIngredient(strength:,is_active:,item:,modifier_extension:,extension:,id:,))}
pub fn medication_to_json(medication: Medication) -> Json {
    let Medication(batch:,ingredient:,amount:,form:,manufacturer:,status:,code:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medication
    let fields = []
let fields = case batch {
                          Some(v) -> [#("batch", medication_batch_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case ingredient {
                        [] -> fields
                        _ -> [#("ingredient", json.array(ingredient,medication_ingredient_to_json)), ..fields]
                          }
let fields = case amount {
                          Some(v) -> [#("amount", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case form {
                          Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacturer {
                          Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.medicationstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medication_decoder() -> Decoder(Medication) {use batch <- decode.optional_field("batch", None, decode.optional(medication_batch_decoder()))
use ingredient <- decode.optional_field("ingredient", [], decode.list(medication_ingredient_decoder()))
use amount <- decode.optional_field("amount", None, decode.optional(ratio_decoder()))
use form <- decode.optional_field("form", None, decode.optional(codeableconcept_decoder()))
use manufacturer <- decode.optional_field("manufacturer", None, decode.optional(reference_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.medicationstatus_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medication(batch:,ingredient:,amount:,form:,manufacturer:,status:,code:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type Medicationadministration
{
Medicationadministration(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates: List(String),
part_of: List(Reference),
status: r4valuesets.Medicationadminstatus,
status_reason: List(Codeableconcept),
category: Option(Codeableconcept),
medication: MedicationadministrationMedication,
subject: Reference,
context: Option(Reference),
supporting_information: List(Reference),
effective: MedicationadministrationEffective,
performer: List(MedicationadministrationPerformer),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
request: Option(Reference),
device: List(Reference),
note: List(Annotation),
dosage: Option(MedicationadministrationDosage),
event_history: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationMedication{
MedicationadministrationMedicationCodeableconcept(medication: Codeableconcept)
MedicationadministrationMedicationReference(medication: Reference)}
pub fn medicationadministration_medication_to_json(elt: MedicationadministrationMedication) -> Json {case elt{MedicationadministrationMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationadministrationMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicationadministration_medication_decoder() -> Decoder(MedicationadministrationMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationadministrationMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicationadministrationMedicationReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationEffective{
MedicationadministrationEffectiveDatetime(effective: String)
MedicationadministrationEffectivePeriod(effective: Period)}
pub fn medicationadministration_effective_to_json(elt: MedicationadministrationEffective) -> Json {case elt{MedicationadministrationEffectiveDatetime(v) -> json.string(v)
MedicationadministrationEffectivePeriod(v) -> period_to_json(v)
}}
pub fn medicationadministration_effective_decoder() -> Decoder(MedicationadministrationEffective){decode.one_of(decode.field("effectiveDateTime", decode.string, decode.success) |> decode.map(MedicationadministrationEffectiveDatetime),[decode.field("effectivePeriod", period_decoder(), decode.success) |> decode.map(MedicationadministrationEffectivePeriod),])}
pub fn medicationadministration_new(effective effective: MedicationadministrationEffective,subject subject: Reference,medication medication: MedicationadministrationMedication,status status: r4valuesets.Medicationadminstatus,) ->Medicationadministration{Medicationadministration(event_history: [],dosage: None,note: [],device: [],request: None,reason_reference: [],reason_code: [],performer: [],effective:,supporting_information: [],context: None,subject:,medication:,category: None,status_reason: [],status:,part_of: [],instantiates: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationPerformer
{
MedicationadministrationPerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
)
}

pub fn medicationadministration_performer_new(actor actor: Reference,) ->MedicationadministrationPerformer{MedicationadministrationPerformer(actor:,function: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosage
{
MedicationadministrationDosage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
text: Option(String),
site: Option(Codeableconcept),
route: Option(Codeableconcept),
method: Option(Codeableconcept),
dose: Option(Quantity),
rate: Option(MedicationadministrationDosageRate),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosageRate{
MedicationadministrationDosageRateRatio(rate: Ratio)
MedicationadministrationDosageRateQuantity(rate: Quantity)}
pub fn medicationadministration_dosage_rate_to_json(elt: MedicationadministrationDosageRate) -> Json {case elt{MedicationadministrationDosageRateRatio(v) -> ratio_to_json(v)
MedicationadministrationDosageRateQuantity(v) -> quantity_to_json(v)
}}
pub fn medicationadministration_dosage_rate_decoder() -> Decoder(MedicationadministrationDosageRate){decode.one_of(decode.field("rateRatio", ratio_decoder(), decode.success) |> decode.map(MedicationadministrationDosageRateRatio),[decode.field("rateQuantity", quantity_decoder(), decode.success) |> decode.map(MedicationadministrationDosageRateQuantity),])}
pub fn medicationadministration_dosage_new() ->MedicationadministrationDosage{MedicationadministrationDosage(rate: None,dose: None,method: None,route: None,site: None,text: None,modifier_extension: [],extension: [],id: None,)
}

pub fn medicationadministration_dosage_to_json(medicationadministration_dosage: MedicationadministrationDosage) -> Json {
    let MedicationadministrationDosage(rate:,dose:,method:,route:,site:,text:,modifier_extension:,extension:,id:,) = medicationadministration_dosage
    let fields = []
let fields = case rate {
                          Some(v) -> [#("rate", medicationadministration_dosage_rate_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dose {
                          Some(v) -> [#("dose", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case route {
                          Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case site {
                          Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationadministration_dosage_decoder() -> Decoder(MedicationadministrationDosage) {use rate <- decode.then(none_if_omitted(medicationadministration_dosage_rate_decoder()))
use dose <- decode.optional_field("dose", None, decode.optional(quantity_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use route <- decode.optional_field("route", None, decode.optional(codeableconcept_decoder()))
use site <- decode.optional_field("site", None, decode.optional(codeableconcept_decoder()))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationadministrationDosage(rate:,dose:,method:,route:,site:,text:,modifier_extension:,extension:,id:,))}
pub fn medicationadministration_performer_to_json(medicationadministration_performer: MedicationadministrationPerformer) -> Json {
    let MedicationadministrationPerformer(actor:,function:,modifier_extension:,extension:,id:,) = medicationadministration_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationadministration_performer_decoder() -> Decoder(MedicationadministrationPerformer) {use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationadministrationPerformer(actor:,function:,modifier_extension:,extension:,id:,))}
pub fn medicationadministration_to_json(medicationadministration: Medicationadministration) -> Json {
    let Medicationadministration(event_history:,dosage:,note:,device:,request:,reason_reference:,reason_code:,performer:,effective:,supporting_information:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,instantiates:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicationadministration
    let fields = [#("effective", medicationadministration_effective_to_json(effective)),#("subject", reference_to_json(subject)),#("medication", medicationadministration_medication_to_json(medication)),#("status", r4valuesets.medicationadminstatus_to_json(status)),]
let fields = case event_history {
                        [] -> fields
                        _ -> [#("eventHistory", json.array(event_history,reference_to_json)), ..fields]
                          }
let fields = case dosage {
                          Some(v) -> [#("dosage", medicationadministration_dosage_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case device {
                        [] -> fields
                        _ -> [#("device", json.array(device,reference_to_json)), ..fields]
                          }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,medicationadministration_performer_to_json)), ..fields]
                          }
let fields = case supporting_information {
                        [] -> fields
                        _ -> [#("supportingInformation", json.array(supporting_information,reference_to_json)), ..fields]
                          }
let fields = case context {
                          Some(v) -> [#("context", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                        [] -> fields
                        _ -> [#("statusReason", json.array(status_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case instantiates {
                        [] -> fields
                        _ -> [#("instantiates", json.array(instantiates,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationadministration_decoder() -> Decoder(Medicationadministration) {use event_history <- decode.optional_field("eventHistory", [], decode.list(reference_decoder()))
use dosage <- decode.optional_field("dosage", None, decode.optional(medicationadministration_dosage_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use device <- decode.optional_field("device", [], decode.list(reference_decoder()))
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(medicationadministration_performer_decoder()))
use effective <- decode.then(medicationadministration_effective_decoder())
use supporting_information <- decode.optional_field("supportingInformation", [], decode.list(reference_decoder()))
use context <- decode.optional_field("context", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use medication <- decode.then(medicationadministration_medication_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", [], decode.list(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.medicationadminstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use instantiates <- decode.optional_field("instantiates", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicationadministration(event_history:,dosage:,note:,device:,request:,reason_reference:,reason_code:,performer:,effective:,supporting_information:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,instantiates:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationDispense#resource
pub type Medicationdispense
{
Medicationdispense(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
part_of: List(Reference),
status: r4valuesets.Medicationdispensestatus,
status_reason: Option(MedicationdispenseStatusreason),
category: Option(Codeableconcept),
medication: MedicationdispenseMedication,
subject: Option(Reference),
context: Option(Reference),
supporting_information: List(Reference),
performer: List(MedicationdispensePerformer),
location: Option(Reference),
authorizing_prescription: List(Reference),
type_: Option(Codeableconcept),
quantity: Option(Quantity),
days_supply: Option(Quantity),
when_prepared: Option(String),
when_handed_over: Option(String),
destination: Option(Reference),
receiver: List(Reference),
note: List(Annotation),
dosage_instruction: List(Dosage),
substitution: Option(MedicationdispenseSubstitution),
detected_issue: List(Reference),
event_history: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseStatusreason{
MedicationdispenseStatusreasonCodeableconcept(status_reason: Codeableconcept)
MedicationdispenseStatusreasonReference(status_reason: Reference)}
pub fn medicationdispense_statusreason_to_json(elt: MedicationdispenseStatusreason) -> Json {case elt{MedicationdispenseStatusreasonCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationdispenseStatusreasonReference(v) -> reference_to_json(v)
}}
pub fn medicationdispense_statusreason_decoder() -> Decoder(MedicationdispenseStatusreason){decode.one_of(decode.field("statusReasonCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationdispenseStatusreasonCodeableconcept),[decode.field("statusReasonReference", reference_decoder(), decode.success) |> decode.map(MedicationdispenseStatusreasonReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseMedication{
MedicationdispenseMedicationCodeableconcept(medication: Codeableconcept)
MedicationdispenseMedicationReference(medication: Reference)}
pub fn medicationdispense_medication_to_json(elt: MedicationdispenseMedication) -> Json {case elt{MedicationdispenseMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationdispenseMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicationdispense_medication_decoder() -> Decoder(MedicationdispenseMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationdispenseMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicationdispenseMedicationReference),])}
pub fn medicationdispense_new(medication medication: MedicationdispenseMedication,status status: r4valuesets.Medicationdispensestatus,) ->Medicationdispense{Medicationdispense(event_history: [],detected_issue: [],substitution: None,dosage_instruction: [],note: [],receiver: [],destination: None,when_handed_over: None,when_prepared: None,days_supply: None,quantity: None,type_: None,authorizing_prescription: [],location: None,performer: [],supporting_information: [],context: None,subject: None,medication:,category: None,status_reason: None,status:,part_of: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationDispense#resource
pub type MedicationdispensePerformer
{
MedicationdispensePerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
)
}

pub fn medicationdispense_performer_new(actor actor: Reference,) ->MedicationdispensePerformer{MedicationdispensePerformer(actor:,function: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseSubstitution
{
MedicationdispenseSubstitution(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
was_substituted: Bool,
type_: Option(Codeableconcept),
reason: List(Codeableconcept),
responsible_party: List(Reference),
)
}

pub fn medicationdispense_substitution_new(was_substituted was_substituted: Bool,) ->MedicationdispenseSubstitution{MedicationdispenseSubstitution(responsible_party: [],reason: [],type_: None,was_substituted:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicationdispense_substitution_to_json(medicationdispense_substitution: MedicationdispenseSubstitution) -> Json {
    let MedicationdispenseSubstitution(responsible_party:,reason:,type_:,was_substituted:,modifier_extension:,extension:,id:,) = medicationdispense_substitution
    let fields = [#("wasSubstituted", json.bool(was_substituted)),]
let fields = case responsible_party {
                        [] -> fields
                        _ -> [#("responsibleParty", json.array(responsible_party,reference_to_json)), ..fields]
                          }
let fields = case reason {
                        [] -> fields
                        _ -> [#("reason", json.array(reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationdispense_substitution_decoder() -> Decoder(MedicationdispenseSubstitution) {use responsible_party <- decode.optional_field("responsibleParty", [], decode.list(reference_decoder()))
use reason <- decode.optional_field("reason", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use was_substituted <- decode.field("wasSubstituted",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationdispenseSubstitution(responsible_party:,reason:,type_:,was_substituted:,modifier_extension:,extension:,id:,))}
pub fn medicationdispense_performer_to_json(medicationdispense_performer: MedicationdispensePerformer) -> Json {
    let MedicationdispensePerformer(actor:,function:,modifier_extension:,extension:,id:,) = medicationdispense_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationdispense_performer_decoder() -> Decoder(MedicationdispensePerformer) {use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationdispensePerformer(actor:,function:,modifier_extension:,extension:,id:,))}
pub fn medicationdispense_to_json(medicationdispense: Medicationdispense) -> Json {
    let Medicationdispense(event_history:,detected_issue:,substitution:,dosage_instruction:,note:,receiver:,destination:,when_handed_over:,when_prepared:,days_supply:,quantity:,type_:,authorizing_prescription:,location:,performer:,supporting_information:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicationdispense
    let fields = [#("medication", medicationdispense_medication_to_json(medication)),#("status", r4valuesets.medicationdispensestatus_to_json(status)),]
let fields = case event_history {
                        [] -> fields
                        _ -> [#("eventHistory", json.array(event_history,reference_to_json)), ..fields]
                          }
let fields = case detected_issue {
                        [] -> fields
                        _ -> [#("detectedIssue", json.array(detected_issue,reference_to_json)), ..fields]
                          }
let fields = case substitution {
                          Some(v) -> [#("substitution", medicationdispense_substitution_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dosage_instruction {
                        [] -> fields
                        _ -> [#("dosageInstruction", json.array(dosage_instruction,dosage_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case receiver {
                        [] -> fields
                        _ -> [#("receiver", json.array(receiver,reference_to_json)), ..fields]
                          }
let fields = case destination {
                          Some(v) -> [#("destination", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case when_handed_over {
                          Some(v) -> [#("whenHandedOver", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case when_prepared {
                          Some(v) -> [#("whenPrepared", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case days_supply {
                          Some(v) -> [#("daysSupply", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authorizing_prescription {
                        [] -> fields
                        _ -> [#("authorizingPrescription", json.array(authorizing_prescription,reference_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,medicationdispense_performer_to_json)), ..fields]
                          }
let fields = case supporting_information {
                        [] -> fields
                        _ -> [#("supportingInformation", json.array(supporting_information,reference_to_json)), ..fields]
                          }
let fields = case context {
                          Some(v) -> [#("context", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", medicationdispense_statusreason_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationdispense_decoder() -> Decoder(Medicationdispense) {use event_history <- decode.optional_field("eventHistory", [], decode.list(reference_decoder()))
use detected_issue <- decode.optional_field("detectedIssue", [], decode.list(reference_decoder()))
use substitution <- decode.optional_field("substitution", None, decode.optional(medicationdispense_substitution_decoder()))
use dosage_instruction <- decode.optional_field("dosageInstruction", [], decode.list(dosage_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use receiver <- decode.optional_field("receiver", [], decode.list(reference_decoder()))
use destination <- decode.optional_field("destination", None, decode.optional(reference_decoder()))
use when_handed_over <- decode.optional_field("whenHandedOver", None, decode.optional(decode.string))
use when_prepared <- decode.optional_field("whenPrepared", None, decode.optional(decode.string))
use days_supply <- decode.optional_field("daysSupply", None, decode.optional(quantity_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use authorizing_prescription <- decode.optional_field("authorizingPrescription", [], decode.list(reference_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(medicationdispense_performer_decoder()))
use supporting_information <- decode.optional_field("supportingInformation", [], decode.list(reference_decoder()))
use context <- decode.optional_field("context", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use medication <- decode.then(medicationdispense_medication_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.then(none_if_omitted(medicationdispense_statusreason_decoder()))
use status <- decode.field("status",r4valuesets.medicationdispensestatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicationdispense(event_history:,detected_issue:,substitution:,dosage_instruction:,note:,receiver:,destination:,when_handed_over:,when_prepared:,days_supply:,quantity:,type_:,authorizing_prescription:,location:,performer:,supporting_information:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type Medicationknowledge
{
Medicationknowledge(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
status: Option(r4valuesets.Medicationknowledgestatus),
manufacturer: Option(Reference),
dose_form: Option(Codeableconcept),
amount: Option(Quantity),
synonym: List(String),
related_medication_knowledge: List(MedicationknowledgeRelatedmedicationknowledge),
associated_medication: List(Reference),
product_type: List(Codeableconcept),
monograph: List(MedicationknowledgeMonograph),
ingredient: List(MedicationknowledgeIngredient),
preparation_instruction: Option(String),
intended_route: List(Codeableconcept),
cost: List(MedicationknowledgeCost),
monitoring_program: List(MedicationknowledgeMonitoringprogram),
administration_guidelines: List(MedicationknowledgeAdministrationguidelines),
medicine_classification: List(MedicationknowledgeMedicineclassification),
packaging: Option(MedicationknowledgePackaging),
drug_characteristic: List(MedicationknowledgeDrugcharacteristic),
contraindication: List(Reference),
regulatory: List(MedicationknowledgeRegulatory),
kinetics: List(MedicationknowledgeKinetics),
)
}

pub fn medicationknowledge_new() ->Medicationknowledge{Medicationknowledge(kinetics: [],regulatory: [],contraindication: [],drug_characteristic: [],packaging: None,medicine_classification: [],administration_guidelines: [],monitoring_program: [],cost: [],intended_route: [],preparation_instruction: None,ingredient: [],monograph: [],product_type: [],associated_medication: [],related_medication_knowledge: [],synonym: [],amount: None,dose_form: None,manufacturer: None,status: None,code: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRelatedmedicationknowledge
{
MedicationknowledgeRelatedmedicationknowledge(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
reference: List(Reference),
)
}

pub fn medicationknowledge_relatedmedicationknowledge_new(type_ type_: Codeableconcept,) ->MedicationknowledgeRelatedmedicationknowledge{MedicationknowledgeRelatedmedicationknowledge(reference: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonograph
{
MedicationknowledgeMonograph(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
source: Option(Reference),
)
}

pub fn medicationknowledge_monograph_new() ->MedicationknowledgeMonograph{MedicationknowledgeMonograph(source: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIngredient
{
MedicationknowledgeIngredient(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item: MedicationknowledgeIngredientItem,
is_active: Option(Bool),
strength: Option(Ratio),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIngredientItem{
MedicationknowledgeIngredientItemCodeableconcept(item: Codeableconcept)
MedicationknowledgeIngredientItemReference(item: Reference)}
pub fn medicationknowledge_ingredient_item_to_json(elt: MedicationknowledgeIngredientItem) -> Json {case elt{MedicationknowledgeIngredientItemCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationknowledgeIngredientItemReference(v) -> reference_to_json(v)
}}
pub fn medicationknowledge_ingredient_item_decoder() -> Decoder(MedicationknowledgeIngredientItem){decode.one_of(decode.field("itemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationknowledgeIngredientItemCodeableconcept),[decode.field("itemReference", reference_decoder(), decode.success) |> decode.map(MedicationknowledgeIngredientItemReference),])}
pub fn medicationknowledge_ingredient_new(item item: MedicationknowledgeIngredientItem,) ->MedicationknowledgeIngredient{MedicationknowledgeIngredient(strength: None,is_active: None,item:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeCost
{
MedicationknowledgeCost(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
source: Option(String),
cost: Money,
)
}

pub fn medicationknowledge_cost_new(cost cost: Money,type_ type_: Codeableconcept,) ->MedicationknowledgeCost{MedicationknowledgeCost(cost:,source: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonitoringprogram
{
MedicationknowledgeMonitoringprogram(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
name: Option(String),
)
}

pub fn medicationknowledge_monitoringprogram_new() ->MedicationknowledgeMonitoringprogram{MedicationknowledgeMonitoringprogram(name: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelines
{
MedicationknowledgeAdministrationguidelines(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
dosage: List(MedicationknowledgeAdministrationguidelinesDosage),
indication: Option(MedicationknowledgeAdministrationguidelinesIndication),
patient_characteristics: List(MedicationknowledgeAdministrationguidelinesPatientcharacteristics),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesIndication{
MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept(indication: Codeableconcept)
MedicationknowledgeAdministrationguidelinesIndicationReference(indication: Reference)}
pub fn medicationknowledge_administrationguidelines_indication_to_json(elt: MedicationknowledgeAdministrationguidelinesIndication) -> Json {case elt{MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationknowledgeAdministrationguidelinesIndicationReference(v) -> reference_to_json(v)
}}
pub fn medicationknowledge_administrationguidelines_indication_decoder() -> Decoder(MedicationknowledgeAdministrationguidelinesIndication){decode.one_of(decode.field("indicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationknowledgeAdministrationguidelinesIndicationCodeableconcept),[decode.field("indicationReference", reference_decoder(), decode.success) |> decode.map(MedicationknowledgeAdministrationguidelinesIndicationReference),])}
pub fn medicationknowledge_administrationguidelines_new() ->MedicationknowledgeAdministrationguidelines{MedicationknowledgeAdministrationguidelines(patient_characteristics: [],indication: None,dosage: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesDosage
{
MedicationknowledgeAdministrationguidelinesDosage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
dosage: List(Dosage),
)
}

pub fn medicationknowledge_administrationguidelines_dosage_new(type_ type_: Codeableconcept,) ->MedicationknowledgeAdministrationguidelinesDosage{MedicationknowledgeAdministrationguidelinesDosage(dosage: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesPatientcharacteristics
{
MedicationknowledgeAdministrationguidelinesPatientcharacteristics(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
characteristic: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,
value: List(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic{
MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept(characteristic: Codeableconcept)
MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity(characteristic: Quantity)}
pub fn medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_to_json(elt: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic) -> Json {case elt{MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity(v) -> quantity_to_json(v)
}}
pub fn medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_decoder() -> Decoder(MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic){decode.one_of(decode.field("characteristicCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicCodeableconcept),[decode.field("characteristicQuantity", quantity_decoder(), decode.success) |> decode.map(MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristicQuantity),])}
pub fn medicationknowledge_administrationguidelines_patientcharacteristics_new(characteristic characteristic: MedicationknowledgeAdministrationguidelinesPatientcharacteristicsCharacteristic,) ->MedicationknowledgeAdministrationguidelinesPatientcharacteristics{MedicationknowledgeAdministrationguidelinesPatientcharacteristics(value: [],characteristic:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMedicineclassification
{
MedicationknowledgeMedicineclassification(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
classification: List(Codeableconcept),
)
}

pub fn medicationknowledge_medicineclassification_new(type_ type_: Codeableconcept,) ->MedicationknowledgeMedicineclassification{MedicationknowledgeMedicineclassification(classification: [],type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgePackaging
{
MedicationknowledgePackaging(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
quantity: Option(Quantity),
)
}

pub fn medicationknowledge_packaging_new() ->MedicationknowledgePackaging{MedicationknowledgePackaging(quantity: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDrugcharacteristic
{
MedicationknowledgeDrugcharacteristic(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
value: Option(MedicationknowledgeDrugcharacteristicValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDrugcharacteristicValue{
MedicationknowledgeDrugcharacteristicValueCodeableconcept(value: Codeableconcept)
MedicationknowledgeDrugcharacteristicValueString(value: String)
MedicationknowledgeDrugcharacteristicValueQuantity(value: Quantity)
MedicationknowledgeDrugcharacteristicValueBase64binary(value: String)}
pub fn medicationknowledge_drugcharacteristic_value_to_json(elt: MedicationknowledgeDrugcharacteristicValue) -> Json {case elt{MedicationknowledgeDrugcharacteristicValueCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationknowledgeDrugcharacteristicValueString(v) -> json.string(v)
MedicationknowledgeDrugcharacteristicValueQuantity(v) -> quantity_to_json(v)
MedicationknowledgeDrugcharacteristicValueBase64binary(v) -> json.string(v)
}}
pub fn medicationknowledge_drugcharacteristic_value_decoder() -> Decoder(MedicationknowledgeDrugcharacteristicValue){decode.one_of(decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationknowledgeDrugcharacteristicValueCodeableconcept),[decode.field("valueString", decode.string, decode.success) |> decode.map(MedicationknowledgeDrugcharacteristicValueString),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(MedicationknowledgeDrugcharacteristicValueQuantity),decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(MedicationknowledgeDrugcharacteristicValueBase64binary),])}
pub fn medicationknowledge_drugcharacteristic_new() ->MedicationknowledgeDrugcharacteristic{MedicationknowledgeDrugcharacteristic(value: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatory
{
MedicationknowledgeRegulatory(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
regulatory_authority: Reference,
substitution: List(MedicationknowledgeRegulatorySubstitution),
schedule: List(MedicationknowledgeRegulatorySchedule),
max_dispense: Option(MedicationknowledgeRegulatoryMaxdispense),
)
}

pub fn medicationknowledge_regulatory_new(regulatory_authority regulatory_authority: Reference,) ->MedicationknowledgeRegulatory{MedicationknowledgeRegulatory(max_dispense: None,schedule: [],substitution: [],regulatory_authority:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatorySubstitution
{
MedicationknowledgeRegulatorySubstitution(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
allowed: Bool,
)
}

pub fn medicationknowledge_regulatory_substitution_new(allowed allowed: Bool,type_ type_: Codeableconcept,) ->MedicationknowledgeRegulatorySubstitution{MedicationknowledgeRegulatorySubstitution(allowed:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatorySchedule
{
MedicationknowledgeRegulatorySchedule(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
schedule: Codeableconcept,
)
}

pub fn medicationknowledge_regulatory_schedule_new(schedule schedule: Codeableconcept,) ->MedicationknowledgeRegulatorySchedule{MedicationknowledgeRegulatorySchedule(schedule:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatoryMaxdispense
{
MedicationknowledgeRegulatoryMaxdispense(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
quantity: Quantity,
period: Option(Duration),
)
}

pub fn medicationknowledge_regulatory_maxdispense_new(quantity quantity: Quantity,) ->MedicationknowledgeRegulatoryMaxdispense{MedicationknowledgeRegulatoryMaxdispense(period: None,quantity:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeKinetics
{
MedicationknowledgeKinetics(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
area_under_curve: List(Quantity),
lethal_dose50: List(Quantity),
half_life_period: Option(Duration),
)
}

pub fn medicationknowledge_kinetics_new() ->MedicationknowledgeKinetics{MedicationknowledgeKinetics(half_life_period: None,lethal_dose50: [],area_under_curve: [],modifier_extension: [],extension: [],id: None,)
}

pub fn medicationknowledge_kinetics_to_json(medicationknowledge_kinetics: MedicationknowledgeKinetics) -> Json {
    let MedicationknowledgeKinetics(half_life_period:,lethal_dose50:,area_under_curve:,modifier_extension:,extension:,id:,) = medicationknowledge_kinetics
    let fields = []
let fields = case half_life_period {
                          Some(v) -> [#("halfLifePeriod", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case lethal_dose50 {
                        [] -> fields
                        _ -> [#("lethalDose50", json.array(lethal_dose50,quantity_to_json)), ..fields]
                          }
let fields = case area_under_curve {
                        [] -> fields
                        _ -> [#("areaUnderCurve", json.array(area_under_curve,quantity_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_kinetics_decoder() -> Decoder(MedicationknowledgeKinetics) {use half_life_period <- decode.optional_field("halfLifePeriod", None, decode.optional(duration_decoder()))
use lethal_dose50 <- decode.optional_field("lethalDose50", [], decode.list(quantity_decoder()))
use area_under_curve <- decode.optional_field("areaUnderCurve", [], decode.list(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeKinetics(half_life_period:,lethal_dose50:,area_under_curve:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_regulatory_maxdispense_to_json(medicationknowledge_regulatory_maxdispense: MedicationknowledgeRegulatoryMaxdispense) -> Json {
    let MedicationknowledgeRegulatoryMaxdispense(period:,quantity:,modifier_extension:,extension:,id:,) = medicationknowledge_regulatory_maxdispense
    let fields = [#("quantity", quantity_to_json(quantity)),]
let fields = case period {
                          Some(v) -> [#("period", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_regulatory_maxdispense_decoder() -> Decoder(MedicationknowledgeRegulatoryMaxdispense) {use period <- decode.optional_field("period", None, decode.optional(duration_decoder()))
use quantity <- decode.field("quantity",quantity_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeRegulatoryMaxdispense(period:,quantity:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_regulatory_schedule_to_json(medicationknowledge_regulatory_schedule: MedicationknowledgeRegulatorySchedule) -> Json {
    let MedicationknowledgeRegulatorySchedule(schedule:,modifier_extension:,extension:,id:,) = medicationknowledge_regulatory_schedule
    let fields = [#("schedule", codeableconcept_to_json(schedule)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_regulatory_schedule_decoder() -> Decoder(MedicationknowledgeRegulatorySchedule) {use schedule <- decode.field("schedule",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeRegulatorySchedule(schedule:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_regulatory_substitution_to_json(medicationknowledge_regulatory_substitution: MedicationknowledgeRegulatorySubstitution) -> Json {
    let MedicationknowledgeRegulatorySubstitution(allowed:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_regulatory_substitution
    let fields = [#("allowed", json.bool(allowed)),#("type", codeableconcept_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_regulatory_substitution_decoder() -> Decoder(MedicationknowledgeRegulatorySubstitution) {use allowed <- decode.field("allowed",decode.bool)
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeRegulatorySubstitution(allowed:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_regulatory_to_json(medicationknowledge_regulatory: MedicationknowledgeRegulatory) -> Json {
    let MedicationknowledgeRegulatory(max_dispense:,schedule:,substitution:,regulatory_authority:,modifier_extension:,extension:,id:,) = medicationknowledge_regulatory
    let fields = [#("regulatoryAuthority", reference_to_json(regulatory_authority)),]
let fields = case max_dispense {
                          Some(v) -> [#("maxDispense", medicationknowledge_regulatory_maxdispense_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case schedule {
                        [] -> fields
                        _ -> [#("schedule", json.array(schedule,medicationknowledge_regulatory_schedule_to_json)), ..fields]
                          }
let fields = case substitution {
                        [] -> fields
                        _ -> [#("substitution", json.array(substitution,medicationknowledge_regulatory_substitution_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_regulatory_decoder() -> Decoder(MedicationknowledgeRegulatory) {use max_dispense <- decode.optional_field("maxDispense", None, decode.optional(medicationknowledge_regulatory_maxdispense_decoder()))
use schedule <- decode.optional_field("schedule", [], decode.list(medicationknowledge_regulatory_schedule_decoder()))
use substitution <- decode.optional_field("substitution", [], decode.list(medicationknowledge_regulatory_substitution_decoder()))
use regulatory_authority <- decode.field("regulatoryAuthority",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeRegulatory(max_dispense:,schedule:,substitution:,regulatory_authority:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_drugcharacteristic_to_json(medicationknowledge_drugcharacteristic: MedicationknowledgeDrugcharacteristic) -> Json {
    let MedicationknowledgeDrugcharacteristic(value:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_drugcharacteristic
    let fields = []
let fields = case value {
                          Some(v) -> [#("value", medicationknowledge_drugcharacteristic_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_drugcharacteristic_decoder() -> Decoder(MedicationknowledgeDrugcharacteristic) {use value <- decode.then(none_if_omitted(medicationknowledge_drugcharacteristic_value_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeDrugcharacteristic(value:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_packaging_to_json(medicationknowledge_packaging: MedicationknowledgePackaging) -> Json {
    let MedicationknowledgePackaging(quantity:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_packaging
    let fields = []
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_packaging_decoder() -> Decoder(MedicationknowledgePackaging) {use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgePackaging(quantity:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_medicineclassification_to_json(medicationknowledge_medicineclassification: MedicationknowledgeMedicineclassification) -> Json {
    let MedicationknowledgeMedicineclassification(classification:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_medicineclassification
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case classification {
                        [] -> fields
                        _ -> [#("classification", json.array(classification,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_medicineclassification_decoder() -> Decoder(MedicationknowledgeMedicineclassification) {use classification <- decode.optional_field("classification", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeMedicineclassification(classification:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_administrationguidelines_patientcharacteristics_to_json(medicationknowledge_administrationguidelines_patientcharacteristics: MedicationknowledgeAdministrationguidelinesPatientcharacteristics) -> Json {
    let MedicationknowledgeAdministrationguidelinesPatientcharacteristics(value:,characteristic:,modifier_extension:,extension:,id:,) = medicationknowledge_administrationguidelines_patientcharacteristics
    let fields = [#("characteristic", medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_to_json(characteristic)),]
let fields = case value {
                        [] -> fields
                        _ -> [#("value", json.array(value,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_administrationguidelines_patientcharacteristics_decoder() -> Decoder(MedicationknowledgeAdministrationguidelinesPatientcharacteristics) {use value <- decode.optional_field("value", [], decode.list(decode.string))
use characteristic <- decode.then(medicationknowledge_administrationguidelines_patientcharacteristics_characteristic_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeAdministrationguidelinesPatientcharacteristics(value:,characteristic:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_administrationguidelines_dosage_to_json(medicationknowledge_administrationguidelines_dosage: MedicationknowledgeAdministrationguidelinesDosage) -> Json {
    let MedicationknowledgeAdministrationguidelinesDosage(dosage:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_administrationguidelines_dosage
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case dosage {
                        [] -> fields
                        _ -> [#("dosage", json.array(dosage,dosage_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_administrationguidelines_dosage_decoder() -> Decoder(MedicationknowledgeAdministrationguidelinesDosage) {use dosage <- decode.optional_field("dosage", [], decode.list(dosage_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeAdministrationguidelinesDosage(dosage:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_administrationguidelines_to_json(medicationknowledge_administrationguidelines: MedicationknowledgeAdministrationguidelines) -> Json {
    let MedicationknowledgeAdministrationguidelines(patient_characteristics:,indication:,dosage:,modifier_extension:,extension:,id:,) = medicationknowledge_administrationguidelines
    let fields = []
let fields = case patient_characteristics {
                        [] -> fields
                        _ -> [#("patientCharacteristics", json.array(patient_characteristics,medicationknowledge_administrationguidelines_patientcharacteristics_to_json)), ..fields]
                          }
let fields = case indication {
                          Some(v) -> [#("indication", medicationknowledge_administrationguidelines_indication_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dosage {
                        [] -> fields
                        _ -> [#("dosage", json.array(dosage,medicationknowledge_administrationguidelines_dosage_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_administrationguidelines_decoder() -> Decoder(MedicationknowledgeAdministrationguidelines) {use patient_characteristics <- decode.optional_field("patientCharacteristics", [], decode.list(medicationknowledge_administrationguidelines_patientcharacteristics_decoder()))
use indication <- decode.then(none_if_omitted(medicationknowledge_administrationguidelines_indication_decoder()))
use dosage <- decode.optional_field("dosage", [], decode.list(medicationknowledge_administrationguidelines_dosage_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeAdministrationguidelines(patient_characteristics:,indication:,dosage:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_monitoringprogram_to_json(medicationknowledge_monitoringprogram: MedicationknowledgeMonitoringprogram) -> Json {
    let MedicationknowledgeMonitoringprogram(name:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_monitoringprogram
    let fields = []
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_monitoringprogram_decoder() -> Decoder(MedicationknowledgeMonitoringprogram) {use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeMonitoringprogram(name:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_cost_to_json(medicationknowledge_cost: MedicationknowledgeCost) -> Json {
    let MedicationknowledgeCost(cost:,source:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_cost
    let fields = [#("cost", money_to_json(cost)),#("type", codeableconcept_to_json(type_)),]
let fields = case source {
                          Some(v) -> [#("source", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_cost_decoder() -> Decoder(MedicationknowledgeCost) {use cost <- decode.field("cost",money_decoder())
use source <- decode.optional_field("source", None, decode.optional(decode.string))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeCost(cost:,source:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_ingredient_to_json(medicationknowledge_ingredient: MedicationknowledgeIngredient) -> Json {
    let MedicationknowledgeIngredient(strength:,is_active:,item:,modifier_extension:,extension:,id:,) = medicationknowledge_ingredient
    let fields = [#("item", medicationknowledge_ingredient_item_to_json(item)),]
let fields = case strength {
                          Some(v) -> [#("strength", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_active {
                          Some(v) -> [#("isActive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_ingredient_decoder() -> Decoder(MedicationknowledgeIngredient) {use strength <- decode.optional_field("strength", None, decode.optional(ratio_decoder()))
use is_active <- decode.optional_field("isActive", None, decode.optional(decode.bool))
use item <- decode.then(medicationknowledge_ingredient_item_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeIngredient(strength:,is_active:,item:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_monograph_to_json(medicationknowledge_monograph: MedicationknowledgeMonograph) -> Json {
    let MedicationknowledgeMonograph(source:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_monograph
    let fields = []
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_monograph_decoder() -> Decoder(MedicationknowledgeMonograph) {use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeMonograph(source:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_relatedmedicationknowledge_to_json(medicationknowledge_relatedmedicationknowledge: MedicationknowledgeRelatedmedicationknowledge) -> Json {
    let MedicationknowledgeRelatedmedicationknowledge(reference:,type_:,modifier_extension:,extension:,id:,) = medicationknowledge_relatedmedicationknowledge
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case reference {
                        [] -> fields
                        _ -> [#("reference", json.array(reference,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_relatedmedicationknowledge_decoder() -> Decoder(MedicationknowledgeRelatedmedicationknowledge) {use reference <- decode.optional_field("reference", [], decode.list(reference_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationknowledgeRelatedmedicationknowledge(reference:,type_:,modifier_extension:,extension:,id:,))}
pub fn medicationknowledge_to_json(medicationknowledge: Medicationknowledge) -> Json {
    let Medicationknowledge(kinetics:,regulatory:,contraindication:,drug_characteristic:,packaging:,medicine_classification:,administration_guidelines:,monitoring_program:,cost:,intended_route:,preparation_instruction:,ingredient:,monograph:,product_type:,associated_medication:,related_medication_knowledge:,synonym:,amount:,dose_form:,manufacturer:,status:,code:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicationknowledge
    let fields = []
let fields = case kinetics {
                        [] -> fields
                        _ -> [#("kinetics", json.array(kinetics,medicationknowledge_kinetics_to_json)), ..fields]
                          }
let fields = case regulatory {
                        [] -> fields
                        _ -> [#("regulatory", json.array(regulatory,medicationknowledge_regulatory_to_json)), ..fields]
                          }
let fields = case contraindication {
                        [] -> fields
                        _ -> [#("contraindication", json.array(contraindication,reference_to_json)), ..fields]
                          }
let fields = case drug_characteristic {
                        [] -> fields
                        _ -> [#("drugCharacteristic", json.array(drug_characteristic,medicationknowledge_drugcharacteristic_to_json)), ..fields]
                          }
let fields = case packaging {
                          Some(v) -> [#("packaging", medicationknowledge_packaging_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case medicine_classification {
                        [] -> fields
                        _ -> [#("medicineClassification", json.array(medicine_classification,medicationknowledge_medicineclassification_to_json)), ..fields]
                          }
let fields = case administration_guidelines {
                        [] -> fields
                        _ -> [#("administrationGuidelines", json.array(administration_guidelines,medicationknowledge_administrationguidelines_to_json)), ..fields]
                          }
let fields = case monitoring_program {
                        [] -> fields
                        _ -> [#("monitoringProgram", json.array(monitoring_program,medicationknowledge_monitoringprogram_to_json)), ..fields]
                          }
let fields = case cost {
                        [] -> fields
                        _ -> [#("cost", json.array(cost,medicationknowledge_cost_to_json)), ..fields]
                          }
let fields = case intended_route {
                        [] -> fields
                        _ -> [#("intendedRoute", json.array(intended_route,codeableconcept_to_json)), ..fields]
                          }
let fields = case preparation_instruction {
                          Some(v) -> [#("preparationInstruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case ingredient {
                        [] -> fields
                        _ -> [#("ingredient", json.array(ingredient,medicationknowledge_ingredient_to_json)), ..fields]
                          }
let fields = case monograph {
                        [] -> fields
                        _ -> [#("monograph", json.array(monograph,medicationknowledge_monograph_to_json)), ..fields]
                          }
let fields = case product_type {
                        [] -> fields
                        _ -> [#("productType", json.array(product_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case associated_medication {
                        [] -> fields
                        _ -> [#("associatedMedication", json.array(associated_medication,reference_to_json)), ..fields]
                          }
let fields = case related_medication_knowledge {
                        [] -> fields
                        _ -> [#("relatedMedicationKnowledge", json.array(related_medication_knowledge,medicationknowledge_relatedmedicationknowledge_to_json)), ..fields]
                          }
let fields = case synonym {
                        [] -> fields
                        _ -> [#("synonym", json.array(synonym,json.string)), ..fields]
                          }
let fields = case amount {
                          Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dose_form {
                          Some(v) -> [#("doseForm", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacturer {
                          Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.medicationknowledgestatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationknowledge_decoder() -> Decoder(Medicationknowledge) {use kinetics <- decode.optional_field("kinetics", [], decode.list(medicationknowledge_kinetics_decoder()))
use regulatory <- decode.optional_field("regulatory", [], decode.list(medicationknowledge_regulatory_decoder()))
use contraindication <- decode.optional_field("contraindication", [], decode.list(reference_decoder()))
use drug_characteristic <- decode.optional_field("drugCharacteristic", [], decode.list(medicationknowledge_drugcharacteristic_decoder()))
use packaging <- decode.optional_field("packaging", None, decode.optional(medicationknowledge_packaging_decoder()))
use medicine_classification <- decode.optional_field("medicineClassification", [], decode.list(medicationknowledge_medicineclassification_decoder()))
use administration_guidelines <- decode.optional_field("administrationGuidelines", [], decode.list(medicationknowledge_administrationguidelines_decoder()))
use monitoring_program <- decode.optional_field("monitoringProgram", [], decode.list(medicationknowledge_monitoringprogram_decoder()))
use cost <- decode.optional_field("cost", [], decode.list(medicationknowledge_cost_decoder()))
use intended_route <- decode.optional_field("intendedRoute", [], decode.list(codeableconcept_decoder()))
use preparation_instruction <- decode.optional_field("preparationInstruction", None, decode.optional(decode.string))
use ingredient <- decode.optional_field("ingredient", [], decode.list(medicationknowledge_ingredient_decoder()))
use monograph <- decode.optional_field("monograph", [], decode.list(medicationknowledge_monograph_decoder()))
use product_type <- decode.optional_field("productType", [], decode.list(codeableconcept_decoder()))
use associated_medication <- decode.optional_field("associatedMedication", [], decode.list(reference_decoder()))
use related_medication_knowledge <- decode.optional_field("relatedMedicationKnowledge", [], decode.list(medicationknowledge_relatedmedicationknowledge_decoder()))
use synonym <- decode.optional_field("synonym", [], decode.list(decode.string))
use amount <- decode.optional_field("amount", None, decode.optional(quantity_decoder()))
use dose_form <- decode.optional_field("doseForm", None, decode.optional(codeableconcept_decoder()))
use manufacturer <- decode.optional_field("manufacturer", None, decode.optional(reference_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.medicationknowledgestatus_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicationknowledge(kinetics:,regulatory:,contraindication:,drug_characteristic:,packaging:,medicine_classification:,administration_guidelines:,monitoring_program:,cost:,intended_route:,preparation_instruction:,ingredient:,monograph:,product_type:,associated_medication:,related_medication_knowledge:,synonym:,amount:,dose_form:,manufacturer:,status:,code:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type Medicationrequest
{
Medicationrequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Medicationrequeststatus,
status_reason: Option(Codeableconcept),
intent: r4valuesets.Medicationrequestintent,
category: List(Codeableconcept),
priority: Option(r4valuesets.Requestpriority),
do_not_perform: Option(Bool),
reported: Option(MedicationrequestReported),
medication: MedicationrequestMedication,
subject: Reference,
encounter: Option(Reference),
supporting_information: List(Reference),
authored_on: Option(String),
requester: Option(Reference),
performer: Option(Reference),
performer_type: Option(Codeableconcept),
recorder: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
group_identifier: Option(Identifier),
course_of_therapy_type: Option(Codeableconcept),
insurance: List(Reference),
note: List(Annotation),
dosage_instruction: List(Dosage),
dispense_request: Option(MedicationrequestDispenserequest),
substitution: Option(MedicationrequestSubstitution),
prior_prescription: Option(Reference),
detected_issue: List(Reference),
event_history: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestReported{
MedicationrequestReportedBoolean(reported: Bool)
MedicationrequestReportedReference(reported: Reference)}
pub fn medicationrequest_reported_to_json(elt: MedicationrequestReported) -> Json {case elt{MedicationrequestReportedBoolean(v) -> json.bool(v)
MedicationrequestReportedReference(v) -> reference_to_json(v)
}}
pub fn medicationrequest_reported_decoder() -> Decoder(MedicationrequestReported){decode.one_of(decode.field("reportedBoolean", decode.bool, decode.success) |> decode.map(MedicationrequestReportedBoolean),[decode.field("reportedReference", reference_decoder(), decode.success) |> decode.map(MedicationrequestReportedReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestMedication{
MedicationrequestMedicationCodeableconcept(medication: Codeableconcept)
MedicationrequestMedicationReference(medication: Reference)}
pub fn medicationrequest_medication_to_json(elt: MedicationrequestMedication) -> Json {case elt{MedicationrequestMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationrequestMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicationrequest_medication_decoder() -> Decoder(MedicationrequestMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationrequestMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicationrequestMedicationReference),])}
pub fn medicationrequest_new(subject subject: Reference,medication medication: MedicationrequestMedication,intent intent: r4valuesets.Medicationrequestintent,status status: r4valuesets.Medicationrequeststatus,) ->Medicationrequest{Medicationrequest(event_history: [],detected_issue: [],prior_prescription: None,substitution: None,dispense_request: None,dosage_instruction: [],note: [],insurance: [],course_of_therapy_type: None,group_identifier: None,based_on: [],instantiates_uri: [],instantiates_canonical: [],reason_reference: [],reason_code: [],recorder: None,performer_type: None,performer: None,requester: None,authored_on: None,supporting_information: [],encounter: None,subject:,medication:,reported: None,do_not_perform: None,priority: None,category: [],intent:,status_reason: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequest
{
MedicationrequestDispenserequest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
initial_fill: Option(MedicationrequestDispenserequestInitialfill),
dispense_interval: Option(Duration),
validity_period: Option(Period),
number_of_repeats_allowed: Option(Int),
quantity: Option(Quantity),
expected_supply_duration: Option(Duration),
performer: Option(Reference),
)
}

pub fn medicationrequest_dispenserequest_new() ->MedicationrequestDispenserequest{MedicationrequestDispenserequest(performer: None,expected_supply_duration: None,quantity: None,number_of_repeats_allowed: None,validity_period: None,dispense_interval: None,initial_fill: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequestInitialfill
{
MedicationrequestDispenserequestInitialfill(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
quantity: Option(Quantity),
duration: Option(Duration),
)
}

pub fn medicationrequest_dispenserequest_initialfill_new() ->MedicationrequestDispenserequestInitialfill{MedicationrequestDispenserequestInitialfill(duration: None,quantity: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitution
{
MedicationrequestSubstitution(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
allowed: MedicationrequestSubstitutionAllowed,
reason: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitutionAllowed{
MedicationrequestSubstitutionAllowedBoolean(allowed: Bool)
MedicationrequestSubstitutionAllowedCodeableconcept(allowed: Codeableconcept)}
pub fn medicationrequest_substitution_allowed_to_json(elt: MedicationrequestSubstitutionAllowed) -> Json {case elt{MedicationrequestSubstitutionAllowedBoolean(v) -> json.bool(v)
MedicationrequestSubstitutionAllowedCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn medicationrequest_substitution_allowed_decoder() -> Decoder(MedicationrequestSubstitutionAllowed){decode.one_of(decode.field("allowedBoolean", decode.bool, decode.success) |> decode.map(MedicationrequestSubstitutionAllowedBoolean),[decode.field("allowedCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationrequestSubstitutionAllowedCodeableconcept),])}
pub fn medicationrequest_substitution_new(allowed allowed: MedicationrequestSubstitutionAllowed,) ->MedicationrequestSubstitution{MedicationrequestSubstitution(reason: None,allowed:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicationrequest_substitution_to_json(medicationrequest_substitution: MedicationrequestSubstitution) -> Json {
    let MedicationrequestSubstitution(reason:,allowed:,modifier_extension:,extension:,id:,) = medicationrequest_substitution
    let fields = [#("allowed", medicationrequest_substitution_allowed_to_json(allowed)),]
let fields = case reason {
                          Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationrequest_substitution_decoder() -> Decoder(MedicationrequestSubstitution) {use reason <- decode.optional_field("reason", None, decode.optional(codeableconcept_decoder()))
use allowed <- decode.then(medicationrequest_substitution_allowed_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationrequestSubstitution(reason:,allowed:,modifier_extension:,extension:,id:,))}
pub fn medicationrequest_dispenserequest_initialfill_to_json(medicationrequest_dispenserequest_initialfill: MedicationrequestDispenserequestInitialfill) -> Json {
    let MedicationrequestDispenserequestInitialfill(duration:,quantity:,modifier_extension:,extension:,id:,) = medicationrequest_dispenserequest_initialfill
    let fields = []
let fields = case duration {
                          Some(v) -> [#("duration", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationrequest_dispenserequest_initialfill_decoder() -> Decoder(MedicationrequestDispenserequestInitialfill) {use duration <- decode.optional_field("duration", None, decode.optional(duration_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationrequestDispenserequestInitialfill(duration:,quantity:,modifier_extension:,extension:,id:,))}
pub fn medicationrequest_dispenserequest_to_json(medicationrequest_dispenserequest: MedicationrequestDispenserequest) -> Json {
    let MedicationrequestDispenserequest(performer:,expected_supply_duration:,quantity:,number_of_repeats_allowed:,validity_period:,dispense_interval:,initial_fill:,modifier_extension:,extension:,id:,) = medicationrequest_dispenserequest
    let fields = []
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case expected_supply_duration {
                          Some(v) -> [#("expectedSupplyDuration", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_repeats_allowed {
                          Some(v) -> [#("numberOfRepeatsAllowed", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case validity_period {
                          Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dispense_interval {
                          Some(v) -> [#("dispenseInterval", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case initial_fill {
                          Some(v) -> [#("initialFill", medicationrequest_dispenserequest_initialfill_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationrequest_dispenserequest_decoder() -> Decoder(MedicationrequestDispenserequest) {use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use expected_supply_duration <- decode.optional_field("expectedSupplyDuration", None, decode.optional(duration_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use number_of_repeats_allowed <- decode.optional_field("numberOfRepeatsAllowed", None, decode.optional(decode.int))
use validity_period <- decode.optional_field("validityPeriod", None, decode.optional(period_decoder()))
use dispense_interval <- decode.optional_field("dispenseInterval", None, decode.optional(duration_decoder()))
use initial_fill <- decode.optional_field("initialFill", None, decode.optional(medicationrequest_dispenserequest_initialfill_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicationrequestDispenserequest(performer:,expected_supply_duration:,quantity:,number_of_repeats_allowed:,validity_period:,dispense_interval:,initial_fill:,modifier_extension:,extension:,id:,))}
pub fn medicationrequest_to_json(medicationrequest: Medicationrequest) -> Json {
    let Medicationrequest(event_history:,detected_issue:,prior_prescription:,substitution:,dispense_request:,dosage_instruction:,note:,insurance:,course_of_therapy_type:,group_identifier:,based_on:,instantiates_uri:,instantiates_canonical:,reason_reference:,reason_code:,recorder:,performer_type:,performer:,requester:,authored_on:,supporting_information:,encounter:,subject:,medication:,reported:,do_not_perform:,priority:,category:,intent:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicationrequest
    let fields = [#("subject", reference_to_json(subject)),#("medication", medicationrequest_medication_to_json(medication)),#("intent", r4valuesets.medicationrequestintent_to_json(intent)),#("status", r4valuesets.medicationrequeststatus_to_json(status)),]
let fields = case event_history {
                        [] -> fields
                        _ -> [#("eventHistory", json.array(event_history,reference_to_json)), ..fields]
                          }
let fields = case detected_issue {
                        [] -> fields
                        _ -> [#("detectedIssue", json.array(detected_issue,reference_to_json)), ..fields]
                          }
let fields = case prior_prescription {
                          Some(v) -> [#("priorPrescription", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case substitution {
                          Some(v) -> [#("substitution", medicationrequest_substitution_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dispense_request {
                          Some(v) -> [#("dispenseRequest", medicationrequest_dispenserequest_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case dosage_instruction {
                        [] -> fields
                        _ -> [#("dosageInstruction", json.array(dosage_instruction,dosage_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,reference_to_json)), ..fields]
                          }
let fields = case course_of_therapy_type {
                          Some(v) -> [#("courseOfTherapyType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case group_identifier {
                          Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case recorder {
                          Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer_type {
                          Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case supporting_information {
                        [] -> fields
                        _ -> [#("supportingInformation", json.array(supporting_information,reference_to_json)), ..fields]
                          }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reported {
                          Some(v) -> [#("reported", medicationrequest_reported_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationrequest_decoder() -> Decoder(Medicationrequest) {use event_history <- decode.optional_field("eventHistory", [], decode.list(reference_decoder()))
use detected_issue <- decode.optional_field("detectedIssue", [], decode.list(reference_decoder()))
use prior_prescription <- decode.optional_field("priorPrescription", None, decode.optional(reference_decoder()))
use substitution <- decode.optional_field("substitution", None, decode.optional(medicationrequest_substitution_decoder()))
use dispense_request <- decode.optional_field("dispenseRequest", None, decode.optional(medicationrequest_dispenserequest_decoder()))
use dosage_instruction <- decode.optional_field("dosageInstruction", [], decode.list(dosage_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(reference_decoder()))
use course_of_therapy_type <- decode.optional_field("courseOfTherapyType", None, decode.optional(codeableconcept_decoder()))
use group_identifier <- decode.optional_field("groupIdentifier", None, decode.optional(identifier_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use recorder <- decode.optional_field("recorder", None, decode.optional(reference_decoder()))
use performer_type <- decode.optional_field("performerType", None, decode.optional(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use supporting_information <- decode.optional_field("supportingInformation", [], decode.list(reference_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use medication <- decode.then(medicationrequest_medication_decoder())
use reported <- decode.then(none_if_omitted(medicationrequest_reported_decoder()))
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use intent <- decode.field("intent",r4valuesets.medicationrequestintent_decoder())
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.medicationrequeststatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicationrequest(event_history:,detected_issue:,prior_prescription:,substitution:,dispense_request:,dosage_instruction:,note:,insurance:,course_of_therapy_type:,group_identifier:,based_on:,instantiates_uri:,instantiates_canonical:,reason_reference:,reason_code:,recorder:,performer_type:,performer:,requester:,authored_on:,supporting_information:,encounter:,subject:,medication:,reported:,do_not_perform:,priority:,category:,intent:,status_reason:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicationStatement#resource
pub type Medicationstatement
{
Medicationstatement(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
part_of: List(Reference),
status: r4valuesets.Medicationstatementstatus,
status_reason: List(Codeableconcept),
category: Option(Codeableconcept),
medication: MedicationstatementMedication,
subject: Reference,
context: Option(Reference),
effective: Option(MedicationstatementEffective),
date_asserted: Option(String),
information_source: Option(Reference),
derived_from: List(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
dosage: List(Dosage),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementMedication{
MedicationstatementMedicationCodeableconcept(medication: Codeableconcept)
MedicationstatementMedicationReference(medication: Reference)}
pub fn medicationstatement_medication_to_json(elt: MedicationstatementMedication) -> Json {case elt{MedicationstatementMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicationstatementMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicationstatement_medication_decoder() -> Decoder(MedicationstatementMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicationstatementMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicationstatementMedicationReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementEffective{
MedicationstatementEffectiveDatetime(effective: String)
MedicationstatementEffectivePeriod(effective: Period)}
pub fn medicationstatement_effective_to_json(elt: MedicationstatementEffective) -> Json {case elt{MedicationstatementEffectiveDatetime(v) -> json.string(v)
MedicationstatementEffectivePeriod(v) -> period_to_json(v)
}}
pub fn medicationstatement_effective_decoder() -> Decoder(MedicationstatementEffective){decode.one_of(decode.field("effectiveDateTime", decode.string, decode.success) |> decode.map(MedicationstatementEffectiveDatetime),[decode.field("effectivePeriod", period_decoder(), decode.success) |> decode.map(MedicationstatementEffectivePeriod),])}
pub fn medicationstatement_new(subject subject: Reference,medication medication: MedicationstatementMedication,status status: r4valuesets.Medicationstatementstatus,) ->Medicationstatement{Medicationstatement(dosage: [],note: [],reason_reference: [],reason_code: [],derived_from: [],information_source: None,date_asserted: None,effective: None,context: None,subject:,medication:,category: None,status_reason: [],status:,part_of: [],based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn medicationstatement_to_json(medicationstatement: Medicationstatement) -> Json {
    let Medicationstatement(dosage:,note:,reason_reference:,reason_code:,derived_from:,information_source:,date_asserted:,effective:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicationstatement
    let fields = [#("subject", reference_to_json(subject)),#("medication", medicationstatement_medication_to_json(medication)),#("status", r4valuesets.medicationstatementstatus_to_json(status)),]
let fields = case dosage {
                        [] -> fields
                        _ -> [#("dosage", json.array(dosage,dosage_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case derived_from {
                        [] -> fields
                        _ -> [#("derivedFrom", json.array(derived_from,reference_to_json)), ..fields]
                          }
let fields = case information_source {
                          Some(v) -> [#("informationSource", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date_asserted {
                          Some(v) -> [#("dateAsserted", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case effective {
                          Some(v) -> [#("effective", medicationstatement_effective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case context {
                          Some(v) -> [#("context", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                        [] -> fields
                        _ -> [#("statusReason", json.array(status_reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicationstatement_decoder() -> Decoder(Medicationstatement) {use dosage <- decode.optional_field("dosage", [], decode.list(dosage_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use derived_from <- decode.optional_field("derivedFrom", [], decode.list(reference_decoder()))
use information_source <- decode.optional_field("informationSource", None, decode.optional(reference_decoder()))
use date_asserted <- decode.optional_field("dateAsserted", None, decode.optional(decode.string))
use effective <- decode.then(none_if_omitted(medicationstatement_effective_decoder()))
use context <- decode.optional_field("context", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use medication <- decode.then(medicationstatement_medication_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", [], decode.list(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.medicationstatementstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicationstatement(dosage:,note:,reason_reference:,reason_code:,derived_from:,information_source:,date_asserted:,effective:,context:,subject:,medication:,category:,status_reason:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type Medicinalproduct
{
Medicinalproduct(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Option(Codeableconcept),
domain: Option(Coding),
combined_pharmaceutical_dose_form: Option(Codeableconcept),
legal_status_of_supply: Option(Codeableconcept),
additional_monitoring_indicator: Option(Codeableconcept),
special_measures: List(String),
paediatric_use_indicator: Option(Codeableconcept),
product_classification: List(Codeableconcept),
marketing_status: List(Marketingstatus),
pharmaceutical_product: List(Reference),
packaged_medicinal_product: List(Reference),
attached_document: List(Reference),
master_file: List(Reference),
contact: List(Reference),
clinical_trial: List(Reference),
name: List(MedicinalproductName),
cross_reference: List(Identifier),
manufacturing_business_operation: List(MedicinalproductManufacturingbusinessoperation),
special_designation: List(MedicinalproductSpecialdesignation),
)
}

pub fn medicinalproduct_new() ->Medicinalproduct{Medicinalproduct(special_designation: [],manufacturing_business_operation: [],cross_reference: [],name: [],clinical_trial: [],contact: [],master_file: [],attached_document: [],packaged_medicinal_product: [],pharmaceutical_product: [],marketing_status: [],product_classification: [],paediatric_use_indicator: None,special_measures: [],additional_monitoring_indicator: None,legal_status_of_supply: None,combined_pharmaceutical_dose_form: None,domain: None,type_: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductName
{
MedicinalproductName(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product_name: String,
name_part: List(MedicinalproductNameNamepart),
country_language: List(MedicinalproductNameCountrylanguage),
)
}

pub fn medicinalproduct_name_new(product_name product_name: String,) ->MedicinalproductName{MedicinalproductName(country_language: [],name_part: [],product_name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductNameNamepart
{
MedicinalproductNameNamepart(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
part: String,
type_: Coding,
)
}

pub fn medicinalproduct_name_namepart_new(type_ type_: Coding,part part: String,) ->MedicinalproductNameNamepart{MedicinalproductNameNamepart(type_:,part:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductNameCountrylanguage
{
MedicinalproductNameCountrylanguage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
country: Codeableconcept,
jurisdiction: Option(Codeableconcept),
language: Codeableconcept,
)
}

pub fn medicinalproduct_name_countrylanguage_new(language language: Codeableconcept,country country: Codeableconcept,) ->MedicinalproductNameCountrylanguage{MedicinalproductNameCountrylanguage(language:,jurisdiction: None,country:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductManufacturingbusinessoperation
{
MedicinalproductManufacturingbusinessoperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
operation_type: Option(Codeableconcept),
authorisation_reference_number: Option(Identifier),
effective_date: Option(String),
confidentiality_indicator: Option(Codeableconcept),
manufacturer: List(Reference),
regulator: Option(Reference),
)
}

pub fn medicinalproduct_manufacturingbusinessoperation_new() ->MedicinalproductManufacturingbusinessoperation{MedicinalproductManufacturingbusinessoperation(regulator: None,manufacturer: [],confidentiality_indicator: None,effective_date: None,authorisation_reference_number: None,operation_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductSpecialdesignation
{
MedicinalproductSpecialdesignation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Option(Codeableconcept),
intended_use: Option(Codeableconcept),
indication: Option(MedicinalproductSpecialdesignationIndication),
status: Option(Codeableconcept),
date: Option(String),
species: Option(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProduct#resource
pub type MedicinalproductSpecialdesignationIndication{
MedicinalproductSpecialdesignationIndicationCodeableconcept(indication: Codeableconcept)
MedicinalproductSpecialdesignationIndicationReference(indication: Reference)}
pub fn medicinalproduct_specialdesignation_indication_to_json(elt: MedicinalproductSpecialdesignationIndication) -> Json {case elt{MedicinalproductSpecialdesignationIndicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicinalproductSpecialdesignationIndicationReference(v) -> reference_to_json(v)
}}
pub fn medicinalproduct_specialdesignation_indication_decoder() -> Decoder(MedicinalproductSpecialdesignationIndication){decode.one_of(decode.field("indicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicinalproductSpecialdesignationIndicationCodeableconcept),[decode.field("indicationReference", reference_decoder(), decode.success) |> decode.map(MedicinalproductSpecialdesignationIndicationReference),])}
pub fn medicinalproduct_specialdesignation_new() ->MedicinalproductSpecialdesignation{MedicinalproductSpecialdesignation(species: None,date: None,status: None,indication: None,intended_use: None,type_: None,identifier: [],modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproduct_specialdesignation_to_json(medicinalproduct_specialdesignation: MedicinalproductSpecialdesignation) -> Json {
    let MedicinalproductSpecialdesignation(species:,date:,status:,indication:,intended_use:,type_:,identifier:,modifier_extension:,extension:,id:,) = medicinalproduct_specialdesignation
    let fields = []
let fields = case species {
                          Some(v) -> [#("species", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case indication {
                          Some(v) -> [#("indication", medicinalproduct_specialdesignation_indication_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case intended_use {
                          Some(v) -> [#("intendedUse", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_specialdesignation_decoder() -> Decoder(MedicinalproductSpecialdesignation) {use species <- decode.optional_field("species", None, decode.optional(codeableconcept_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use indication <- decode.then(none_if_omitted(medicinalproduct_specialdesignation_indication_decoder()))
use intended_use <- decode.optional_field("intendedUse", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductSpecialdesignation(species:,date:,status:,indication:,intended_use:,type_:,identifier:,modifier_extension:,extension:,id:,))}
pub fn medicinalproduct_manufacturingbusinessoperation_to_json(medicinalproduct_manufacturingbusinessoperation: MedicinalproductManufacturingbusinessoperation) -> Json {
    let MedicinalproductManufacturingbusinessoperation(regulator:,manufacturer:,confidentiality_indicator:,effective_date:,authorisation_reference_number:,operation_type:,modifier_extension:,extension:,id:,) = medicinalproduct_manufacturingbusinessoperation
    let fields = []
let fields = case regulator {
                          Some(v) -> [#("regulator", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case manufacturer {
                        [] -> fields
                        _ -> [#("manufacturer", json.array(manufacturer,reference_to_json)), ..fields]
                          }
let fields = case confidentiality_indicator {
                          Some(v) -> [#("confidentialityIndicator", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case effective_date {
                          Some(v) -> [#("effectiveDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case authorisation_reference_number {
                          Some(v) -> [#("authorisationReferenceNumber", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case operation_type {
                          Some(v) -> [#("operationType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_manufacturingbusinessoperation_decoder() -> Decoder(MedicinalproductManufacturingbusinessoperation) {use regulator <- decode.optional_field("regulator", None, decode.optional(reference_decoder()))
use manufacturer <- decode.optional_field("manufacturer", [], decode.list(reference_decoder()))
use confidentiality_indicator <- decode.optional_field("confidentialityIndicator", None, decode.optional(codeableconcept_decoder()))
use effective_date <- decode.optional_field("effectiveDate", None, decode.optional(decode.string))
use authorisation_reference_number <- decode.optional_field("authorisationReferenceNumber", None, decode.optional(identifier_decoder()))
use operation_type <- decode.optional_field("operationType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductManufacturingbusinessoperation(regulator:,manufacturer:,confidentiality_indicator:,effective_date:,authorisation_reference_number:,operation_type:,modifier_extension:,extension:,id:,))}
pub fn medicinalproduct_name_countrylanguage_to_json(medicinalproduct_name_countrylanguage: MedicinalproductNameCountrylanguage) -> Json {
    let MedicinalproductNameCountrylanguage(language:,jurisdiction:,country:,modifier_extension:,extension:,id:,) = medicinalproduct_name_countrylanguage
    let fields = [#("language", codeableconcept_to_json(language)),#("country", codeableconcept_to_json(country)),]
let fields = case jurisdiction {
                          Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_name_countrylanguage_decoder() -> Decoder(MedicinalproductNameCountrylanguage) {use language <- decode.field("language",codeableconcept_decoder())
use jurisdiction <- decode.optional_field("jurisdiction", None, decode.optional(codeableconcept_decoder()))
use country <- decode.field("country",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductNameCountrylanguage(language:,jurisdiction:,country:,modifier_extension:,extension:,id:,))}
pub fn medicinalproduct_name_namepart_to_json(medicinalproduct_name_namepart: MedicinalproductNameNamepart) -> Json {
    let MedicinalproductNameNamepart(type_:,part:,modifier_extension:,extension:,id:,) = medicinalproduct_name_namepart
    let fields = [#("type", coding_to_json(type_)),#("part", json.string(part)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_name_namepart_decoder() -> Decoder(MedicinalproductNameNamepart) {use type_ <- decode.field("type",coding_decoder())
use part <- decode.field("part",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductNameNamepart(type_:,part:,modifier_extension:,extension:,id:,))}
pub fn medicinalproduct_name_to_json(medicinalproduct_name: MedicinalproductName) -> Json {
    let MedicinalproductName(country_language:,name_part:,product_name:,modifier_extension:,extension:,id:,) = medicinalproduct_name
    let fields = [#("productName", json.string(product_name)),]
let fields = case country_language {
                        [] -> fields
                        _ -> [#("countryLanguage", json.array(country_language,medicinalproduct_name_countrylanguage_to_json)), ..fields]
                          }
let fields = case name_part {
                        [] -> fields
                        _ -> [#("namePart", json.array(name_part,medicinalproduct_name_namepart_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_name_decoder() -> Decoder(MedicinalproductName) {use country_language <- decode.optional_field("countryLanguage", [], decode.list(medicinalproduct_name_countrylanguage_decoder()))
use name_part <- decode.optional_field("namePart", [], decode.list(medicinalproduct_name_namepart_decoder()))
use product_name <- decode.field("productName",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductName(country_language:,name_part:,product_name:,modifier_extension:,extension:,id:,))}
pub fn medicinalproduct_to_json(medicinalproduct: Medicinalproduct) -> Json {
    let Medicinalproduct(special_designation:,manufacturing_business_operation:,cross_reference:,name:,clinical_trial:,contact:,master_file:,attached_document:,packaged_medicinal_product:,pharmaceutical_product:,marketing_status:,product_classification:,paediatric_use_indicator:,special_measures:,additional_monitoring_indicator:,legal_status_of_supply:,combined_pharmaceutical_dose_form:,domain:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproduct
    let fields = []
let fields = case special_designation {
                        [] -> fields
                        _ -> [#("specialDesignation", json.array(special_designation,medicinalproduct_specialdesignation_to_json)), ..fields]
                          }
let fields = case manufacturing_business_operation {
                        [] -> fields
                        _ -> [#("manufacturingBusinessOperation", json.array(manufacturing_business_operation,medicinalproduct_manufacturingbusinessoperation_to_json)), ..fields]
                          }
let fields = case cross_reference {
                        [] -> fields
                        _ -> [#("crossReference", json.array(cross_reference,identifier_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,medicinalproduct_name_to_json)), ..fields]
                          }
let fields = case clinical_trial {
                        [] -> fields
                        _ -> [#("clinicalTrial", json.array(clinical_trial,reference_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,reference_to_json)), ..fields]
                          }
let fields = case master_file {
                        [] -> fields
                        _ -> [#("masterFile", json.array(master_file,reference_to_json)), ..fields]
                          }
let fields = case attached_document {
                        [] -> fields
                        _ -> [#("attachedDocument", json.array(attached_document,reference_to_json)), ..fields]
                          }
let fields = case packaged_medicinal_product {
                        [] -> fields
                        _ -> [#("packagedMedicinalProduct", json.array(packaged_medicinal_product,reference_to_json)), ..fields]
                          }
let fields = case pharmaceutical_product {
                        [] -> fields
                        _ -> [#("pharmaceuticalProduct", json.array(pharmaceutical_product,reference_to_json)), ..fields]
                          }
let fields = case marketing_status {
                        [] -> fields
                        _ -> [#("marketingStatus", json.array(marketing_status,marketingstatus_to_json)), ..fields]
                          }
let fields = case product_classification {
                        [] -> fields
                        _ -> [#("productClassification", json.array(product_classification,codeableconcept_to_json)), ..fields]
                          }
let fields = case paediatric_use_indicator {
                          Some(v) -> [#("paediatricUseIndicator", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case special_measures {
                        [] -> fields
                        _ -> [#("specialMeasures", json.array(special_measures,json.string)), ..fields]
                          }
let fields = case additional_monitoring_indicator {
                          Some(v) -> [#("additionalMonitoringIndicator", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case legal_status_of_supply {
                          Some(v) -> [#("legalStatusOfSupply", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case combined_pharmaceutical_dose_form {
                          Some(v) -> [#("combinedPharmaceuticalDoseForm", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case domain {
                          Some(v) -> [#("domain", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproduct_decoder() -> Decoder(Medicinalproduct) {use special_designation <- decode.optional_field("specialDesignation", [], decode.list(medicinalproduct_specialdesignation_decoder()))
use manufacturing_business_operation <- decode.optional_field("manufacturingBusinessOperation", [], decode.list(medicinalproduct_manufacturingbusinessoperation_decoder()))
use cross_reference <- decode.optional_field("crossReference", [], decode.list(identifier_decoder()))
use name <- decode.optional_field("name", [], decode.list(medicinalproduct_name_decoder()))
use clinical_trial <- decode.optional_field("clinicalTrial", [], decode.list(reference_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(reference_decoder()))
use master_file <- decode.optional_field("masterFile", [], decode.list(reference_decoder()))
use attached_document <- decode.optional_field("attachedDocument", [], decode.list(reference_decoder()))
use packaged_medicinal_product <- decode.optional_field("packagedMedicinalProduct", [], decode.list(reference_decoder()))
use pharmaceutical_product <- decode.optional_field("pharmaceuticalProduct", [], decode.list(reference_decoder()))
use marketing_status <- decode.optional_field("marketingStatus", [], decode.list(marketingstatus_decoder()))
use product_classification <- decode.optional_field("productClassification", [], decode.list(codeableconcept_decoder()))
use paediatric_use_indicator <- decode.optional_field("paediatricUseIndicator", None, decode.optional(codeableconcept_decoder()))
use special_measures <- decode.optional_field("specialMeasures", [], decode.list(decode.string))
use additional_monitoring_indicator <- decode.optional_field("additionalMonitoringIndicator", None, decode.optional(codeableconcept_decoder()))
use legal_status_of_supply <- decode.optional_field("legalStatusOfSupply", None, decode.optional(codeableconcept_decoder()))
use combined_pharmaceutical_dose_form <- decode.optional_field("combinedPharmaceuticalDoseForm", None, decode.optional(codeableconcept_decoder()))
use domain <- decode.optional_field("domain", None, decode.optional(coding_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproduct(special_designation:,manufacturing_business_operation:,cross_reference:,name:,clinical_trial:,contact:,master_file:,attached_document:,packaged_medicinal_product:,pharmaceutical_product:,marketing_status:,product_classification:,paediatric_use_indicator:,special_measures:,additional_monitoring_indicator:,legal_status_of_supply:,combined_pharmaceutical_dose_form:,domain:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductAuthorization#resource
pub type Medicinalproductauthorization
{
Medicinalproductauthorization(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
subject: Option(Reference),
country: List(Codeableconcept),
jurisdiction: List(Codeableconcept),
status: Option(Codeableconcept),
status_date: Option(String),
restore_date: Option(String),
validity_period: Option(Period),
data_exclusivity_period: Option(Period),
date_of_first_authorization: Option(String),
international_birth_date: Option(String),
legal_basis: Option(Codeableconcept),
jurisdictional_authorization: List(MedicinalproductauthorizationJurisdictionalauthorization),
holder: Option(Reference),
regulator: Option(Reference),
procedure: Option(MedicinalproductauthorizationProcedure),
)
}

pub fn medicinalproductauthorization_new() ->Medicinalproductauthorization{Medicinalproductauthorization(procedure: None,regulator: None,holder: None,jurisdictional_authorization: [],legal_basis: None,international_birth_date: None,date_of_first_authorization: None,data_exclusivity_period: None,validity_period: None,restore_date: None,status_date: None,status: None,jurisdiction: [],country: [],subject: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductAuthorization#resource
pub type MedicinalproductauthorizationJurisdictionalauthorization
{
MedicinalproductauthorizationJurisdictionalauthorization(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
country: Option(Codeableconcept),
jurisdiction: List(Codeableconcept),
legal_status_of_supply: Option(Codeableconcept),
validity_period: Option(Period),
)
}

pub fn medicinalproductauthorization_jurisdictionalauthorization_new() ->MedicinalproductauthorizationJurisdictionalauthorization{MedicinalproductauthorizationJurisdictionalauthorization(validity_period: None,legal_status_of_supply: None,jurisdiction: [],country: None,identifier: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductAuthorization#resource
pub type MedicinalproductauthorizationProcedure
{
MedicinalproductauthorizationProcedure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
type_: Codeableconcept,
date: Option(MedicinalproductauthorizationProcedureDate),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductAuthorization#resource
pub type MedicinalproductauthorizationProcedureDate{
MedicinalproductauthorizationProcedureDatePeriod(date: Period)
MedicinalproductauthorizationProcedureDateDatetime(date: String)}
pub fn medicinalproductauthorization_procedure_date_to_json(elt: MedicinalproductauthorizationProcedureDate) -> Json {case elt{MedicinalproductauthorizationProcedureDatePeriod(v) -> period_to_json(v)
MedicinalproductauthorizationProcedureDateDatetime(v) -> json.string(v)
}}
pub fn medicinalproductauthorization_procedure_date_decoder() -> Decoder(MedicinalproductauthorizationProcedureDate){decode.one_of(decode.field("datePeriod", period_decoder(), decode.success) |> decode.map(MedicinalproductauthorizationProcedureDatePeriod),[decode.field("dateDateTime", decode.string, decode.success) |> decode.map(MedicinalproductauthorizationProcedureDateDatetime),])}
pub fn medicinalproductauthorization_procedure_new(type_ type_: Codeableconcept,) ->MedicinalproductauthorizationProcedure{MedicinalproductauthorizationProcedure(date: None,type_:,identifier: None,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductauthorization_procedure_to_json(medicinalproductauthorization_procedure: MedicinalproductauthorizationProcedure) -> Json {
    let MedicinalproductauthorizationProcedure(date:,type_:,identifier:,modifier_extension:,extension:,id:,) = medicinalproductauthorization_procedure
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case date {
                          Some(v) -> [#("date", medicinalproductauthorization_procedure_date_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductauthorization_procedure_decoder() -> Decoder(MedicinalproductauthorizationProcedure) {use date <- decode.then(none_if_omitted(medicinalproductauthorization_procedure_date_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductauthorizationProcedure(date:,type_:,identifier:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductauthorization_jurisdictionalauthorization_to_json(medicinalproductauthorization_jurisdictionalauthorization: MedicinalproductauthorizationJurisdictionalauthorization) -> Json {
    let MedicinalproductauthorizationJurisdictionalauthorization(validity_period:,legal_status_of_supply:,jurisdiction:,country:,identifier:,modifier_extension:,extension:,id:,) = medicinalproductauthorization_jurisdictionalauthorization
    let fields = []
let fields = case validity_period {
                          Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case legal_status_of_supply {
                          Some(v) -> [#("legalStatusOfSupply", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case country {
                          Some(v) -> [#("country", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductauthorization_jurisdictionalauthorization_decoder() -> Decoder(MedicinalproductauthorizationJurisdictionalauthorization) {use validity_period <- decode.optional_field("validityPeriod", None, decode.optional(period_decoder()))
use legal_status_of_supply <- decode.optional_field("legalStatusOfSupply", None, decode.optional(codeableconcept_decoder()))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use country <- decode.optional_field("country", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductauthorizationJurisdictionalauthorization(validity_period:,legal_status_of_supply:,jurisdiction:,country:,identifier:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductauthorization_to_json(medicinalproductauthorization: Medicinalproductauthorization) -> Json {
    let Medicinalproductauthorization(procedure:,regulator:,holder:,jurisdictional_authorization:,legal_basis:,international_birth_date:,date_of_first_authorization:,data_exclusivity_period:,validity_period:,restore_date:,status_date:,status:,jurisdiction:,country:,subject:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductauthorization
    let fields = []
let fields = case procedure {
                          Some(v) -> [#("procedure", medicinalproductauthorization_procedure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case regulator {
                          Some(v) -> [#("regulator", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case holder {
                          Some(v) -> [#("holder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdictional_authorization {
                        [] -> fields
                        _ -> [#("jurisdictionalAuthorization", json.array(jurisdictional_authorization,medicinalproductauthorization_jurisdictionalauthorization_to_json)), ..fields]
                          }
let fields = case legal_basis {
                          Some(v) -> [#("legalBasis", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case international_birth_date {
                          Some(v) -> [#("internationalBirthDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date_of_first_authorization {
                          Some(v) -> [#("dateOfFirstAuthorization", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case data_exclusivity_period {
                          Some(v) -> [#("dataExclusivityPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case validity_period {
                          Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case restore_date {
                          Some(v) -> [#("restoreDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status_date {
                          Some(v) -> [#("statusDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case country {
                        [] -> fields
                        _ -> [#("country", json.array(country,codeableconcept_to_json)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductauthorization_decoder() -> Decoder(Medicinalproductauthorization) {use procedure <- decode.optional_field("procedure", None, decode.optional(medicinalproductauthorization_procedure_decoder()))
use regulator <- decode.optional_field("regulator", None, decode.optional(reference_decoder()))
use holder <- decode.optional_field("holder", None, decode.optional(reference_decoder()))
use jurisdictional_authorization <- decode.optional_field("jurisdictionalAuthorization", [], decode.list(medicinalproductauthorization_jurisdictionalauthorization_decoder()))
use legal_basis <- decode.optional_field("legalBasis", None, decode.optional(codeableconcept_decoder()))
use international_birth_date <- decode.optional_field("internationalBirthDate", None, decode.optional(decode.string))
use date_of_first_authorization <- decode.optional_field("dateOfFirstAuthorization", None, decode.optional(decode.string))
use data_exclusivity_period <- decode.optional_field("dataExclusivityPeriod", None, decode.optional(period_decoder()))
use validity_period <- decode.optional_field("validityPeriod", None, decode.optional(period_decoder()))
use restore_date <- decode.optional_field("restoreDate", None, decode.optional(decode.string))
use status_date <- decode.optional_field("statusDate", None, decode.optional(decode.string))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use country <- decode.optional_field("country", [], decode.list(codeableconcept_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductauthorization(procedure:,regulator:,holder:,jurisdictional_authorization:,legal_basis:,international_birth_date:,date_of_first_authorization:,data_exclusivity_period:,validity_period:,restore_date:,status_date:,status:,jurisdiction:,country:,subject:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductContraindication#resource
pub type Medicinalproductcontraindication
{
Medicinalproductcontraindication(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
subject: List(Reference),
disease: Option(Codeableconcept),
disease_status: Option(Codeableconcept),
comorbidity: List(Codeableconcept),
therapeutic_indication: List(Reference),
other_therapy: List(MedicinalproductcontraindicationOthertherapy),
population: List(Population),
)
}

pub fn medicinalproductcontraindication_new() ->Medicinalproductcontraindication{Medicinalproductcontraindication(population: [],other_therapy: [],therapeutic_indication: [],comorbidity: [],disease_status: None,disease: None,subject: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductContraindication#resource
pub type MedicinalproductcontraindicationOthertherapy
{
MedicinalproductcontraindicationOthertherapy(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
therapy_relationship_type: Codeableconcept,
medication: MedicinalproductcontraindicationOthertherapyMedication,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductContraindication#resource
pub type MedicinalproductcontraindicationOthertherapyMedication{
MedicinalproductcontraindicationOthertherapyMedicationCodeableconcept(medication: Codeableconcept)
MedicinalproductcontraindicationOthertherapyMedicationReference(medication: Reference)}
pub fn medicinalproductcontraindication_othertherapy_medication_to_json(elt: MedicinalproductcontraindicationOthertherapyMedication) -> Json {case elt{MedicinalproductcontraindicationOthertherapyMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicinalproductcontraindicationOthertherapyMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicinalproductcontraindication_othertherapy_medication_decoder() -> Decoder(MedicinalproductcontraindicationOthertherapyMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicinalproductcontraindicationOthertherapyMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicinalproductcontraindicationOthertherapyMedicationReference),])}
pub fn medicinalproductcontraindication_othertherapy_new(medication medication: MedicinalproductcontraindicationOthertherapyMedication,therapy_relationship_type therapy_relationship_type: Codeableconcept,) ->MedicinalproductcontraindicationOthertherapy{MedicinalproductcontraindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductcontraindication_othertherapy_to_json(medicinalproductcontraindication_othertherapy: MedicinalproductcontraindicationOthertherapy) -> Json {
    let MedicinalproductcontraindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension:,extension:,id:,) = medicinalproductcontraindication_othertherapy
    let fields = [#("medication", medicinalproductcontraindication_othertherapy_medication_to_json(medication)),#("therapyRelationshipType", codeableconcept_to_json(therapy_relationship_type)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductcontraindication_othertherapy_decoder() -> Decoder(MedicinalproductcontraindicationOthertherapy) {use medication <- decode.then(medicinalproductcontraindication_othertherapy_medication_decoder())
use therapy_relationship_type <- decode.field("therapyRelationshipType",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductcontraindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductcontraindication_to_json(medicinalproductcontraindication: Medicinalproductcontraindication) -> Json {
    let Medicinalproductcontraindication(population:,other_therapy:,therapeutic_indication:,comorbidity:,disease_status:,disease:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductcontraindication
    let fields = []
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,population_to_json)), ..fields]
                          }
let fields = case other_therapy {
                        [] -> fields
                        _ -> [#("otherTherapy", json.array(other_therapy,medicinalproductcontraindication_othertherapy_to_json)), ..fields]
                          }
let fields = case therapeutic_indication {
                        [] -> fields
                        _ -> [#("therapeuticIndication", json.array(therapeutic_indication,reference_to_json)), ..fields]
                          }
let fields = case comorbidity {
                        [] -> fields
                        _ -> [#("comorbidity", json.array(comorbidity,codeableconcept_to_json)), ..fields]
                          }
let fields = case disease_status {
                          Some(v) -> [#("diseaseStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case disease {
                          Some(v) -> [#("disease", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductcontraindication_decoder() -> Decoder(Medicinalproductcontraindication) {use population <- decode.optional_field("population", [], decode.list(population_decoder()))
use other_therapy <- decode.optional_field("otherTherapy", [], decode.list(medicinalproductcontraindication_othertherapy_decoder()))
use therapeutic_indication <- decode.optional_field("therapeuticIndication", [], decode.list(reference_decoder()))
use comorbidity <- decode.optional_field("comorbidity", [], decode.list(codeableconcept_decoder()))
use disease_status <- decode.optional_field("diseaseStatus", None, decode.optional(codeableconcept_decoder()))
use disease <- decode.optional_field("disease", None, decode.optional(codeableconcept_decoder()))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductcontraindication(population:,other_therapy:,therapeutic_indication:,comorbidity:,disease_status:,disease:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIndication#resource
pub type Medicinalproductindication
{
Medicinalproductindication(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
subject: List(Reference),
disease_symptom_procedure: Option(Codeableconcept),
disease_status: Option(Codeableconcept),
comorbidity: List(Codeableconcept),
intended_effect: Option(Codeableconcept),
duration: Option(Quantity),
other_therapy: List(MedicinalproductindicationOthertherapy),
undesirable_effect: List(Reference),
population: List(Population),
)
}

pub fn medicinalproductindication_new() ->Medicinalproductindication{Medicinalproductindication(population: [],undesirable_effect: [],other_therapy: [],duration: None,intended_effect: None,comorbidity: [],disease_status: None,disease_symptom_procedure: None,subject: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIndication#resource
pub type MedicinalproductindicationOthertherapy
{
MedicinalproductindicationOthertherapy(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
therapy_relationship_type: Codeableconcept,
medication: MedicinalproductindicationOthertherapyMedication,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIndication#resource
pub type MedicinalproductindicationOthertherapyMedication{
MedicinalproductindicationOthertherapyMedicationCodeableconcept(medication: Codeableconcept)
MedicinalproductindicationOthertherapyMedicationReference(medication: Reference)}
pub fn medicinalproductindication_othertherapy_medication_to_json(elt: MedicinalproductindicationOthertherapyMedication) -> Json {case elt{MedicinalproductindicationOthertherapyMedicationCodeableconcept(v) -> codeableconcept_to_json(v)
MedicinalproductindicationOthertherapyMedicationReference(v) -> reference_to_json(v)
}}
pub fn medicinalproductindication_othertherapy_medication_decoder() -> Decoder(MedicinalproductindicationOthertherapyMedication){decode.one_of(decode.field("medicationCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicinalproductindicationOthertherapyMedicationCodeableconcept),[decode.field("medicationReference", reference_decoder(), decode.success) |> decode.map(MedicinalproductindicationOthertherapyMedicationReference),])}
pub fn medicinalproductindication_othertherapy_new(medication medication: MedicinalproductindicationOthertherapyMedication,therapy_relationship_type therapy_relationship_type: Codeableconcept,) ->MedicinalproductindicationOthertherapy{MedicinalproductindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductindication_othertherapy_to_json(medicinalproductindication_othertherapy: MedicinalproductindicationOthertherapy) -> Json {
    let MedicinalproductindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension:,extension:,id:,) = medicinalproductindication_othertherapy
    let fields = [#("medication", medicinalproductindication_othertherapy_medication_to_json(medication)),#("therapyRelationshipType", codeableconcept_to_json(therapy_relationship_type)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductindication_othertherapy_decoder() -> Decoder(MedicinalproductindicationOthertherapy) {use medication <- decode.then(medicinalproductindication_othertherapy_medication_decoder())
use therapy_relationship_type <- decode.field("therapyRelationshipType",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductindicationOthertherapy(medication:,therapy_relationship_type:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductindication_to_json(medicinalproductindication: Medicinalproductindication) -> Json {
    let Medicinalproductindication(population:,undesirable_effect:,other_therapy:,duration:,intended_effect:,comorbidity:,disease_status:,disease_symptom_procedure:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductindication
    let fields = []
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,population_to_json)), ..fields]
                          }
let fields = case undesirable_effect {
                        [] -> fields
                        _ -> [#("undesirableEffect", json.array(undesirable_effect,reference_to_json)), ..fields]
                          }
let fields = case other_therapy {
                        [] -> fields
                        _ -> [#("otherTherapy", json.array(other_therapy,medicinalproductindication_othertherapy_to_json)), ..fields]
                          }
let fields = case duration {
                          Some(v) -> [#("duration", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case intended_effect {
                          Some(v) -> [#("intendedEffect", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case comorbidity {
                        [] -> fields
                        _ -> [#("comorbidity", json.array(comorbidity,codeableconcept_to_json)), ..fields]
                          }
let fields = case disease_status {
                          Some(v) -> [#("diseaseStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case disease_symptom_procedure {
                          Some(v) -> [#("diseaseSymptomProcedure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductindication_decoder() -> Decoder(Medicinalproductindication) {use population <- decode.optional_field("population", [], decode.list(population_decoder()))
use undesirable_effect <- decode.optional_field("undesirableEffect", [], decode.list(reference_decoder()))
use other_therapy <- decode.optional_field("otherTherapy", [], decode.list(medicinalproductindication_othertherapy_decoder()))
use duration <- decode.optional_field("duration", None, decode.optional(quantity_decoder()))
use intended_effect <- decode.optional_field("intendedEffect", None, decode.optional(codeableconcept_decoder()))
use comorbidity <- decode.optional_field("comorbidity", [], decode.list(codeableconcept_decoder()))
use disease_status <- decode.optional_field("diseaseStatus", None, decode.optional(codeableconcept_decoder()))
use disease_symptom_procedure <- decode.optional_field("diseaseSymptomProcedure", None, decode.optional(codeableconcept_decoder()))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductindication(population:,undesirable_effect:,other_therapy:,duration:,intended_effect:,comorbidity:,disease_status:,disease_symptom_procedure:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIngredient#resource
pub type Medicinalproductingredient
{
Medicinalproductingredient(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
role: Codeableconcept,
allergenic_indicator: Option(Bool),
manufacturer: List(Reference),
specified_substance: List(MedicinalproductingredientSpecifiedsubstance),
substance: Option(MedicinalproductingredientSubstance),
)
}

pub fn medicinalproductingredient_new(role role: Codeableconcept,) ->Medicinalproductingredient{Medicinalproductingredient(substance: None,specified_substance: [],manufacturer: [],allergenic_indicator: None,role:,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIngredient#resource
pub type MedicinalproductingredientSpecifiedsubstance
{
MedicinalproductingredientSpecifiedsubstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
group: Codeableconcept,
confidentiality: Option(Codeableconcept),
strength: List(MedicinalproductingredientSpecifiedsubstanceStrength),
)
}

pub fn medicinalproductingredient_specifiedsubstance_new(group group: Codeableconcept,code code: Codeableconcept,) ->MedicinalproductingredientSpecifiedsubstance{MedicinalproductingredientSpecifiedsubstance(strength: [],confidentiality: None,group:,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIngredient#resource
pub type MedicinalproductingredientSpecifiedsubstanceStrength
{
MedicinalproductingredientSpecifiedsubstanceStrength(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
presentation: Ratio,
presentation_low_limit: Option(Ratio),
concentration: Option(Ratio),
concentration_low_limit: Option(Ratio),
measurement_point: Option(String),
country: List(Codeableconcept),
reference_strength: List(MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength),
)
}

pub fn medicinalproductingredient_specifiedsubstance_strength_new(presentation presentation: Ratio,) ->MedicinalproductingredientSpecifiedsubstanceStrength{MedicinalproductingredientSpecifiedsubstanceStrength(reference_strength: [],country: [],measurement_point: None,concentration_low_limit: None,concentration: None,presentation_low_limit: None,presentation:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIngredient#resource
pub type MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength
{
MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
substance: Option(Codeableconcept),
strength: Ratio,
strength_low_limit: Option(Ratio),
measurement_point: Option(String),
country: List(Codeableconcept),
)
}

pub fn medicinalproductingredient_specifiedsubstance_strength_referencestrength_new(strength strength: Ratio,) ->MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength{MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength(country: [],measurement_point: None,strength_low_limit: None,strength:,substance: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductIngredient#resource
pub type MedicinalproductingredientSubstance
{
MedicinalproductingredientSubstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
)
}

pub fn medicinalproductingredient_substance_new(code code: Codeableconcept,) ->MedicinalproductingredientSubstance{MedicinalproductingredientSubstance(code:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductingredient_substance_to_json(medicinalproductingredient_substance: MedicinalproductingredientSubstance) -> Json {
    let MedicinalproductingredientSubstance(code:,modifier_extension:,extension:,id:,) = medicinalproductingredient_substance
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductingredient_substance_decoder() -> Decoder(MedicinalproductingredientSubstance) {use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductingredientSubstance(code:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductingredient_specifiedsubstance_strength_referencestrength_to_json(medicinalproductingredient_specifiedsubstance_strength_referencestrength: MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength) -> Json {
    let MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength(country:,measurement_point:,strength_low_limit:,strength:,substance:,modifier_extension:,extension:,id:,) = medicinalproductingredient_specifiedsubstance_strength_referencestrength
    let fields = [#("strength", ratio_to_json(strength)),]
let fields = case country {
                        [] -> fields
                        _ -> [#("country", json.array(country,codeableconcept_to_json)), ..fields]
                          }
let fields = case measurement_point {
                          Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case strength_low_limit {
                          Some(v) -> [#("strengthLowLimit", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case substance {
                          Some(v) -> [#("substance", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductingredient_specifiedsubstance_strength_referencestrength_decoder() -> Decoder(MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength) {use country <- decode.optional_field("country", [], decode.list(codeableconcept_decoder()))
use measurement_point <- decode.optional_field("measurementPoint", None, decode.optional(decode.string))
use strength_low_limit <- decode.optional_field("strengthLowLimit", None, decode.optional(ratio_decoder()))
use strength <- decode.field("strength",ratio_decoder())
use substance <- decode.optional_field("substance", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductingredientSpecifiedsubstanceStrengthReferencestrength(country:,measurement_point:,strength_low_limit:,strength:,substance:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductingredient_specifiedsubstance_strength_to_json(medicinalproductingredient_specifiedsubstance_strength: MedicinalproductingredientSpecifiedsubstanceStrength) -> Json {
    let MedicinalproductingredientSpecifiedsubstanceStrength(reference_strength:,country:,measurement_point:,concentration_low_limit:,concentration:,presentation_low_limit:,presentation:,modifier_extension:,extension:,id:,) = medicinalproductingredient_specifiedsubstance_strength
    let fields = [#("presentation", ratio_to_json(presentation)),]
let fields = case reference_strength {
                        [] -> fields
                        _ -> [#("referenceStrength", json.array(reference_strength,medicinalproductingredient_specifiedsubstance_strength_referencestrength_to_json)), ..fields]
                          }
let fields = case country {
                        [] -> fields
                        _ -> [#("country", json.array(country,codeableconcept_to_json)), ..fields]
                          }
let fields = case measurement_point {
                          Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case concentration_low_limit {
                          Some(v) -> [#("concentrationLowLimit", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case concentration {
                          Some(v) -> [#("concentration", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case presentation_low_limit {
                          Some(v) -> [#("presentationLowLimit", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductingredient_specifiedsubstance_strength_decoder() -> Decoder(MedicinalproductingredientSpecifiedsubstanceStrength) {use reference_strength <- decode.optional_field("referenceStrength", [], decode.list(medicinalproductingredient_specifiedsubstance_strength_referencestrength_decoder()))
use country <- decode.optional_field("country", [], decode.list(codeableconcept_decoder()))
use measurement_point <- decode.optional_field("measurementPoint", None, decode.optional(decode.string))
use concentration_low_limit <- decode.optional_field("concentrationLowLimit", None, decode.optional(ratio_decoder()))
use concentration <- decode.optional_field("concentration", None, decode.optional(ratio_decoder()))
use presentation_low_limit <- decode.optional_field("presentationLowLimit", None, decode.optional(ratio_decoder()))
use presentation <- decode.field("presentation",ratio_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductingredientSpecifiedsubstanceStrength(reference_strength:,country:,measurement_point:,concentration_low_limit:,concentration:,presentation_low_limit:,presentation:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductingredient_specifiedsubstance_to_json(medicinalproductingredient_specifiedsubstance: MedicinalproductingredientSpecifiedsubstance) -> Json {
    let MedicinalproductingredientSpecifiedsubstance(strength:,confidentiality:,group:,code:,modifier_extension:,extension:,id:,) = medicinalproductingredient_specifiedsubstance
    let fields = [#("group", codeableconcept_to_json(group)),#("code", codeableconcept_to_json(code)),]
let fields = case strength {
                        [] -> fields
                        _ -> [#("strength", json.array(strength,medicinalproductingredient_specifiedsubstance_strength_to_json)), ..fields]
                          }
let fields = case confidentiality {
                          Some(v) -> [#("confidentiality", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductingredient_specifiedsubstance_decoder() -> Decoder(MedicinalproductingredientSpecifiedsubstance) {use strength <- decode.optional_field("strength", [], decode.list(medicinalproductingredient_specifiedsubstance_strength_decoder()))
use confidentiality <- decode.optional_field("confidentiality", None, decode.optional(codeableconcept_decoder()))
use group <- decode.field("group",codeableconcept_decoder())
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductingredientSpecifiedsubstance(strength:,confidentiality:,group:,code:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductingredient_to_json(medicinalproductingredient: Medicinalproductingredient) -> Json {
    let Medicinalproductingredient(substance:,specified_substance:,manufacturer:,allergenic_indicator:,role:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductingredient
    let fields = [#("role", codeableconcept_to_json(role)),]
let fields = case substance {
                          Some(v) -> [#("substance", medicinalproductingredient_substance_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specified_substance {
                        [] -> fields
                        _ -> [#("specifiedSubstance", json.array(specified_substance,medicinalproductingredient_specifiedsubstance_to_json)), ..fields]
                          }
let fields = case manufacturer {
                        [] -> fields
                        _ -> [#("manufacturer", json.array(manufacturer,reference_to_json)), ..fields]
                          }
let fields = case allergenic_indicator {
                          Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductingredient_decoder() -> Decoder(Medicinalproductingredient) {use substance <- decode.optional_field("substance", None, decode.optional(medicinalproductingredient_substance_decoder()))
use specified_substance <- decode.optional_field("specifiedSubstance", [], decode.list(medicinalproductingredient_specifiedsubstance_decoder()))
use manufacturer <- decode.optional_field("manufacturer", [], decode.list(reference_decoder()))
use allergenic_indicator <- decode.optional_field("allergenicIndicator", None, decode.optional(decode.bool))
use role <- decode.field("role",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductingredient(substance:,specified_substance:,manufacturer:,allergenic_indicator:,role:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductInteraction#resource
pub type Medicinalproductinteraction
{
Medicinalproductinteraction(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
subject: List(Reference),
description: Option(String),
interactant: List(MedicinalproductinteractionInteractant),
type_: Option(Codeableconcept),
effect: Option(Codeableconcept),
incidence: Option(Codeableconcept),
management: Option(Codeableconcept),
)
}

pub fn medicinalproductinteraction_new() ->Medicinalproductinteraction{Medicinalproductinteraction(management: None,incidence: None,effect: None,type_: None,interactant: [],description: None,subject: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductInteraction#resource
pub type MedicinalproductinteractionInteractant
{
MedicinalproductinteractionInteractant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
item: MedicinalproductinteractionInteractantItem,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductInteraction#resource
pub type MedicinalproductinteractionInteractantItem{
MedicinalproductinteractionInteractantItemReference(item: Reference)
MedicinalproductinteractionInteractantItemCodeableconcept(item: Codeableconcept)}
pub fn medicinalproductinteraction_interactant_item_to_json(elt: MedicinalproductinteractionInteractantItem) -> Json {case elt{MedicinalproductinteractionInteractantItemReference(v) -> reference_to_json(v)
MedicinalproductinteractionInteractantItemCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn medicinalproductinteraction_interactant_item_decoder() -> Decoder(MedicinalproductinteractionInteractantItem){decode.one_of(decode.field("itemReference", reference_decoder(), decode.success) |> decode.map(MedicinalproductinteractionInteractantItemReference),[decode.field("itemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(MedicinalproductinteractionInteractantItemCodeableconcept),])}
pub fn medicinalproductinteraction_interactant_new(item item: MedicinalproductinteractionInteractantItem,) ->MedicinalproductinteractionInteractant{MedicinalproductinteractionInteractant(item:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductinteraction_interactant_to_json(medicinalproductinteraction_interactant: MedicinalproductinteractionInteractant) -> Json {
    let MedicinalproductinteractionInteractant(item:,modifier_extension:,extension:,id:,) = medicinalproductinteraction_interactant
    let fields = [#("item", medicinalproductinteraction_interactant_item_to_json(item)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductinteraction_interactant_decoder() -> Decoder(MedicinalproductinteractionInteractant) {use item <- decode.then(medicinalproductinteraction_interactant_item_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductinteractionInteractant(item:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductinteraction_to_json(medicinalproductinteraction: Medicinalproductinteraction) -> Json {
    let Medicinalproductinteraction(management:,incidence:,effect:,type_:,interactant:,description:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductinteraction
    let fields = []
let fields = case management {
                          Some(v) -> [#("management", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case incidence {
                          Some(v) -> [#("incidence", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case effect {
                          Some(v) -> [#("effect", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case interactant {
                        [] -> fields
                        _ -> [#("interactant", json.array(interactant,medicinalproductinteraction_interactant_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductinteraction_decoder() -> Decoder(Medicinalproductinteraction) {use management <- decode.optional_field("management", None, decode.optional(codeableconcept_decoder()))
use incidence <- decode.optional_field("incidence", None, decode.optional(codeableconcept_decoder()))
use effect <- decode.optional_field("effect", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use interactant <- decode.optional_field("interactant", [], decode.list(medicinalproductinteraction_interactant_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductinteraction(management:,incidence:,effect:,type_:,interactant:,description:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductManufactured#resource
pub type Medicinalproductmanufactured
{
Medicinalproductmanufactured(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
manufactured_dose_form: Codeableconcept,
unit_of_presentation: Option(Codeableconcept),
quantity: Quantity,
manufacturer: List(Reference),
ingredient: List(Reference),
physical_characteristics: Option(Prodcharacteristic),
other_characteristics: List(Codeableconcept),
)
}

pub fn medicinalproductmanufactured_new(quantity quantity: Quantity,manufactured_dose_form manufactured_dose_form: Codeableconcept,) ->Medicinalproductmanufactured{Medicinalproductmanufactured(other_characteristics: [],physical_characteristics: None,ingredient: [],manufacturer: [],quantity:,unit_of_presentation: None,manufactured_dose_form:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn medicinalproductmanufactured_to_json(medicinalproductmanufactured: Medicinalproductmanufactured) -> Json {
    let Medicinalproductmanufactured(other_characteristics:,physical_characteristics:,ingredient:,manufacturer:,quantity:,unit_of_presentation:,manufactured_dose_form:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductmanufactured
    let fields = [#("quantity", quantity_to_json(quantity)),#("manufacturedDoseForm", codeableconcept_to_json(manufactured_dose_form)),]
let fields = case other_characteristics {
                        [] -> fields
                        _ -> [#("otherCharacteristics", json.array(other_characteristics,codeableconcept_to_json)), ..fields]
                          }
let fields = case physical_characteristics {
                          Some(v) -> [#("physicalCharacteristics", prodcharacteristic_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case ingredient {
                        [] -> fields
                        _ -> [#("ingredient", json.array(ingredient,reference_to_json)), ..fields]
                          }
let fields = case manufacturer {
                        [] -> fields
                        _ -> [#("manufacturer", json.array(manufacturer,reference_to_json)), ..fields]
                          }
let fields = case unit_of_presentation {
                          Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductmanufactured_decoder() -> Decoder(Medicinalproductmanufactured) {use other_characteristics <- decode.optional_field("otherCharacteristics", [], decode.list(codeableconcept_decoder()))
use physical_characteristics <- decode.optional_field("physicalCharacteristics", None, decode.optional(prodcharacteristic_decoder()))
use ingredient <- decode.optional_field("ingredient", [], decode.list(reference_decoder()))
use manufacturer <- decode.optional_field("manufacturer", [], decode.list(reference_decoder()))
use quantity <- decode.field("quantity",quantity_decoder())
use unit_of_presentation <- decode.optional_field("unitOfPresentation", None, decode.optional(codeableconcept_decoder()))
use manufactured_dose_form <- decode.field("manufacturedDoseForm",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductmanufactured(other_characteristics:,physical_characteristics:,ingredient:,manufacturer:,quantity:,unit_of_presentation:,manufactured_dose_form:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPackaged#resource
pub type Medicinalproductpackaged
{
Medicinalproductpackaged(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
subject: List(Reference),
description: Option(String),
legal_status_of_supply: Option(Codeableconcept),
marketing_status: List(Marketingstatus),
marketing_authorization: Option(Reference),
manufacturer: List(Reference),
batch_identifier: List(MedicinalproductpackagedBatchidentifier),
package_item: List(MedicinalproductpackagedPackageitem),
)
}

pub fn medicinalproductpackaged_new() ->Medicinalproductpackaged{Medicinalproductpackaged(package_item: [],batch_identifier: [],manufacturer: [],marketing_authorization: None,marketing_status: [],legal_status_of_supply: None,description: None,subject: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPackaged#resource
pub type MedicinalproductpackagedBatchidentifier
{
MedicinalproductpackagedBatchidentifier(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
outer_packaging: Identifier,
immediate_packaging: Option(Identifier),
)
}

pub fn medicinalproductpackaged_batchidentifier_new(outer_packaging outer_packaging: Identifier,) ->MedicinalproductpackagedBatchidentifier{MedicinalproductpackagedBatchidentifier(immediate_packaging: None,outer_packaging:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPackaged#resource
pub type MedicinalproductpackagedPackageitem
{
MedicinalproductpackagedPackageitem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Codeableconcept,
quantity: Quantity,
material: List(Codeableconcept),
alternate_material: List(Codeableconcept),
device: List(Reference),
manufactured_item: List(Reference),
physical_characteristics: Option(Prodcharacteristic),
other_characteristics: List(Codeableconcept),
shelf_life_storage: List(Productshelflife),
manufacturer: List(Reference),
)
}

pub fn medicinalproductpackaged_packageitem_new(quantity quantity: Quantity,type_ type_: Codeableconcept,) ->MedicinalproductpackagedPackageitem{MedicinalproductpackagedPackageitem(manufacturer: [],shelf_life_storage: [],other_characteristics: [],physical_characteristics: None,manufactured_item: [],device: [],alternate_material: [],material: [],quantity:,type_:,identifier: [],modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductpackaged_packageitem_to_json(medicinalproductpackaged_packageitem: MedicinalproductpackagedPackageitem) -> Json {
    let MedicinalproductpackagedPackageitem(manufacturer:,shelf_life_storage:,other_characteristics:,physical_characteristics:,manufactured_item:,device:,alternate_material:,material:,quantity:,type_:,identifier:,modifier_extension:,extension:,id:,) = medicinalproductpackaged_packageitem
    let fields = [#("quantity", quantity_to_json(quantity)),#("type", codeableconcept_to_json(type_)),]
let fields = case manufacturer {
                        [] -> fields
                        _ -> [#("manufacturer", json.array(manufacturer,reference_to_json)), ..fields]
                          }
let fields = case shelf_life_storage {
                        [] -> fields
                        _ -> [#("shelfLifeStorage", json.array(shelf_life_storage,productshelflife_to_json)), ..fields]
                          }
let fields = case other_characteristics {
                        [] -> fields
                        _ -> [#("otherCharacteristics", json.array(other_characteristics,codeableconcept_to_json)), ..fields]
                          }
let fields = case physical_characteristics {
                          Some(v) -> [#("physicalCharacteristics", prodcharacteristic_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case manufactured_item {
                        [] -> fields
                        _ -> [#("manufacturedItem", json.array(manufactured_item,reference_to_json)), ..fields]
                          }
let fields = case device {
                        [] -> fields
                        _ -> [#("device", json.array(device,reference_to_json)), ..fields]
                          }
let fields = case alternate_material {
                        [] -> fields
                        _ -> [#("alternateMaterial", json.array(alternate_material,codeableconcept_to_json)), ..fields]
                          }
let fields = case material {
                        [] -> fields
                        _ -> [#("material", json.array(material,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpackaged_packageitem_decoder() -> Decoder(MedicinalproductpackagedPackageitem) {use manufacturer <- decode.optional_field("manufacturer", [], decode.list(reference_decoder()))
use shelf_life_storage <- decode.optional_field("shelfLifeStorage", [], decode.list(productshelflife_decoder()))
use other_characteristics <- decode.optional_field("otherCharacteristics", [], decode.list(codeableconcept_decoder()))
use physical_characteristics <- decode.optional_field("physicalCharacteristics", None, decode.optional(prodcharacteristic_decoder()))
use manufactured_item <- decode.optional_field("manufacturedItem", [], decode.list(reference_decoder()))
use device <- decode.optional_field("device", [], decode.list(reference_decoder()))
use alternate_material <- decode.optional_field("alternateMaterial", [], decode.list(codeableconcept_decoder()))
use material <- decode.optional_field("material", [], decode.list(codeableconcept_decoder()))
use quantity <- decode.field("quantity",quantity_decoder())
use type_ <- decode.field("type",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpackagedPackageitem(manufacturer:,shelf_life_storage:,other_characteristics:,physical_characteristics:,manufactured_item:,device:,alternate_material:,material:,quantity:,type_:,identifier:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpackaged_batchidentifier_to_json(medicinalproductpackaged_batchidentifier: MedicinalproductpackagedBatchidentifier) -> Json {
    let MedicinalproductpackagedBatchidentifier(immediate_packaging:,outer_packaging:,modifier_extension:,extension:,id:,) = medicinalproductpackaged_batchidentifier
    let fields = [#("outerPackaging", identifier_to_json(outer_packaging)),]
let fields = case immediate_packaging {
                          Some(v) -> [#("immediatePackaging", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpackaged_batchidentifier_decoder() -> Decoder(MedicinalproductpackagedBatchidentifier) {use immediate_packaging <- decode.optional_field("immediatePackaging", None, decode.optional(identifier_decoder()))
use outer_packaging <- decode.field("outerPackaging",identifier_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpackagedBatchidentifier(immediate_packaging:,outer_packaging:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpackaged_to_json(medicinalproductpackaged: Medicinalproductpackaged) -> Json {
    let Medicinalproductpackaged(package_item:,batch_identifier:,manufacturer:,marketing_authorization:,marketing_status:,legal_status_of_supply:,description:,subject:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductpackaged
    let fields = []
let fields = case package_item {
                        [] -> fields
                        _ -> [#("packageItem", json.array(package_item,medicinalproductpackaged_packageitem_to_json)), ..fields]
                          }
let fields = case batch_identifier {
                        [] -> fields
                        _ -> [#("batchIdentifier", json.array(batch_identifier,medicinalproductpackaged_batchidentifier_to_json)), ..fields]
                          }
let fields = case manufacturer {
                        [] -> fields
                        _ -> [#("manufacturer", json.array(manufacturer,reference_to_json)), ..fields]
                          }
let fields = case marketing_authorization {
                          Some(v) -> [#("marketingAuthorization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case marketing_status {
                        [] -> fields
                        _ -> [#("marketingStatus", json.array(marketing_status,marketingstatus_to_json)), ..fields]
                          }
let fields = case legal_status_of_supply {
                          Some(v) -> [#("legalStatusOfSupply", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpackaged_decoder() -> Decoder(Medicinalproductpackaged) {use package_item <- decode.optional_field("packageItem", [], decode.list(medicinalproductpackaged_packageitem_decoder()))
use batch_identifier <- decode.optional_field("batchIdentifier", [], decode.list(medicinalproductpackaged_batchidentifier_decoder()))
use manufacturer <- decode.optional_field("manufacturer", [], decode.list(reference_decoder()))
use marketing_authorization <- decode.optional_field("marketingAuthorization", None, decode.optional(reference_decoder()))
use marketing_status <- decode.optional_field("marketingStatus", [], decode.list(marketingstatus_decoder()))
use legal_status_of_supply <- decode.optional_field("legalStatusOfSupply", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductpackaged(package_item:,batch_identifier:,manufacturer:,marketing_authorization:,marketing_status:,legal_status_of_supply:,description:,subject:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPharmaceutical#resource
pub type Medicinalproductpharmaceutical
{
Medicinalproductpharmaceutical(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
administrable_dose_form: Codeableconcept,
unit_of_presentation: Option(Codeableconcept),
ingredient: List(Reference),
device: List(Reference),
characteristics: List(MedicinalproductpharmaceuticalCharacteristics),
route_of_administration: List(MedicinalproductpharmaceuticalRouteofadministration),
)
}

pub fn medicinalproductpharmaceutical_new(administrable_dose_form administrable_dose_form: Codeableconcept,) ->Medicinalproductpharmaceutical{Medicinalproductpharmaceutical(route_of_administration: [],characteristics: [],device: [],ingredient: [],unit_of_presentation: None,administrable_dose_form:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPharmaceutical#resource
pub type MedicinalproductpharmaceuticalCharacteristics
{
MedicinalproductpharmaceuticalCharacteristics(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
status: Option(Codeableconcept),
)
}

pub fn medicinalproductpharmaceutical_characteristics_new(code code: Codeableconcept,) ->MedicinalproductpharmaceuticalCharacteristics{MedicinalproductpharmaceuticalCharacteristics(status: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPharmaceutical#resource
pub type MedicinalproductpharmaceuticalRouteofadministration
{
MedicinalproductpharmaceuticalRouteofadministration(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
first_dose: Option(Quantity),
max_single_dose: Option(Quantity),
max_dose_per_day: Option(Quantity),
max_dose_per_treatment_period: Option(Ratio),
max_treatment_period: Option(Duration),
target_species: List(MedicinalproductpharmaceuticalRouteofadministrationTargetspecies),
)
}

pub fn medicinalproductpharmaceutical_routeofadministration_new(code code: Codeableconcept,) ->MedicinalproductpharmaceuticalRouteofadministration{MedicinalproductpharmaceuticalRouteofadministration(target_species: [],max_treatment_period: None,max_dose_per_treatment_period: None,max_dose_per_day: None,max_single_dose: None,first_dose: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPharmaceutical#resource
pub type MedicinalproductpharmaceuticalRouteofadministrationTargetspecies
{
MedicinalproductpharmaceuticalRouteofadministrationTargetspecies(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
withdrawal_period: List(MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod),
)
}

pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_new(code code: Codeableconcept,) ->MedicinalproductpharmaceuticalRouteofadministrationTargetspecies{MedicinalproductpharmaceuticalRouteofadministrationTargetspecies(withdrawal_period: [],code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductPharmaceutical#resource
pub type MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod
{
MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
tissue: Codeableconcept,
value: Quantity,
supporting_information: Option(String),
)
}

pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod_new(value value: Quantity,tissue tissue: Codeableconcept,) ->MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod{MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod(supporting_information: None,value:,tissue:,modifier_extension: [],extension: [],id: None,)
}

pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod_to_json(medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod: MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod) -> Json {
    let MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod(supporting_information:,value:,tissue:,modifier_extension:,extension:,id:,) = medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod
    let fields = [#("value", quantity_to_json(value)),#("tissue", codeableconcept_to_json(tissue)),]
let fields = case supporting_information {
                          Some(v) -> [#("supportingInformation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod_decoder() -> Decoder(MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod) {use supporting_information <- decode.optional_field("supportingInformation", None, decode.optional(decode.string))
use value <- decode.field("value",quantity_decoder())
use tissue <- decode.field("tissue",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpharmaceuticalRouteofadministrationTargetspeciesWithdrawalperiod(supporting_information:,value:,tissue:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_to_json(medicinalproductpharmaceutical_routeofadministration_targetspecies: MedicinalproductpharmaceuticalRouteofadministrationTargetspecies) -> Json {
    let MedicinalproductpharmaceuticalRouteofadministrationTargetspecies(withdrawal_period:,code:,modifier_extension:,extension:,id:,) = medicinalproductpharmaceutical_routeofadministration_targetspecies
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case withdrawal_period {
                        [] -> fields
                        _ -> [#("withdrawalPeriod", json.array(withdrawal_period,medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpharmaceutical_routeofadministration_targetspecies_decoder() -> Decoder(MedicinalproductpharmaceuticalRouteofadministrationTargetspecies) {use withdrawal_period <- decode.optional_field("withdrawalPeriod", [], decode.list(medicinalproductpharmaceutical_routeofadministration_targetspecies_withdrawalperiod_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpharmaceuticalRouteofadministrationTargetspecies(withdrawal_period:,code:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpharmaceutical_routeofadministration_to_json(medicinalproductpharmaceutical_routeofadministration: MedicinalproductpharmaceuticalRouteofadministration) -> Json {
    let MedicinalproductpharmaceuticalRouteofadministration(target_species:,max_treatment_period:,max_dose_per_treatment_period:,max_dose_per_day:,max_single_dose:,first_dose:,code:,modifier_extension:,extension:,id:,) = medicinalproductpharmaceutical_routeofadministration
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case target_species {
                        [] -> fields
                        _ -> [#("targetSpecies", json.array(target_species,medicinalproductpharmaceutical_routeofadministration_targetspecies_to_json)), ..fields]
                          }
let fields = case max_treatment_period {
                          Some(v) -> [#("maxTreatmentPeriod", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max_dose_per_treatment_period {
                          Some(v) -> [#("maxDosePerTreatmentPeriod", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max_dose_per_day {
                          Some(v) -> [#("maxDosePerDay", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case max_single_dose {
                          Some(v) -> [#("maxSingleDose", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case first_dose {
                          Some(v) -> [#("firstDose", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpharmaceutical_routeofadministration_decoder() -> Decoder(MedicinalproductpharmaceuticalRouteofadministration) {use target_species <- decode.optional_field("targetSpecies", [], decode.list(medicinalproductpharmaceutical_routeofadministration_targetspecies_decoder()))
use max_treatment_period <- decode.optional_field("maxTreatmentPeriod", None, decode.optional(duration_decoder()))
use max_dose_per_treatment_period <- decode.optional_field("maxDosePerTreatmentPeriod", None, decode.optional(ratio_decoder()))
use max_dose_per_day <- decode.optional_field("maxDosePerDay", None, decode.optional(quantity_decoder()))
use max_single_dose <- decode.optional_field("maxSingleDose", None, decode.optional(quantity_decoder()))
use first_dose <- decode.optional_field("firstDose", None, decode.optional(quantity_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpharmaceuticalRouteofadministration(target_species:,max_treatment_period:,max_dose_per_treatment_period:,max_dose_per_day:,max_single_dose:,first_dose:,code:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpharmaceutical_characteristics_to_json(medicinalproductpharmaceutical_characteristics: MedicinalproductpharmaceuticalCharacteristics) -> Json {
    let MedicinalproductpharmaceuticalCharacteristics(status:,code:,modifier_extension:,extension:,id:,) = medicinalproductpharmaceutical_characteristics
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpharmaceutical_characteristics_decoder() -> Decoder(MedicinalproductpharmaceuticalCharacteristics) {use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MedicinalproductpharmaceuticalCharacteristics(status:,code:,modifier_extension:,extension:,id:,))}
pub fn medicinalproductpharmaceutical_to_json(medicinalproductpharmaceutical: Medicinalproductpharmaceutical) -> Json {
    let Medicinalproductpharmaceutical(route_of_administration:,characteristics:,device:,ingredient:,unit_of_presentation:,administrable_dose_form:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductpharmaceutical
    let fields = [#("administrableDoseForm", codeableconcept_to_json(administrable_dose_form)),]
let fields = case route_of_administration {
                        [] -> fields
                        _ -> [#("routeOfAdministration", json.array(route_of_administration,medicinalproductpharmaceutical_routeofadministration_to_json)), ..fields]
                          }
let fields = case characteristics {
                        [] -> fields
                        _ -> [#("characteristics", json.array(characteristics,medicinalproductpharmaceutical_characteristics_to_json)), ..fields]
                          }
let fields = case device {
                        [] -> fields
                        _ -> [#("device", json.array(device,reference_to_json)), ..fields]
                          }
let fields = case ingredient {
                        [] -> fields
                        _ -> [#("ingredient", json.array(ingredient,reference_to_json)), ..fields]
                          }
let fields = case unit_of_presentation {
                          Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductpharmaceutical_decoder() -> Decoder(Medicinalproductpharmaceutical) {use route_of_administration <- decode.optional_field("routeOfAdministration", [], decode.list(medicinalproductpharmaceutical_routeofadministration_decoder()))
use characteristics <- decode.optional_field("characteristics", [], decode.list(medicinalproductpharmaceutical_characteristics_decoder()))
use device <- decode.optional_field("device", [], decode.list(reference_decoder()))
use ingredient <- decode.optional_field("ingredient", [], decode.list(reference_decoder()))
use unit_of_presentation <- decode.optional_field("unitOfPresentation", None, decode.optional(codeableconcept_decoder()))
use administrable_dose_form <- decode.field("administrableDoseForm",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductpharmaceutical(route_of_administration:,characteristics:,device:,ingredient:,unit_of_presentation:,administrable_dose_form:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MedicinalProductUndesirableEffect#resource
pub type Medicinalproductundesirableeffect
{
Medicinalproductundesirableeffect(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
subject: List(Reference),
symptom_condition_effect: Option(Codeableconcept),
classification: Option(Codeableconcept),
frequency_of_occurrence: Option(Codeableconcept),
population: List(Population),
)
}

pub fn medicinalproductundesirableeffect_new() ->Medicinalproductundesirableeffect{Medicinalproductundesirableeffect(population: [],frequency_of_occurrence: None,classification: None,symptom_condition_effect: None,subject: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn medicinalproductundesirableeffect_to_json(medicinalproductundesirableeffect: Medicinalproductundesirableeffect) -> Json {
    let Medicinalproductundesirableeffect(population:,frequency_of_occurrence:,classification:,symptom_condition_effect:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = medicinalproductundesirableeffect
    let fields = []
let fields = case population {
                        [] -> fields
                        _ -> [#("population", json.array(population,population_to_json)), ..fields]
                          }
let fields = case frequency_of_occurrence {
                          Some(v) -> [#("frequencyOfOccurrence", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case classification {
                          Some(v) -> [#("classification", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case symptom_condition_effect {
                          Some(v) -> [#("symptomConditionEffect", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                        [] -> fields
                        _ -> [#("subject", json.array(subject,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn medicinalproductundesirableeffect_decoder() -> Decoder(Medicinalproductundesirableeffect) {use population <- decode.optional_field("population", [], decode.list(population_decoder()))
use frequency_of_occurrence <- decode.optional_field("frequencyOfOccurrence", None, decode.optional(codeableconcept_decoder()))
use classification <- decode.optional_field("classification", None, decode.optional(codeableconcept_decoder()))
use symptom_condition_effect <- decode.optional_field("symptomConditionEffect", None, decode.optional(codeableconcept_decoder()))
use subject <- decode.optional_field("subject", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Medicinalproductundesirableeffect(population:,frequency_of_occurrence:,classification:,symptom_condition_effect:,subject:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MessageDefinition#resource
pub type Messagedefinition
{
Messagedefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
replaces: List(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: String,
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
base: Option(String),
parent: List(String),
event: MessagedefinitionEvent,
category: Option(r4valuesets.Messagesignificancecategory),
focus: List(MessagedefinitionFocus),
response_required: Option(r4valuesets.Messageheaderresponserequest),
allowed_response: List(MessagedefinitionAllowedresponse),
graph: List(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionEvent{
MessagedefinitionEventCoding(event: Coding)
MessagedefinitionEventUri(event: String)}
pub fn messagedefinition_event_to_json(elt: MessagedefinitionEvent) -> Json {case elt{MessagedefinitionEventCoding(v) -> coding_to_json(v)
MessagedefinitionEventUri(v) -> json.string(v)
}}
pub fn messagedefinition_event_decoder() -> Decoder(MessagedefinitionEvent){decode.one_of(decode.field("eventCoding", coding_decoder(), decode.success) |> decode.map(MessagedefinitionEventCoding),[decode.field("eventUri", decode.string, decode.success) |> decode.map(MessagedefinitionEventUri),])}
pub fn messagedefinition_new(event event: MessagedefinitionEvent,date date: String,status status: r4valuesets.Publicationstatus,) ->Messagedefinition{Messagedefinition(graph: [],allowed_response: [],response_required: None,focus: [],category: None,event:,parent: [],base: None,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date:,experimental: None,status:,replaces: [],title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionFocus
{
MessagedefinitionFocus(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: r4valuesets.Resourcetypes,
profile: Option(String),
min: Int,
max: Option(String),
)
}

pub fn messagedefinition_focus_new(min min: Int,code code: r4valuesets.Resourcetypes,) ->MessagedefinitionFocus{MessagedefinitionFocus(max: None,min:,profile: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionAllowedresponse
{
MessagedefinitionAllowedresponse(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
message: String,
situation: Option(String),
)
}

pub fn messagedefinition_allowedresponse_new(message message: String,) ->MessagedefinitionAllowedresponse{MessagedefinitionAllowedresponse(situation: None,message:,modifier_extension: [],extension: [],id: None,)
}

pub fn messagedefinition_allowedresponse_to_json(messagedefinition_allowedresponse: MessagedefinitionAllowedresponse) -> Json {
    let MessagedefinitionAllowedresponse(situation:,message:,modifier_extension:,extension:,id:,) = messagedefinition_allowedresponse
    let fields = [#("message", json.string(message)),]
let fields = case situation {
                          Some(v) -> [#("situation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messagedefinition_allowedresponse_decoder() -> Decoder(MessagedefinitionAllowedresponse) {use situation <- decode.optional_field("situation", None, decode.optional(decode.string))
use message <- decode.field("message",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MessagedefinitionAllowedresponse(situation:,message:,modifier_extension:,extension:,id:,))}
pub fn messagedefinition_focus_to_json(messagedefinition_focus: MessagedefinitionFocus) -> Json {
    let MessagedefinitionFocus(max:,min:,profile:,code:,modifier_extension:,extension:,id:,) = messagedefinition_focus
    let fields = [#("min", json.int(min)),#("code", r4valuesets.resourcetypes_to_json(code)),]
let fields = case max {
                          Some(v) -> [#("max", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case profile {
                          Some(v) -> [#("profile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messagedefinition_focus_decoder() -> Decoder(MessagedefinitionFocus) {use max <- decode.optional_field("max", None, decode.optional(decode.string))
use min <- decode.field("min",decode.int)
use profile <- decode.optional_field("profile", None, decode.optional(decode.string))
use code <- decode.field("code",r4valuesets.resourcetypes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MessagedefinitionFocus(max:,min:,profile:,code:,modifier_extension:,extension:,id:,))}
pub fn messagedefinition_to_json(messagedefinition: Messagedefinition) -> Json {
    let Messagedefinition(graph:,allowed_response:,response_required:,focus:,category:,event:,parent:,base:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,replaces:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = messagedefinition
    let fields = [#("event", messagedefinition_event_to_json(event)),#("date", json.string(date)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case graph {
                        [] -> fields
                        _ -> [#("graph", json.array(graph,json.string)), ..fields]
                          }
let fields = case allowed_response {
                        [] -> fields
                        _ -> [#("allowedResponse", json.array(allowed_response,messagedefinition_allowedresponse_to_json)), ..fields]
                          }
let fields = case response_required {
                          Some(v) -> [#("responseRequired", r4valuesets.messageheaderresponserequest_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case focus {
                        [] -> fields
                        _ -> [#("focus", json.array(focus,messagedefinition_focus_to_json)), ..fields]
                          }
let fields = case category {
                          Some(v) -> [#("category", r4valuesets.messagesignificancecategory_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parent {
                        [] -> fields
                        _ -> [#("parent", json.array(parent,json.string)), ..fields]
                          }
let fields = case base {
                          Some(v) -> [#("base", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,json.string)), ..fields]
                          }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messagedefinition_decoder() -> Decoder(Messagedefinition) {use graph <- decode.optional_field("graph", [], decode.list(decode.string))
use allowed_response <- decode.optional_field("allowedResponse", [], decode.list(messagedefinition_allowedresponse_decoder()))
use response_required <- decode.optional_field("responseRequired", None, decode.optional(r4valuesets.messageheaderresponserequest_decoder()))
use focus <- decode.optional_field("focus", [], decode.list(messagedefinition_focus_decoder()))
use category <- decode.optional_field("category", None, decode.optional(r4valuesets.messagesignificancecategory_decoder()))
use event <- decode.then(messagedefinition_event_decoder())
use parent <- decode.optional_field("parent", [], decode.list(decode.string))
use base <- decode.optional_field("base", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.field("date",decode.string)
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use replaces <- decode.optional_field("replaces", [], decode.list(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Messagedefinition(graph:,allowed_response:,response_required:,focus:,category:,event:,parent:,base:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,replaces:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MessageHeader#resource
pub type Messageheader
{
Messageheader(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
event: MessageheaderEvent,
destination: List(MessageheaderDestination),
sender: Option(Reference),
enterer: Option(Reference),
author: Option(Reference),
source: MessageheaderSource,
responsible: Option(Reference),
reason: Option(Codeableconcept),
response: Option(MessageheaderResponse),
focus: List(Reference),
definition: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/MessageHeader#resource
pub type MessageheaderEvent{
MessageheaderEventCoding(event: Coding)
MessageheaderEventUri(event: String)}
pub fn messageheader_event_to_json(elt: MessageheaderEvent) -> Json {case elt{MessageheaderEventCoding(v) -> coding_to_json(v)
MessageheaderEventUri(v) -> json.string(v)
}}
pub fn messageheader_event_decoder() -> Decoder(MessageheaderEvent){decode.one_of(decode.field("eventCoding", coding_decoder(), decode.success) |> decode.map(MessageheaderEventCoding),[decode.field("eventUri", decode.string, decode.success) |> decode.map(MessageheaderEventUri),])}
pub fn messageheader_new(source source: MessageheaderSource,event event: MessageheaderEvent,) ->Messageheader{Messageheader(definition: None,focus: [],response: None,reason: None,responsible: None,source:,author: None,enterer: None,sender: None,destination: [],event:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MessageHeader#resource
pub type MessageheaderDestination
{
MessageheaderDestination(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: Option(String),
target: Option(Reference),
endpoint: String,
receiver: Option(Reference),
)
}

pub fn messageheader_destination_new(endpoint endpoint: String,) ->MessageheaderDestination{MessageheaderDestination(receiver: None,endpoint:,target: None,name: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MessageHeader#resource
pub type MessageheaderSource
{
MessageheaderSource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: Option(String),
software: Option(String),
version: Option(String),
contact: Option(Contactpoint),
endpoint: String,
)
}

pub fn messageheader_source_new(endpoint endpoint: String,) ->MessageheaderSource{MessageheaderSource(endpoint:,contact: None,version: None,software: None,name: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MessageHeader#resource
pub type MessageheaderResponse
{
MessageheaderResponse(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: String,
code: r4valuesets.Responsecode,
details: Option(Reference),
)
}

pub fn messageheader_response_new(code code: r4valuesets.Responsecode,identifier identifier: String,) ->MessageheaderResponse{MessageheaderResponse(details: None,code:,identifier:,modifier_extension: [],extension: [],id: None,)
}

pub fn messageheader_response_to_json(messageheader_response: MessageheaderResponse) -> Json {
    let MessageheaderResponse(details:,code:,identifier:,modifier_extension:,extension:,id:,) = messageheader_response
    let fields = [#("code", r4valuesets.responsecode_to_json(code)),#("identifier", json.string(identifier)),]
let fields = case details {
                          Some(v) -> [#("details", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messageheader_response_decoder() -> Decoder(MessageheaderResponse) {use details <- decode.optional_field("details", None, decode.optional(reference_decoder()))
use code <- decode.field("code",r4valuesets.responsecode_decoder())
use identifier <- decode.field("identifier",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MessageheaderResponse(details:,code:,identifier:,modifier_extension:,extension:,id:,))}
pub fn messageheader_source_to_json(messageheader_source: MessageheaderSource) -> Json {
    let MessageheaderSource(endpoint:,contact:,version:,software:,name:,modifier_extension:,extension:,id:,) = messageheader_source
    let fields = [#("endpoint", json.string(endpoint)),]
let fields = case contact {
                          Some(v) -> [#("contact", contactpoint_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case software {
                          Some(v) -> [#("software", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messageheader_source_decoder() -> Decoder(MessageheaderSource) {use endpoint <- decode.field("endpoint",decode.string)
use contact <- decode.optional_field("contact", None, decode.optional(contactpoint_decoder()))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use software <- decode.optional_field("software", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MessageheaderSource(endpoint:,contact:,version:,software:,name:,modifier_extension:,extension:,id:,))}
pub fn messageheader_destination_to_json(messageheader_destination: MessageheaderDestination) -> Json {
    let MessageheaderDestination(receiver:,endpoint:,target:,name:,modifier_extension:,extension:,id:,) = messageheader_destination
    let fields = [#("endpoint", json.string(endpoint)),]
let fields = case receiver {
                          Some(v) -> [#("receiver", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                          Some(v) -> [#("target", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messageheader_destination_decoder() -> Decoder(MessageheaderDestination) {use receiver <- decode.optional_field("receiver", None, decode.optional(reference_decoder()))
use endpoint <- decode.field("endpoint",decode.string)
use target <- decode.optional_field("target", None, decode.optional(reference_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MessageheaderDestination(receiver:,endpoint:,target:,name:,modifier_extension:,extension:,id:,))}
pub fn messageheader_to_json(messageheader: Messageheader) -> Json {
    let Messageheader(definition:,focus:,response:,reason:,responsible:,source:,author:,enterer:,sender:,destination:,event:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = messageheader
    let fields = [#("source", messageheader_source_to_json(source)),#("event", messageheader_event_to_json(event)),]
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case focus {
                        [] -> fields
                        _ -> [#("focus", json.array(focus,reference_to_json)), ..fields]
                          }
let fields = case response {
                          Some(v) -> [#("response", messageheader_response_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason {
                          Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enterer {
                          Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sender {
                          Some(v) -> [#("sender", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case destination {
                        [] -> fields
                        _ -> [#("destination", json.array(destination,messageheader_destination_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn messageheader_decoder() -> Decoder(Messageheader) {use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use focus <- decode.optional_field("focus", [], decode.list(reference_decoder()))
use response <- decode.optional_field("response", None, decode.optional(messageheader_response_decoder()))
use reason <- decode.optional_field("reason", None, decode.optional(codeableconcept_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(reference_decoder()))
use source <- decode.field("source",messageheader_source_decoder())
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use enterer <- decode.optional_field("enterer", None, decode.optional(reference_decoder()))
use sender <- decode.optional_field("sender", None, decode.optional(reference_decoder()))
use destination <- decode.optional_field("destination", [], decode.list(messageheader_destination_decoder()))
use event <- decode.then(messageheader_event_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Messageheader(definition:,focus:,response:,reason:,responsible:,source:,author:,enterer:,sender:,destination:,event:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type Molecularsequence
{
Molecularsequence(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
type_: Option(r4valuesets.Sequencetype),
coordinate_system: Int,
patient: Option(Reference),
specimen: Option(Reference),
device: Option(Reference),
performer: Option(Reference),
quantity: Option(Quantity),
reference_seq: Option(MolecularsequenceReferenceseq),
variant: List(MolecularsequenceVariant),
observed_seq: Option(String),
quality: List(MolecularsequenceQuality),
read_coverage: Option(Int),
repository: List(MolecularsequenceRepository),
pointer: List(Reference),
structure_variant: List(MolecularsequenceStructurevariant),
)
}

pub fn molecularsequence_new(coordinate_system coordinate_system: Int,) ->Molecularsequence{Molecularsequence(structure_variant: [],pointer: [],repository: [],read_coverage: None,quality: [],observed_seq: None,variant: [],reference_seq: None,quantity: None,performer: None,device: None,specimen: None,patient: None,coordinate_system:,type_: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceReferenceseq
{
MolecularsequenceReferenceseq(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
chromosome: Option(Codeableconcept),
genome_build: Option(String),
orientation: Option(r4valuesets.Orientationtype),
reference_seq_id: Option(Codeableconcept),
reference_seq_pointer: Option(Reference),
reference_seq_string: Option(String),
strand: Option(r4valuesets.Strandtype),
window_start: Option(Int),
window_end: Option(Int),
)
}

pub fn molecularsequence_referenceseq_new() ->MolecularsequenceReferenceseq{MolecularsequenceReferenceseq(window_end: None,window_start: None,strand: None,reference_seq_string: None,reference_seq_pointer: None,reference_seq_id: None,orientation: None,genome_build: None,chromosome: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceVariant
{
MolecularsequenceVariant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
start: Option(Int),
end: Option(Int),
observed_allele: Option(String),
reference_allele: Option(String),
cigar: Option(String),
variant_pointer: Option(Reference),
)
}

pub fn molecularsequence_variant_new() ->MolecularsequenceVariant{MolecularsequenceVariant(variant_pointer: None,cigar: None,reference_allele: None,observed_allele: None,end: None,start: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceQuality
{
MolecularsequenceQuality(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Qualitytype,
standard_sequence: Option(Codeableconcept),
start: Option(Int),
end: Option(Int),
score: Option(Quantity),
method: Option(Codeableconcept),
truth_tp: Option(Float),
query_tp: Option(Float),
truth_fn: Option(Float),
query_fp: Option(Float),
gt_fp: Option(Float),
precision: Option(Float),
recall: Option(Float),
f_score: Option(Float),
roc: Option(MolecularsequenceQualityRoc),
)
}

pub fn molecularsequence_quality_new(type_ type_: r4valuesets.Qualitytype,) ->MolecularsequenceQuality{MolecularsequenceQuality(roc: None,f_score: None,recall: None,precision: None,gt_fp: None,query_fp: None,truth_fn: None,query_tp: None,truth_tp: None,method: None,score: None,end: None,start: None,standard_sequence: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceQualityRoc
{
MolecularsequenceQualityRoc(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
score: List(Int),
num_tp: List(Int),
num_fp: List(Int),
num_fn: List(Int),
precision: List(Float),
sensitivity: List(Float),
f_measure: List(Float),
)
}

pub fn molecularsequence_quality_roc_new() ->MolecularsequenceQualityRoc{MolecularsequenceQualityRoc(f_measure: [],sensitivity: [],precision: [],num_fn: [],num_fp: [],num_tp: [],score: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRepository
{
MolecularsequenceRepository(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Repositorytype,
url: Option(String),
name: Option(String),
dataset_id: Option(String),
variantset_id: Option(String),
readset_id: Option(String),
)
}

pub fn molecularsequence_repository_new(type_ type_: r4valuesets.Repositorytype,) ->MolecularsequenceRepository{MolecularsequenceRepository(readset_id: None,variantset_id: None,dataset_id: None,name: None,url: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariant
{
MolecularsequenceStructurevariant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
variant_type: Option(Codeableconcept),
exact: Option(Bool),
length: Option(Int),
outer: Option(MolecularsequenceStructurevariantOuter),
inner: Option(MolecularsequenceStructurevariantInner),
)
}

pub fn molecularsequence_structurevariant_new() ->MolecularsequenceStructurevariant{MolecularsequenceStructurevariant(inner: None,outer: None,length: None,exact: None,variant_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariantOuter
{
MolecularsequenceStructurevariantOuter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
start: Option(Int),
end: Option(Int),
)
}

pub fn molecularsequence_structurevariant_outer_new() ->MolecularsequenceStructurevariantOuter{MolecularsequenceStructurevariantOuter(end: None,start: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceStructurevariantInner
{
MolecularsequenceStructurevariantInner(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
start: Option(Int),
end: Option(Int),
)
}

pub fn molecularsequence_structurevariant_inner_new() ->MolecularsequenceStructurevariantInner{MolecularsequenceStructurevariantInner(end: None,start: None,modifier_extension: [],extension: [],id: None,)
}

pub fn molecularsequence_structurevariant_inner_to_json(molecularsequence_structurevariant_inner: MolecularsequenceStructurevariantInner) -> Json {
    let MolecularsequenceStructurevariantInner(end:,start:,modifier_extension:,extension:,id:,) = molecularsequence_structurevariant_inner
    let fields = []
let fields = case end {
                          Some(v) -> [#("end", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_structurevariant_inner_decoder() -> Decoder(MolecularsequenceStructurevariantInner) {use end <- decode.optional_field("end", None, decode.optional(decode.int))
use start <- decode.optional_field("start", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceStructurevariantInner(end:,start:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_structurevariant_outer_to_json(molecularsequence_structurevariant_outer: MolecularsequenceStructurevariantOuter) -> Json {
    let MolecularsequenceStructurevariantOuter(end:,start:,modifier_extension:,extension:,id:,) = molecularsequence_structurevariant_outer
    let fields = []
let fields = case end {
                          Some(v) -> [#("end", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_structurevariant_outer_decoder() -> Decoder(MolecularsequenceStructurevariantOuter) {use end <- decode.optional_field("end", None, decode.optional(decode.int))
use start <- decode.optional_field("start", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceStructurevariantOuter(end:,start:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_structurevariant_to_json(molecularsequence_structurevariant: MolecularsequenceStructurevariant) -> Json {
    let MolecularsequenceStructurevariant(inner:,outer:,length:,exact:,variant_type:,modifier_extension:,extension:,id:,) = molecularsequence_structurevariant
    let fields = []
let fields = case inner {
                          Some(v) -> [#("inner", molecularsequence_structurevariant_inner_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case outer {
                          Some(v) -> [#("outer", molecularsequence_structurevariant_outer_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case length {
                          Some(v) -> [#("length", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case exact {
                          Some(v) -> [#("exact", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case variant_type {
                          Some(v) -> [#("variantType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_structurevariant_decoder() -> Decoder(MolecularsequenceStructurevariant) {use inner <- decode.optional_field("inner", None, decode.optional(molecularsequence_structurevariant_inner_decoder()))
use outer <- decode.optional_field("outer", None, decode.optional(molecularsequence_structurevariant_outer_decoder()))
use length <- decode.optional_field("length", None, decode.optional(decode.int))
use exact <- decode.optional_field("exact", None, decode.optional(decode.bool))
use variant_type <- decode.optional_field("variantType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceStructurevariant(inner:,outer:,length:,exact:,variant_type:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_repository_to_json(molecularsequence_repository: MolecularsequenceRepository) -> Json {
    let MolecularsequenceRepository(readset_id:,variantset_id:,dataset_id:,name:,url:,type_:,modifier_extension:,extension:,id:,) = molecularsequence_repository
    let fields = [#("type", r4valuesets.repositorytype_to_json(type_)),]
let fields = case readset_id {
                          Some(v) -> [#("readsetId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case variantset_id {
                          Some(v) -> [#("variantsetId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case dataset_id {
                          Some(v) -> [#("datasetId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_repository_decoder() -> Decoder(MolecularsequenceRepository) {use readset_id <- decode.optional_field("readsetId", None, decode.optional(decode.string))
use variantset_id <- decode.optional_field("variantsetId", None, decode.optional(decode.string))
use dataset_id <- decode.optional_field("datasetId", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.repositorytype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceRepository(readset_id:,variantset_id:,dataset_id:,name:,url:,type_:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_quality_roc_to_json(molecularsequence_quality_roc: MolecularsequenceQualityRoc) -> Json {
    let MolecularsequenceQualityRoc(f_measure:,sensitivity:,precision:,num_fn:,num_fp:,num_tp:,score:,modifier_extension:,extension:,id:,) = molecularsequence_quality_roc
    let fields = []
let fields = case f_measure {
                        [] -> fields
                        _ -> [#("fMeasure", json.array(f_measure,json.float)), ..fields]
                          }
let fields = case sensitivity {
                        [] -> fields
                        _ -> [#("sensitivity", json.array(sensitivity,json.float)), ..fields]
                          }
let fields = case precision {
                        [] -> fields
                        _ -> [#("precision", json.array(precision,json.float)), ..fields]
                          }
let fields = case num_fn {
                        [] -> fields
                        _ -> [#("numFN", json.array(num_fn,json.int)), ..fields]
                          }
let fields = case num_fp {
                        [] -> fields
                        _ -> [#("numFP", json.array(num_fp,json.int)), ..fields]
                          }
let fields = case num_tp {
                        [] -> fields
                        _ -> [#("numTP", json.array(num_tp,json.int)), ..fields]
                          }
let fields = case score {
                        [] -> fields
                        _ -> [#("score", json.array(score,json.int)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_quality_roc_decoder() -> Decoder(MolecularsequenceQualityRoc) {use f_measure <- decode.optional_field("fMeasure", [], decode.list(decode.float))
use sensitivity <- decode.optional_field("sensitivity", [], decode.list(decode.float))
use precision <- decode.optional_field("precision", [], decode.list(decode.float))
use num_fn <- decode.optional_field("numFN", [], decode.list(decode.int))
use num_fp <- decode.optional_field("numFP", [], decode.list(decode.int))
use num_tp <- decode.optional_field("numTP", [], decode.list(decode.int))
use score <- decode.optional_field("score", [], decode.list(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceQualityRoc(f_measure:,sensitivity:,precision:,num_fn:,num_fp:,num_tp:,score:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_quality_to_json(molecularsequence_quality: MolecularsequenceQuality) -> Json {
    let MolecularsequenceQuality(roc:,f_score:,recall:,precision:,gt_fp:,query_fp:,truth_fn:,query_tp:,truth_tp:,method:,score:,end:,start:,standard_sequence:,type_:,modifier_extension:,extension:,id:,) = molecularsequence_quality
    let fields = [#("type", r4valuesets.qualitytype_to_json(type_)),]
let fields = case roc {
                          Some(v) -> [#("roc", molecularsequence_quality_roc_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case f_score {
                          Some(v) -> [#("fScore", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case recall {
                          Some(v) -> [#("recall", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case precision {
                          Some(v) -> [#("precision", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case gt_fp {
                          Some(v) -> [#("gtFP", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case query_fp {
                          Some(v) -> [#("queryFP", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case truth_fn {
                          Some(v) -> [#("truthFN", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case query_tp {
                          Some(v) -> [#("queryTP", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case truth_tp {
                          Some(v) -> [#("truthTP", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case score {
                          Some(v) -> [#("score", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case end {
                          Some(v) -> [#("end", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case standard_sequence {
                          Some(v) -> [#("standardSequence", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_quality_decoder() -> Decoder(MolecularsequenceQuality) {use roc <- decode.optional_field("roc", None, decode.optional(molecularsequence_quality_roc_decoder()))
use f_score <- decode.optional_field("fScore", None, decode.optional(decode.float))
use recall <- decode.optional_field("recall", None, decode.optional(decode.float))
use precision <- decode.optional_field("precision", None, decode.optional(decode.float))
use gt_fp <- decode.optional_field("gtFP", None, decode.optional(decode.float))
use query_fp <- decode.optional_field("queryFP", None, decode.optional(decode.float))
use truth_fn <- decode.optional_field("truthFN", None, decode.optional(decode.float))
use query_tp <- decode.optional_field("queryTP", None, decode.optional(decode.float))
use truth_tp <- decode.optional_field("truthTP", None, decode.optional(decode.float))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use score <- decode.optional_field("score", None, decode.optional(quantity_decoder()))
use end <- decode.optional_field("end", None, decode.optional(decode.int))
use start <- decode.optional_field("start", None, decode.optional(decode.int))
use standard_sequence <- decode.optional_field("standardSequence", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",r4valuesets.qualitytype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceQuality(roc:,f_score:,recall:,precision:,gt_fp:,query_fp:,truth_fn:,query_tp:,truth_tp:,method:,score:,end:,start:,standard_sequence:,type_:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_variant_to_json(molecularsequence_variant: MolecularsequenceVariant) -> Json {
    let MolecularsequenceVariant(variant_pointer:,cigar:,reference_allele:,observed_allele:,end:,start:,modifier_extension:,extension:,id:,) = molecularsequence_variant
    let fields = []
let fields = case variant_pointer {
                          Some(v) -> [#("variantPointer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case cigar {
                          Some(v) -> [#("cigar", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case reference_allele {
                          Some(v) -> [#("referenceAllele", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case observed_allele {
                          Some(v) -> [#("observedAllele", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case end {
                          Some(v) -> [#("end", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case start {
                          Some(v) -> [#("start", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_variant_decoder() -> Decoder(MolecularsequenceVariant) {use variant_pointer <- decode.optional_field("variantPointer", None, decode.optional(reference_decoder()))
use cigar <- decode.optional_field("cigar", None, decode.optional(decode.string))
use reference_allele <- decode.optional_field("referenceAllele", None, decode.optional(decode.string))
use observed_allele <- decode.optional_field("observedAllele", None, decode.optional(decode.string))
use end <- decode.optional_field("end", None, decode.optional(decode.int))
use start <- decode.optional_field("start", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceVariant(variant_pointer:,cigar:,reference_allele:,observed_allele:,end:,start:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_referenceseq_to_json(molecularsequence_referenceseq: MolecularsequenceReferenceseq) -> Json {
    let MolecularsequenceReferenceseq(window_end:,window_start:,strand:,reference_seq_string:,reference_seq_pointer:,reference_seq_id:,orientation:,genome_build:,chromosome:,modifier_extension:,extension:,id:,) = molecularsequence_referenceseq
    let fields = []
let fields = case window_end {
                          Some(v) -> [#("windowEnd", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case window_start {
                          Some(v) -> [#("windowStart", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case strand {
                          Some(v) -> [#("strand", r4valuesets.strandtype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reference_seq_string {
                          Some(v) -> [#("referenceSeqString", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case reference_seq_pointer {
                          Some(v) -> [#("referenceSeqPointer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reference_seq_id {
                          Some(v) -> [#("referenceSeqId", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case orientation {
                          Some(v) -> [#("orientation", r4valuesets.orientationtype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case genome_build {
                          Some(v) -> [#("genomeBuild", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case chromosome {
                          Some(v) -> [#("chromosome", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_referenceseq_decoder() -> Decoder(MolecularsequenceReferenceseq) {use window_end <- decode.optional_field("windowEnd", None, decode.optional(decode.int))
use window_start <- decode.optional_field("windowStart", None, decode.optional(decode.int))
use strand <- decode.optional_field("strand", None, decode.optional(r4valuesets.strandtype_decoder()))
use reference_seq_string <- decode.optional_field("referenceSeqString", None, decode.optional(decode.string))
use reference_seq_pointer <- decode.optional_field("referenceSeqPointer", None, decode.optional(reference_decoder()))
use reference_seq_id <- decode.optional_field("referenceSeqId", None, decode.optional(codeableconcept_decoder()))
use orientation <- decode.optional_field("orientation", None, decode.optional(r4valuesets.orientationtype_decoder()))
use genome_build <- decode.optional_field("genomeBuild", None, decode.optional(decode.string))
use chromosome <- decode.optional_field("chromosome", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(MolecularsequenceReferenceseq(window_end:,window_start:,strand:,reference_seq_string:,reference_seq_pointer:,reference_seq_id:,orientation:,genome_build:,chromosome:,modifier_extension:,extension:,id:,))}
pub fn molecularsequence_to_json(molecularsequence: Molecularsequence) -> Json {
    let Molecularsequence(structure_variant:,pointer:,repository:,read_coverage:,quality:,observed_seq:,variant:,reference_seq:,quantity:,performer:,device:,specimen:,patient:,coordinate_system:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = molecularsequence
    let fields = [#("coordinateSystem", json.int(coordinate_system)),]
let fields = case structure_variant {
                        [] -> fields
                        _ -> [#("structureVariant", json.array(structure_variant,molecularsequence_structurevariant_to_json)), ..fields]
                          }
let fields = case pointer {
                        [] -> fields
                        _ -> [#("pointer", json.array(pointer,reference_to_json)), ..fields]
                          }
let fields = case repository {
                        [] -> fields
                        _ -> [#("repository", json.array(repository,molecularsequence_repository_to_json)), ..fields]
                          }
let fields = case read_coverage {
                          Some(v) -> [#("readCoverage", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case quality {
                        [] -> fields
                        _ -> [#("quality", json.array(quality,molecularsequence_quality_to_json)), ..fields]
                          }
let fields = case observed_seq {
                          Some(v) -> [#("observedSeq", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case variant {
                        [] -> fields
                        _ -> [#("variant", json.array(variant,molecularsequence_variant_to_json)), ..fields]
                          }
let fields = case reference_seq {
                          Some(v) -> [#("referenceSeq", molecularsequence_referenceseq_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case device {
                          Some(v) -> [#("device", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specimen {
                          Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case patient {
                          Some(v) -> [#("patient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.sequencetype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn molecularsequence_decoder() -> Decoder(Molecularsequence) {use structure_variant <- decode.optional_field("structureVariant", [], decode.list(molecularsequence_structurevariant_decoder()))
use pointer <- decode.optional_field("pointer", [], decode.list(reference_decoder()))
use repository <- decode.optional_field("repository", [], decode.list(molecularsequence_repository_decoder()))
use read_coverage <- decode.optional_field("readCoverage", None, decode.optional(decode.int))
use quality <- decode.optional_field("quality", [], decode.list(molecularsequence_quality_decoder()))
use observed_seq <- decode.optional_field("observedSeq", None, decode.optional(decode.string))
use variant <- decode.optional_field("variant", [], decode.list(molecularsequence_variant_decoder()))
use reference_seq <- decode.optional_field("referenceSeq", None, decode.optional(molecularsequence_referenceseq_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use device <- decode.optional_field("device", None, decode.optional(reference_decoder()))
use specimen <- decode.optional_field("specimen", None, decode.optional(reference_decoder()))
use patient <- decode.optional_field("patient", None, decode.optional(reference_decoder()))
use coordinate_system <- decode.field("coordinateSystem",decode.int)
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.sequencetype_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Molecularsequence(structure_variant:,pointer:,repository:,read_coverage:,quality:,observed_seq:,variant:,reference_seq:,quantity:,performer:,device:,specimen:,patient:,coordinate_system:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/NamingSystem#resource
pub type Namingsystem
{
Namingsystem(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
status: r4valuesets.Publicationstatus,
kind: r4valuesets.Namingsystemtype,
date: String,
publisher: Option(String),
contact: List(Contactdetail),
responsible: Option(String),
type_: Option(Codeableconcept),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
usage: Option(String),
unique_id: List(NamingsystemUniqueid),
)
}

pub fn namingsystem_new(date date: String,kind kind: r4valuesets.Namingsystemtype,status status: r4valuesets.Publicationstatus,name name: String,) ->Namingsystem{Namingsystem(unique_id: [],usage: None,jurisdiction: [],use_context: [],description: None,type_: None,responsible: None,contact: [],publisher: None,date:,kind:,status:,name:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NamingSystem#resource
pub type NamingsystemUniqueid
{
NamingsystemUniqueid(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Namingsystemidentifiertype,
value: String,
preferred: Option(Bool),
comment: Option(String),
period: Option(Period),
)
}

pub fn namingsystem_uniqueid_new(value value: String,type_ type_: r4valuesets.Namingsystemidentifiertype,) ->NamingsystemUniqueid{NamingsystemUniqueid(period: None,comment: None,preferred: None,value:,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn namingsystem_uniqueid_to_json(namingsystem_uniqueid: NamingsystemUniqueid) -> Json {
    let NamingsystemUniqueid(period:,comment:,preferred:,value:,type_:,modifier_extension:,extension:,id:,) = namingsystem_uniqueid
    let fields = [#("value", json.string(value)),#("type", r4valuesets.namingsystemidentifiertype_to_json(type_)),]
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case preferred {
                          Some(v) -> [#("preferred", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn namingsystem_uniqueid_decoder() -> Decoder(NamingsystemUniqueid) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use preferred <- decode.optional_field("preferred", None, decode.optional(decode.bool))
use value <- decode.field("value",decode.string)
use type_ <- decode.field("type",r4valuesets.namingsystemidentifiertype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NamingsystemUniqueid(period:,comment:,preferred:,value:,type_:,modifier_extension:,extension:,id:,))}
pub fn namingsystem_to_json(namingsystem: Namingsystem) -> Json {
    let Namingsystem(unique_id:,usage:,jurisdiction:,use_context:,description:,type_:,responsible:,contact:,publisher:,date:,kind:,status:,name:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = namingsystem
    let fields = [#("date", json.string(date)),#("kind", r4valuesets.namingsystemtype_to_json(kind)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),]
let fields = case unique_id {
                        [] -> fields
                        _ -> [#("uniqueId", json.array(unique_id,namingsystem_uniqueid_to_json)), ..fields]
                          }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn namingsystem_decoder() -> Decoder(Namingsystem) {use unique_id <- decode.optional_field("uniqueId", [], decode.list(namingsystem_uniqueid_decoder()))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.field("date",decode.string)
use kind <- decode.field("kind",r4valuesets.namingsystemtype_decoder())
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Namingsystem(unique_id:,usage:,jurisdiction:,use_context:,description:,type_:,responsible:,contact:,publisher:,date:,kind:,status:,name:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type Nutritionorder
{
Nutritionorder(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
instantiates: List(String),
status: r4valuesets.Requeststatus,
intent: r4valuesets.Requestintent,
patient: Reference,
encounter: Option(Reference),
date_time: String,
orderer: Option(Reference),
allergy_intolerance: List(Reference),
food_preference_modifier: List(Codeableconcept),
exclude_food_modifier: List(Codeableconcept),
oral_diet: Option(NutritionorderOraldiet),
supplement: List(NutritionorderSupplement),
enteral_formula: Option(NutritionorderEnteralformula),
note: List(Annotation),
)
}

pub fn nutritionorder_new(date_time date_time: String,patient patient: Reference,intent intent: r4valuesets.Requestintent,status status: r4valuesets.Requeststatus,) ->Nutritionorder{Nutritionorder(note: [],enteral_formula: None,supplement: [],oral_diet: None,exclude_food_modifier: [],food_preference_modifier: [],allergy_intolerance: [],orderer: None,date_time:,encounter: None,patient:,intent:,status:,instantiates: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldiet
{
NutritionorderOraldiet(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: List(Codeableconcept),
schedule: List(Timing),
nutrient: List(NutritionorderOraldietNutrient),
texture: List(NutritionorderOraldietTexture),
fluid_consistency_type: List(Codeableconcept),
instruction: Option(String),
)
}

pub fn nutritionorder_oraldiet_new() ->NutritionorderOraldiet{NutritionorderOraldiet(instruction: None,fluid_consistency_type: [],texture: [],nutrient: [],schedule: [],type_: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietNutrient
{
NutritionorderOraldietNutrient(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
modifier: Option(Codeableconcept),
amount: Option(Quantity),
)
}

pub fn nutritionorder_oraldiet_nutrient_new() ->NutritionorderOraldietNutrient{NutritionorderOraldietNutrient(amount: None,modifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietTexture
{
NutritionorderOraldietTexture(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
modifier: Option(Codeableconcept),
food_type: Option(Codeableconcept),
)
}

pub fn nutritionorder_oraldiet_texture_new() ->NutritionorderOraldietTexture{NutritionorderOraldietTexture(food_type: None,modifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderSupplement
{
NutritionorderSupplement(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
product_name: Option(String),
schedule: List(Timing),
quantity: Option(Quantity),
instruction: Option(String),
)
}

pub fn nutritionorder_supplement_new() ->NutritionorderSupplement{NutritionorderSupplement(instruction: None,quantity: None,schedule: [],product_name: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformula
{
NutritionorderEnteralformula(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
base_formula_type: Option(Codeableconcept),
base_formula_product_name: Option(String),
additive_type: Option(Codeableconcept),
additive_product_name: Option(String),
caloric_density: Option(Quantity),
routeof_administration: Option(Codeableconcept),
administration: List(NutritionorderEnteralformulaAdministration),
max_volume_to_deliver: Option(Quantity),
administration_instruction: Option(String),
)
}

pub fn nutritionorder_enteralformula_new() ->NutritionorderEnteralformula{NutritionorderEnteralformula(administration_instruction: None,max_volume_to_deliver: None,administration: [],routeof_administration: None,caloric_density: None,additive_product_name: None,additive_type: None,base_formula_product_name: None,base_formula_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministration
{
NutritionorderEnteralformulaAdministration(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
schedule: Option(Timing),
quantity: Option(Quantity),
rate: Option(NutritionorderEnteralformulaAdministrationRate),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministrationRate{
NutritionorderEnteralformulaAdministrationRateQuantity(rate: Quantity)
NutritionorderEnteralformulaAdministrationRateRatio(rate: Ratio)}
pub fn nutritionorder_enteralformula_administration_rate_to_json(elt: NutritionorderEnteralformulaAdministrationRate) -> Json {case elt{NutritionorderEnteralformulaAdministrationRateQuantity(v) -> quantity_to_json(v)
NutritionorderEnteralformulaAdministrationRateRatio(v) -> ratio_to_json(v)
}}
pub fn nutritionorder_enteralformula_administration_rate_decoder() -> Decoder(NutritionorderEnteralformulaAdministrationRate){decode.one_of(decode.field("rateQuantity", quantity_decoder(), decode.success) |> decode.map(NutritionorderEnteralformulaAdministrationRateQuantity),[decode.field("rateRatio", ratio_decoder(), decode.success) |> decode.map(NutritionorderEnteralformulaAdministrationRateRatio),])}
pub fn nutritionorder_enteralformula_administration_new() ->NutritionorderEnteralformulaAdministration{NutritionorderEnteralformulaAdministration(rate: None,quantity: None,schedule: None,modifier_extension: [],extension: [],id: None,)
}

pub fn nutritionorder_enteralformula_administration_to_json(nutritionorder_enteralformula_administration: NutritionorderEnteralformulaAdministration) -> Json {
    let NutritionorderEnteralformulaAdministration(rate:,quantity:,schedule:,modifier_extension:,extension:,id:,) = nutritionorder_enteralformula_administration
    let fields = []
let fields = case rate {
                          Some(v) -> [#("rate", nutritionorder_enteralformula_administration_rate_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case schedule {
                          Some(v) -> [#("schedule", timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_enteralformula_administration_decoder() -> Decoder(NutritionorderEnteralformulaAdministration) {use rate <- decode.then(none_if_omitted(nutritionorder_enteralformula_administration_rate_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use schedule <- decode.optional_field("schedule", None, decode.optional(timing_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderEnteralformulaAdministration(rate:,quantity:,schedule:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_enteralformula_to_json(nutritionorder_enteralformula: NutritionorderEnteralformula) -> Json {
    let NutritionorderEnteralformula(administration_instruction:,max_volume_to_deliver:,administration:,routeof_administration:,caloric_density:,additive_product_name:,additive_type:,base_formula_product_name:,base_formula_type:,modifier_extension:,extension:,id:,) = nutritionorder_enteralformula
    let fields = []
let fields = case administration_instruction {
                          Some(v) -> [#("administrationInstruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max_volume_to_deliver {
                          Some(v) -> [#("maxVolumeToDeliver", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case administration {
                        [] -> fields
                        _ -> [#("administration", json.array(administration,nutritionorder_enteralformula_administration_to_json)), ..fields]
                          }
let fields = case routeof_administration {
                          Some(v) -> [#("routeofAdministration", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case caloric_density {
                          Some(v) -> [#("caloricDensity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case additive_product_name {
                          Some(v) -> [#("additiveProductName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case additive_type {
                          Some(v) -> [#("additiveType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case base_formula_product_name {
                          Some(v) -> [#("baseFormulaProductName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case base_formula_type {
                          Some(v) -> [#("baseFormulaType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_enteralformula_decoder() -> Decoder(NutritionorderEnteralformula) {use administration_instruction <- decode.optional_field("administrationInstruction", None, decode.optional(decode.string))
use max_volume_to_deliver <- decode.optional_field("maxVolumeToDeliver", None, decode.optional(quantity_decoder()))
use administration <- decode.optional_field("administration", [], decode.list(nutritionorder_enteralformula_administration_decoder()))
use routeof_administration <- decode.optional_field("routeofAdministration", None, decode.optional(codeableconcept_decoder()))
use caloric_density <- decode.optional_field("caloricDensity", None, decode.optional(quantity_decoder()))
use additive_product_name <- decode.optional_field("additiveProductName", None, decode.optional(decode.string))
use additive_type <- decode.optional_field("additiveType", None, decode.optional(codeableconcept_decoder()))
use base_formula_product_name <- decode.optional_field("baseFormulaProductName", None, decode.optional(decode.string))
use base_formula_type <- decode.optional_field("baseFormulaType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderEnteralformula(administration_instruction:,max_volume_to_deliver:,administration:,routeof_administration:,caloric_density:,additive_product_name:,additive_type:,base_formula_product_name:,base_formula_type:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_supplement_to_json(nutritionorder_supplement: NutritionorderSupplement) -> Json {
    let NutritionorderSupplement(instruction:,quantity:,schedule:,product_name:,type_:,modifier_extension:,extension:,id:,) = nutritionorder_supplement
    let fields = []
let fields = case instruction {
                          Some(v) -> [#("instruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case schedule {
                        [] -> fields
                        _ -> [#("schedule", json.array(schedule,timing_to_json)), ..fields]
                          }
let fields = case product_name {
                          Some(v) -> [#("productName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_supplement_decoder() -> Decoder(NutritionorderSupplement) {use instruction <- decode.optional_field("instruction", None, decode.optional(decode.string))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use schedule <- decode.optional_field("schedule", [], decode.list(timing_decoder()))
use product_name <- decode.optional_field("productName", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderSupplement(instruction:,quantity:,schedule:,product_name:,type_:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_oraldiet_texture_to_json(nutritionorder_oraldiet_texture: NutritionorderOraldietTexture) -> Json {
    let NutritionorderOraldietTexture(food_type:,modifier:,modifier_extension:,extension:,id:,) = nutritionorder_oraldiet_texture
    let fields = []
let fields = case food_type {
                          Some(v) -> [#("foodType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                          Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_oraldiet_texture_decoder() -> Decoder(NutritionorderOraldietTexture) {use food_type <- decode.optional_field("foodType", None, decode.optional(codeableconcept_decoder()))
use modifier <- decode.optional_field("modifier", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderOraldietTexture(food_type:,modifier:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_oraldiet_nutrient_to_json(nutritionorder_oraldiet_nutrient: NutritionorderOraldietNutrient) -> Json {
    let NutritionorderOraldietNutrient(amount:,modifier:,modifier_extension:,extension:,id:,) = nutritionorder_oraldiet_nutrient
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier {
                          Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_oraldiet_nutrient_decoder() -> Decoder(NutritionorderOraldietNutrient) {use amount <- decode.optional_field("amount", None, decode.optional(quantity_decoder()))
use modifier <- decode.optional_field("modifier", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderOraldietNutrient(amount:,modifier:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_oraldiet_to_json(nutritionorder_oraldiet: NutritionorderOraldiet) -> Json {
    let NutritionorderOraldiet(instruction:,fluid_consistency_type:,texture:,nutrient:,schedule:,type_:,modifier_extension:,extension:,id:,) = nutritionorder_oraldiet
    let fields = []
let fields = case instruction {
                          Some(v) -> [#("instruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case fluid_consistency_type {
                        [] -> fields
                        _ -> [#("fluidConsistencyType", json.array(fluid_consistency_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case texture {
                        [] -> fields
                        _ -> [#("texture", json.array(texture,nutritionorder_oraldiet_texture_to_json)), ..fields]
                          }
let fields = case nutrient {
                        [] -> fields
                        _ -> [#("nutrient", json.array(nutrient,nutritionorder_oraldiet_nutrient_to_json)), ..fields]
                          }
let fields = case schedule {
                        [] -> fields
                        _ -> [#("schedule", json.array(schedule,timing_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_oraldiet_decoder() -> Decoder(NutritionorderOraldiet) {use instruction <- decode.optional_field("instruction", None, decode.optional(decode.string))
use fluid_consistency_type <- decode.optional_field("fluidConsistencyType", [], decode.list(codeableconcept_decoder()))
use texture <- decode.optional_field("texture", [], decode.list(nutritionorder_oraldiet_texture_decoder()))
use nutrient <- decode.optional_field("nutrient", [], decode.list(nutritionorder_oraldiet_nutrient_decoder()))
use schedule <- decode.optional_field("schedule", [], decode.list(timing_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(NutritionorderOraldiet(instruction:,fluid_consistency_type:,texture:,nutrient:,schedule:,type_:,modifier_extension:,extension:,id:,))}
pub fn nutritionorder_to_json(nutritionorder: Nutritionorder) -> Json {
    let Nutritionorder(note:,enteral_formula:,supplement:,oral_diet:,exclude_food_modifier:,food_preference_modifier:,allergy_intolerance:,orderer:,date_time:,encounter:,patient:,intent:,status:,instantiates:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = nutritionorder
    let fields = [#("dateTime", json.string(date_time)),#("patient", reference_to_json(patient)),#("intent", r4valuesets.requestintent_to_json(intent)),#("status", r4valuesets.requeststatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case enteral_formula {
                          Some(v) -> [#("enteralFormula", nutritionorder_enteralformula_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case supplement {
                        [] -> fields
                        _ -> [#("supplement", json.array(supplement,nutritionorder_supplement_to_json)), ..fields]
                          }
let fields = case oral_diet {
                          Some(v) -> [#("oralDiet", nutritionorder_oraldiet_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exclude_food_modifier {
                        [] -> fields
                        _ -> [#("excludeFoodModifier", json.array(exclude_food_modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case food_preference_modifier {
                        [] -> fields
                        _ -> [#("foodPreferenceModifier", json.array(food_preference_modifier,codeableconcept_to_json)), ..fields]
                          }
let fields = case allergy_intolerance {
                        [] -> fields
                        _ -> [#("allergyIntolerance", json.array(allergy_intolerance,reference_to_json)), ..fields]
                          }
let fields = case orderer {
                          Some(v) -> [#("orderer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates {
                        [] -> fields
                        _ -> [#("instantiates", json.array(instantiates,json.string)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn nutritionorder_decoder() -> Decoder(Nutritionorder) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use enteral_formula <- decode.optional_field("enteralFormula", None, decode.optional(nutritionorder_enteralformula_decoder()))
use supplement <- decode.optional_field("supplement", [], decode.list(nutritionorder_supplement_decoder()))
use oral_diet <- decode.optional_field("oralDiet", None, decode.optional(nutritionorder_oraldiet_decoder()))
use exclude_food_modifier <- decode.optional_field("excludeFoodModifier", [], decode.list(codeableconcept_decoder()))
use food_preference_modifier <- decode.optional_field("foodPreferenceModifier", [], decode.list(codeableconcept_decoder()))
use allergy_intolerance <- decode.optional_field("allergyIntolerance", [], decode.list(reference_decoder()))
use orderer <- decode.optional_field("orderer", None, decode.optional(reference_decoder()))
use date_time <- decode.field("dateTime",decode.string)
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use patient <- decode.field("patient",reference_decoder())
use intent <- decode.field("intent",r4valuesets.requestintent_decoder())
use status <- decode.field("status",r4valuesets.requeststatus_decoder())
use instantiates <- decode.optional_field("instantiates", [], decode.list(decode.string))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Nutritionorder(note:,enteral_formula:,supplement:,oral_diet:,exclude_food_modifier:,food_preference_modifier:,allergy_intolerance:,orderer:,date_time:,encounter:,patient:,intent:,status:,instantiates:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type Observation
{
Observation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
part_of: List(Reference),
status: r4valuesets.Observationstatus,
category: List(Codeableconcept),
code: Codeableconcept,
subject: Option(Reference),
focus: List(Reference),
encounter: Option(Reference),
effective: Option(ObservationEffective),
issued: Option(String),
performer: List(Reference),
value: Option(ObservationValue),
data_absent_reason: Option(Codeableconcept),
interpretation: List(Codeableconcept),
note: List(Annotation),
body_site: Option(Codeableconcept),
method: Option(Codeableconcept),
specimen: Option(Reference),
device: Option(Reference),
reference_range: List(ObservationReferencerange),
has_member: List(Reference),
derived_from: List(Reference),
component: List(ObservationComponent),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type ObservationEffective{
ObservationEffectiveDatetime(effective: String)
ObservationEffectivePeriod(effective: Period)
ObservationEffectiveTiming(effective: Timing)
ObservationEffectiveInstant(effective: String)}
pub fn observation_effective_to_json(elt: ObservationEffective) -> Json {case elt{ObservationEffectiveDatetime(v) -> json.string(v)
ObservationEffectivePeriod(v) -> period_to_json(v)
ObservationEffectiveTiming(v) -> timing_to_json(v)
ObservationEffectiveInstant(v) -> json.string(v)
}}
pub fn observation_effective_decoder() -> Decoder(ObservationEffective){decode.one_of(decode.field("effectiveDateTime", decode.string, decode.success) |> decode.map(ObservationEffectiveDatetime),[decode.field("effectivePeriod", period_decoder(), decode.success) |> decode.map(ObservationEffectivePeriod),decode.field("effectiveTiming", timing_decoder(), decode.success) |> decode.map(ObservationEffectiveTiming),decode.field("effectiveInstant", decode.string, decode.success) |> decode.map(ObservationEffectiveInstant),])}

///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type ObservationValue{
ObservationValueQuantity(value: Quantity)
ObservationValueCodeableconcept(value: Codeableconcept)
ObservationValueString(value: String)
ObservationValueBoolean(value: Bool)
ObservationValueInteger(value: Int)
ObservationValueRange(value: Range)
ObservationValueRatio(value: Ratio)
ObservationValueSampleddata(value: Sampleddata)
ObservationValueTime(value: String)
ObservationValueDatetime(value: String)
ObservationValuePeriod(value: Period)}
pub fn observation_value_to_json(elt: ObservationValue) -> Json {case elt{ObservationValueQuantity(v) -> quantity_to_json(v)
ObservationValueCodeableconcept(v) -> codeableconcept_to_json(v)
ObservationValueString(v) -> json.string(v)
ObservationValueBoolean(v) -> json.bool(v)
ObservationValueInteger(v) -> json.int(v)
ObservationValueRange(v) -> range_to_json(v)
ObservationValueRatio(v) -> ratio_to_json(v)
ObservationValueSampleddata(v) -> sampleddata_to_json(v)
ObservationValueTime(v) -> json.string(v)
ObservationValueDatetime(v) -> json.string(v)
ObservationValuePeriod(v) -> period_to_json(v)
}}
pub fn observation_value_decoder() -> Decoder(ObservationValue){decode.one_of(decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ObservationValueQuantity),[decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ObservationValueCodeableconcept),decode.field("valueString", decode.string, decode.success) |> decode.map(ObservationValueString),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ObservationValueBoolean),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ObservationValueInteger),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(ObservationValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(ObservationValueRatio),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(ObservationValueSampleddata),decode.field("valueTime", decode.string, decode.success) |> decode.map(ObservationValueTime),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ObservationValueDatetime),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(ObservationValuePeriod),])}
pub fn observation_new(code code: Codeableconcept,status status: r4valuesets.Observationstatus,) ->Observation{Observation(component: [],derived_from: [],has_member: [],reference_range: [],device: None,specimen: None,method: None,body_site: None,note: [],interpretation: [],data_absent_reason: None,value: None,performer: [],issued: None,effective: None,encounter: None,focus: [],subject: None,code:,category: [],status:,part_of: [],based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type ObservationReferencerange
{
ObservationReferencerange(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
low: Option(Quantity),
high: Option(Quantity),
type_: Option(Codeableconcept),
applies_to: List(Codeableconcept),
age: Option(Range),
text: Option(String),
)
}

pub fn observation_referencerange_new() ->ObservationReferencerange{ObservationReferencerange(text: None,age: None,applies_to: [],type_: None,high: None,low: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type ObservationComponent
{
ObservationComponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Codeableconcept,
value: Option(ObservationComponentValue),
data_absent_reason: Option(Codeableconcept),
interpretation: List(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Observation#resource
pub type ObservationComponentValue{
ObservationComponentValueQuantity(value: Quantity)
ObservationComponentValueCodeableconcept(value: Codeableconcept)
ObservationComponentValueString(value: String)
ObservationComponentValueBoolean(value: Bool)
ObservationComponentValueInteger(value: Int)
ObservationComponentValueRange(value: Range)
ObservationComponentValueRatio(value: Ratio)
ObservationComponentValueSampleddata(value: Sampleddata)
ObservationComponentValueTime(value: String)
ObservationComponentValueDatetime(value: String)
ObservationComponentValuePeriod(value: Period)}
pub fn observation_component_value_to_json(elt: ObservationComponentValue) -> Json {case elt{ObservationComponentValueQuantity(v) -> quantity_to_json(v)
ObservationComponentValueCodeableconcept(v) -> codeableconcept_to_json(v)
ObservationComponentValueString(v) -> json.string(v)
ObservationComponentValueBoolean(v) -> json.bool(v)
ObservationComponentValueInteger(v) -> json.int(v)
ObservationComponentValueRange(v) -> range_to_json(v)
ObservationComponentValueRatio(v) -> ratio_to_json(v)
ObservationComponentValueSampleddata(v) -> sampleddata_to_json(v)
ObservationComponentValueTime(v) -> json.string(v)
ObservationComponentValueDatetime(v) -> json.string(v)
ObservationComponentValuePeriod(v) -> period_to_json(v)
}}
pub fn observation_component_value_decoder() -> Decoder(ObservationComponentValue){decode.one_of(decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ObservationComponentValueQuantity),[decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ObservationComponentValueCodeableconcept),decode.field("valueString", decode.string, decode.success) |> decode.map(ObservationComponentValueString),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ObservationComponentValueBoolean),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ObservationComponentValueInteger),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(ObservationComponentValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(ObservationComponentValueRatio),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(ObservationComponentValueSampleddata),decode.field("valueTime", decode.string, decode.success) |> decode.map(ObservationComponentValueTime),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ObservationComponentValueDatetime),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(ObservationComponentValuePeriod),])}
pub fn observation_component_new(code code: Codeableconcept,) ->ObservationComponent{ObservationComponent(interpretation: [],data_absent_reason: None,value: None,code:,modifier_extension: [],extension: [],id: None,)
}

pub fn observation_component_to_json(observation_component: ObservationComponent) -> Json {
    let ObservationComponent(interpretation:,data_absent_reason:,value:,code:,modifier_extension:,extension:,id:,) = observation_component
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case interpretation {
                        [] -> fields
                        _ -> [#("interpretation", json.array(interpretation,codeableconcept_to_json)), ..fields]
                          }
let fields = case data_absent_reason {
                          Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", observation_component_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observation_component_decoder() -> Decoder(ObservationComponent) {use interpretation <- decode.optional_field("interpretation", [], decode.list(codeableconcept_decoder()))
use data_absent_reason <- decode.optional_field("dataAbsentReason", None, decode.optional(codeableconcept_decoder()))
use value <- decode.then(none_if_omitted(observation_component_value_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ObservationComponent(interpretation:,data_absent_reason:,value:,code:,modifier_extension:,extension:,id:,))}
pub fn observation_referencerange_to_json(observation_referencerange: ObservationReferencerange) -> Json {
    let ObservationReferencerange(text:,age:,applies_to:,type_:,high:,low:,modifier_extension:,extension:,id:,) = observation_referencerange
    let fields = []
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case age {
                          Some(v) -> [#("age", range_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case applies_to {
                        [] -> fields
                        _ -> [#("appliesTo", json.array(applies_to,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case high {
                          Some(v) -> [#("high", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case low {
                          Some(v) -> [#("low", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observation_referencerange_decoder() -> Decoder(ObservationReferencerange) {use text <- decode.optional_field("text", None, decode.optional(decode.string))
use age <- decode.optional_field("age", None, decode.optional(range_decoder()))
use applies_to <- decode.optional_field("appliesTo", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use high <- decode.optional_field("high", None, decode.optional(quantity_decoder()))
use low <- decode.optional_field("low", None, decode.optional(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ObservationReferencerange(text:,age:,applies_to:,type_:,high:,low:,modifier_extension:,extension:,id:,))}
pub fn observation_to_json(observation: Observation) -> Json {
    let Observation(component:,derived_from:,has_member:,reference_range:,device:,specimen:,method:,body_site:,note:,interpretation:,data_absent_reason:,value:,performer:,issued:,effective:,encounter:,focus:,subject:,code:,category:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = observation
    let fields = [#("code", codeableconcept_to_json(code)),#("status", r4valuesets.observationstatus_to_json(status)),]
let fields = case component {
                        [] -> fields
                        _ -> [#("component", json.array(component,observation_component_to_json)), ..fields]
                          }
let fields = case derived_from {
                        [] -> fields
                        _ -> [#("derivedFrom", json.array(derived_from,reference_to_json)), ..fields]
                          }
let fields = case has_member {
                        [] -> fields
                        _ -> [#("hasMember", json.array(has_member,reference_to_json)), ..fields]
                          }
let fields = case reference_range {
                        [] -> fields
                        _ -> [#("referenceRange", json.array(reference_range,observation_referencerange_to_json)), ..fields]
                          }
let fields = case device {
                          Some(v) -> [#("device", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specimen {
                          Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case interpretation {
                        [] -> fields
                        _ -> [#("interpretation", json.array(interpretation,codeableconcept_to_json)), ..fields]
                          }
let fields = case data_absent_reason {
                          Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", observation_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,reference_to_json)), ..fields]
                          }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case effective {
                          Some(v) -> [#("effective", observation_effective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case focus {
                        [] -> fields
                        _ -> [#("focus", json.array(focus,reference_to_json)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observation_decoder() -> Decoder(Observation) {use component <- decode.optional_field("component", [], decode.list(observation_component_decoder()))
use derived_from <- decode.optional_field("derivedFrom", [], decode.list(reference_decoder()))
use has_member <- decode.optional_field("hasMember", [], decode.list(reference_decoder()))
use reference_range <- decode.optional_field("referenceRange", [], decode.list(observation_referencerange_decoder()))
use device <- decode.optional_field("device", None, decode.optional(reference_decoder()))
use specimen <- decode.optional_field("specimen", None, decode.optional(reference_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use interpretation <- decode.optional_field("interpretation", [], decode.list(codeableconcept_decoder()))
use data_absent_reason <- decode.optional_field("dataAbsentReason", None, decode.optional(codeableconcept_decoder()))
use value <- decode.then(none_if_omitted(observation_value_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(reference_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use effective <- decode.then(none_if_omitted(observation_effective_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use focus <- decode.optional_field("focus", [], decode.list(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.observationstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Observation(component:,derived_from:,has_member:,reference_range:,device:,specimen:,method:,body_site:,note:,interpretation:,data_absent_reason:,value:,performer:,issued:,effective:,encounter:,focus:,subject:,code:,category:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ObservationDefinition#resource
pub type Observationdefinition
{
Observationdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
category: List(Codeableconcept),
code: Codeableconcept,
identifier: List(Identifier),
permitted_data_type: List(r4valuesets.Permitteddatatype),
multiple_results_allowed: Option(Bool),
method: Option(Codeableconcept),
preferred_report_name: Option(String),
quantitative_details: Option(ObservationdefinitionQuantitativedetails),
qualified_interval: List(ObservationdefinitionQualifiedinterval),
valid_coded_value_set: Option(Reference),
normal_coded_value_set: Option(Reference),
abnormal_coded_value_set: Option(Reference),
critical_coded_value_set: Option(Reference),
)
}

pub fn observationdefinition_new(code code: Codeableconcept,) ->Observationdefinition{Observationdefinition(critical_coded_value_set: None,abnormal_coded_value_set: None,normal_coded_value_set: None,valid_coded_value_set: None,qualified_interval: [],quantitative_details: None,preferred_report_name: None,method: None,multiple_results_allowed: None,permitted_data_type: [],identifier: [],code:,category: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionQuantitativedetails
{
ObservationdefinitionQuantitativedetails(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
customary_unit: Option(Codeableconcept),
unit: Option(Codeableconcept),
conversion_factor: Option(Float),
decimal_precision: Option(Int),
)
}

pub fn observationdefinition_quantitativedetails_new() ->ObservationdefinitionQuantitativedetails{ObservationdefinitionQuantitativedetails(decimal_precision: None,conversion_factor: None,unit: None,customary_unit: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionQualifiedinterval
{
ObservationdefinitionQualifiedinterval(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Option(r4valuesets.Observationrangecategory),
range: Option(Range),
context: Option(Codeableconcept),
applies_to: List(Codeableconcept),
gender: Option(r4valuesets.Administrativegender),
age: Option(Range),
gestational_age: Option(Range),
condition: Option(String),
)
}

pub fn observationdefinition_qualifiedinterval_new() ->ObservationdefinitionQualifiedinterval{ObservationdefinitionQualifiedinterval(condition: None,gestational_age: None,age: None,gender: None,applies_to: [],context: None,range: None,category: None,modifier_extension: [],extension: [],id: None,)
}

pub fn observationdefinition_qualifiedinterval_to_json(observationdefinition_qualifiedinterval: ObservationdefinitionQualifiedinterval) -> Json {
    let ObservationdefinitionQualifiedinterval(condition:,gestational_age:,age:,gender:,applies_to:,context:,range:,category:,modifier_extension:,extension:,id:,) = observationdefinition_qualifiedinterval
    let fields = []
let fields = case condition {
                          Some(v) -> [#("condition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case gestational_age {
                          Some(v) -> [#("gestationalAge", range_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case age {
                          Some(v) -> [#("age", range_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case applies_to {
                        [] -> fields
                        _ -> [#("appliesTo", json.array(applies_to,codeableconcept_to_json)), ..fields]
                          }
let fields = case context {
                          Some(v) -> [#("context", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case range {
                          Some(v) -> [#("range", range_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", r4valuesets.observationrangecategory_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observationdefinition_qualifiedinterval_decoder() -> Decoder(ObservationdefinitionQualifiedinterval) {use condition <- decode.optional_field("condition", None, decode.optional(decode.string))
use gestational_age <- decode.optional_field("gestationalAge", None, decode.optional(range_decoder()))
use age <- decode.optional_field("age", None, decode.optional(range_decoder()))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use applies_to <- decode.optional_field("appliesTo", [], decode.list(codeableconcept_decoder()))
use context <- decode.optional_field("context", None, decode.optional(codeableconcept_decoder()))
use range <- decode.optional_field("range", None, decode.optional(range_decoder()))
use category <- decode.optional_field("category", None, decode.optional(r4valuesets.observationrangecategory_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ObservationdefinitionQualifiedinterval(condition:,gestational_age:,age:,gender:,applies_to:,context:,range:,category:,modifier_extension:,extension:,id:,))}
pub fn observationdefinition_quantitativedetails_to_json(observationdefinition_quantitativedetails: ObservationdefinitionQuantitativedetails) -> Json {
    let ObservationdefinitionQuantitativedetails(decimal_precision:,conversion_factor:,unit:,customary_unit:,modifier_extension:,extension:,id:,) = observationdefinition_quantitativedetails
    let fields = []
let fields = case decimal_precision {
                          Some(v) -> [#("decimalPrecision", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case conversion_factor {
                          Some(v) -> [#("conversionFactor", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case unit {
                          Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case customary_unit {
                          Some(v) -> [#("customaryUnit", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observationdefinition_quantitativedetails_decoder() -> Decoder(ObservationdefinitionQuantitativedetails) {use decimal_precision <- decode.optional_field("decimalPrecision", None, decode.optional(decode.int))
use conversion_factor <- decode.optional_field("conversionFactor", None, decode.optional(decode.float))
use unit <- decode.optional_field("unit", None, decode.optional(codeableconcept_decoder()))
use customary_unit <- decode.optional_field("customaryUnit", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ObservationdefinitionQuantitativedetails(decimal_precision:,conversion_factor:,unit:,customary_unit:,modifier_extension:,extension:,id:,))}
pub fn observationdefinition_to_json(observationdefinition: Observationdefinition) -> Json {
    let Observationdefinition(critical_coded_value_set:,abnormal_coded_value_set:,normal_coded_value_set:,valid_coded_value_set:,qualified_interval:,quantitative_details:,preferred_report_name:,method:,multiple_results_allowed:,permitted_data_type:,identifier:,code:,category:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = observationdefinition
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case critical_coded_value_set {
                          Some(v) -> [#("criticalCodedValueSet", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case abnormal_coded_value_set {
                          Some(v) -> [#("abnormalCodedValueSet", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case normal_coded_value_set {
                          Some(v) -> [#("normalCodedValueSet", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case valid_coded_value_set {
                          Some(v) -> [#("validCodedValueSet", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case qualified_interval {
                        [] -> fields
                        _ -> [#("qualifiedInterval", json.array(qualified_interval,observationdefinition_qualifiedinterval_to_json)), ..fields]
                          }
let fields = case quantitative_details {
                          Some(v) -> [#("quantitativeDetails", observationdefinition_quantitativedetails_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case preferred_report_name {
                          Some(v) -> [#("preferredReportName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case multiple_results_allowed {
                          Some(v) -> [#("multipleResultsAllowed", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case permitted_data_type {
                        [] -> fields
                        _ -> [#("permittedDataType", json.array(permitted_data_type,r4valuesets.permitteddatatype_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn observationdefinition_decoder() -> Decoder(Observationdefinition) {use critical_coded_value_set <- decode.optional_field("criticalCodedValueSet", None, decode.optional(reference_decoder()))
use abnormal_coded_value_set <- decode.optional_field("abnormalCodedValueSet", None, decode.optional(reference_decoder()))
use normal_coded_value_set <- decode.optional_field("normalCodedValueSet", None, decode.optional(reference_decoder()))
use valid_coded_value_set <- decode.optional_field("validCodedValueSet", None, decode.optional(reference_decoder()))
use qualified_interval <- decode.optional_field("qualifiedInterval", [], decode.list(observationdefinition_qualifiedinterval_decoder()))
use quantitative_details <- decode.optional_field("quantitativeDetails", None, decode.optional(observationdefinition_quantitativedetails_decoder()))
use preferred_report_name <- decode.optional_field("preferredReportName", None, decode.optional(decode.string))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use multiple_results_allowed <- decode.optional_field("multipleResultsAllowed", None, decode.optional(decode.bool))
use permitted_data_type <- decode.optional_field("permittedDataType", [], decode.list(r4valuesets.permitteddatatype_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Observationdefinition(critical_coded_value_set:,abnormal_coded_value_set:,normal_coded_value_set:,valid_coded_value_set:,qualified_interval:,quantitative_details:,preferred_report_name:,method:,multiple_results_allowed:,permitted_data_type:,identifier:,code:,category:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/OperationDefinition#resource
pub type Operationdefinition
{
Operationdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
version: Option(String),
name: String,
title: Option(String),
status: r4valuesets.Publicationstatus,
kind: r4valuesets.Operationkind,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
affects_state: Option(Bool),
code: String,
comment: Option(String),
base: Option(String),
resource: List(r4valuesets.Resourcetypes),
system: Bool,
type_: Bool,
instance: Bool,
input_profile: Option(String),
output_profile: Option(String),
parameter: List(OperationdefinitionParameter),
overload: List(OperationdefinitionOverload),
)
}

pub fn operationdefinition_new(instance instance: Bool,type_ type_: Bool,system system: Bool,code code: String,kind kind: r4valuesets.Operationkind,status status: r4valuesets.Publicationstatus,name name: String,) ->Operationdefinition{Operationdefinition(overload: [],parameter: [],output_profile: None,input_profile: None,instance:,type_:,system:,resource: [],base: None,comment: None,code:,affects_state: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,kind:,status:,title: None,name:,version: None,url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameter
{
OperationdefinitionParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
use_: r4valuesets.Operationparameteruse,
min: Int,
max: String,
documentation: Option(String),
type_: Option(r4valuesets.Alltypes),
target_profile: List(String),
search_type: Option(r4valuesets.Searchparamtype),
binding: Option(OperationdefinitionParameterBinding),
referenced_from: List(OperationdefinitionParameterReferencedfrom),
)
}

pub fn operationdefinition_parameter_new(max max: String,min min: Int,use_ use_: r4valuesets.Operationparameteruse,name name: String,) ->OperationdefinitionParameter{OperationdefinitionParameter(referenced_from: [],binding: None,search_type: None,target_profile: [],type_: None,documentation: None,max:,min:,use_:,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterBinding
{
OperationdefinitionParameterBinding(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
strength: r4valuesets.Bindingstrength,
value_set: String,
)
}

pub fn operationdefinition_parameter_binding_new(value_set value_set: String,strength strength: r4valuesets.Bindingstrength,) ->OperationdefinitionParameterBinding{OperationdefinitionParameterBinding(value_set:,strength:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterReferencedfrom
{
OperationdefinitionParameterReferencedfrom(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
source: String,
source_id: Option(String),
)
}

pub fn operationdefinition_parameter_referencedfrom_new(source source: String,) ->OperationdefinitionParameterReferencedfrom{OperationdefinitionParameterReferencedfrom(source_id: None,source:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionOverload
{
OperationdefinitionOverload(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
parameter_name: List(String),
comment: Option(String),
)
}

pub fn operationdefinition_overload_new() ->OperationdefinitionOverload{OperationdefinitionOverload(comment: None,parameter_name: [],modifier_extension: [],extension: [],id: None,)
}

pub fn operationdefinition_overload_to_json(operationdefinition_overload: OperationdefinitionOverload) -> Json {
    let OperationdefinitionOverload(comment:,parameter_name:,modifier_extension:,extension:,id:,) = operationdefinition_overload
    let fields = []
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case parameter_name {
                        [] -> fields
                        _ -> [#("parameterName", json.array(parameter_name,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationdefinition_overload_decoder() -> Decoder(OperationdefinitionOverload) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use parameter_name <- decode.optional_field("parameterName", [], decode.list(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OperationdefinitionOverload(comment:,parameter_name:,modifier_extension:,extension:,id:,))}
pub fn operationdefinition_parameter_referencedfrom_to_json(operationdefinition_parameter_referencedfrom: OperationdefinitionParameterReferencedfrom) -> Json {
    let OperationdefinitionParameterReferencedfrom(source_id:,source:,modifier_extension:,extension:,id:,) = operationdefinition_parameter_referencedfrom
    let fields = [#("source", json.string(source)),]
let fields = case source_id {
                          Some(v) -> [#("sourceId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationdefinition_parameter_referencedfrom_decoder() -> Decoder(OperationdefinitionParameterReferencedfrom) {use source_id <- decode.optional_field("sourceId", None, decode.optional(decode.string))
use source <- decode.field("source",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OperationdefinitionParameterReferencedfrom(source_id:,source:,modifier_extension:,extension:,id:,))}
pub fn operationdefinition_parameter_binding_to_json(operationdefinition_parameter_binding: OperationdefinitionParameterBinding) -> Json {
    let OperationdefinitionParameterBinding(value_set:,strength:,modifier_extension:,extension:,id:,) = operationdefinition_parameter_binding
    let fields = [#("valueSet", json.string(value_set)),#("strength", r4valuesets.bindingstrength_to_json(strength)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationdefinition_parameter_binding_decoder() -> Decoder(OperationdefinitionParameterBinding) {use value_set <- decode.field("valueSet",decode.string)
use strength <- decode.field("strength",r4valuesets.bindingstrength_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OperationdefinitionParameterBinding(value_set:,strength:,modifier_extension:,extension:,id:,))}
pub fn operationdefinition_parameter_to_json(operationdefinition_parameter: OperationdefinitionParameter) -> Json {
    let OperationdefinitionParameter(referenced_from:,binding:,search_type:,target_profile:,type_:,documentation:,max:,min:,use_:,name:,modifier_extension:,extension:,id:,) = operationdefinition_parameter
    let fields = [#("max", json.string(max)),#("min", json.int(min)),#("use", r4valuesets.operationparameteruse_to_json(use_)),#("name", json.string(name)),]
let fields = case referenced_from {
                        [] -> fields
                        _ -> [#("referencedFrom", json.array(referenced_from,operationdefinition_parameter_referencedfrom_to_json)), ..fields]
                          }
let fields = case binding {
                          Some(v) -> [#("binding", operationdefinition_parameter_binding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case search_type {
                          Some(v) -> [#("searchType", r4valuesets.searchparamtype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target_profile {
                        [] -> fields
                        _ -> [#("targetProfile", json.array(target_profile,json.string)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.alltypes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationdefinition_parameter_decoder() -> Decoder(OperationdefinitionParameter) {use referenced_from <- decode.optional_field("referencedFrom", [], decode.list(operationdefinition_parameter_referencedfrom_decoder()))
use binding <- decode.optional_field("binding", None, decode.optional(operationdefinition_parameter_binding_decoder()))
use search_type <- decode.optional_field("searchType", None, decode.optional(r4valuesets.searchparamtype_decoder()))
use target_profile <- decode.optional_field("targetProfile", [], decode.list(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.alltypes_decoder()))
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use max <- decode.field("max",decode.string)
use min <- decode.field("min",decode.int)
use use_ <- decode.field("use",r4valuesets.operationparameteruse_decoder())
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OperationdefinitionParameter(referenced_from:,binding:,search_type:,target_profile:,type_:,documentation:,max:,min:,use_:,name:,modifier_extension:,extension:,id:,))}
pub fn operationdefinition_to_json(operationdefinition: Operationdefinition) -> Json {
    let Operationdefinition(overload:,parameter:,output_profile:,input_profile:,instance:,type_:,system:,resource:,base:,comment:,code:,affects_state:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,kind:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = operationdefinition
    let fields = [#("instance", json.bool(instance)),#("type", json.bool(type_)),#("system", json.bool(system)),#("code", json.string(code)),#("kind", r4valuesets.operationkind_to_json(kind)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),]
let fields = case overload {
                        [] -> fields
                        _ -> [#("overload", json.array(overload,operationdefinition_overload_to_json)), ..fields]
                          }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,operationdefinition_parameter_to_json)), ..fields]
                          }
let fields = case output_profile {
                          Some(v) -> [#("outputProfile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case input_profile {
                          Some(v) -> [#("inputProfile", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case resource {
                        [] -> fields
                        _ -> [#("resource", json.array(resource,r4valuesets.resourcetypes_to_json)), ..fields]
                          }
let fields = case base {
                          Some(v) -> [#("base", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case affects_state {
                          Some(v) -> [#("affectsState", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationdefinition_decoder() -> Decoder(Operationdefinition) {use overload <- decode.optional_field("overload", [], decode.list(operationdefinition_overload_decoder()))
use parameter <- decode.optional_field("parameter", [], decode.list(operationdefinition_parameter_decoder()))
use output_profile <- decode.optional_field("outputProfile", None, decode.optional(decode.string))
use input_profile <- decode.optional_field("inputProfile", None, decode.optional(decode.string))
use instance <- decode.field("instance",decode.bool)
use type_ <- decode.field("type",decode.bool)
use system <- decode.field("system",decode.bool)
use resource <- decode.optional_field("resource", [], decode.list(r4valuesets.resourcetypes_decoder()))
use base <- decode.optional_field("base", None, decode.optional(decode.string))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use code <- decode.field("code",decode.string)
use affects_state <- decode.optional_field("affectsState", None, decode.optional(decode.bool))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use kind <- decode.field("kind",r4valuesets.operationkind_decoder())
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Operationdefinition(overload:,parameter:,output_profile:,input_profile:,instance:,type_:,system:,resource:,base:,comment:,code:,affects_state:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,kind:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/OperationOutcome#resource
pub type Operationoutcome
{
Operationoutcome(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
issue: List(OperationoutcomeIssue),
)
}

pub fn operationoutcome_new() ->Operationoutcome{Operationoutcome(issue: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/OperationOutcome#resource
pub type OperationoutcomeIssue
{
OperationoutcomeIssue(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
severity: r4valuesets.Issueseverity,
code: r4valuesets.Issuetype,
details: Option(Codeableconcept),
diagnostics: Option(String),
location: List(String),
expression: List(String),
)
}

pub fn operationoutcome_issue_new(code code: r4valuesets.Issuetype,severity severity: r4valuesets.Issueseverity,) ->OperationoutcomeIssue{OperationoutcomeIssue(expression: [],location: [],diagnostics: None,details: None,code:,severity:,modifier_extension: [],extension: [],id: None,)
}

pub fn operationoutcome_issue_to_json(operationoutcome_issue: OperationoutcomeIssue) -> Json {
    let OperationoutcomeIssue(expression:,location:,diagnostics:,details:,code:,severity:,modifier_extension:,extension:,id:,) = operationoutcome_issue
    let fields = [#("code", r4valuesets.issuetype_to_json(code)),#("severity", r4valuesets.issueseverity_to_json(severity)),]
let fields = case expression {
                        [] -> fields
                        _ -> [#("expression", json.array(expression,json.string)), ..fields]
                          }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,json.string)), ..fields]
                          }
let fields = case diagnostics {
                          Some(v) -> [#("diagnostics", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case details {
                          Some(v) -> [#("details", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationoutcome_issue_decoder() -> Decoder(OperationoutcomeIssue) {use expression <- decode.optional_field("expression", [], decode.list(decode.string))
use location <- decode.optional_field("location", [], decode.list(decode.string))
use diagnostics <- decode.optional_field("diagnostics", None, decode.optional(decode.string))
use details <- decode.optional_field("details", None, decode.optional(codeableconcept_decoder()))
use code <- decode.field("code",r4valuesets.issuetype_decoder())
use severity <- decode.field("severity",r4valuesets.issueseverity_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OperationoutcomeIssue(expression:,location:,diagnostics:,details:,code:,severity:,modifier_extension:,extension:,id:,))}
pub fn operationoutcome_to_json(operationoutcome: Operationoutcome) -> Json {
    let Operationoutcome(issue:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = operationoutcome
    let fields = []
let fields = case issue {
                        [] -> fields
                        _ -> [#("issue", json.array(issue,operationoutcome_issue_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn operationoutcome_decoder() -> Decoder(Operationoutcome) {use issue <- decode.optional_field("issue", [], decode.list(operationoutcome_issue_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Operationoutcome(issue:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Organization#resource
pub type Organization
{
Organization(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
type_: List(Codeableconcept),
name: Option(String),
alias: List(String),
telecom: List(Contactpoint),
address: List(Address),
part_of: Option(Reference),
contact: List(OrganizationContact),
endpoint: List(Reference),
)
}

pub fn organization_new() ->Organization{Organization(endpoint: [],contact: [],part_of: None,address: [],telecom: [],alias: [],name: None,type_: [],active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Organization#resource
pub type OrganizationContact
{
OrganizationContact(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
purpose: Option(Codeableconcept),
name: Option(Humanname),
telecom: List(Contactpoint),
address: Option(Address),
)
}

pub fn organization_contact_new() ->OrganizationContact{OrganizationContact(address: None,telecom: [],name: None,purpose: None,modifier_extension: [],extension: [],id: None,)
}

pub fn organization_contact_to_json(organization_contact: OrganizationContact) -> Json {
    let OrganizationContact(address:,telecom:,name:,purpose:,modifier_extension:,extension:,id:,) = organization_contact
    let fields = []
let fields = case address {
                          Some(v) -> [#("address", address_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", humanname_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn organization_contact_decoder() -> Decoder(OrganizationContact) {use address <- decode.optional_field("address", None, decode.optional(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", None, decode.optional(humanname_decoder()))
use purpose <- decode.optional_field("purpose", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(OrganizationContact(address:,telecom:,name:,purpose:,modifier_extension:,extension:,id:,))}
pub fn organization_to_json(organization: Organization) -> Json {
    let Organization(endpoint:,contact:,part_of:,address:,telecom:,alias:,name:,type_:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = organization
    let fields = []
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,organization_contact_to_json)), ..fields]
                          }
let fields = case part_of {
                          Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                        [] -> fields
                        _ -> [#("address", json.array(address,address_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case alias {
                        [] -> fields
                        _ -> [#("alias", json.array(alias,json.string)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn organization_decoder() -> Decoder(Organization) {use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(organization_contact_decoder()))
use part_of <- decode.optional_field("partOf", None, decode.optional(reference_decoder()))
use address <- decode.optional_field("address", [], decode.list(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use alias <- decode.optional_field("alias", [], decode.list(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Organization(endpoint:,contact:,part_of:,address:,telecom:,alias:,name:,type_:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/OrganizationAffiliation#resource
pub type Organizationaffiliation
{
Organizationaffiliation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
period: Option(Period),
organization: Option(Reference),
participating_organization: Option(Reference),
network: List(Reference),
code: List(Codeableconcept),
specialty: List(Codeableconcept),
location: List(Reference),
healthcare_service: List(Reference),
telecom: List(Contactpoint),
endpoint: List(Reference),
)
}

pub fn organizationaffiliation_new() ->Organizationaffiliation{Organizationaffiliation(endpoint: [],telecom: [],healthcare_service: [],location: [],specialty: [],code: [],network: [],participating_organization: None,organization: None,period: None,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn organizationaffiliation_to_json(organizationaffiliation: Organizationaffiliation) -> Json {
    let Organizationaffiliation(endpoint:,telecom:,healthcare_service:,location:,specialty:,code:,network:,participating_organization:,organization:,period:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = organizationaffiliation
    let fields = []
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case healthcare_service {
                        [] -> fields
                        _ -> [#("healthcareService", json.array(healthcare_service,reference_to_json)), ..fields]
                          }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,reference_to_json)), ..fields]
                          }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case network {
                        [] -> fields
                        _ -> [#("network", json.array(network,reference_to_json)), ..fields]
                          }
let fields = case participating_organization {
                          Some(v) -> [#("participatingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organization {
                          Some(v) -> [#("organization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn organizationaffiliation_decoder() -> Decoder(Organizationaffiliation) {use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use healthcare_service <- decode.optional_field("healthcareService", [], decode.list(reference_decoder()))
use location <- decode.optional_field("location", [], decode.list(reference_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use network <- decode.optional_field("network", [], decode.list(reference_decoder()))
use participating_organization <- decode.optional_field("participatingOrganization", None, decode.optional(reference_decoder()))
use organization <- decode.optional_field("organization", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Organizationaffiliation(endpoint:,telecom:,healthcare_service:,location:,specialty:,code:,network:,participating_organization:,organization:,period:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Parameters#resource
pub type Parameters
{
Parameters(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
parameter: List(ParametersParameter),
)
}

pub fn parameters_new() ->Parameters{Parameters(parameter: [],language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Parameters#resource
pub type ParametersParameter
{
ParametersParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
value: Option(ParametersParameterValue),
resource: Option(Resource),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Parameters#resource
pub type ParametersParameterValue{
ParametersParameterValueBase64binary(value: String)
ParametersParameterValueBoolean(value: Bool)
ParametersParameterValueCanonical(value: String)
ParametersParameterValueCode(value: String)
ParametersParameterValueDate(value: String)
ParametersParameterValueDatetime(value: String)
ParametersParameterValueDecimal(value: Float)
ParametersParameterValueId(value: String)
ParametersParameterValueInstant(value: String)
ParametersParameterValueInteger(value: Int)
ParametersParameterValueMarkdown(value: String)
ParametersParameterValueOid(value: String)
ParametersParameterValuePositiveint(value: Int)
ParametersParameterValueString(value: String)
ParametersParameterValueTime(value: String)
ParametersParameterValueUnsignedint(value: Int)
ParametersParameterValueUri(value: String)
ParametersParameterValueUrl(value: String)
ParametersParameterValueUuid(value: String)
ParametersParameterValueAddress(value: Address)
ParametersParameterValueAge(value: Age)
ParametersParameterValueAnnotation(value: Annotation)
ParametersParameterValueAttachment(value: Attachment)
ParametersParameterValueCodeableconcept(value: Codeableconcept)
ParametersParameterValueCoding(value: Coding)
ParametersParameterValueContactpoint(value: Contactpoint)
ParametersParameterValueCount(value: Count)
ParametersParameterValueDistance(value: Distance)
ParametersParameterValueDuration(value: Duration)
ParametersParameterValueHumanname(value: Humanname)
ParametersParameterValueIdentifier(value: Identifier)
ParametersParameterValueMoney(value: Money)
ParametersParameterValuePeriod(value: Period)
ParametersParameterValueQuantity(value: Quantity)
ParametersParameterValueRange(value: Range)
ParametersParameterValueRatio(value: Ratio)
ParametersParameterValueReference(value: Reference)
ParametersParameterValueSampleddata(value: Sampleddata)
ParametersParameterValueSignature(value: Signature)
ParametersParameterValueTiming(value: Timing)
ParametersParameterValueContactdetail(value: Contactdetail)
ParametersParameterValueContributor(value: Contributor)
ParametersParameterValueDatarequirement(value: Datarequirement)
ParametersParameterValueExpression(value: Expression)
ParametersParameterValueParameterdefinition(value: Parameterdefinition)
ParametersParameterValueRelatedartifact(value: Relatedartifact)
ParametersParameterValueTriggerdefinition(value: Triggerdefinition)
ParametersParameterValueUsagecontext(value: Usagecontext)
ParametersParameterValueDosage(value: Dosage)
ParametersParameterValueMeta(value: Meta)}
pub fn parameters_parameter_value_to_json(elt: ParametersParameterValue) -> Json {case elt{ParametersParameterValueBase64binary(v) -> json.string(v)
ParametersParameterValueBoolean(v) -> json.bool(v)
ParametersParameterValueCanonical(v) -> json.string(v)
ParametersParameterValueCode(v) -> json.string(v)
ParametersParameterValueDate(v) -> json.string(v)
ParametersParameterValueDatetime(v) -> json.string(v)
ParametersParameterValueDecimal(v) -> json.float(v)
ParametersParameterValueId(v) -> json.string(v)
ParametersParameterValueInstant(v) -> json.string(v)
ParametersParameterValueInteger(v) -> json.int(v)
ParametersParameterValueMarkdown(v) -> json.string(v)
ParametersParameterValueOid(v) -> json.string(v)
ParametersParameterValuePositiveint(v) -> json.int(v)
ParametersParameterValueString(v) -> json.string(v)
ParametersParameterValueTime(v) -> json.string(v)
ParametersParameterValueUnsignedint(v) -> json.int(v)
ParametersParameterValueUri(v) -> json.string(v)
ParametersParameterValueUrl(v) -> json.string(v)
ParametersParameterValueUuid(v) -> json.string(v)
ParametersParameterValueAddress(v) -> address_to_json(v)
ParametersParameterValueAge(v) -> age_to_json(v)
ParametersParameterValueAnnotation(v) -> annotation_to_json(v)
ParametersParameterValueAttachment(v) -> attachment_to_json(v)
ParametersParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
ParametersParameterValueCoding(v) -> coding_to_json(v)
ParametersParameterValueContactpoint(v) -> contactpoint_to_json(v)
ParametersParameterValueCount(v) -> count_to_json(v)
ParametersParameterValueDistance(v) -> distance_to_json(v)
ParametersParameterValueDuration(v) -> duration_to_json(v)
ParametersParameterValueHumanname(v) -> humanname_to_json(v)
ParametersParameterValueIdentifier(v) -> identifier_to_json(v)
ParametersParameterValueMoney(v) -> money_to_json(v)
ParametersParameterValuePeriod(v) -> period_to_json(v)
ParametersParameterValueQuantity(v) -> quantity_to_json(v)
ParametersParameterValueRange(v) -> range_to_json(v)
ParametersParameterValueRatio(v) -> ratio_to_json(v)
ParametersParameterValueReference(v) -> reference_to_json(v)
ParametersParameterValueSampleddata(v) -> sampleddata_to_json(v)
ParametersParameterValueSignature(v) -> signature_to_json(v)
ParametersParameterValueTiming(v) -> timing_to_json(v)
ParametersParameterValueContactdetail(v) -> contactdetail_to_json(v)
ParametersParameterValueContributor(v) -> contributor_to_json(v)
ParametersParameterValueDatarequirement(v) -> datarequirement_to_json(v)
ParametersParameterValueExpression(v) -> expression_to_json(v)
ParametersParameterValueParameterdefinition(v) -> parameterdefinition_to_json(v)
ParametersParameterValueRelatedartifact(v) -> relatedartifact_to_json(v)
ParametersParameterValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
ParametersParameterValueUsagecontext(v) -> usagecontext_to_json(v)
ParametersParameterValueDosage(v) -> dosage_to_json(v)
ParametersParameterValueMeta(v) -> meta_to_json(v)
}}
pub fn parameters_parameter_value_decoder() -> Decoder(ParametersParameterValue){decode.one_of(decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(ParametersParameterValueBase64binary),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ParametersParameterValueBoolean),decode.field("valueCanonical", decode.string, decode.success) |> decode.map(ParametersParameterValueCanonical),decode.field("valueCode", decode.string, decode.success) |> decode.map(ParametersParameterValueCode),decode.field("valueDate", decode.string, decode.success) |> decode.map(ParametersParameterValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ParametersParameterValueDatetime),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(ParametersParameterValueDecimal),decode.field("valueId", decode.string, decode.success) |> decode.map(ParametersParameterValueId),decode.field("valueInstant", decode.string, decode.success) |> decode.map(ParametersParameterValueInstant),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ParametersParameterValueInteger),decode.field("valueMarkdown", decode.string, decode.success) |> decode.map(ParametersParameterValueMarkdown),decode.field("valueOid", decode.string, decode.success) |> decode.map(ParametersParameterValueOid),decode.field("valuePositiveInt", decode.int, decode.success) |> decode.map(ParametersParameterValuePositiveint),decode.field("valueString", decode.string, decode.success) |> decode.map(ParametersParameterValueString),decode.field("valueTime", decode.string, decode.success) |> decode.map(ParametersParameterValueTime),decode.field("valueUnsignedInt", decode.int, decode.success) |> decode.map(ParametersParameterValueUnsignedint),decode.field("valueUri", decode.string, decode.success) |> decode.map(ParametersParameterValueUri),decode.field("valueUrl", decode.string, decode.success) |> decode.map(ParametersParameterValueUrl),decode.field("valueUuid", decode.string, decode.success) |> decode.map(ParametersParameterValueUuid),decode.field("valueAddress", address_decoder(), decode.success) |> decode.map(ParametersParameterValueAddress),decode.field("valueAge", age_decoder(), decode.success) |> decode.map(ParametersParameterValueAge),decode.field("valueAnnotation", annotation_decoder(), decode.success) |> decode.map(ParametersParameterValueAnnotation),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(ParametersParameterValueAttachment),decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ParametersParameterValueCodeableconcept),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(ParametersParameterValueCoding),decode.field("valueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(ParametersParameterValueContactpoint),decode.field("valueCount", count_decoder(), decode.success) |> decode.map(ParametersParameterValueCount),decode.field("valueDistance", distance_decoder(), decode.success) |> decode.map(ParametersParameterValueDistance),decode.field("valueDuration", duration_decoder(), decode.success) |> decode.map(ParametersParameterValueDuration),decode.field("valueHumanName", humanname_decoder(), decode.success) |> decode.map(ParametersParameterValueHumanname),decode.field("valueIdentifier", identifier_decoder(), decode.success) |> decode.map(ParametersParameterValueIdentifier),decode.field("valueMoney", money_decoder(), decode.success) |> decode.map(ParametersParameterValueMoney),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(ParametersParameterValuePeriod),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(ParametersParameterValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(ParametersParameterValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(ParametersParameterValueRatio),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(ParametersParameterValueReference),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(ParametersParameterValueSampleddata),decode.field("valueSignature", signature_decoder(), decode.success) |> decode.map(ParametersParameterValueSignature),decode.field("valueTiming", timing_decoder(), decode.success) |> decode.map(ParametersParameterValueTiming),decode.field("valueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(ParametersParameterValueContactdetail),decode.field("valueContributor", contributor_decoder(), decode.success) |> decode.map(ParametersParameterValueContributor),decode.field("valueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ParametersParameterValueDatarequirement),decode.field("valueExpression", expression_decoder(), decode.success) |> decode.map(ParametersParameterValueExpression),decode.field("valueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(ParametersParameterValueParameterdefinition),decode.field("valueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(ParametersParameterValueRelatedartifact),decode.field("valueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(ParametersParameterValueTriggerdefinition),decode.field("valueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(ParametersParameterValueUsagecontext),decode.field("valueDosage", dosage_decoder(), decode.success) |> decode.map(ParametersParameterValueDosage),decode.field("valueMeta", meta_decoder(), decode.success) |> decode.map(ParametersParameterValueMeta),])}
pub fn parameters_parameter_new(name name: String,) ->ParametersParameter{ParametersParameter(resource: None,value: None,name:,modifier_extension: [],extension: [],id: None,)
}

pub fn parameters_parameter_to_json(parameters_parameter: ParametersParameter) -> Json {
    let ParametersParameter(resource:,value:,name:,modifier_extension:,extension:,id:,) = parameters_parameter
    let fields = [#("name", json.string(name)),]
let fields = case resource {
                          Some(v) -> [#("resource", resource_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", parameters_parameter_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn parameters_parameter_decoder() -> Decoder(ParametersParameter) {use resource <- decode.optional_field("resource", None, decode.optional(resource_decoder()))
use value <- decode.then(none_if_omitted(parameters_parameter_value_decoder()))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ParametersParameter(resource:,value:,name:,modifier_extension:,extension:,id:,))}
pub fn parameters_to_json(parameters: Parameters) -> Json {
    let Parameters(parameter:,language:,implicit_rules:,meta:,id:,) = parameters
    let fields = []
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,parameters_parameter_to_json)), ..fields]
                          }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn parameters_decoder() -> Decoder(Parameters) {use parameter <- decode.optional_field("parameter", [], decode.list(parameters_parameter_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Parameters(parameter:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type Patient
{
Patient(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
name: List(Humanname),
telecom: List(Contactpoint),
gender: Option(r4valuesets.Administrativegender),
birth_date: Option(String),
deceased: Option(PatientDeceased),
address: List(Address),
marital_status: Option(Codeableconcept),
multiple_birth: Option(PatientMultiplebirth),
photo: List(Attachment),
contact: List(PatientContact),
communication: List(PatientCommunication),
general_practitioner: List(Reference),
managing_organization: Option(Reference),
link: List(PatientLink),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type PatientDeceased{
PatientDeceasedBoolean(deceased: Bool)
PatientDeceasedDatetime(deceased: String)}
pub fn patient_deceased_to_json(elt: PatientDeceased) -> Json {case elt{PatientDeceasedBoolean(v) -> json.bool(v)
PatientDeceasedDatetime(v) -> json.string(v)
}}
pub fn patient_deceased_decoder() -> Decoder(PatientDeceased){decode.one_of(decode.field("deceasedBoolean", decode.bool, decode.success) |> decode.map(PatientDeceasedBoolean),[decode.field("deceasedDateTime", decode.string, decode.success) |> decode.map(PatientDeceasedDatetime),])}

///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type PatientMultiplebirth{
PatientMultiplebirthBoolean(multiple_birth: Bool)
PatientMultiplebirthInteger(multiple_birth: Int)}
pub fn patient_multiplebirth_to_json(elt: PatientMultiplebirth) -> Json {case elt{PatientMultiplebirthBoolean(v) -> json.bool(v)
PatientMultiplebirthInteger(v) -> json.int(v)
}}
pub fn patient_multiplebirth_decoder() -> Decoder(PatientMultiplebirth){decode.one_of(decode.field("multipleBirthBoolean", decode.bool, decode.success) |> decode.map(PatientMultiplebirthBoolean),[decode.field("multipleBirthInteger", decode.int, decode.success) |> decode.map(PatientMultiplebirthInteger),])}
pub fn patient_new() ->Patient{Patient(link: [],managing_organization: None,general_practitioner: [],communication: [],contact: [],photo: [],multiple_birth: None,marital_status: None,address: [],deceased: None,birth_date: None,gender: None,telecom: [],name: [],active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type PatientContact
{
PatientContact(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
relationship: List(Codeableconcept),
name: Option(Humanname),
telecom: List(Contactpoint),
address: Option(Address),
gender: Option(r4valuesets.Administrativegender),
organization: Option(Reference),
period: Option(Period),
)
}

pub fn patient_contact_new() ->PatientContact{PatientContact(period: None,organization: None,gender: None,address: None,telecom: [],name: None,relationship: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type PatientCommunication
{
PatientCommunication(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
language: Codeableconcept,
preferred: Option(Bool),
)
}

pub fn patient_communication_new(language language: Codeableconcept,) ->PatientCommunication{PatientCommunication(preferred: None,language:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Patient#resource
pub type PatientLink
{
PatientLink(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
other: Reference,
type_: r4valuesets.Linktype,
)
}

pub fn patient_link_new(type_ type_: r4valuesets.Linktype,other other: Reference,) ->PatientLink{PatientLink(type_:,other:,modifier_extension: [],extension: [],id: None,)
}

pub fn patient_link_to_json(patient_link: PatientLink) -> Json {
    let PatientLink(type_:,other:,modifier_extension:,extension:,id:,) = patient_link
    let fields = [#("type", r4valuesets.linktype_to_json(type_)),#("other", reference_to_json(other)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn patient_link_decoder() -> Decoder(PatientLink) {use type_ <- decode.field("type",r4valuesets.linktype_decoder())
use other <- decode.field("other",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PatientLink(type_:,other:,modifier_extension:,extension:,id:,))}
pub fn patient_communication_to_json(patient_communication: PatientCommunication) -> Json {
    let PatientCommunication(preferred:,language:,modifier_extension:,extension:,id:,) = patient_communication
    let fields = [#("language", codeableconcept_to_json(language)),]
let fields = case preferred {
                          Some(v) -> [#("preferred", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn patient_communication_decoder() -> Decoder(PatientCommunication) {use preferred <- decode.optional_field("preferred", None, decode.optional(decode.bool))
use language <- decode.field("language",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PatientCommunication(preferred:,language:,modifier_extension:,extension:,id:,))}
pub fn patient_contact_to_json(patient_contact: PatientContact) -> Json {
    let PatientContact(period:,organization:,gender:,address:,telecom:,name:,relationship:,modifier_extension:,extension:,id:,) = patient_contact
    let fields = []
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organization {
                          Some(v) -> [#("organization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                          Some(v) -> [#("address", address_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                          Some(v) -> [#("name", humanname_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                        [] -> fields
                        _ -> [#("relationship", json.array(relationship,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn patient_contact_decoder() -> Decoder(PatientContact) {use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use organization <- decode.optional_field("organization", None, decode.optional(reference_decoder()))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use address <- decode.optional_field("address", None, decode.optional(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", None, decode.optional(humanname_decoder()))
use relationship <- decode.optional_field("relationship", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PatientContact(period:,organization:,gender:,address:,telecom:,name:,relationship:,modifier_extension:,extension:,id:,))}
pub fn patient_to_json(patient: Patient) -> Json {
    let Patient(link:,managing_organization:,general_practitioner:,communication:,contact:,photo:,multiple_birth:,marital_status:,address:,deceased:,birth_date:,gender:,telecom:,name:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = patient
    let fields = []
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,patient_link_to_json)), ..fields]
                          }
let fields = case managing_organization {
                          Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case general_practitioner {
                        [] -> fields
                        _ -> [#("generalPractitioner", json.array(general_practitioner,reference_to_json)), ..fields]
                          }
let fields = case communication {
                        [] -> fields
                        _ -> [#("communication", json.array(communication,patient_communication_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,patient_contact_to_json)), ..fields]
                          }
let fields = case photo {
                        [] -> fields
                        _ -> [#("photo", json.array(photo,attachment_to_json)), ..fields]
                          }
let fields = case multiple_birth {
                          Some(v) -> [#("multipleBirth", patient_multiplebirth_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case marital_status {
                          Some(v) -> [#("maritalStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                        [] -> fields
                        _ -> [#("address", json.array(address,address_to_json)), ..fields]
                          }
let fields = case deceased {
                          Some(v) -> [#("deceased", patient_deceased_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case birth_date {
                          Some(v) -> [#("birthDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,humanname_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn patient_decoder() -> Decoder(Patient) {use link <- decode.optional_field("link", [], decode.list(patient_link_decoder()))
use managing_organization <- decode.optional_field("managingOrganization", None, decode.optional(reference_decoder()))
use general_practitioner <- decode.optional_field("generalPractitioner", [], decode.list(reference_decoder()))
use communication <- decode.optional_field("communication", [], decode.list(patient_communication_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(patient_contact_decoder()))
use photo <- decode.optional_field("photo", [], decode.list(attachment_decoder()))
use multiple_birth <- decode.then(none_if_omitted(patient_multiplebirth_decoder()))
use marital_status <- decode.optional_field("maritalStatus", None, decode.optional(codeableconcept_decoder()))
use address <- decode.optional_field("address", [], decode.list(address_decoder()))
use deceased <- decode.then(none_if_omitted(patient_deceased_decoder()))
use birth_date <- decode.optional_field("birthDate", None, decode.optional(decode.string))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", [], decode.list(humanname_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Patient(link:,managing_organization:,general_practitioner:,communication:,contact:,photo:,multiple_birth:,marital_status:,address:,deceased:,birth_date:,gender:,telecom:,name:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/PaymentNotice#resource
pub type Paymentnotice
{
Paymentnotice(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
request: Option(Reference),
response: Option(Reference),
created: String,
provider: Option(Reference),
payment: Reference,
payment_date: Option(String),
payee: Option(Reference),
recipient: Reference,
amount: Money,
payment_status: Option(Codeableconcept),
)
}

pub fn paymentnotice_new(amount amount: Money,recipient recipient: Reference,payment payment: Reference,created created: String,status status: r4valuesets.Fmstatus,) ->Paymentnotice{Paymentnotice(payment_status: None,amount:,recipient:,payee: None,payment_date: None,payment:,provider: None,created:,response: None,request: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn paymentnotice_to_json(paymentnotice: Paymentnotice) -> Json {
    let Paymentnotice(payment_status:,amount:,recipient:,payee:,payment_date:,payment:,provider:,created:,response:,request:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = paymentnotice
    let fields = [#("amount", money_to_json(amount)),#("recipient", reference_to_json(recipient)),#("payment", reference_to_json(payment)),#("created", json.string(created)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case payment_status {
                          Some(v) -> [#("paymentStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payee {
                          Some(v) -> [#("payee", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payment_date {
                          Some(v) -> [#("paymentDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case provider {
                          Some(v) -> [#("provider", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case response {
                          Some(v) -> [#("response", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn paymentnotice_decoder() -> Decoder(Paymentnotice) {use payment_status <- decode.optional_field("paymentStatus", None, decode.optional(codeableconcept_decoder()))
use amount <- decode.field("amount",money_decoder())
use recipient <- decode.field("recipient",reference_decoder())
use payee <- decode.optional_field("payee", None, decode.optional(reference_decoder()))
use payment_date <- decode.optional_field("paymentDate", None, decode.optional(decode.string))
use payment <- decode.field("payment",reference_decoder())
use provider <- decode.optional_field("provider", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use response <- decode.optional_field("response", None, decode.optional(reference_decoder()))
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Paymentnotice(payment_status:,amount:,recipient:,payee:,payment_date:,payment:,provider:,created:,response:,request:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/PaymentReconciliation#resource
pub type Paymentreconciliation
{
Paymentreconciliation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
period: Option(Period),
created: String,
payment_issuer: Option(Reference),
request: Option(Reference),
requestor: Option(Reference),
outcome: Option(r4valuesets.Remittanceoutcome),
disposition: Option(String),
payment_date: String,
payment_amount: Money,
payment_identifier: Option(Identifier),
detail: List(PaymentreconciliationDetail),
form_code: Option(Codeableconcept),
process_note: List(PaymentreconciliationProcessnote),
)
}

pub fn paymentreconciliation_new(payment_amount payment_amount: Money,payment_date payment_date: String,created created: String,status status: r4valuesets.Fmstatus,) ->Paymentreconciliation{Paymentreconciliation(process_note: [],form_code: None,detail: [],payment_identifier: None,payment_amount:,payment_date:,disposition: None,outcome: None,requestor: None,request: None,payment_issuer: None,created:,period: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationDetail
{
PaymentreconciliationDetail(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
predecessor: Option(Identifier),
type_: Codeableconcept,
request: Option(Reference),
submitter: Option(Reference),
response: Option(Reference),
date: Option(String),
responsible: Option(Reference),
payee: Option(Reference),
amount: Option(Money),
)
}

pub fn paymentreconciliation_detail_new(type_ type_: Codeableconcept,) ->PaymentreconciliationDetail{PaymentreconciliationDetail(amount: None,payee: None,responsible: None,date: None,response: None,submitter: None,request: None,type_:,predecessor: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationProcessnote
{
PaymentreconciliationProcessnote(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(r4valuesets.Notetype),
text: Option(String),
)
}

pub fn paymentreconciliation_processnote_new() ->PaymentreconciliationProcessnote{PaymentreconciliationProcessnote(text: None,type_: None,modifier_extension: [],extension: [],id: None,)
}

pub fn paymentreconciliation_processnote_to_json(paymentreconciliation_processnote: PaymentreconciliationProcessnote) -> Json {
    let PaymentreconciliationProcessnote(text:,type_:,modifier_extension:,extension:,id:,) = paymentreconciliation_processnote
    let fields = []
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", r4valuesets.notetype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn paymentreconciliation_processnote_decoder() -> Decoder(PaymentreconciliationProcessnote) {use text <- decode.optional_field("text", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(r4valuesets.notetype_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PaymentreconciliationProcessnote(text:,type_:,modifier_extension:,extension:,id:,))}
pub fn paymentreconciliation_detail_to_json(paymentreconciliation_detail: PaymentreconciliationDetail) -> Json {
    let PaymentreconciliationDetail(amount:,payee:,responsible:,date:,response:,submitter:,request:,type_:,predecessor:,identifier:,modifier_extension:,extension:,id:,) = paymentreconciliation_detail
    let fields = [#("type", codeableconcept_to_json(type_)),]
let fields = case amount {
                          Some(v) -> [#("amount", money_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payee {
                          Some(v) -> [#("payee", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case responsible {
                          Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case response {
                          Some(v) -> [#("response", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case submitter {
                          Some(v) -> [#("submitter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case predecessor {
                          Some(v) -> [#("predecessor", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn paymentreconciliation_detail_decoder() -> Decoder(PaymentreconciliationDetail) {use amount <- decode.optional_field("amount", None, decode.optional(money_decoder()))
use payee <- decode.optional_field("payee", None, decode.optional(reference_decoder()))
use responsible <- decode.optional_field("responsible", None, decode.optional(reference_decoder()))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use response <- decode.optional_field("response", None, decode.optional(reference_decoder()))
use submitter <- decode.optional_field("submitter", None, decode.optional(reference_decoder()))
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use type_ <- decode.field("type",codeableconcept_decoder())
use predecessor <- decode.optional_field("predecessor", None, decode.optional(identifier_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PaymentreconciliationDetail(amount:,payee:,responsible:,date:,response:,submitter:,request:,type_:,predecessor:,identifier:,modifier_extension:,extension:,id:,))}
pub fn paymentreconciliation_to_json(paymentreconciliation: Paymentreconciliation) -> Json {
    let Paymentreconciliation(process_note:,form_code:,detail:,payment_identifier:,payment_amount:,payment_date:,disposition:,outcome:,requestor:,request:,payment_issuer:,created:,period:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = paymentreconciliation
    let fields = [#("paymentAmount", money_to_json(payment_amount)),#("paymentDate", json.string(payment_date)),#("created", json.string(created)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case process_note {
                        [] -> fields
                        _ -> [#("processNote", json.array(process_note,paymentreconciliation_processnote_to_json)), ..fields]
                          }
let fields = case form_code {
                          Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case detail {
                        [] -> fields
                        _ -> [#("detail", json.array(detail,paymentreconciliation_detail_to_json)), ..fields]
                          }
let fields = case payment_identifier {
                          Some(v) -> [#("paymentIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case disposition {
                          Some(v) -> [#("disposition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", r4valuesets.remittanceoutcome_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requestor {
                          Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                          Some(v) -> [#("request", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case payment_issuer {
                          Some(v) -> [#("paymentIssuer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn paymentreconciliation_decoder() -> Decoder(Paymentreconciliation) {use process_note <- decode.optional_field("processNote", [], decode.list(paymentreconciliation_processnote_decoder()))
use form_code <- decode.optional_field("formCode", None, decode.optional(codeableconcept_decoder()))
use detail <- decode.optional_field("detail", [], decode.list(paymentreconciliation_detail_decoder()))
use payment_identifier <- decode.optional_field("paymentIdentifier", None, decode.optional(identifier_decoder()))
use payment_amount <- decode.field("paymentAmount",money_decoder())
use payment_date <- decode.field("paymentDate",decode.string)
use disposition <- decode.optional_field("disposition", None, decode.optional(decode.string))
use outcome <- decode.optional_field("outcome", None, decode.optional(r4valuesets.remittanceoutcome_decoder()))
use requestor <- decode.optional_field("requestor", None, decode.optional(reference_decoder()))
use request <- decode.optional_field("request", None, decode.optional(reference_decoder()))
use payment_issuer <- decode.optional_field("paymentIssuer", None, decode.optional(reference_decoder()))
use created <- decode.field("created",decode.string)
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Paymentreconciliation(process_note:,form_code:,detail:,payment_identifier:,payment_amount:,payment_date:,disposition:,outcome:,requestor:,request:,payment_issuer:,created:,period:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Person#resource
pub type Person
{
Person(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
name: List(Humanname),
telecom: List(Contactpoint),
gender: Option(r4valuesets.Administrativegender),
birth_date: Option(String),
address: List(Address),
photo: Option(Attachment),
managing_organization: Option(Reference),
active: Option(Bool),
link: List(PersonLink),
)
}

pub fn person_new() ->Person{Person(link: [],active: None,managing_organization: None,photo: None,address: [],birth_date: None,gender: None,telecom: [],name: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Person#resource
pub type PersonLink
{
PersonLink(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
target: Reference,
assurance: Option(r4valuesets.Identityassurancelevel),
)
}

pub fn person_link_new(target target: Reference,) ->PersonLink{PersonLink(assurance: None,target:,modifier_extension: [],extension: [],id: None,)
}

pub fn person_link_to_json(person_link: PersonLink) -> Json {
    let PersonLink(assurance:,target:,modifier_extension:,extension:,id:,) = person_link
    let fields = [#("target", reference_to_json(target)),]
let fields = case assurance {
                          Some(v) -> [#("assurance", r4valuesets.identityassurancelevel_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn person_link_decoder() -> Decoder(PersonLink) {use assurance <- decode.optional_field("assurance", None, decode.optional(r4valuesets.identityassurancelevel_decoder()))
use target <- decode.field("target",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PersonLink(assurance:,target:,modifier_extension:,extension:,id:,))}
pub fn person_to_json(person: Person) -> Json {
    let Person(link:,active:,managing_organization:,photo:,address:,birth_date:,gender:,telecom:,name:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = person
    let fields = []
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,person_link_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case managing_organization {
                          Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case photo {
                          Some(v) -> [#("photo", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                        [] -> fields
                        _ -> [#("address", json.array(address,address_to_json)), ..fields]
                          }
let fields = case birth_date {
                          Some(v) -> [#("birthDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,humanname_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn person_decoder() -> Decoder(Person) {use link <- decode.optional_field("link", [], decode.list(person_link_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use managing_organization <- decode.optional_field("managingOrganization", None, decode.optional(reference_decoder()))
use photo <- decode.optional_field("photo", None, decode.optional(attachment_decoder()))
use address <- decode.optional_field("address", [], decode.list(address_decoder()))
use birth_date <- decode.optional_field("birthDate", None, decode.optional(decode.string))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", [], decode.list(humanname_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Person(link:,active:,managing_organization:,photo:,address:,birth_date:,gender:,telecom:,name:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type Plandefinition
{
Plandefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
subtitle: Option(String),
type_: Option(Codeableconcept),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(PlandefinitionSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
library: List(String),
goal: List(PlandefinitionGoal),
action: List(PlandefinitionAction),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionSubject{
PlandefinitionSubjectCodeableconcept(subject: Codeableconcept)
PlandefinitionSubjectReference(subject: Reference)}
pub fn plandefinition_subject_to_json(elt: PlandefinitionSubject) -> Json {case elt{PlandefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
PlandefinitionSubjectReference(v) -> reference_to_json(v)
}}
pub fn plandefinition_subject_decoder() -> Decoder(PlandefinitionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(PlandefinitionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(PlandefinitionSubjectReference),])}
pub fn plandefinition_new(status status: r4valuesets.Publicationstatus,) ->Plandefinition{Plandefinition(action: [],goal: [],library: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,type_: None,subtitle: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoal
{
PlandefinitionGoal(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Option(Codeableconcept),
description: Codeableconcept,
priority: Option(Codeableconcept),
start: Option(Codeableconcept),
addresses: List(Codeableconcept),
documentation: List(Relatedartifact),
target: List(PlandefinitionGoalTarget),
)
}

pub fn plandefinition_goal_new(description description: Codeableconcept,) ->PlandefinitionGoal{PlandefinitionGoal(target: [],documentation: [],addresses: [],start: None,priority: None,description:,category: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTarget
{
PlandefinitionGoalTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
measure: Option(Codeableconcept),
detail: Option(PlandefinitionGoalTargetDetail),
due: Option(Duration),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTargetDetail{
PlandefinitionGoalTargetDetailQuantity(detail: Quantity)
PlandefinitionGoalTargetDetailRange(detail: Range)
PlandefinitionGoalTargetDetailCodeableconcept(detail: Codeableconcept)}
pub fn plandefinition_goal_target_detail_to_json(elt: PlandefinitionGoalTargetDetail) -> Json {case elt{PlandefinitionGoalTargetDetailQuantity(v) -> quantity_to_json(v)
PlandefinitionGoalTargetDetailRange(v) -> range_to_json(v)
PlandefinitionGoalTargetDetailCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn plandefinition_goal_target_detail_decoder() -> Decoder(PlandefinitionGoalTargetDetail){decode.one_of(decode.field("detailQuantity", quantity_decoder(), decode.success) |> decode.map(PlandefinitionGoalTargetDetailQuantity),[decode.field("detailRange", range_decoder(), decode.success) |> decode.map(PlandefinitionGoalTargetDetailRange),decode.field("detailCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(PlandefinitionGoalTargetDetailCodeableconcept),])}
pub fn plandefinition_goal_target_new() ->PlandefinitionGoalTarget{PlandefinitionGoalTarget(due: None,detail: None,measure: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionAction
{
PlandefinitionAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
prefix: Option(String),
title: Option(String),
description: Option(String),
text_equivalent: Option(String),
priority: Option(r4valuesets.Requestpriority),
code: List(Codeableconcept),
reason: List(Codeableconcept),
documentation: List(Relatedartifact),
goal_id: List(String),
subject: Option(PlandefinitionActionSubject),
trigger: List(Triggerdefinition),
condition: List(PlandefinitionActionCondition),
input: List(Datarequirement),
output: List(Datarequirement),
related_action: List(PlandefinitionActionRelatedaction),
timing: Option(PlandefinitionActionTiming),
participant: List(PlandefinitionActionParticipant),
type_: Option(Codeableconcept),
grouping_behavior: Option(r4valuesets.Actiongroupingbehavior),
selection_behavior: Option(r4valuesets.Actionselectionbehavior),
required_behavior: Option(r4valuesets.Actionrequiredbehavior),
precheck_behavior: Option(r4valuesets.Actionprecheckbehavior),
cardinality_behavior: Option(r4valuesets.Actioncardinalitybehavior),
definition: Option(PlandefinitionActionDefinition),
transform: Option(String),
dynamic_value: List(PlandefinitionActionDynamicvalue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionSubject{
PlandefinitionActionSubjectCodeableconcept(subject: Codeableconcept)
PlandefinitionActionSubjectReference(subject: Reference)}
pub fn plandefinition_action_subject_to_json(elt: PlandefinitionActionSubject) -> Json {case elt{PlandefinitionActionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
PlandefinitionActionSubjectReference(v) -> reference_to_json(v)
}}
pub fn plandefinition_action_subject_decoder() -> Decoder(PlandefinitionActionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(PlandefinitionActionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(PlandefinitionActionSubjectReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionTiming{
PlandefinitionActionTimingDatetime(timing: String)
PlandefinitionActionTimingAge(timing: Age)
PlandefinitionActionTimingPeriod(timing: Period)
PlandefinitionActionTimingDuration(timing: Duration)
PlandefinitionActionTimingRange(timing: Range)
PlandefinitionActionTimingTiming(timing: Timing)}
pub fn plandefinition_action_timing_to_json(elt: PlandefinitionActionTiming) -> Json {case elt{PlandefinitionActionTimingDatetime(v) -> json.string(v)
PlandefinitionActionTimingAge(v) -> age_to_json(v)
PlandefinitionActionTimingPeriod(v) -> period_to_json(v)
PlandefinitionActionTimingDuration(v) -> duration_to_json(v)
PlandefinitionActionTimingRange(v) -> range_to_json(v)
PlandefinitionActionTimingTiming(v) -> timing_to_json(v)
}}
pub fn plandefinition_action_timing_decoder() -> Decoder(PlandefinitionActionTiming){decode.one_of(decode.field("timingDateTime", decode.string, decode.success) |> decode.map(PlandefinitionActionTimingDatetime),[decode.field("timingAge", age_decoder(), decode.success) |> decode.map(PlandefinitionActionTimingAge),decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(PlandefinitionActionTimingPeriod),decode.field("timingDuration", duration_decoder(), decode.success) |> decode.map(PlandefinitionActionTimingDuration),decode.field("timingRange", range_decoder(), decode.success) |> decode.map(PlandefinitionActionTimingRange),decode.field("timingTiming", timing_decoder(), decode.success) |> decode.map(PlandefinitionActionTimingTiming),])}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDefinition{
PlandefinitionActionDefinitionCanonical(definition: String)
PlandefinitionActionDefinitionUri(definition: String)}
pub fn plandefinition_action_definition_to_json(elt: PlandefinitionActionDefinition) -> Json {case elt{PlandefinitionActionDefinitionCanonical(v) -> json.string(v)
PlandefinitionActionDefinitionUri(v) -> json.string(v)
}}
pub fn plandefinition_action_definition_decoder() -> Decoder(PlandefinitionActionDefinition){decode.one_of(decode.field("definitionCanonical", decode.string, decode.success) |> decode.map(PlandefinitionActionDefinitionCanonical),[decode.field("definitionUri", decode.string, decode.success) |> decode.map(PlandefinitionActionDefinitionUri),])}
pub fn plandefinition_action_new() ->PlandefinitionAction{PlandefinitionAction(dynamic_value: [],transform: None,definition: None,cardinality_behavior: None,precheck_behavior: None,required_behavior: None,selection_behavior: None,grouping_behavior: None,type_: None,participant: [],timing: None,related_action: [],output: [],input: [],condition: [],trigger: [],subject: None,goal_id: [],documentation: [],reason: [],code: [],priority: None,text_equivalent: None,description: None,title: None,prefix: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionCondition
{
PlandefinitionActionCondition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
kind: r4valuesets.Actionconditionkind,
expression: Option(Expression),
)
}

pub fn plandefinition_action_condition_new(kind kind: r4valuesets.Actionconditionkind,) ->PlandefinitionActionCondition{PlandefinitionActionCondition(expression: None,kind:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedaction
{
PlandefinitionActionRelatedaction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action_id: String,
relationship: r4valuesets.Actionrelationshiptype,
offset: Option(PlandefinitionActionRelatedactionOffset),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedactionOffset{
PlandefinitionActionRelatedactionOffsetDuration(offset: Duration)
PlandefinitionActionRelatedactionOffsetRange(offset: Range)}
pub fn plandefinition_action_relatedaction_offset_to_json(elt: PlandefinitionActionRelatedactionOffset) -> Json {case elt{PlandefinitionActionRelatedactionOffsetDuration(v) -> duration_to_json(v)
PlandefinitionActionRelatedactionOffsetRange(v) -> range_to_json(v)
}}
pub fn plandefinition_action_relatedaction_offset_decoder() -> Decoder(PlandefinitionActionRelatedactionOffset){decode.one_of(decode.field("offsetDuration", duration_decoder(), decode.success) |> decode.map(PlandefinitionActionRelatedactionOffsetDuration),[decode.field("offsetRange", range_decoder(), decode.success) |> decode.map(PlandefinitionActionRelatedactionOffsetRange),])}
pub fn plandefinition_action_relatedaction_new(relationship relationship: r4valuesets.Actionrelationshiptype,action_id action_id: String,) ->PlandefinitionActionRelatedaction{PlandefinitionActionRelatedaction(offset: None,relationship:,action_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionParticipant
{
PlandefinitionActionParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Actionparticipanttype,
role: Option(Codeableconcept),
)
}

pub fn plandefinition_action_participant_new(type_ type_: r4valuesets.Actionparticipanttype,) ->PlandefinitionActionParticipant{PlandefinitionActionParticipant(role: None,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDynamicvalue
{
PlandefinitionActionDynamicvalue(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
path: Option(String),
expression: Option(Expression),
)
}

pub fn plandefinition_action_dynamicvalue_new() ->PlandefinitionActionDynamicvalue{PlandefinitionActionDynamicvalue(expression: None,path: None,modifier_extension: [],extension: [],id: None,)
}

pub fn plandefinition_action_dynamicvalue_to_json(plandefinition_action_dynamicvalue: PlandefinitionActionDynamicvalue) -> Json {
    let PlandefinitionActionDynamicvalue(expression:,path:,modifier_extension:,extension:,id:,) = plandefinition_action_dynamicvalue
    let fields = []
let fields = case expression {
                          Some(v) -> [#("expression", expression_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case path {
                          Some(v) -> [#("path", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_action_dynamicvalue_decoder() -> Decoder(PlandefinitionActionDynamicvalue) {use expression <- decode.optional_field("expression", None, decode.optional(expression_decoder()))
use path <- decode.optional_field("path", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionActionDynamicvalue(expression:,path:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_action_participant_to_json(plandefinition_action_participant: PlandefinitionActionParticipant) -> Json {
    let PlandefinitionActionParticipant(role:,type_:,modifier_extension:,extension:,id:,) = plandefinition_action_participant
    let fields = [#("type", r4valuesets.actionparticipanttype_to_json(type_)),]
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_action_participant_decoder() -> Decoder(PlandefinitionActionParticipant) {use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.field("type",r4valuesets.actionparticipanttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionActionParticipant(role:,type_:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_action_relatedaction_to_json(plandefinition_action_relatedaction: PlandefinitionActionRelatedaction) -> Json {
    let PlandefinitionActionRelatedaction(offset:,relationship:,action_id:,modifier_extension:,extension:,id:,) = plandefinition_action_relatedaction
    let fields = [#("relationship", r4valuesets.actionrelationshiptype_to_json(relationship)),#("actionId", json.string(action_id)),]
let fields = case offset {
                          Some(v) -> [#("offset", plandefinition_action_relatedaction_offset_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_action_relatedaction_decoder() -> Decoder(PlandefinitionActionRelatedaction) {use offset <- decode.then(none_if_omitted(plandefinition_action_relatedaction_offset_decoder()))
use relationship <- decode.field("relationship",r4valuesets.actionrelationshiptype_decoder())
use action_id <- decode.field("actionId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionActionRelatedaction(offset:,relationship:,action_id:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_action_condition_to_json(plandefinition_action_condition: PlandefinitionActionCondition) -> Json {
    let PlandefinitionActionCondition(expression:,kind:,modifier_extension:,extension:,id:,) = plandefinition_action_condition
    let fields = [#("kind", r4valuesets.actionconditionkind_to_json(kind)),]
let fields = case expression {
                          Some(v) -> [#("expression", expression_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_action_condition_decoder() -> Decoder(PlandefinitionActionCondition) {use expression <- decode.optional_field("expression", None, decode.optional(expression_decoder()))
use kind <- decode.field("kind",r4valuesets.actionconditionkind_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionActionCondition(expression:,kind:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_action_to_json(plandefinition_action: PlandefinitionAction) -> Json {
    let PlandefinitionAction(dynamic_value:,transform:,definition:,cardinality_behavior:,precheck_behavior:,required_behavior:,selection_behavior:,grouping_behavior:,type_:,participant:,timing:,related_action:,output:,input:,condition:,trigger:,subject:,goal_id:,documentation:,reason:,code:,priority:,text_equivalent:,description:,title:,prefix:,modifier_extension:,extension:,id:,) = plandefinition_action
    let fields = []
let fields = case dynamic_value {
                        [] -> fields
                        _ -> [#("dynamicValue", json.array(dynamic_value,plandefinition_action_dynamicvalue_to_json)), ..fields]
                          }
let fields = case transform {
                          Some(v) -> [#("transform", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                          Some(v) -> [#("definition", plandefinition_action_definition_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case cardinality_behavior {
                          Some(v) -> [#("cardinalityBehavior", r4valuesets.actioncardinalitybehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case precheck_behavior {
                          Some(v) -> [#("precheckBehavior", r4valuesets.actionprecheckbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case required_behavior {
                          Some(v) -> [#("requiredBehavior", r4valuesets.actionrequiredbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case selection_behavior {
                          Some(v) -> [#("selectionBehavior", r4valuesets.actionselectionbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case grouping_behavior {
                          Some(v) -> [#("groupingBehavior", r4valuesets.actiongroupingbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,plandefinition_action_participant_to_json)), ..fields]
                          }
let fields = case timing {
                          Some(v) -> [#("timing", plandefinition_action_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related_action {
                        [] -> fields
                        _ -> [#("relatedAction", json.array(related_action,plandefinition_action_relatedaction_to_json)), ..fields]
                          }
let fields = case output {
                        [] -> fields
                        _ -> [#("output", json.array(output,datarequirement_to_json)), ..fields]
                          }
let fields = case input {
                        [] -> fields
                        _ -> [#("input", json.array(input,datarequirement_to_json)), ..fields]
                          }
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,plandefinition_action_condition_to_json)), ..fields]
                          }
let fields = case trigger {
                        [] -> fields
                        _ -> [#("trigger", json.array(trigger,triggerdefinition_to_json)), ..fields]
                          }
let fields = case subject {
                          Some(v) -> [#("subject", plandefinition_action_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case goal_id {
                        [] -> fields
                        _ -> [#("goalId", json.array(goal_id,json.string)), ..fields]
                          }
let fields = case documentation {
                        [] -> fields
                        _ -> [#("documentation", json.array(documentation,relatedartifact_to_json)), ..fields]
                          }
let fields = case reason {
                        [] -> fields
                        _ -> [#("reason", json.array(reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case text_equivalent {
                          Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case prefix {
                          Some(v) -> [#("prefix", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_action_decoder() -> Decoder(PlandefinitionAction) {use dynamic_value <- decode.optional_field("dynamicValue", [], decode.list(plandefinition_action_dynamicvalue_decoder()))
use transform <- decode.optional_field("transform", None, decode.optional(decode.string))
use definition <- decode.then(none_if_omitted(plandefinition_action_definition_decoder()))
use cardinality_behavior <- decode.optional_field("cardinalityBehavior", None, decode.optional(r4valuesets.actioncardinalitybehavior_decoder()))
use precheck_behavior <- decode.optional_field("precheckBehavior", None, decode.optional(r4valuesets.actionprecheckbehavior_decoder()))
use required_behavior <- decode.optional_field("requiredBehavior", None, decode.optional(r4valuesets.actionrequiredbehavior_decoder()))
use selection_behavior <- decode.optional_field("selectionBehavior", None, decode.optional(r4valuesets.actionselectionbehavior_decoder()))
use grouping_behavior <- decode.optional_field("groupingBehavior", None, decode.optional(r4valuesets.actiongroupingbehavior_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(plandefinition_action_participant_decoder()))
use timing <- decode.then(none_if_omitted(plandefinition_action_timing_decoder()))
use related_action <- decode.optional_field("relatedAction", [], decode.list(plandefinition_action_relatedaction_decoder()))
use output <- decode.optional_field("output", [], decode.list(datarequirement_decoder()))
use input <- decode.optional_field("input", [], decode.list(datarequirement_decoder()))
use condition <- decode.optional_field("condition", [], decode.list(plandefinition_action_condition_decoder()))
use trigger <- decode.optional_field("trigger", [], decode.list(triggerdefinition_decoder()))
use subject <- decode.then(none_if_omitted(plandefinition_action_subject_decoder()))
use goal_id <- decode.optional_field("goalId", [], decode.list(decode.string))
use documentation <- decode.optional_field("documentation", [], decode.list(relatedartifact_decoder()))
use reason <- decode.optional_field("reason", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use text_equivalent <- decode.optional_field("textEquivalent", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use prefix <- decode.optional_field("prefix", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionAction(dynamic_value:,transform:,definition:,cardinality_behavior:,precheck_behavior:,required_behavior:,selection_behavior:,grouping_behavior:,type_:,participant:,timing:,related_action:,output:,input:,condition:,trigger:,subject:,goal_id:,documentation:,reason:,code:,priority:,text_equivalent:,description:,title:,prefix:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_goal_target_to_json(plandefinition_goal_target: PlandefinitionGoalTarget) -> Json {
    let PlandefinitionGoalTarget(due:,detail:,measure:,modifier_extension:,extension:,id:,) = plandefinition_goal_target
    let fields = []
let fields = case due {
                          Some(v) -> [#("due", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case detail {
                          Some(v) -> [#("detail", plandefinition_goal_target_detail_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case measure {
                          Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_goal_target_decoder() -> Decoder(PlandefinitionGoalTarget) {use due <- decode.optional_field("due", None, decode.optional(duration_decoder()))
use detail <- decode.then(none_if_omitted(plandefinition_goal_target_detail_decoder()))
use measure <- decode.optional_field("measure", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionGoalTarget(due:,detail:,measure:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_goal_to_json(plandefinition_goal: PlandefinitionGoal) -> Json {
    let PlandefinitionGoal(target:,documentation:,addresses:,start:,priority:,description:,category:,modifier_extension:,extension:,id:,) = plandefinition_goal
    let fields = [#("description", codeableconcept_to_json(description)),]
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,plandefinition_goal_target_to_json)), ..fields]
                          }
let fields = case documentation {
                        [] -> fields
                        _ -> [#("documentation", json.array(documentation,relatedartifact_to_json)), ..fields]
                          }
let fields = case addresses {
                        [] -> fields
                        _ -> [#("addresses", json.array(addresses,codeableconcept_to_json)), ..fields]
                          }
let fields = case start {
                          Some(v) -> [#("start", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_goal_decoder() -> Decoder(PlandefinitionGoal) {use target <- decode.optional_field("target", [], decode.list(plandefinition_goal_target_decoder()))
use documentation <- decode.optional_field("documentation", [], decode.list(relatedartifact_decoder()))
use addresses <- decode.optional_field("addresses", [], decode.list(codeableconcept_decoder()))
use start <- decode.optional_field("start", None, decode.optional(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(codeableconcept_decoder()))
use description <- decode.field("description",codeableconcept_decoder())
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PlandefinitionGoal(target:,documentation:,addresses:,start:,priority:,description:,category:,modifier_extension:,extension:,id:,))}
pub fn plandefinition_to_json(plandefinition: Plandefinition) -> Json {
    let Plandefinition(action:,goal:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,type_:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = plandefinition
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,plandefinition_action_to_json)), ..fields]
                          }
let fields = case goal {
                        [] -> fields
                        _ -> [#("goal", json.array(goal,plandefinition_goal_to_json)), ..fields]
                          }
let fields = case library {
                        [] -> fields
                        _ -> [#("library", json.array(library,json.string)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", plandefinition_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn plandefinition_decoder() -> Decoder(Plandefinition) {use action <- decode.optional_field("action", [], decode.list(plandefinition_action_decoder()))
use goal <- decode.optional_field("goal", [], decode.list(plandefinition_goal_decoder()))
use library <- decode.optional_field("library", [], decode.list(decode.string))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(plandefinition_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Plandefinition(action:,goal:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject:,experimental:,status:,type_:,subtitle:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Practitioner#resource
pub type Practitioner
{
Practitioner(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
name: List(Humanname),
telecom: List(Contactpoint),
address: List(Address),
gender: Option(r4valuesets.Administrativegender),
birth_date: Option(String),
photo: List(Attachment),
qualification: List(PractitionerQualification),
communication: List(Codeableconcept),
)
}

pub fn practitioner_new() ->Practitioner{Practitioner(communication: [],qualification: [],photo: [],birth_date: None,gender: None,address: [],telecom: [],name: [],active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Practitioner#resource
pub type PractitionerQualification
{
PractitionerQualification(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
code: Codeableconcept,
period: Option(Period),
issuer: Option(Reference),
)
}

pub fn practitioner_qualification_new(code code: Codeableconcept,) ->PractitionerQualification{PractitionerQualification(issuer: None,period: None,code:,identifier: [],modifier_extension: [],extension: [],id: None,)
}

pub fn practitioner_qualification_to_json(practitioner_qualification: PractitionerQualification) -> Json {
    let PractitionerQualification(issuer:,period:,code:,identifier:,modifier_extension:,extension:,id:,) = practitioner_qualification
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case issuer {
                          Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn practitioner_qualification_decoder() -> Decoder(PractitionerQualification) {use issuer <- decode.optional_field("issuer", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use code <- decode.field("code",codeableconcept_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PractitionerQualification(issuer:,period:,code:,identifier:,modifier_extension:,extension:,id:,))}
pub fn practitioner_to_json(practitioner: Practitioner) -> Json {
    let Practitioner(communication:,qualification:,photo:,birth_date:,gender:,address:,telecom:,name:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = practitioner
    let fields = []
let fields = case communication {
                        [] -> fields
                        _ -> [#("communication", json.array(communication,codeableconcept_to_json)), ..fields]
                          }
let fields = case qualification {
                        [] -> fields
                        _ -> [#("qualification", json.array(qualification,practitioner_qualification_to_json)), ..fields]
                          }
let fields = case photo {
                        [] -> fields
                        _ -> [#("photo", json.array(photo,attachment_to_json)), ..fields]
                          }
let fields = case birth_date {
                          Some(v) -> [#("birthDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case address {
                        [] -> fields
                        _ -> [#("address", json.array(address,address_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,humanname_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn practitioner_decoder() -> Decoder(Practitioner) {use communication <- decode.optional_field("communication", [], decode.list(codeableconcept_decoder()))
use qualification <- decode.optional_field("qualification", [], decode.list(practitioner_qualification_decoder()))
use photo <- decode.optional_field("photo", [], decode.list(attachment_decoder()))
use birth_date <- decode.optional_field("birthDate", None, decode.optional(decode.string))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use address <- decode.optional_field("address", [], decode.list(address_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", [], decode.list(humanname_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Practitioner(communication:,qualification:,photo:,birth_date:,gender:,address:,telecom:,name:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/PractitionerRole#resource
pub type Practitionerrole
{
Practitionerrole(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
period: Option(Period),
practitioner: Option(Reference),
organization: Option(Reference),
code: List(Codeableconcept),
specialty: List(Codeableconcept),
location: List(Reference),
healthcare_service: List(Reference),
telecom: List(Contactpoint),
available_time: List(PractitionerroleAvailabletime),
not_available: List(PractitionerroleNotavailable),
availability_exceptions: Option(String),
endpoint: List(Reference),
)
}

pub fn practitionerrole_new() ->Practitionerrole{Practitionerrole(endpoint: [],availability_exceptions: None,not_available: [],available_time: [],telecom: [],healthcare_service: [],location: [],specialty: [],code: [],organization: None,practitioner: None,period: None,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PractitionerRole#resource
pub type PractitionerroleAvailabletime
{
PractitionerroleAvailabletime(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
days_of_week: List(r4valuesets.Daysofweek),
all_day: Option(Bool),
available_start_time: Option(String),
available_end_time: Option(String),
)
}

pub fn practitionerrole_availabletime_new() ->PractitionerroleAvailabletime{PractitionerroleAvailabletime(available_end_time: None,available_start_time: None,all_day: None,days_of_week: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/PractitionerRole#resource
pub type PractitionerroleNotavailable
{
PractitionerroleNotavailable(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: String,
during: Option(Period),
)
}

pub fn practitionerrole_notavailable_new(description description: String,) ->PractitionerroleNotavailable{PractitionerroleNotavailable(during: None,description:,modifier_extension: [],extension: [],id: None,)
}

pub fn practitionerrole_notavailable_to_json(practitionerrole_notavailable: PractitionerroleNotavailable) -> Json {
    let PractitionerroleNotavailable(during:,description:,modifier_extension:,extension:,id:,) = practitionerrole_notavailable
    let fields = [#("description", json.string(description)),]
let fields = case during {
                          Some(v) -> [#("during", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn practitionerrole_notavailable_decoder() -> Decoder(PractitionerroleNotavailable) {use during <- decode.optional_field("during", None, decode.optional(period_decoder()))
use description <- decode.field("description",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PractitionerroleNotavailable(during:,description:,modifier_extension:,extension:,id:,))}
pub fn practitionerrole_availabletime_to_json(practitionerrole_availabletime: PractitionerroleAvailabletime) -> Json {
    let PractitionerroleAvailabletime(available_end_time:,available_start_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,) = practitionerrole_availabletime
    let fields = []
let fields = case available_end_time {
                          Some(v) -> [#("availableEndTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case available_start_time {
                          Some(v) -> [#("availableStartTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case all_day {
                          Some(v) -> [#("allDay", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case days_of_week {
                        [] -> fields
                        _ -> [#("daysOfWeek", json.array(days_of_week,r4valuesets.daysofweek_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn practitionerrole_availabletime_decoder() -> Decoder(PractitionerroleAvailabletime) {use available_end_time <- decode.optional_field("availableEndTime", None, decode.optional(decode.string))
use available_start_time <- decode.optional_field("availableStartTime", None, decode.optional(decode.string))
use all_day <- decode.optional_field("allDay", None, decode.optional(decode.bool))
use days_of_week <- decode.optional_field("daysOfWeek", [], decode.list(r4valuesets.daysofweek_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(PractitionerroleAvailabletime(available_end_time:,available_start_time:,all_day:,days_of_week:,modifier_extension:,extension:,id:,))}
pub fn practitionerrole_to_json(practitionerrole: Practitionerrole) -> Json {
    let Practitionerrole(endpoint:,availability_exceptions:,not_available:,available_time:,telecom:,healthcare_service:,location:,specialty:,code:,organization:,practitioner:,period:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = practitionerrole
    let fields = []
let fields = case endpoint {
                        [] -> fields
                        _ -> [#("endpoint", json.array(endpoint,reference_to_json)), ..fields]
                          }
let fields = case availability_exceptions {
                          Some(v) -> [#("availabilityExceptions", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case not_available {
                        [] -> fields
                        _ -> [#("notAvailable", json.array(not_available,practitionerrole_notavailable_to_json)), ..fields]
                          }
let fields = case available_time {
                        [] -> fields
                        _ -> [#("availableTime", json.array(available_time,practitionerrole_availabletime_to_json)), ..fields]
                          }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case healthcare_service {
                        [] -> fields
                        _ -> [#("healthcareService", json.array(healthcare_service,reference_to_json)), ..fields]
                          }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,reference_to_json)), ..fields]
                          }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case organization {
                          Some(v) -> [#("organization", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case practitioner {
                          Some(v) -> [#("practitioner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn practitionerrole_decoder() -> Decoder(Practitionerrole) {use endpoint <- decode.optional_field("endpoint", [], decode.list(reference_decoder()))
use availability_exceptions <- decode.optional_field("availabilityExceptions", None, decode.optional(decode.string))
use not_available <- decode.optional_field("notAvailable", [], decode.list(practitionerrole_notavailable_decoder()))
use available_time <- decode.optional_field("availableTime", [], decode.list(practitionerrole_availabletime_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use healthcare_service <- decode.optional_field("healthcareService", [], decode.list(reference_decoder()))
use location <- decode.optional_field("location", [], decode.list(reference_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use organization <- decode.optional_field("organization", None, decode.optional(reference_decoder()))
use practitioner <- decode.optional_field("practitioner", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Practitionerrole(endpoint:,availability_exceptions:,not_available:,available_time:,telecom:,healthcare_service:,location:,specialty:,code:,organization:,practitioner:,period:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Procedure#resource
pub type Procedure
{
Procedure(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
part_of: List(Reference),
status: r4valuesets.Eventstatus,
status_reason: Option(Codeableconcept),
category: Option(Codeableconcept),
code: Option(Codeableconcept),
subject: Reference,
encounter: Option(Reference),
performed: Option(ProcedurePerformed),
recorder: Option(Reference),
asserter: Option(Reference),
performer: List(ProcedurePerformer),
location: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
body_site: List(Codeableconcept),
outcome: Option(Codeableconcept),
report: List(Reference),
complication: List(Codeableconcept),
complication_detail: List(Reference),
follow_up: List(Codeableconcept),
note: List(Annotation),
focal_device: List(ProcedureFocaldevice),
used_reference: List(Reference),
used_code: List(Codeableconcept),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Procedure#resource
pub type ProcedurePerformed{
ProcedurePerformedDatetime(performed: String)
ProcedurePerformedPeriod(performed: Period)
ProcedurePerformedString(performed: String)
ProcedurePerformedAge(performed: Age)
ProcedurePerformedRange(performed: Range)}
pub fn procedure_performed_to_json(elt: ProcedurePerformed) -> Json {case elt{ProcedurePerformedDatetime(v) -> json.string(v)
ProcedurePerformedPeriod(v) -> period_to_json(v)
ProcedurePerformedString(v) -> json.string(v)
ProcedurePerformedAge(v) -> age_to_json(v)
ProcedurePerformedRange(v) -> range_to_json(v)
}}
pub fn procedure_performed_decoder() -> Decoder(ProcedurePerformed){decode.one_of(decode.field("performedDateTime", decode.string, decode.success) |> decode.map(ProcedurePerformedDatetime),[decode.field("performedPeriod", period_decoder(), decode.success) |> decode.map(ProcedurePerformedPeriod),decode.field("performedString", decode.string, decode.success) |> decode.map(ProcedurePerformedString),decode.field("performedAge", age_decoder(), decode.success) |> decode.map(ProcedurePerformedAge),decode.field("performedRange", range_decoder(), decode.success) |> decode.map(ProcedurePerformedRange),])}
pub fn procedure_new(subject subject: Reference,status status: r4valuesets.Eventstatus,) ->Procedure{Procedure(used_code: [],used_reference: [],focal_device: [],note: [],follow_up: [],complication_detail: [],complication: [],report: [],outcome: None,body_site: [],reason_reference: [],reason_code: [],location: None,performer: [],asserter: None,recorder: None,performed: None,encounter: None,subject:,code: None,category: None,status_reason: None,status:,part_of: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Procedure#resource
pub type ProcedurePerformer
{
ProcedurePerformer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
function: Option(Codeableconcept),
actor: Reference,
on_behalf_of: Option(Reference),
)
}

pub fn procedure_performer_new(actor actor: Reference,) ->ProcedurePerformer{ProcedurePerformer(on_behalf_of: None,actor:,function: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Procedure#resource
pub type ProcedureFocaldevice
{
ProcedureFocaldevice(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: Option(Codeableconcept),
manipulated: Reference,
)
}

pub fn procedure_focaldevice_new(manipulated manipulated: Reference,) ->ProcedureFocaldevice{ProcedureFocaldevice(manipulated:,action: None,modifier_extension: [],extension: [],id: None,)
}

pub fn procedure_focaldevice_to_json(procedure_focaldevice: ProcedureFocaldevice) -> Json {
    let ProcedureFocaldevice(manipulated:,action:,modifier_extension:,extension:,id:,) = procedure_focaldevice
    let fields = [#("manipulated", reference_to_json(manipulated)),]
let fields = case action {
                          Some(v) -> [#("action", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn procedure_focaldevice_decoder() -> Decoder(ProcedureFocaldevice) {use manipulated <- decode.field("manipulated",reference_decoder())
use action <- decode.optional_field("action", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ProcedureFocaldevice(manipulated:,action:,modifier_extension:,extension:,id:,))}
pub fn procedure_performer_to_json(procedure_performer: ProcedurePerformer) -> Json {
    let ProcedurePerformer(on_behalf_of:,actor:,function:,modifier_extension:,extension:,id:,) = procedure_performer
    let fields = [#("actor", reference_to_json(actor)),]
let fields = case on_behalf_of {
                          Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case function {
                          Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn procedure_performer_decoder() -> Decoder(ProcedurePerformer) {use on_behalf_of <- decode.optional_field("onBehalfOf", None, decode.optional(reference_decoder()))
use actor <- decode.field("actor",reference_decoder())
use function <- decode.optional_field("function", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ProcedurePerformer(on_behalf_of:,actor:,function:,modifier_extension:,extension:,id:,))}
pub fn procedure_to_json(procedure: Procedure) -> Json {
    let Procedure(used_code:,used_reference:,focal_device:,note:,follow_up:,complication_detail:,complication:,report:,outcome:,body_site:,reason_reference:,reason_code:,location:,performer:,asserter:,recorder:,performed:,encounter:,subject:,code:,category:,status_reason:,status:,part_of:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = procedure
    let fields = [#("subject", reference_to_json(subject)),#("status", r4valuesets.eventstatus_to_json(status)),]
let fields = case used_code {
                        [] -> fields
                        _ -> [#("usedCode", json.array(used_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case used_reference {
                        [] -> fields
                        _ -> [#("usedReference", json.array(used_reference,reference_to_json)), ..fields]
                          }
let fields = case focal_device {
                        [] -> fields
                        _ -> [#("focalDevice", json.array(focal_device,procedure_focaldevice_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case follow_up {
                        [] -> fields
                        _ -> [#("followUp", json.array(follow_up,codeableconcept_to_json)), ..fields]
                          }
let fields = case complication_detail {
                        [] -> fields
                        _ -> [#("complicationDetail", json.array(complication_detail,reference_to_json)), ..fields]
                          }
let fields = case complication {
                        [] -> fields
                        _ -> [#("complication", json.array(complication,codeableconcept_to_json)), ..fields]
                          }
let fields = case report {
                        [] -> fields
                        _ -> [#("report", json.array(report,reference_to_json)), ..fields]
                          }
let fields = case outcome {
                          Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                        [] -> fields
                        _ -> [#("bodySite", json.array(body_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,procedure_performer_to_json)), ..fields]
                          }
let fields = case asserter {
                          Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case recorder {
                          Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performed {
                          Some(v) -> [#("performed", procedure_performed_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn procedure_decoder() -> Decoder(Procedure) {use used_code <- decode.optional_field("usedCode", [], decode.list(codeableconcept_decoder()))
use used_reference <- decode.optional_field("usedReference", [], decode.list(reference_decoder()))
use focal_device <- decode.optional_field("focalDevice", [], decode.list(procedure_focaldevice_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use follow_up <- decode.optional_field("followUp", [], decode.list(codeableconcept_decoder()))
use complication_detail <- decode.optional_field("complicationDetail", [], decode.list(reference_decoder()))
use complication <- decode.optional_field("complication", [], decode.list(codeableconcept_decoder()))
use report <- decode.optional_field("report", [], decode.list(reference_decoder()))
use outcome <- decode.optional_field("outcome", None, decode.optional(codeableconcept_decoder()))
use body_site <- decode.optional_field("bodySite", [], decode.list(codeableconcept_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(procedure_performer_decoder()))
use asserter <- decode.optional_field("asserter", None, decode.optional(reference_decoder()))
use recorder <- decode.optional_field("recorder", None, decode.optional(reference_decoder()))
use performed <- decode.then(none_if_omitted(procedure_performed_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.eventstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Procedure(used_code:,used_reference:,focal_device:,note:,follow_up:,complication_detail:,complication:,report:,outcome:,body_site:,reason_reference:,reason_code:,location:,performer:,asserter:,recorder:,performed:,encounter:,subject:,code:,category:,status_reason:,status:,part_of:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Provenance#resource
pub type Provenance
{
Provenance(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
target: List(Reference),
occurred: Option(ProvenanceOccurred),
recorded: String,
policy: List(String),
location: Option(Reference),
reason: List(Codeableconcept),
activity: Option(Codeableconcept),
agent: List(ProvenanceAgent),
entity: List(ProvenanceEntity),
signature: List(Signature),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Provenance#resource
pub type ProvenanceOccurred{
ProvenanceOccurredPeriod(occurred: Period)
ProvenanceOccurredDatetime(occurred: String)}
pub fn provenance_occurred_to_json(elt: ProvenanceOccurred) -> Json {case elt{ProvenanceOccurredPeriod(v) -> period_to_json(v)
ProvenanceOccurredDatetime(v) -> json.string(v)
}}
pub fn provenance_occurred_decoder() -> Decoder(ProvenanceOccurred){decode.one_of(decode.field("occurredPeriod", period_decoder(), decode.success) |> decode.map(ProvenanceOccurredPeriod),[decode.field("occurredDateTime", decode.string, decode.success) |> decode.map(ProvenanceOccurredDatetime),])}
pub fn provenance_new(recorded recorded: String,) ->Provenance{Provenance(signature: [],entity: [],agent: [],activity: None,reason: [],location: None,policy: [],recorded:,occurred: None,target: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Provenance#resource
pub type ProvenanceAgent
{
ProvenanceAgent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
role: List(Codeableconcept),
who: Reference,
on_behalf_of: Option(Reference),
)
}

pub fn provenance_agent_new(who who: Reference,) ->ProvenanceAgent{ProvenanceAgent(on_behalf_of: None,who:,role: [],type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Provenance#resource
pub type ProvenanceEntity
{
ProvenanceEntity(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
role: r4valuesets.Provenanceentityrole,
what: Reference,
)
}

pub fn provenance_entity_new(what what: Reference,role role: r4valuesets.Provenanceentityrole,) ->ProvenanceEntity{ProvenanceEntity(what:,role:,modifier_extension: [],extension: [],id: None,)
}

pub fn provenance_entity_to_json(provenance_entity: ProvenanceEntity) -> Json {
    let ProvenanceEntity(what:,role:,modifier_extension:,extension:,id:,) = provenance_entity
    let fields = [#("what", reference_to_json(what)),#("role", r4valuesets.provenanceentityrole_to_json(role)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn provenance_entity_decoder() -> Decoder(ProvenanceEntity) {use what <- decode.field("what",reference_decoder())
use role <- decode.field("role",r4valuesets.provenanceentityrole_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ProvenanceEntity(what:,role:,modifier_extension:,extension:,id:,))}
pub fn provenance_agent_to_json(provenance_agent: ProvenanceAgent) -> Json {
    let ProvenanceAgent(on_behalf_of:,who:,role:,type_:,modifier_extension:,extension:,id:,) = provenance_agent
    let fields = [#("who", reference_to_json(who)),]
let fields = case on_behalf_of {
                          Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                        [] -> fields
                        _ -> [#("role", json.array(role,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn provenance_agent_decoder() -> Decoder(ProvenanceAgent) {use on_behalf_of <- decode.optional_field("onBehalfOf", None, decode.optional(reference_decoder()))
use who <- decode.field("who",reference_decoder())
use role <- decode.optional_field("role", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ProvenanceAgent(on_behalf_of:,who:,role:,type_:,modifier_extension:,extension:,id:,))}
pub fn provenance_to_json(provenance: Provenance) -> Json {
    let Provenance(signature:,entity:,agent:,activity:,reason:,location:,policy:,recorded:,occurred:,target:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = provenance
    let fields = [#("recorded", json.string(recorded)),]
let fields = case signature {
                        [] -> fields
                        _ -> [#("signature", json.array(signature,signature_to_json)), ..fields]
                          }
let fields = case entity {
                        [] -> fields
                        _ -> [#("entity", json.array(entity,provenance_entity_to_json)), ..fields]
                          }
let fields = case agent {
                        [] -> fields
                        _ -> [#("agent", json.array(agent,provenance_agent_to_json)), ..fields]
                          }
let fields = case activity {
                          Some(v) -> [#("activity", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason {
                        [] -> fields
                        _ -> [#("reason", json.array(reason,codeableconcept_to_json)), ..fields]
                          }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case policy {
                        [] -> fields
                        _ -> [#("policy", json.array(policy,json.string)), ..fields]
                          }
let fields = case occurred {
                          Some(v) -> [#("occurred", provenance_occurred_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn provenance_decoder() -> Decoder(Provenance) {use signature <- decode.optional_field("signature", [], decode.list(signature_decoder()))
use entity <- decode.optional_field("entity", [], decode.list(provenance_entity_decoder()))
use agent <- decode.optional_field("agent", [], decode.list(provenance_agent_decoder()))
use activity <- decode.optional_field("activity", None, decode.optional(codeableconcept_decoder()))
use reason <- decode.optional_field("reason", [], decode.list(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use policy <- decode.optional_field("policy", [], decode.list(decode.string))
use recorded <- decode.field("recorded",decode.string)
use occurred <- decode.then(none_if_omitted(provenance_occurred_decoder()))
use target <- decode.optional_field("target", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Provenance(signature:,entity:,agent:,activity:,reason:,location:,policy:,recorded:,occurred:,target:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type Questionnaire
{
Questionnaire(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
derived_from: List(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject_type: List(r4valuesets.Resourcetypes),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
code: List(Coding),
item: List(QuestionnaireItem),
)
}

pub fn questionnaire_new(status status: r4valuesets.Publicationstatus,) ->Questionnaire{Questionnaire(item: [],code: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,subject_type: [],experimental: None,status:,derived_from: [],title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItem
{
QuestionnaireItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
link_id: String,
definition: Option(String),
code: List(Coding),
prefix: Option(String),
text: Option(String),
type_: r4valuesets.Itemtype,
enable_when: List(QuestionnaireItemEnablewhen),
enable_behavior: Option(r4valuesets.Questionnaireenablebehavior),
required: Option(Bool),
repeats: Option(Bool),
read_only: Option(Bool),
max_length: Option(Int),
answer_value_set: Option(String),
answer_option: List(QuestionnaireItemAnsweroption),
initial: List(QuestionnaireItemInitial),
)
}

pub fn questionnaire_item_new(type_ type_: r4valuesets.Itemtype,link_id link_id: String,) ->QuestionnaireItem{QuestionnaireItem(initial: [],answer_option: [],answer_value_set: None,max_length: None,read_only: None,repeats: None,required: None,enable_behavior: None,enable_when: [],type_:,text: None,prefix: None,code: [],definition: None,link_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhen
{
QuestionnaireItemEnablewhen(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
question: String,
operator: r4valuesets.Questionnaireenableoperator,
answer: QuestionnaireItemEnablewhenAnswer,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhenAnswer{
QuestionnaireItemEnablewhenAnswerBoolean(answer: Bool)
QuestionnaireItemEnablewhenAnswerDecimal(answer: Float)
QuestionnaireItemEnablewhenAnswerInteger(answer: Int)
QuestionnaireItemEnablewhenAnswerDate(answer: String)
QuestionnaireItemEnablewhenAnswerDatetime(answer: String)
QuestionnaireItemEnablewhenAnswerTime(answer: String)
QuestionnaireItemEnablewhenAnswerString(answer: String)
QuestionnaireItemEnablewhenAnswerCoding(answer: Coding)
QuestionnaireItemEnablewhenAnswerQuantity(answer: Quantity)
QuestionnaireItemEnablewhenAnswerReference(answer: Reference)}
pub fn questionnaire_item_enablewhen_answer_to_json(elt: QuestionnaireItemEnablewhenAnswer) -> Json {case elt{QuestionnaireItemEnablewhenAnswerBoolean(v) -> json.bool(v)
QuestionnaireItemEnablewhenAnswerDecimal(v) -> json.float(v)
QuestionnaireItemEnablewhenAnswerInteger(v) -> json.int(v)
QuestionnaireItemEnablewhenAnswerDate(v) -> json.string(v)
QuestionnaireItemEnablewhenAnswerDatetime(v) -> json.string(v)
QuestionnaireItemEnablewhenAnswerTime(v) -> json.string(v)
QuestionnaireItemEnablewhenAnswerString(v) -> json.string(v)
QuestionnaireItemEnablewhenAnswerCoding(v) -> coding_to_json(v)
QuestionnaireItemEnablewhenAnswerQuantity(v) -> quantity_to_json(v)
QuestionnaireItemEnablewhenAnswerReference(v) -> reference_to_json(v)
}}
pub fn questionnaire_item_enablewhen_answer_decoder() -> Decoder(QuestionnaireItemEnablewhenAnswer){decode.one_of(decode.field("answerBoolean", decode.bool, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerBoolean),[decode.field("answerDecimal", decode.float, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerDecimal),decode.field("answerInteger", decode.int, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerInteger),decode.field("answerDate", decode.string, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerDate),decode.field("answerDateTime", decode.string, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerDatetime),decode.field("answerTime", decode.string, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerTime),decode.field("answerString", decode.string, decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerString),decode.field("answerCoding", coding_decoder(), decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerCoding),decode.field("answerQuantity", quantity_decoder(), decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerQuantity),decode.field("answerReference", reference_decoder(), decode.success) |> decode.map(QuestionnaireItemEnablewhenAnswerReference),])}
pub fn questionnaire_item_enablewhen_new(answer answer: QuestionnaireItemEnablewhenAnswer,operator operator: r4valuesets.Questionnaireenableoperator,question question: String,) ->QuestionnaireItemEnablewhen{QuestionnaireItemEnablewhen(answer:,operator:,question:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroption
{
QuestionnaireItemAnsweroption(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: QuestionnaireItemAnsweroptionValue,
initial_selected: Option(Bool),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroptionValue{
QuestionnaireItemAnsweroptionValueInteger(value: Int)
QuestionnaireItemAnsweroptionValueDate(value: String)
QuestionnaireItemAnsweroptionValueTime(value: String)
QuestionnaireItemAnsweroptionValueString(value: String)
QuestionnaireItemAnsweroptionValueCoding(value: Coding)
QuestionnaireItemAnsweroptionValueReference(value: Reference)}
pub fn questionnaire_item_answeroption_value_to_json(elt: QuestionnaireItemAnsweroptionValue) -> Json {case elt{QuestionnaireItemAnsweroptionValueInteger(v) -> json.int(v)
QuestionnaireItemAnsweroptionValueDate(v) -> json.string(v)
QuestionnaireItemAnsweroptionValueTime(v) -> json.string(v)
QuestionnaireItemAnsweroptionValueString(v) -> json.string(v)
QuestionnaireItemAnsweroptionValueCoding(v) -> coding_to_json(v)
QuestionnaireItemAnsweroptionValueReference(v) -> reference_to_json(v)
}}
pub fn questionnaire_item_answeroption_value_decoder() -> Decoder(QuestionnaireItemAnsweroptionValue){decode.one_of(decode.field("valueInteger", decode.int, decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueInteger),[decode.field("valueDate", decode.string, decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueDate),decode.field("valueTime", decode.string, decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueTime),decode.field("valueString", decode.string, decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueString),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueCoding),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(QuestionnaireItemAnsweroptionValueReference),])}
pub fn questionnaire_item_answeroption_new(value value: QuestionnaireItemAnsweroptionValue,) ->QuestionnaireItemAnsweroption{QuestionnaireItemAnsweroption(initial_selected: None,value:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitial
{
QuestionnaireItemInitial(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: QuestionnaireItemInitialValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitialValue{
QuestionnaireItemInitialValueBoolean(value: Bool)
QuestionnaireItemInitialValueDecimal(value: Float)
QuestionnaireItemInitialValueInteger(value: Int)
QuestionnaireItemInitialValueDate(value: String)
QuestionnaireItemInitialValueDatetime(value: String)
QuestionnaireItemInitialValueTime(value: String)
QuestionnaireItemInitialValueString(value: String)
QuestionnaireItemInitialValueUri(value: String)
QuestionnaireItemInitialValueAttachment(value: Attachment)
QuestionnaireItemInitialValueCoding(value: Coding)
QuestionnaireItemInitialValueQuantity(value: Quantity)
QuestionnaireItemInitialValueReference(value: Reference)}
pub fn questionnaire_item_initial_value_to_json(elt: QuestionnaireItemInitialValue) -> Json {case elt{QuestionnaireItemInitialValueBoolean(v) -> json.bool(v)
QuestionnaireItemInitialValueDecimal(v) -> json.float(v)
QuestionnaireItemInitialValueInteger(v) -> json.int(v)
QuestionnaireItemInitialValueDate(v) -> json.string(v)
QuestionnaireItemInitialValueDatetime(v) -> json.string(v)
QuestionnaireItemInitialValueTime(v) -> json.string(v)
QuestionnaireItemInitialValueString(v) -> json.string(v)
QuestionnaireItemInitialValueUri(v) -> json.string(v)
QuestionnaireItemInitialValueAttachment(v) -> attachment_to_json(v)
QuestionnaireItemInitialValueCoding(v) -> coding_to_json(v)
QuestionnaireItemInitialValueQuantity(v) -> quantity_to_json(v)
QuestionnaireItemInitialValueReference(v) -> reference_to_json(v)
}}
pub fn questionnaire_item_initial_value_decoder() -> Decoder(QuestionnaireItemInitialValue){decode.one_of(decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(QuestionnaireItemInitialValueBoolean),[decode.field("valueDecimal", decode.float, decode.success) |> decode.map(QuestionnaireItemInitialValueDecimal),decode.field("valueInteger", decode.int, decode.success) |> decode.map(QuestionnaireItemInitialValueInteger),decode.field("valueDate", decode.string, decode.success) |> decode.map(QuestionnaireItemInitialValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(QuestionnaireItemInitialValueDatetime),decode.field("valueTime", decode.string, decode.success) |> decode.map(QuestionnaireItemInitialValueTime),decode.field("valueString", decode.string, decode.success) |> decode.map(QuestionnaireItemInitialValueString),decode.field("valueUri", decode.string, decode.success) |> decode.map(QuestionnaireItemInitialValueUri),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(QuestionnaireItemInitialValueAttachment),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(QuestionnaireItemInitialValueCoding),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(QuestionnaireItemInitialValueQuantity),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(QuestionnaireItemInitialValueReference),])}
pub fn questionnaire_item_initial_new(value value: QuestionnaireItemInitialValue,) ->QuestionnaireItemInitial{QuestionnaireItemInitial(value:,modifier_extension: [],extension: [],id: None,)
}

pub fn questionnaire_item_initial_to_json(questionnaire_item_initial: QuestionnaireItemInitial) -> Json {
    let QuestionnaireItemInitial(value:,modifier_extension:,extension:,id:,) = questionnaire_item_initial
    let fields = [#("value", questionnaire_item_initial_value_to_json(value)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaire_item_initial_decoder() -> Decoder(QuestionnaireItemInitial) {use value <- decode.then(questionnaire_item_initial_value_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireItemInitial(value:,modifier_extension:,extension:,id:,))}
pub fn questionnaire_item_answeroption_to_json(questionnaire_item_answeroption: QuestionnaireItemAnsweroption) -> Json {
    let QuestionnaireItemAnsweroption(initial_selected:,value:,modifier_extension:,extension:,id:,) = questionnaire_item_answeroption
    let fields = [#("value", questionnaire_item_answeroption_value_to_json(value)),]
let fields = case initial_selected {
                          Some(v) -> [#("initialSelected", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaire_item_answeroption_decoder() -> Decoder(QuestionnaireItemAnsweroption) {use initial_selected <- decode.optional_field("initialSelected", None, decode.optional(decode.bool))
use value <- decode.then(questionnaire_item_answeroption_value_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireItemAnsweroption(initial_selected:,value:,modifier_extension:,extension:,id:,))}
pub fn questionnaire_item_enablewhen_to_json(questionnaire_item_enablewhen: QuestionnaireItemEnablewhen) -> Json {
    let QuestionnaireItemEnablewhen(answer:,operator:,question:,modifier_extension:,extension:,id:,) = questionnaire_item_enablewhen
    let fields = [#("answer", questionnaire_item_enablewhen_answer_to_json(answer)),#("operator", r4valuesets.questionnaireenableoperator_to_json(operator)),#("question", json.string(question)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaire_item_enablewhen_decoder() -> Decoder(QuestionnaireItemEnablewhen) {use answer <- decode.then(questionnaire_item_enablewhen_answer_decoder())
use operator <- decode.field("operator",r4valuesets.questionnaireenableoperator_decoder())
use question <- decode.field("question",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireItemEnablewhen(answer:,operator:,question:,modifier_extension:,extension:,id:,))}
pub fn questionnaire_item_to_json(questionnaire_item: QuestionnaireItem) -> Json {
    let QuestionnaireItem(initial:,answer_option:,answer_value_set:,max_length:,read_only:,repeats:,required:,enable_behavior:,enable_when:,type_:,text:,prefix:,code:,definition:,link_id:,modifier_extension:,extension:,id:,) = questionnaire_item
    let fields = [#("type", r4valuesets.itemtype_to_json(type_)),#("linkId", json.string(link_id)),]
let fields = case initial {
                        [] -> fields
                        _ -> [#("initial", json.array(initial,questionnaire_item_initial_to_json)), ..fields]
                          }
let fields = case answer_option {
                        [] -> fields
                        _ -> [#("answerOption", json.array(answer_option,questionnaire_item_answeroption_to_json)), ..fields]
                          }
let fields = case answer_value_set {
                          Some(v) -> [#("answerValueSet", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max_length {
                          Some(v) -> [#("maxLength", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case read_only {
                          Some(v) -> [#("readOnly", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case repeats {
                          Some(v) -> [#("repeats", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case required {
                          Some(v) -> [#("required", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case enable_behavior {
                          Some(v) -> [#("enableBehavior", r4valuesets.questionnaireenablebehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enable_when {
                        [] -> fields
                        _ -> [#("enableWhen", json.array(enable_when,questionnaire_item_enablewhen_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case prefix {
                          Some(v) -> [#("prefix", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,coding_to_json)), ..fields]
                          }
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaire_item_decoder() -> Decoder(QuestionnaireItem) {use initial <- decode.optional_field("initial", [], decode.list(questionnaire_item_initial_decoder()))
use answer_option <- decode.optional_field("answerOption", [], decode.list(questionnaire_item_answeroption_decoder()))
use answer_value_set <- decode.optional_field("answerValueSet", None, decode.optional(decode.string))
use max_length <- decode.optional_field("maxLength", None, decode.optional(decode.int))
use read_only <- decode.optional_field("readOnly", None, decode.optional(decode.bool))
use repeats <- decode.optional_field("repeats", None, decode.optional(decode.bool))
use required <- decode.optional_field("required", None, decode.optional(decode.bool))
use enable_behavior <- decode.optional_field("enableBehavior", None, decode.optional(r4valuesets.questionnaireenablebehavior_decoder()))
use enable_when <- decode.optional_field("enableWhen", [], decode.list(questionnaire_item_enablewhen_decoder()))
use type_ <- decode.field("type",r4valuesets.itemtype_decoder())
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use prefix <- decode.optional_field("prefix", None, decode.optional(decode.string))
use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use link_id <- decode.field("linkId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireItem(initial:,answer_option:,answer_value_set:,max_length:,read_only:,repeats:,required:,enable_behavior:,enable_when:,type_:,text:,prefix:,code:,definition:,link_id:,modifier_extension:,extension:,id:,))}
pub fn questionnaire_to_json(questionnaire: Questionnaire) -> Json {
    let Questionnaire(item:,code:,effective_period:,last_review_date:,approval_date:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject_type:,experimental:,status:,derived_from:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = questionnaire
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,questionnaire_item_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,coding_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject_type {
                        [] -> fields
                        _ -> [#("subjectType", json.array(subject_type,r4valuesets.resourcetypes_to_json)), ..fields]
                          }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case derived_from {
                        [] -> fields
                        _ -> [#("derivedFrom", json.array(derived_from,json.string)), ..fields]
                          }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaire_decoder() -> Decoder(Questionnaire) {use item <- decode.optional_field("item", [], decode.list(questionnaire_item_decoder()))
use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject_type <- decode.optional_field("subjectType", [], decode.list(r4valuesets.resourcetypes_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use derived_from <- decode.optional_field("derivedFrom", [], decode.list(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Questionnaire(item:,code:,effective_period:,last_review_date:,approval_date:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,subject_type:,experimental:,status:,derived_from:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/QuestionnaireResponse#resource
pub type Questionnaireresponse
{
Questionnaireresponse(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
based_on: List(Reference),
part_of: List(Reference),
questionnaire: Option(String),
status: r4valuesets.Questionnaireanswersstatus,
subject: Option(Reference),
encounter: Option(Reference),
authored: Option(String),
author: Option(Reference),
source: Option(Reference),
item: List(QuestionnaireresponseItem),
)
}

pub fn questionnaireresponse_new(status status: r4valuesets.Questionnaireanswersstatus,) ->Questionnaireresponse{Questionnaireresponse(item: [],source: None,author: None,authored: None,encounter: None,subject: None,status:,questionnaire: None,part_of: [],based_on: [],identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItem
{
QuestionnaireresponseItem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
link_id: String,
definition: Option(String),
text: Option(String),
answer: List(QuestionnaireresponseItemAnswer),
)
}

pub fn questionnaireresponse_item_new(link_id link_id: String,) ->QuestionnaireresponseItem{QuestionnaireresponseItem(answer: [],text: None,definition: None,link_id:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswer
{
QuestionnaireresponseItemAnswer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: Option(QuestionnaireresponseItemAnswerValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswerValue{
QuestionnaireresponseItemAnswerValueBoolean(value: Bool)
QuestionnaireresponseItemAnswerValueDecimal(value: Float)
QuestionnaireresponseItemAnswerValueInteger(value: Int)
QuestionnaireresponseItemAnswerValueDate(value: String)
QuestionnaireresponseItemAnswerValueDatetime(value: String)
QuestionnaireresponseItemAnswerValueTime(value: String)
QuestionnaireresponseItemAnswerValueString(value: String)
QuestionnaireresponseItemAnswerValueUri(value: String)
QuestionnaireresponseItemAnswerValueAttachment(value: Attachment)
QuestionnaireresponseItemAnswerValueCoding(value: Coding)
QuestionnaireresponseItemAnswerValueQuantity(value: Quantity)
QuestionnaireresponseItemAnswerValueReference(value: Reference)}
pub fn questionnaireresponse_item_answer_value_to_json(elt: QuestionnaireresponseItemAnswerValue) -> Json {case elt{QuestionnaireresponseItemAnswerValueBoolean(v) -> json.bool(v)
QuestionnaireresponseItemAnswerValueDecimal(v) -> json.float(v)
QuestionnaireresponseItemAnswerValueInteger(v) -> json.int(v)
QuestionnaireresponseItemAnswerValueDate(v) -> json.string(v)
QuestionnaireresponseItemAnswerValueDatetime(v) -> json.string(v)
QuestionnaireresponseItemAnswerValueTime(v) -> json.string(v)
QuestionnaireresponseItemAnswerValueString(v) -> json.string(v)
QuestionnaireresponseItemAnswerValueUri(v) -> json.string(v)
QuestionnaireresponseItemAnswerValueAttachment(v) -> attachment_to_json(v)
QuestionnaireresponseItemAnswerValueCoding(v) -> coding_to_json(v)
QuestionnaireresponseItemAnswerValueQuantity(v) -> quantity_to_json(v)
QuestionnaireresponseItemAnswerValueReference(v) -> reference_to_json(v)
}}
pub fn questionnaireresponse_item_answer_value_decoder() -> Decoder(QuestionnaireresponseItemAnswerValue){decode.one_of(decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueBoolean),[decode.field("valueDecimal", decode.float, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueDecimal),decode.field("valueInteger", decode.int, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueInteger),decode.field("valueDate", decode.string, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueDatetime),decode.field("valueTime", decode.string, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueTime),decode.field("valueString", decode.string, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueString),decode.field("valueUri", decode.string, decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueUri),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueAttachment),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueCoding),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueQuantity),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(QuestionnaireresponseItemAnswerValueReference),])}
pub fn questionnaireresponse_item_answer_new() ->QuestionnaireresponseItemAnswer{QuestionnaireresponseItemAnswer(value: None,modifier_extension: [],extension: [],id: None,)
}

pub fn questionnaireresponse_item_answer_to_json(questionnaireresponse_item_answer: QuestionnaireresponseItemAnswer) -> Json {
    let QuestionnaireresponseItemAnswer(value:,modifier_extension:,extension:,id:,) = questionnaireresponse_item_answer
    let fields = []
let fields = case value {
                          Some(v) -> [#("value", questionnaireresponse_item_answer_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaireresponse_item_answer_decoder() -> Decoder(QuestionnaireresponseItemAnswer) {use value <- decode.then(none_if_omitted(questionnaireresponse_item_answer_value_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireresponseItemAnswer(value:,modifier_extension:,extension:,id:,))}
pub fn questionnaireresponse_item_to_json(questionnaireresponse_item: QuestionnaireresponseItem) -> Json {
    let QuestionnaireresponseItem(answer:,text:,definition:,link_id:,modifier_extension:,extension:,id:,) = questionnaireresponse_item
    let fields = [#("linkId", json.string(link_id)),]
let fields = case answer {
                        [] -> fields
                        _ -> [#("answer", json.array(answer,questionnaireresponse_item_answer_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case definition {
                          Some(v) -> [#("definition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaireresponse_item_decoder() -> Decoder(QuestionnaireresponseItem) {use answer <- decode.optional_field("answer", [], decode.list(questionnaireresponse_item_answer_decoder()))
use text <- decode.optional_field("text", None, decode.optional(decode.string))
use definition <- decode.optional_field("definition", None, decode.optional(decode.string))
use link_id <- decode.field("linkId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(QuestionnaireresponseItem(answer:,text:,definition:,link_id:,modifier_extension:,extension:,id:,))}
pub fn questionnaireresponse_to_json(questionnaireresponse: Questionnaireresponse) -> Json {
    let Questionnaireresponse(item:,source:,author:,authored:,encounter:,subject:,status:,questionnaire:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = questionnaireresponse
    let fields = [#("status", r4valuesets.questionnaireanswersstatus_to_json(status)),]
let fields = case item {
                        [] -> fields
                        _ -> [#("item", json.array(item,questionnaireresponse_item_to_json)), ..fields]
                          }
let fields = case source {
                          Some(v) -> [#("source", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored {
                          Some(v) -> [#("authored", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case questionnaire {
                          Some(v) -> [#("questionnaire", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn questionnaireresponse_decoder() -> Decoder(Questionnaireresponse) {use item <- decode.optional_field("item", [], decode.list(questionnaireresponse_item_decoder()))
use source <- decode.optional_field("source", None, decode.optional(reference_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use authored <- decode.optional_field("authored", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use status <- decode.field("status",r4valuesets.questionnaireanswersstatus_decoder())
use questionnaire <- decode.optional_field("questionnaire", None, decode.optional(decode.string))
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Questionnaireresponse(item:,source:,author:,authored:,encounter:,subject:,status:,questionnaire:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/RelatedPerson#resource
pub type Relatedperson
{
Relatedperson(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
patient: Reference,
relationship: List(Codeableconcept),
name: List(Humanname),
telecom: List(Contactpoint),
gender: Option(r4valuesets.Administrativegender),
birth_date: Option(String),
address: List(Address),
photo: List(Attachment),
period: Option(Period),
communication: List(RelatedpersonCommunication),
)
}

pub fn relatedperson_new(patient patient: Reference,) ->Relatedperson{Relatedperson(communication: [],period: None,photo: [],address: [],birth_date: None,gender: None,telecom: [],name: [],relationship: [],patient:,active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RelatedPerson#resource
pub type RelatedpersonCommunication
{
RelatedpersonCommunication(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
language: Codeableconcept,
preferred: Option(Bool),
)
}

pub fn relatedperson_communication_new(language language: Codeableconcept,) ->RelatedpersonCommunication{RelatedpersonCommunication(preferred: None,language:,modifier_extension: [],extension: [],id: None,)
}

pub fn relatedperson_communication_to_json(relatedperson_communication: RelatedpersonCommunication) -> Json {
    let RelatedpersonCommunication(preferred:,language:,modifier_extension:,extension:,id:,) = relatedperson_communication
    let fields = [#("language", codeableconcept_to_json(language)),]
let fields = case preferred {
                          Some(v) -> [#("preferred", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn relatedperson_communication_decoder() -> Decoder(RelatedpersonCommunication) {use preferred <- decode.optional_field("preferred", None, decode.optional(decode.bool))
use language <- decode.field("language",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RelatedpersonCommunication(preferred:,language:,modifier_extension:,extension:,id:,))}
pub fn relatedperson_to_json(relatedperson: Relatedperson) -> Json {
    let Relatedperson(communication:,period:,photo:,address:,birth_date:,gender:,telecom:,name:,relationship:,patient:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = relatedperson
    let fields = [#("patient", reference_to_json(patient)),]
let fields = case communication {
                        [] -> fields
                        _ -> [#("communication", json.array(communication,relatedperson_communication_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case photo {
                        [] -> fields
                        _ -> [#("photo", json.array(photo,attachment_to_json)), ..fields]
                          }
let fields = case address {
                        [] -> fields
                        _ -> [#("address", json.array(address,address_to_json)), ..fields]
                          }
let fields = case birth_date {
                          Some(v) -> [#("birthDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case gender {
                          Some(v) -> [#("gender", r4valuesets.administrativegender_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case telecom {
                        [] -> fields
                        _ -> [#("telecom", json.array(telecom,contactpoint_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,humanname_to_json)), ..fields]
                          }
let fields = case relationship {
                        [] -> fields
                        _ -> [#("relationship", json.array(relationship,codeableconcept_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn relatedperson_decoder() -> Decoder(Relatedperson) {use communication <- decode.optional_field("communication", [], decode.list(relatedperson_communication_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use photo <- decode.optional_field("photo", [], decode.list(attachment_decoder()))
use address <- decode.optional_field("address", [], decode.list(address_decoder()))
use birth_date <- decode.optional_field("birthDate", None, decode.optional(decode.string))
use gender <- decode.optional_field("gender", None, decode.optional(r4valuesets.administrativegender_decoder()))
use telecom <- decode.optional_field("telecom", [], decode.list(contactpoint_decoder()))
use name <- decode.optional_field("name", [], decode.list(humanname_decoder()))
use relationship <- decode.optional_field("relationship", [], decode.list(codeableconcept_decoder()))
use patient <- decode.field("patient",reference_decoder())
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Relatedperson(communication:,period:,photo:,address:,birth_date:,gender:,telecom:,name:,relationship:,patient:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type Requestgroup
{
Requestgroup(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
replaces: List(Reference),
group_identifier: Option(Identifier),
status: r4valuesets.Requeststatus,
intent: r4valuesets.Requestintent,
priority: Option(r4valuesets.Requestpriority),
code: Option(Codeableconcept),
subject: Option(Reference),
encounter: Option(Reference),
authored_on: Option(String),
author: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
note: List(Annotation),
action: List(RequestgroupAction),
)
}

pub fn requestgroup_new(intent intent: r4valuesets.Requestintent,status status: r4valuesets.Requeststatus,) ->Requestgroup{Requestgroup(action: [],note: [],reason_reference: [],reason_code: [],author: None,authored_on: None,encounter: None,subject: None,code: None,priority: None,intent:,status:,group_identifier: None,replaces: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type RequestgroupAction
{
RequestgroupAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
prefix: Option(String),
title: Option(String),
description: Option(String),
text_equivalent: Option(String),
priority: Option(r4valuesets.Requestpriority),
code: List(Codeableconcept),
documentation: List(Relatedartifact),
condition: List(RequestgroupActionCondition),
related_action: List(RequestgroupActionRelatedaction),
timing: Option(RequestgroupActionTiming),
participant: List(Reference),
type_: Option(Codeableconcept),
grouping_behavior: Option(r4valuesets.Actiongroupingbehavior),
selection_behavior: Option(r4valuesets.Actionselectionbehavior),
required_behavior: Option(r4valuesets.Actionrequiredbehavior),
precheck_behavior: Option(r4valuesets.Actionprecheckbehavior),
cardinality_behavior: Option(r4valuesets.Actioncardinalitybehavior),
resource: Option(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionTiming{
RequestgroupActionTimingDatetime(timing: String)
RequestgroupActionTimingAge(timing: Age)
RequestgroupActionTimingPeriod(timing: Period)
RequestgroupActionTimingDuration(timing: Duration)
RequestgroupActionTimingRange(timing: Range)
RequestgroupActionTimingTiming(timing: Timing)}
pub fn requestgroup_action_timing_to_json(elt: RequestgroupActionTiming) -> Json {case elt{RequestgroupActionTimingDatetime(v) -> json.string(v)
RequestgroupActionTimingAge(v) -> age_to_json(v)
RequestgroupActionTimingPeriod(v) -> period_to_json(v)
RequestgroupActionTimingDuration(v) -> duration_to_json(v)
RequestgroupActionTimingRange(v) -> range_to_json(v)
RequestgroupActionTimingTiming(v) -> timing_to_json(v)
}}
pub fn requestgroup_action_timing_decoder() -> Decoder(RequestgroupActionTiming){decode.one_of(decode.field("timingDateTime", decode.string, decode.success) |> decode.map(RequestgroupActionTimingDatetime),[decode.field("timingAge", age_decoder(), decode.success) |> decode.map(RequestgroupActionTimingAge),decode.field("timingPeriod", period_decoder(), decode.success) |> decode.map(RequestgroupActionTimingPeriod),decode.field("timingDuration", duration_decoder(), decode.success) |> decode.map(RequestgroupActionTimingDuration),decode.field("timingRange", range_decoder(), decode.success) |> decode.map(RequestgroupActionTimingRange),decode.field("timingTiming", timing_decoder(), decode.success) |> decode.map(RequestgroupActionTimingTiming),])}
pub fn requestgroup_action_new() ->RequestgroupAction{RequestgroupAction(resource: None,cardinality_behavior: None,precheck_behavior: None,required_behavior: None,selection_behavior: None,grouping_behavior: None,type_: None,participant: [],timing: None,related_action: [],condition: [],documentation: [],code: [],priority: None,text_equivalent: None,description: None,title: None,prefix: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionCondition
{
RequestgroupActionCondition(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
kind: r4valuesets.Actionconditionkind,
expression: Option(Expression),
)
}

pub fn requestgroup_action_condition_new(kind kind: r4valuesets.Actionconditionkind,) ->RequestgroupActionCondition{RequestgroupActionCondition(expression: None,kind:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionRelatedaction
{
RequestgroupActionRelatedaction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action_id: String,
relationship: r4valuesets.Actionrelationshiptype,
offset: Option(RequestgroupActionRelatedactionOffset),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/RequestGroup#resource
pub type RequestgroupActionRelatedactionOffset{
RequestgroupActionRelatedactionOffsetDuration(offset: Duration)
RequestgroupActionRelatedactionOffsetRange(offset: Range)}
pub fn requestgroup_action_relatedaction_offset_to_json(elt: RequestgroupActionRelatedactionOffset) -> Json {case elt{RequestgroupActionRelatedactionOffsetDuration(v) -> duration_to_json(v)
RequestgroupActionRelatedactionOffsetRange(v) -> range_to_json(v)
}}
pub fn requestgroup_action_relatedaction_offset_decoder() -> Decoder(RequestgroupActionRelatedactionOffset){decode.one_of(decode.field("offsetDuration", duration_decoder(), decode.success) |> decode.map(RequestgroupActionRelatedactionOffsetDuration),[decode.field("offsetRange", range_decoder(), decode.success) |> decode.map(RequestgroupActionRelatedactionOffsetRange),])}
pub fn requestgroup_action_relatedaction_new(relationship relationship: r4valuesets.Actionrelationshiptype,action_id action_id: String,) ->RequestgroupActionRelatedaction{RequestgroupActionRelatedaction(offset: None,relationship:,action_id:,modifier_extension: [],extension: [],id: None,)
}

pub fn requestgroup_action_relatedaction_to_json(requestgroup_action_relatedaction: RequestgroupActionRelatedaction) -> Json {
    let RequestgroupActionRelatedaction(offset:,relationship:,action_id:,modifier_extension:,extension:,id:,) = requestgroup_action_relatedaction
    let fields = [#("relationship", r4valuesets.actionrelationshiptype_to_json(relationship)),#("actionId", json.string(action_id)),]
let fields = case offset {
                          Some(v) -> [#("offset", requestgroup_action_relatedaction_offset_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn requestgroup_action_relatedaction_decoder() -> Decoder(RequestgroupActionRelatedaction) {use offset <- decode.then(none_if_omitted(requestgroup_action_relatedaction_offset_decoder()))
use relationship <- decode.field("relationship",r4valuesets.actionrelationshiptype_decoder())
use action_id <- decode.field("actionId",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RequestgroupActionRelatedaction(offset:,relationship:,action_id:,modifier_extension:,extension:,id:,))}
pub fn requestgroup_action_condition_to_json(requestgroup_action_condition: RequestgroupActionCondition) -> Json {
    let RequestgroupActionCondition(expression:,kind:,modifier_extension:,extension:,id:,) = requestgroup_action_condition
    let fields = [#("kind", r4valuesets.actionconditionkind_to_json(kind)),]
let fields = case expression {
                          Some(v) -> [#("expression", expression_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn requestgroup_action_condition_decoder() -> Decoder(RequestgroupActionCondition) {use expression <- decode.optional_field("expression", None, decode.optional(expression_decoder()))
use kind <- decode.field("kind",r4valuesets.actionconditionkind_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RequestgroupActionCondition(expression:,kind:,modifier_extension:,extension:,id:,))}
pub fn requestgroup_action_to_json(requestgroup_action: RequestgroupAction) -> Json {
    let RequestgroupAction(resource:,cardinality_behavior:,precheck_behavior:,required_behavior:,selection_behavior:,grouping_behavior:,type_:,participant:,timing:,related_action:,condition:,documentation:,code:,priority:,text_equivalent:,description:,title:,prefix:,modifier_extension:,extension:,id:,) = requestgroup_action
    let fields = []
let fields = case resource {
                          Some(v) -> [#("resource", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case cardinality_behavior {
                          Some(v) -> [#("cardinalityBehavior", r4valuesets.actioncardinalitybehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case precheck_behavior {
                          Some(v) -> [#("precheckBehavior", r4valuesets.actionprecheckbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case required_behavior {
                          Some(v) -> [#("requiredBehavior", r4valuesets.actionrequiredbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case selection_behavior {
                          Some(v) -> [#("selectionBehavior", r4valuesets.actionselectionbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case grouping_behavior {
                          Some(v) -> [#("groupingBehavior", r4valuesets.actiongroupingbehavior_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,reference_to_json)), ..fields]
                          }
let fields = case timing {
                          Some(v) -> [#("timing", requestgroup_action_timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related_action {
                        [] -> fields
                        _ -> [#("relatedAction", json.array(related_action,requestgroup_action_relatedaction_to_json)), ..fields]
                          }
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,requestgroup_action_condition_to_json)), ..fields]
                          }
let fields = case documentation {
                        [] -> fields
                        _ -> [#("documentation", json.array(documentation,relatedartifact_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,codeableconcept_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case text_equivalent {
                          Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case prefix {
                          Some(v) -> [#("prefix", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn requestgroup_action_decoder() -> Decoder(RequestgroupAction) {use resource <- decode.optional_field("resource", None, decode.optional(reference_decoder()))
use cardinality_behavior <- decode.optional_field("cardinalityBehavior", None, decode.optional(r4valuesets.actioncardinalitybehavior_decoder()))
use precheck_behavior <- decode.optional_field("precheckBehavior", None, decode.optional(r4valuesets.actionprecheckbehavior_decoder()))
use required_behavior <- decode.optional_field("requiredBehavior", None, decode.optional(r4valuesets.actionrequiredbehavior_decoder()))
use selection_behavior <- decode.optional_field("selectionBehavior", None, decode.optional(r4valuesets.actionselectionbehavior_decoder()))
use grouping_behavior <- decode.optional_field("groupingBehavior", None, decode.optional(r4valuesets.actiongroupingbehavior_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(reference_decoder()))
use timing <- decode.then(none_if_omitted(requestgroup_action_timing_decoder()))
use related_action <- decode.optional_field("relatedAction", [], decode.list(requestgroup_action_relatedaction_decoder()))
use condition <- decode.optional_field("condition", [], decode.list(requestgroup_action_condition_decoder()))
use documentation <- decode.optional_field("documentation", [], decode.list(relatedartifact_decoder()))
use code <- decode.optional_field("code", [], decode.list(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use text_equivalent <- decode.optional_field("textEquivalent", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use prefix <- decode.optional_field("prefix", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RequestgroupAction(resource:,cardinality_behavior:,precheck_behavior:,required_behavior:,selection_behavior:,grouping_behavior:,type_:,participant:,timing:,related_action:,condition:,documentation:,code:,priority:,text_equivalent:,description:,title:,prefix:,modifier_extension:,extension:,id:,))}
pub fn requestgroup_to_json(requestgroup: Requestgroup) -> Json {
    let Requestgroup(action:,note:,reason_reference:,reason_code:,author:,authored_on:,encounter:,subject:,code:,priority:,intent:,status:,group_identifier:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = requestgroup
    let fields = [#("intent", r4valuesets.requestintent_to_json(intent)),#("status", r4valuesets.requeststatus_to_json(status)),]
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,requestgroup_action_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case author {
                          Some(v) -> [#("author", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case group_identifier {
                          Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn requestgroup_decoder() -> Decoder(Requestgroup) {use action <- decode.optional_field("action", [], decode.list(requestgroup_action_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use author <- decode.optional_field("author", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use intent <- decode.field("intent",r4valuesets.requestintent_decoder())
use status <- decode.field("status",r4valuesets.requeststatus_decoder())
use group_identifier <- decode.optional_field("groupIdentifier", None, decode.optional(identifier_decoder()))
use replaces <- decode.optional_field("replaces", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Requestgroup(action:,note:,reason_reference:,reason_code:,author:,authored_on:,encounter:,subject:,code:,priority:,intent:,status:,group_identifier:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchDefinition#resource
pub type Researchdefinition
{
Researchdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
short_title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(ResearchdefinitionSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
comment: List(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
library: List(String),
population: Reference,
exposure: Option(Reference),
exposure_alternative: Option(Reference),
outcome: Option(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ResearchDefinition#resource
pub type ResearchdefinitionSubject{
ResearchdefinitionSubjectCodeableconcept(subject: Codeableconcept)
ResearchdefinitionSubjectReference(subject: Reference)}
pub fn researchdefinition_subject_to_json(elt: ResearchdefinitionSubject) -> Json {case elt{ResearchdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
ResearchdefinitionSubjectReference(v) -> reference_to_json(v)
}}
pub fn researchdefinition_subject_decoder() -> Decoder(ResearchdefinitionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ResearchdefinitionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(ResearchdefinitionSubjectReference),])}
pub fn researchdefinition_new(population population: Reference,status status: r4valuesets.Publicationstatus,) ->Researchdefinition{Researchdefinition(outcome: None,exposure_alternative: None,exposure: None,population:,library: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],comment: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,subtitle: None,short_title: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn researchdefinition_to_json(researchdefinition: Researchdefinition) -> Json {
    let Researchdefinition(outcome:,exposure_alternative:,exposure:,population:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,comment:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = researchdefinition
    let fields = [#("population", reference_to_json(population)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case outcome {
                          Some(v) -> [#("outcome", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exposure_alternative {
                          Some(v) -> [#("exposureAlternative", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exposure {
                          Some(v) -> [#("exposure", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case library {
                        [] -> fields
                        _ -> [#("library", json.array(library,json.string)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case comment {
                        [] -> fields
                        _ -> [#("comment", json.array(comment,json.string)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", researchdefinition_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case short_title {
                          Some(v) -> [#("shortTitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchdefinition_decoder() -> Decoder(Researchdefinition) {use outcome <- decode.optional_field("outcome", None, decode.optional(reference_decoder()))
use exposure_alternative <- decode.optional_field("exposureAlternative", None, decode.optional(reference_decoder()))
use exposure <- decode.optional_field("exposure", None, decode.optional(reference_decoder()))
use population <- decode.field("population",reference_decoder())
use library <- decode.optional_field("library", [], decode.list(decode.string))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use comment <- decode.optional_field("comment", [], decode.list(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(researchdefinition_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use short_title <- decode.optional_field("shortTitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Researchdefinition(outcome:,exposure_alternative:,exposure:,population:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,comment:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type Researchelementdefinition
{
Researchelementdefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
short_title: Option(String),
subtitle: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
subject: Option(ResearchelementdefinitionSubject),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
comment: List(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
usage: Option(String),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
library: List(String),
type_: r4valuesets.Researchelementtype,
variable_type: Option(r4valuesets.Variabletype),
characteristic: List(ResearchelementdefinitionCharacteristic),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionSubject{
ResearchelementdefinitionSubjectCodeableconcept(subject: Codeableconcept)
ResearchelementdefinitionSubjectReference(subject: Reference)}
pub fn researchelementdefinition_subject_to_json(elt: ResearchelementdefinitionSubject) -> Json {case elt{ResearchelementdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
ResearchelementdefinitionSubjectReference(v) -> reference_to_json(v)
}}
pub fn researchelementdefinition_subject_decoder() -> Decoder(ResearchelementdefinitionSubject){decode.one_of(decode.field("subjectCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ResearchelementdefinitionSubjectCodeableconcept),[decode.field("subjectReference", reference_decoder(), decode.success) |> decode.map(ResearchelementdefinitionSubjectReference),])}
pub fn researchelementdefinition_new(type_ type_: r4valuesets.Researchelementtype,status status: r4valuesets.Publicationstatus,) ->Researchelementdefinition{Researchelementdefinition(characteristic: [],variable_type: None,type_:,library: [],related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,usage: None,purpose: None,jurisdiction: [],use_context: [],comment: [],description: None,contact: [],publisher: None,date: None,subject: None,experimental: None,status:,subtitle: None,short_title: None,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristic
{
ResearchelementdefinitionCharacteristic(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
definition: ResearchelementdefinitionCharacteristicDefinition,
usage_context: List(Usagecontext),
exclude: Option(Bool),
unit_of_measure: Option(Codeableconcept),
study_effective_description: Option(String),
study_effective: Option(ResearchelementdefinitionCharacteristicStudyeffective),
study_effective_time_from_start: Option(Duration),
study_effective_group_measure: Option(r4valuesets.Groupmeasure),
participant_effective_description: Option(String),
participant_effective: Option(ResearchelementdefinitionCharacteristicParticipanteffective),
participant_effective_time_from_start: Option(Duration),
participant_effective_group_measure: Option(r4valuesets.Groupmeasure),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicDefinition{
ResearchelementdefinitionCharacteristicDefinitionCodeableconcept(definition: Codeableconcept)
ResearchelementdefinitionCharacteristicDefinitionCanonical(definition: String)
ResearchelementdefinitionCharacteristicDefinitionExpression(definition: Expression)
ResearchelementdefinitionCharacteristicDefinitionDatarequirement(definition: Datarequirement)}
pub fn researchelementdefinition_characteristic_definition_to_json(elt: ResearchelementdefinitionCharacteristicDefinition) -> Json {case elt{ResearchelementdefinitionCharacteristicDefinitionCodeableconcept(v) -> codeableconcept_to_json(v)
ResearchelementdefinitionCharacteristicDefinitionCanonical(v) -> json.string(v)
ResearchelementdefinitionCharacteristicDefinitionExpression(v) -> expression_to_json(v)
ResearchelementdefinitionCharacteristicDefinitionDatarequirement(v) -> datarequirement_to_json(v)
}}
pub fn researchelementdefinition_characteristic_definition_decoder() -> Decoder(ResearchelementdefinitionCharacteristicDefinition){decode.one_of(decode.field("definitionCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicDefinitionCodeableconcept),[decode.field("definitionCanonical", decode.string, decode.success) |> decode.map(ResearchelementdefinitionCharacteristicDefinitionCanonical),decode.field("definitionExpression", expression_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicDefinitionExpression),decode.field("definitionDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicDefinitionDatarequirement),])}

///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicStudyeffective{
ResearchelementdefinitionCharacteristicStudyeffectiveDatetime(study_effective: String)
ResearchelementdefinitionCharacteristicStudyeffectivePeriod(study_effective: Period)
ResearchelementdefinitionCharacteristicStudyeffectiveDuration(study_effective: Duration)
ResearchelementdefinitionCharacteristicStudyeffectiveTiming(study_effective: Timing)}
pub fn researchelementdefinition_characteristic_studyeffective_to_json(elt: ResearchelementdefinitionCharacteristicStudyeffective) -> Json {case elt{ResearchelementdefinitionCharacteristicStudyeffectiveDatetime(v) -> json.string(v)
ResearchelementdefinitionCharacteristicStudyeffectivePeriod(v) -> period_to_json(v)
ResearchelementdefinitionCharacteristicStudyeffectiveDuration(v) -> duration_to_json(v)
ResearchelementdefinitionCharacteristicStudyeffectiveTiming(v) -> timing_to_json(v)
}}
pub fn researchelementdefinition_characteristic_studyeffective_decoder() -> Decoder(ResearchelementdefinitionCharacteristicStudyeffective){decode.one_of(decode.field("studyEffectiveDateTime", decode.string, decode.success) |> decode.map(ResearchelementdefinitionCharacteristicStudyeffectiveDatetime),[decode.field("studyEffectivePeriod", period_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicStudyeffectivePeriod),decode.field("studyEffectiveDuration", duration_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicStudyeffectiveDuration),decode.field("studyEffectiveTiming", timing_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicStudyeffectiveTiming),])}

///http://hl7.org/fhir/r4/StructureDefinition/ResearchElementDefinition#resource
pub type ResearchelementdefinitionCharacteristicParticipanteffective{
ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime(participant_effective: String)
ResearchelementdefinitionCharacteristicParticipanteffectivePeriod(participant_effective: Period)
ResearchelementdefinitionCharacteristicParticipanteffectiveDuration(participant_effective: Duration)
ResearchelementdefinitionCharacteristicParticipanteffectiveTiming(participant_effective: Timing)}
pub fn researchelementdefinition_characteristic_participanteffective_to_json(elt: ResearchelementdefinitionCharacteristicParticipanteffective) -> Json {case elt{ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime(v) -> json.string(v)
ResearchelementdefinitionCharacteristicParticipanteffectivePeriod(v) -> period_to_json(v)
ResearchelementdefinitionCharacteristicParticipanteffectiveDuration(v) -> duration_to_json(v)
ResearchelementdefinitionCharacteristicParticipanteffectiveTiming(v) -> timing_to_json(v)
}}
pub fn researchelementdefinition_characteristic_participanteffective_decoder() -> Decoder(ResearchelementdefinitionCharacteristicParticipanteffective){decode.one_of(decode.field("participantEffectiveDateTime", decode.string, decode.success) |> decode.map(ResearchelementdefinitionCharacteristicParticipanteffectiveDatetime),[decode.field("participantEffectivePeriod", period_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicParticipanteffectivePeriod),decode.field("participantEffectiveDuration", duration_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicParticipanteffectiveDuration),decode.field("participantEffectiveTiming", timing_decoder(), decode.success) |> decode.map(ResearchelementdefinitionCharacteristicParticipanteffectiveTiming),])}
pub fn researchelementdefinition_characteristic_new(definition definition: ResearchelementdefinitionCharacteristicDefinition,) ->ResearchelementdefinitionCharacteristic{ResearchelementdefinitionCharacteristic(participant_effective_group_measure: None,participant_effective_time_from_start: None,participant_effective: None,participant_effective_description: None,study_effective_group_measure: None,study_effective_time_from_start: None,study_effective: None,study_effective_description: None,unit_of_measure: None,exclude: None,usage_context: [],definition:,modifier_extension: [],extension: [],id: None,)
}

pub fn researchelementdefinition_characteristic_to_json(researchelementdefinition_characteristic: ResearchelementdefinitionCharacteristic) -> Json {
    let ResearchelementdefinitionCharacteristic(participant_effective_group_measure:,participant_effective_time_from_start:,participant_effective:,participant_effective_description:,study_effective_group_measure:,study_effective_time_from_start:,study_effective:,study_effective_description:,unit_of_measure:,exclude:,usage_context:,definition:,modifier_extension:,extension:,id:,) = researchelementdefinition_characteristic
    let fields = [#("definition", researchelementdefinition_characteristic_definition_to_json(definition)),]
let fields = case participant_effective_group_measure {
                          Some(v) -> [#("participantEffectiveGroupMeasure", r4valuesets.groupmeasure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant_effective_time_from_start {
                          Some(v) -> [#("participantEffectiveTimeFromStart", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant_effective {
                          Some(v) -> [#("participantEffective", researchelementdefinition_characteristic_participanteffective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant_effective_description {
                          Some(v) -> [#("participantEffectiveDescription", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case study_effective_group_measure {
                          Some(v) -> [#("studyEffectiveGroupMeasure", r4valuesets.groupmeasure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case study_effective_time_from_start {
                          Some(v) -> [#("studyEffectiveTimeFromStart", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case study_effective {
                          Some(v) -> [#("studyEffective", researchelementdefinition_characteristic_studyeffective_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case study_effective_description {
                          Some(v) -> [#("studyEffectiveDescription", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_of_measure {
                          Some(v) -> [#("unitOfMeasure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exclude {
                          Some(v) -> [#("exclude", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case usage_context {
                        [] -> fields
                        _ -> [#("usageContext", json.array(usage_context,usagecontext_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchelementdefinition_characteristic_decoder() -> Decoder(ResearchelementdefinitionCharacteristic) {use participant_effective_group_measure <- decode.optional_field("participantEffectiveGroupMeasure", None, decode.optional(r4valuesets.groupmeasure_decoder()))
use participant_effective_time_from_start <- decode.optional_field("participantEffectiveTimeFromStart", None, decode.optional(duration_decoder()))
use participant_effective <- decode.then(none_if_omitted(researchelementdefinition_characteristic_participanteffective_decoder()))
use participant_effective_description <- decode.optional_field("participantEffectiveDescription", None, decode.optional(decode.string))
use study_effective_group_measure <- decode.optional_field("studyEffectiveGroupMeasure", None, decode.optional(r4valuesets.groupmeasure_decoder()))
use study_effective_time_from_start <- decode.optional_field("studyEffectiveTimeFromStart", None, decode.optional(duration_decoder()))
use study_effective <- decode.then(none_if_omitted(researchelementdefinition_characteristic_studyeffective_decoder()))
use study_effective_description <- decode.optional_field("studyEffectiveDescription", None, decode.optional(decode.string))
use unit_of_measure <- decode.optional_field("unitOfMeasure", None, decode.optional(codeableconcept_decoder()))
use exclude <- decode.optional_field("exclude", None, decode.optional(decode.bool))
use usage_context <- decode.optional_field("usageContext", [], decode.list(usagecontext_decoder()))
use definition <- decode.then(researchelementdefinition_characteristic_definition_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ResearchelementdefinitionCharacteristic(participant_effective_group_measure:,participant_effective_time_from_start:,participant_effective:,participant_effective_description:,study_effective_group_measure:,study_effective_time_from_start:,study_effective:,study_effective_description:,unit_of_measure:,exclude:,usage_context:,definition:,modifier_extension:,extension:,id:,))}
pub fn researchelementdefinition_to_json(researchelementdefinition: Researchelementdefinition) -> Json {
    let Researchelementdefinition(characteristic:,variable_type:,type_:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,comment:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = researchelementdefinition
    let fields = [#("type", r4valuesets.researchelementtype_to_json(type_)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case characteristic {
                        [] -> fields
                        _ -> [#("characteristic", json.array(characteristic,researchelementdefinition_characteristic_to_json)), ..fields]
                          }
let fields = case variable_type {
                          Some(v) -> [#("variableType", r4valuesets.variabletype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case library {
                        [] -> fields
                        _ -> [#("library", json.array(library,json.string)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case usage {
                          Some(v) -> [#("usage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case comment {
                        [] -> fields
                        _ -> [#("comment", json.array(comment,json.string)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", researchelementdefinition_subject_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case subtitle {
                          Some(v) -> [#("subtitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case short_title {
                          Some(v) -> [#("shortTitle", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchelementdefinition_decoder() -> Decoder(Researchelementdefinition) {use characteristic <- decode.optional_field("characteristic", [], decode.list(researchelementdefinition_characteristic_decoder()))
use variable_type <- decode.optional_field("variableType", None, decode.optional(r4valuesets.variabletype_decoder()))
use type_ <- decode.field("type",r4valuesets.researchelementtype_decoder())
use library <- decode.optional_field("library", [], decode.list(decode.string))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use usage <- decode.optional_field("usage", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use comment <- decode.optional_field("comment", [], decode.list(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use subject <- decode.then(none_if_omitted(researchelementdefinition_subject_decoder()))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use subtitle <- decode.optional_field("subtitle", None, decode.optional(decode.string))
use short_title <- decode.optional_field("shortTitle", None, decode.optional(decode.string))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Researchelementdefinition(characteristic:,variable_type:,type_:,library:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,usage:,purpose:,jurisdiction:,use_context:,comment:,description:,contact:,publisher:,date:,subject:,experimental:,status:,subtitle:,short_title:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchStudy#resource
pub type Researchstudy
{
Researchstudy(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
title: Option(String),
protocol: List(Reference),
part_of: List(Reference),
status: r4valuesets.Researchstudystatus,
primary_purpose_type: Option(Codeableconcept),
phase: Option(Codeableconcept),
category: List(Codeableconcept),
focus: List(Codeableconcept),
condition: List(Codeableconcept),
contact: List(Contactdetail),
related_artifact: List(Relatedartifact),
keyword: List(Codeableconcept),
location: List(Codeableconcept),
description: Option(String),
enrollment: List(Reference),
period: Option(Period),
sponsor: Option(Reference),
principal_investigator: Option(Reference),
site: List(Reference),
reason_stopped: Option(Codeableconcept),
note: List(Annotation),
arm: List(ResearchstudyArm),
objective: List(ResearchstudyObjective),
)
}

pub fn researchstudy_new(status status: r4valuesets.Researchstudystatus,) ->Researchstudy{Researchstudy(objective: [],arm: [],note: [],reason_stopped: None,site: [],principal_investigator: None,sponsor: None,period: None,enrollment: [],description: None,location: [],keyword: [],related_artifact: [],contact: [],condition: [],focus: [],category: [],phase: None,primary_purpose_type: None,status:,part_of: [],protocol: [],title: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyArm
{
ResearchstudyArm(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
type_: Option(Codeableconcept),
description: Option(String),
)
}

pub fn researchstudy_arm_new(name name: String,) ->ResearchstudyArm{ResearchstudyArm(description: None,type_: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyObjective
{
ResearchstudyObjective(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: Option(String),
type_: Option(Codeableconcept),
)
}

pub fn researchstudy_objective_new() ->ResearchstudyObjective{ResearchstudyObjective(type_: None,name: None,modifier_extension: [],extension: [],id: None,)
}

pub fn researchstudy_objective_to_json(researchstudy_objective: ResearchstudyObjective) -> Json {
    let ResearchstudyObjective(type_:,name:,modifier_extension:,extension:,id:,) = researchstudy_objective
    let fields = []
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchstudy_objective_decoder() -> Decoder(ResearchstudyObjective) {use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ResearchstudyObjective(type_:,name:,modifier_extension:,extension:,id:,))}
pub fn researchstudy_arm_to_json(researchstudy_arm: ResearchstudyArm) -> Json {
    let ResearchstudyArm(description:,type_:,name:,modifier_extension:,extension:,id:,) = researchstudy_arm
    let fields = [#("name", json.string(name)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchstudy_arm_decoder() -> Decoder(ResearchstudyArm) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ResearchstudyArm(description:,type_:,name:,modifier_extension:,extension:,id:,))}
pub fn researchstudy_to_json(researchstudy: Researchstudy) -> Json {
    let Researchstudy(objective:,arm:,note:,reason_stopped:,site:,principal_investigator:,sponsor:,period:,enrollment:,description:,location:,keyword:,related_artifact:,contact:,condition:,focus:,category:,phase:,primary_purpose_type:,status:,part_of:,protocol:,title:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = researchstudy
    let fields = [#("status", r4valuesets.researchstudystatus_to_json(status)),]
let fields = case objective {
                        [] -> fields
                        _ -> [#("objective", json.array(objective,researchstudy_objective_to_json)), ..fields]
                          }
let fields = case arm {
                        [] -> fields
                        _ -> [#("arm", json.array(arm,researchstudy_arm_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case reason_stopped {
                          Some(v) -> [#("reasonStopped", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case site {
                        [] -> fields
                        _ -> [#("site", json.array(site,reference_to_json)), ..fields]
                          }
let fields = case principal_investigator {
                          Some(v) -> [#("principalInvestigator", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sponsor {
                          Some(v) -> [#("sponsor", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case enrollment {
                        [] -> fields
                        _ -> [#("enrollment", json.array(enrollment,reference_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                        [] -> fields
                        _ -> [#("location", json.array(location,codeableconcept_to_json)), ..fields]
                          }
let fields = case keyword {
                        [] -> fields
                        _ -> [#("keyword", json.array(keyword,codeableconcept_to_json)), ..fields]
                          }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,codeableconcept_to_json)), ..fields]
                          }
let fields = case focus {
                        [] -> fields
                        _ -> [#("focus", json.array(focus,codeableconcept_to_json)), ..fields]
                          }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case phase {
                          Some(v) -> [#("phase", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case primary_purpose_type {
                          Some(v) -> [#("primaryPurposeType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case protocol {
                        [] -> fields
                        _ -> [#("protocol", json.array(protocol,reference_to_json)), ..fields]
                          }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchstudy_decoder() -> Decoder(Researchstudy) {use objective <- decode.optional_field("objective", [], decode.list(researchstudy_objective_decoder()))
use arm <- decode.optional_field("arm", [], decode.list(researchstudy_arm_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use reason_stopped <- decode.optional_field("reasonStopped", None, decode.optional(codeableconcept_decoder()))
use site <- decode.optional_field("site", [], decode.list(reference_decoder()))
use principal_investigator <- decode.optional_field("principalInvestigator", None, decode.optional(reference_decoder()))
use sponsor <- decode.optional_field("sponsor", None, decode.optional(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use enrollment <- decode.optional_field("enrollment", [], decode.list(reference_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use location <- decode.optional_field("location", [], decode.list(codeableconcept_decoder()))
use keyword <- decode.optional_field("keyword", [], decode.list(codeableconcept_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use condition <- decode.optional_field("condition", [], decode.list(codeableconcept_decoder()))
use focus <- decode.optional_field("focus", [], decode.list(codeableconcept_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use phase <- decode.optional_field("phase", None, decode.optional(codeableconcept_decoder()))
use primary_purpose_type <- decode.optional_field("primaryPurposeType", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.researchstudystatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use protocol <- decode.optional_field("protocol", [], decode.list(reference_decoder()))
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Researchstudy(objective:,arm:,note:,reason_stopped:,site:,principal_investigator:,sponsor:,period:,enrollment:,description:,location:,keyword:,related_artifact:,contact:,condition:,focus:,category:,phase:,primary_purpose_type:,status:,part_of:,protocol:,title:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ResearchSubject#resource
pub type Researchsubject
{
Researchsubject(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Researchsubjectstatus,
period: Option(Period),
study: Reference,
individual: Reference,
assigned_arm: Option(String),
actual_arm: Option(String),
consent: Option(Reference),
)
}

pub fn researchsubject_new(individual individual: Reference,study study: Reference,status status: r4valuesets.Researchsubjectstatus,) ->Researchsubject{Researchsubject(consent: None,actual_arm: None,assigned_arm: None,individual:,study:,period: None,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn researchsubject_to_json(researchsubject: Researchsubject) -> Json {
    let Researchsubject(consent:,actual_arm:,assigned_arm:,individual:,study:,period:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = researchsubject
    let fields = [#("individual", reference_to_json(individual)),#("study", reference_to_json(study)),#("status", r4valuesets.researchsubjectstatus_to_json(status)),]
let fields = case consent {
                          Some(v) -> [#("consent", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case actual_arm {
                          Some(v) -> [#("actualArm", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case assigned_arm {
                          Some(v) -> [#("assignedArm", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn researchsubject_decoder() -> Decoder(Researchsubject) {use consent <- decode.optional_field("consent", None, decode.optional(reference_decoder()))
use actual_arm <- decode.optional_field("actualArm", None, decode.optional(decode.string))
use assigned_arm <- decode.optional_field("assignedArm", None, decode.optional(decode.string))
use individual <- decode.field("individual",reference_decoder())
use study <- decode.field("study",reference_decoder())
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use status <- decode.field("status",r4valuesets.researchsubjectstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Researchsubject(consent:,actual_arm:,assigned_arm:,individual:,study:,period:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/RiskAssessment#resource
pub type Riskassessment
{
Riskassessment(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: Option(Reference),
parent: Option(Reference),
status: r4valuesets.Observationstatus,
method: Option(Codeableconcept),
code: Option(Codeableconcept),
subject: Reference,
encounter: Option(Reference),
occurrence: Option(RiskassessmentOccurrence),
condition: Option(Reference),
performer: Option(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
basis: List(Reference),
prediction: List(RiskassessmentPrediction),
mitigation: Option(String),
note: List(Annotation),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentOccurrence{
RiskassessmentOccurrenceDatetime(occurrence: String)
RiskassessmentOccurrencePeriod(occurrence: Period)}
pub fn riskassessment_occurrence_to_json(elt: RiskassessmentOccurrence) -> Json {case elt{RiskassessmentOccurrenceDatetime(v) -> json.string(v)
RiskassessmentOccurrencePeriod(v) -> period_to_json(v)
}}
pub fn riskassessment_occurrence_decoder() -> Decoder(RiskassessmentOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(RiskassessmentOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(RiskassessmentOccurrencePeriod),])}
pub fn riskassessment_new(subject subject: Reference,status status: r4valuesets.Observationstatus,) ->Riskassessment{Riskassessment(note: [],mitigation: None,prediction: [],basis: [],reason_reference: [],reason_code: [],performer: None,condition: None,occurrence: None,encounter: None,subject:,code: None,method: None,status:,parent: None,based_on: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPrediction
{
RiskassessmentPrediction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
outcome: Option(Codeableconcept),
probability: Option(RiskassessmentPredictionProbability),
qualitative_risk: Option(Codeableconcept),
relative_risk: Option(Float),
when: Option(RiskassessmentPredictionWhen),
rationale: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionProbability{
RiskassessmentPredictionProbabilityDecimal(probability: Float)
RiskassessmentPredictionProbabilityRange(probability: Range)}
pub fn riskassessment_prediction_probability_to_json(elt: RiskassessmentPredictionProbability) -> Json {case elt{RiskassessmentPredictionProbabilityDecimal(v) -> json.float(v)
RiskassessmentPredictionProbabilityRange(v) -> range_to_json(v)
}}
pub fn riskassessment_prediction_probability_decoder() -> Decoder(RiskassessmentPredictionProbability){decode.one_of(decode.field("probabilityDecimal", decode.float, decode.success) |> decode.map(RiskassessmentPredictionProbabilityDecimal),[decode.field("probabilityRange", range_decoder(), decode.success) |> decode.map(RiskassessmentPredictionProbabilityRange),])}

///http://hl7.org/fhir/r4/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionWhen{
RiskassessmentPredictionWhenPeriod(when: Period)
RiskassessmentPredictionWhenRange(when: Range)}
pub fn riskassessment_prediction_when_to_json(elt: RiskassessmentPredictionWhen) -> Json {case elt{RiskassessmentPredictionWhenPeriod(v) -> period_to_json(v)
RiskassessmentPredictionWhenRange(v) -> range_to_json(v)
}}
pub fn riskassessment_prediction_when_decoder() -> Decoder(RiskassessmentPredictionWhen){decode.one_of(decode.field("whenPeriod", period_decoder(), decode.success) |> decode.map(RiskassessmentPredictionWhenPeriod),[decode.field("whenRange", range_decoder(), decode.success) |> decode.map(RiskassessmentPredictionWhenRange),])}
pub fn riskassessment_prediction_new() ->RiskassessmentPrediction{RiskassessmentPrediction(rationale: None,when: None,relative_risk: None,qualitative_risk: None,probability: None,outcome: None,modifier_extension: [],extension: [],id: None,)
}

pub fn riskassessment_prediction_to_json(riskassessment_prediction: RiskassessmentPrediction) -> Json {
    let RiskassessmentPrediction(rationale:,when:,relative_risk:,qualitative_risk:,probability:,outcome:,modifier_extension:,extension:,id:,) = riskassessment_prediction
    let fields = []
let fields = case rationale {
                          Some(v) -> [#("rationale", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case when {
                          Some(v) -> [#("when", riskassessment_prediction_when_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relative_risk {
                          Some(v) -> [#("relativeRisk", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case qualitative_risk {
                          Some(v) -> [#("qualitativeRisk", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case probability {
                          Some(v) -> [#("probability", riskassessment_prediction_probability_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case outcome {
                          Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskassessment_prediction_decoder() -> Decoder(RiskassessmentPrediction) {use rationale <- decode.optional_field("rationale", None, decode.optional(decode.string))
use when <- decode.then(none_if_omitted(riskassessment_prediction_when_decoder()))
use relative_risk <- decode.optional_field("relativeRisk", None, decode.optional(decode.float))
use qualitative_risk <- decode.optional_field("qualitativeRisk", None, decode.optional(codeableconcept_decoder()))
use probability <- decode.then(none_if_omitted(riskassessment_prediction_probability_decoder()))
use outcome <- decode.optional_field("outcome", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskassessmentPrediction(rationale:,when:,relative_risk:,qualitative_risk:,probability:,outcome:,modifier_extension:,extension:,id:,))}
pub fn riskassessment_to_json(riskassessment: Riskassessment) -> Json {
    let Riskassessment(note:,mitigation:,prediction:,basis:,reason_reference:,reason_code:,performer:,condition:,occurrence:,encounter:,subject:,code:,method:,status:,parent:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = riskassessment
    let fields = [#("subject", reference_to_json(subject)),#("status", r4valuesets.observationstatus_to_json(status)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case mitigation {
                          Some(v) -> [#("mitigation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case prediction {
                        [] -> fields
                        _ -> [#("prediction", json.array(prediction,riskassessment_prediction_to_json)), ..fields]
                          }
let fields = case basis {
                        [] -> fields
                        _ -> [#("basis", json.array(basis,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer {
                          Some(v) -> [#("performer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case condition {
                          Some(v) -> [#("condition", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", riskassessment_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parent {
                          Some(v) -> [#("parent", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case based_on {
                          Some(v) -> [#("basedOn", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskassessment_decoder() -> Decoder(Riskassessment) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use mitigation <- decode.optional_field("mitigation", None, decode.optional(decode.string))
use prediction <- decode.optional_field("prediction", [], decode.list(riskassessment_prediction_decoder()))
use basis <- decode.optional_field("basis", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", None, decode.optional(reference_decoder()))
use condition <- decode.optional_field("condition", None, decode.optional(reference_decoder()))
use occurrence <- decode.then(none_if_omitted(riskassessment_occurrence_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.observationstatus_decoder())
use parent <- decode.optional_field("parent", None, decode.optional(reference_decoder()))
use based_on <- decode.optional_field("basedOn", None, decode.optional(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Riskassessment(note:,mitigation:,prediction:,basis:,reason_reference:,reason_code:,performer:,condition:,occurrence:,encounter:,subject:,code:,method:,status:,parent:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type Riskevidencesynthesis
{
Riskevidencesynthesis(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
note: List(Annotation),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
copyright: Option(String),
approval_date: Option(String),
last_review_date: Option(String),
effective_period: Option(Period),
topic: List(Codeableconcept),
author: List(Contactdetail),
editor: List(Contactdetail),
reviewer: List(Contactdetail),
endorser: List(Contactdetail),
related_artifact: List(Relatedartifact),
synthesis_type: Option(Codeableconcept),
study_type: Option(Codeableconcept),
population: Reference,
exposure: Option(Reference),
outcome: Reference,
sample_size: Option(RiskevidencesynthesisSamplesize),
risk_estimate: Option(RiskevidencesynthesisRiskestimate),
certainty: List(RiskevidencesynthesisCertainty),
)
}

pub fn riskevidencesynthesis_new(outcome outcome: Reference,population population: Reference,status status: r4valuesets.Publicationstatus,) ->Riskevidencesynthesis{Riskevidencesynthesis(certainty: [],risk_estimate: None,sample_size: None,outcome:,exposure: None,population:,study_type: None,synthesis_type: None,related_artifact: [],endorser: [],reviewer: [],editor: [],author: [],topic: [],effective_period: None,last_review_date: None,approval_date: None,copyright: None,jurisdiction: [],use_context: [],note: [],description: None,contact: [],publisher: None,date: None,status:,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type RiskevidencesynthesisSamplesize
{
RiskevidencesynthesisSamplesize(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
number_of_studies: Option(Int),
number_of_participants: Option(Int),
)
}

pub fn riskevidencesynthesis_samplesize_new() ->RiskevidencesynthesisSamplesize{RiskevidencesynthesisSamplesize(number_of_participants: None,number_of_studies: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type RiskevidencesynthesisRiskestimate
{
RiskevidencesynthesisRiskestimate(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
type_: Option(Codeableconcept),
value: Option(Float),
unit_of_measure: Option(Codeableconcept),
denominator_count: Option(Int),
numerator_count: Option(Int),
precision_estimate: List(RiskevidencesynthesisRiskestimatePrecisionestimate),
)
}

pub fn riskevidencesynthesis_riskestimate_new() ->RiskevidencesynthesisRiskestimate{RiskevidencesynthesisRiskestimate(precision_estimate: [],numerator_count: None,denominator_count: None,unit_of_measure: None,value: None,type_: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type RiskevidencesynthesisRiskestimatePrecisionestimate
{
RiskevidencesynthesisRiskestimatePrecisionestimate(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
level: Option(Float),
from: Option(Float),
to: Option(Float),
)
}

pub fn riskevidencesynthesis_riskestimate_precisionestimate_new() ->RiskevidencesynthesisRiskestimatePrecisionestimate{RiskevidencesynthesisRiskestimatePrecisionestimate(to: None,from: None,level: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type RiskevidencesynthesisCertainty
{
RiskevidencesynthesisCertainty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
rating: List(Codeableconcept),
note: List(Annotation),
certainty_subcomponent: List(RiskevidencesynthesisCertaintyCertaintysubcomponent),
)
}

pub fn riskevidencesynthesis_certainty_new() ->RiskevidencesynthesisCertainty{RiskevidencesynthesisCertainty(certainty_subcomponent: [],note: [],rating: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/RiskEvidenceSynthesis#resource
pub type RiskevidencesynthesisCertaintyCertaintysubcomponent
{
RiskevidencesynthesisCertaintyCertaintysubcomponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
rating: List(Codeableconcept),
note: List(Annotation),
)
}

pub fn riskevidencesynthesis_certainty_certaintysubcomponent_new() ->RiskevidencesynthesisCertaintyCertaintysubcomponent{RiskevidencesynthesisCertaintyCertaintysubcomponent(note: [],rating: [],type_: None,modifier_extension: [],extension: [],id: None,)
}

pub fn riskevidencesynthesis_certainty_certaintysubcomponent_to_json(riskevidencesynthesis_certainty_certaintysubcomponent: RiskevidencesynthesisCertaintyCertaintysubcomponent) -> Json {
    let RiskevidencesynthesisCertaintyCertaintysubcomponent(note:,rating:,type_:,modifier_extension:,extension:,id:,) = riskevidencesynthesis_certainty_certaintysubcomponent
    let fields = []
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case rating {
                        [] -> fields
                        _ -> [#("rating", json.array(rating,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_certainty_certaintysubcomponent_decoder() -> Decoder(RiskevidencesynthesisCertaintyCertaintysubcomponent) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use rating <- decode.optional_field("rating", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskevidencesynthesisCertaintyCertaintysubcomponent(note:,rating:,type_:,modifier_extension:,extension:,id:,))}
pub fn riskevidencesynthesis_certainty_to_json(riskevidencesynthesis_certainty: RiskevidencesynthesisCertainty) -> Json {
    let RiskevidencesynthesisCertainty(certainty_subcomponent:,note:,rating:,modifier_extension:,extension:,id:,) = riskevidencesynthesis_certainty
    let fields = []
let fields = case certainty_subcomponent {
                        [] -> fields
                        _ -> [#("certaintySubcomponent", json.array(certainty_subcomponent,riskevidencesynthesis_certainty_certaintysubcomponent_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case rating {
                        [] -> fields
                        _ -> [#("rating", json.array(rating,codeableconcept_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_certainty_decoder() -> Decoder(RiskevidencesynthesisCertainty) {use certainty_subcomponent <- decode.optional_field("certaintySubcomponent", [], decode.list(riskevidencesynthesis_certainty_certaintysubcomponent_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use rating <- decode.optional_field("rating", [], decode.list(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskevidencesynthesisCertainty(certainty_subcomponent:,note:,rating:,modifier_extension:,extension:,id:,))}
pub fn riskevidencesynthesis_riskestimate_precisionestimate_to_json(riskevidencesynthesis_riskestimate_precisionestimate: RiskevidencesynthesisRiskestimatePrecisionestimate) -> Json {
    let RiskevidencesynthesisRiskestimatePrecisionestimate(to:,from:,level:,type_:,modifier_extension:,extension:,id:,) = riskevidencesynthesis_riskestimate_precisionestimate
    let fields = []
let fields = case to {
                          Some(v) -> [#("to", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case from {
                          Some(v) -> [#("from", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case level {
                          Some(v) -> [#("level", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_riskestimate_precisionestimate_decoder() -> Decoder(RiskevidencesynthesisRiskestimatePrecisionestimate) {use to <- decode.optional_field("to", None, decode.optional(decode.float))
use from <- decode.optional_field("from", None, decode.optional(decode.float))
use level <- decode.optional_field("level", None, decode.optional(decode.float))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskevidencesynthesisRiskestimatePrecisionestimate(to:,from:,level:,type_:,modifier_extension:,extension:,id:,))}
pub fn riskevidencesynthesis_riskestimate_to_json(riskevidencesynthesis_riskestimate: RiskevidencesynthesisRiskestimate) -> Json {
    let RiskevidencesynthesisRiskestimate(precision_estimate:,numerator_count:,denominator_count:,unit_of_measure:,value:,type_:,description:,modifier_extension:,extension:,id:,) = riskevidencesynthesis_riskestimate
    let fields = []
let fields = case precision_estimate {
                        [] -> fields
                        _ -> [#("precisionEstimate", json.array(precision_estimate,riskevidencesynthesis_riskestimate_precisionestimate_to_json)), ..fields]
                          }
let fields = case numerator_count {
                          Some(v) -> [#("numeratorCount", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case denominator_count {
                          Some(v) -> [#("denominatorCount", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case unit_of_measure {
                          Some(v) -> [#("unitOfMeasure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case value {
                          Some(v) -> [#("value", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_riskestimate_decoder() -> Decoder(RiskevidencesynthesisRiskestimate) {use precision_estimate <- decode.optional_field("precisionEstimate", [], decode.list(riskevidencesynthesis_riskestimate_precisionestimate_decoder()))
use numerator_count <- decode.optional_field("numeratorCount", None, decode.optional(decode.int))
use denominator_count <- decode.optional_field("denominatorCount", None, decode.optional(decode.int))
use unit_of_measure <- decode.optional_field("unitOfMeasure", None, decode.optional(codeableconcept_decoder()))
use value <- decode.optional_field("value", None, decode.optional(decode.float))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskevidencesynthesisRiskestimate(precision_estimate:,numerator_count:,denominator_count:,unit_of_measure:,value:,type_:,description:,modifier_extension:,extension:,id:,))}
pub fn riskevidencesynthesis_samplesize_to_json(riskevidencesynthesis_samplesize: RiskevidencesynthesisSamplesize) -> Json {
    let RiskevidencesynthesisSamplesize(number_of_participants:,number_of_studies:,description:,modifier_extension:,extension:,id:,) = riskevidencesynthesis_samplesize
    let fields = []
let fields = case number_of_participants {
                          Some(v) -> [#("numberOfParticipants", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_studies {
                          Some(v) -> [#("numberOfStudies", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_samplesize_decoder() -> Decoder(RiskevidencesynthesisSamplesize) {use number_of_participants <- decode.optional_field("numberOfParticipants", None, decode.optional(decode.int))
use number_of_studies <- decode.optional_field("numberOfStudies", None, decode.optional(decode.int))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(RiskevidencesynthesisSamplesize(number_of_participants:,number_of_studies:,description:,modifier_extension:,extension:,id:,))}
pub fn riskevidencesynthesis_to_json(riskevidencesynthesis: Riskevidencesynthesis) -> Json {
    let Riskevidencesynthesis(certainty:,risk_estimate:,sample_size:,outcome:,exposure:,population:,study_type:,synthesis_type:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = riskevidencesynthesis
    let fields = [#("outcome", reference_to_json(outcome)),#("population", reference_to_json(population)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case certainty {
                        [] -> fields
                        _ -> [#("certainty", json.array(certainty,riskevidencesynthesis_certainty_to_json)), ..fields]
                          }
let fields = case risk_estimate {
                          Some(v) -> [#("riskEstimate", riskevidencesynthesis_riskestimate_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sample_size {
                          Some(v) -> [#("sampleSize", riskevidencesynthesis_samplesize_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case exposure {
                          Some(v) -> [#("exposure", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case study_type {
                          Some(v) -> [#("studyType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case synthesis_type {
                          Some(v) -> [#("synthesisType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case related_artifact {
                        [] -> fields
                        _ -> [#("relatedArtifact", json.array(related_artifact,relatedartifact_to_json)), ..fields]
                          }
let fields = case endorser {
                        [] -> fields
                        _ -> [#("endorser", json.array(endorser,contactdetail_to_json)), ..fields]
                          }
let fields = case reviewer {
                        [] -> fields
                        _ -> [#("reviewer", json.array(reviewer,contactdetail_to_json)), ..fields]
                          }
let fields = case editor {
                        [] -> fields
                        _ -> [#("editor", json.array(editor,contactdetail_to_json)), ..fields]
                          }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,contactdetail_to_json)), ..fields]
                          }
let fields = case topic {
                        [] -> fields
                        _ -> [#("topic", json.array(topic,codeableconcept_to_json)), ..fields]
                          }
let fields = case effective_period {
                          Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_review_date {
                          Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case approval_date {
                          Some(v) -> [#("approvalDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn riskevidencesynthesis_decoder() -> Decoder(Riskevidencesynthesis) {use certainty <- decode.optional_field("certainty", [], decode.list(riskevidencesynthesis_certainty_decoder()))
use risk_estimate <- decode.optional_field("riskEstimate", None, decode.optional(riskevidencesynthesis_riskestimate_decoder()))
use sample_size <- decode.optional_field("sampleSize", None, decode.optional(riskevidencesynthesis_samplesize_decoder()))
use outcome <- decode.field("outcome",reference_decoder())
use exposure <- decode.optional_field("exposure", None, decode.optional(reference_decoder()))
use population <- decode.field("population",reference_decoder())
use study_type <- decode.optional_field("studyType", None, decode.optional(codeableconcept_decoder()))
use synthesis_type <- decode.optional_field("synthesisType", None, decode.optional(codeableconcept_decoder()))
use related_artifact <- decode.optional_field("relatedArtifact", [], decode.list(relatedartifact_decoder()))
use endorser <- decode.optional_field("endorser", [], decode.list(contactdetail_decoder()))
use reviewer <- decode.optional_field("reviewer", [], decode.list(contactdetail_decoder()))
use editor <- decode.optional_field("editor", [], decode.list(contactdetail_decoder()))
use author <- decode.optional_field("author", [], decode.list(contactdetail_decoder()))
use topic <- decode.optional_field("topic", [], decode.list(codeableconcept_decoder()))
use effective_period <- decode.optional_field("effectivePeriod", None, decode.optional(period_decoder()))
use last_review_date <- decode.optional_field("lastReviewDate", None, decode.optional(decode.string))
use approval_date <- decode.optional_field("approvalDate", None, decode.optional(decode.string))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Riskevidencesynthesis(certainty:,risk_estimate:,sample_size:,outcome:,exposure:,population:,study_type:,synthesis_type:,related_artifact:,endorser:,reviewer:,editor:,author:,topic:,effective_period:,last_review_date:,approval_date:,copyright:,jurisdiction:,use_context:,note:,description:,contact:,publisher:,date:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Schedule#resource
pub type Schedule
{
Schedule(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
active: Option(Bool),
service_category: List(Codeableconcept),
service_type: List(Codeableconcept),
specialty: List(Codeableconcept),
actor: List(Reference),
planning_horizon: Option(Period),
comment: Option(String),
)
}

pub fn schedule_new() ->Schedule{Schedule(comment: None,planning_horizon: None,actor: [],specialty: [],service_type: [],service_category: [],active: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn schedule_to_json(schedule: Schedule) -> Json {
    let Schedule(comment:,planning_horizon:,actor:,specialty:,service_type:,service_category:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = schedule
    let fields = []
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case planning_horizon {
                          Some(v) -> [#("planningHorizon", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case actor {
                        [] -> fields
                        _ -> [#("actor", json.array(actor,reference_to_json)), ..fields]
                          }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_type {
                        [] -> fields
                        _ -> [#("serviceType", json.array(service_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_category {
                        [] -> fields
                        _ -> [#("serviceCategory", json.array(service_category,codeableconcept_to_json)), ..fields]
                          }
let fields = case active {
                          Some(v) -> [#("active", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn schedule_decoder() -> Decoder(Schedule) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use planning_horizon <- decode.optional_field("planningHorizon", None, decode.optional(period_decoder()))
use actor <- decode.optional_field("actor", [], decode.list(reference_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use service_type <- decode.optional_field("serviceType", [], decode.list(codeableconcept_decoder()))
use service_category <- decode.optional_field("serviceCategory", [], decode.list(codeableconcept_decoder()))
use active <- decode.optional_field("active", None, decode.optional(decode.bool))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Schedule(comment:,planning_horizon:,actor:,specialty:,service_type:,service_category:,active:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SearchParameter#resource
pub type Searchparameter
{
Searchparameter(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
version: Option(String),
name: String,
derived_from: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: String,
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
code: String,
base: List(r4valuesets.Resourcetypes),
type_: r4valuesets.Searchparamtype,
expression: Option(String),
xpath: Option(String),
xpath_usage: Option(r4valuesets.Searchxpathusage),
target: List(r4valuesets.Resourcetypes),
multiple_or: Option(Bool),
multiple_and: Option(Bool),
comparator: List(r4valuesets.Searchcomparator),
modifier: List(r4valuesets.Searchmodifiercode),
chain: List(String),
component: List(SearchparameterComponent),
)
}

pub fn searchparameter_new(type_ type_: r4valuesets.Searchparamtype,code code: String,description description: String,status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Searchparameter{Searchparameter(component: [],chain: [],modifier: [],comparator: [],multiple_and: None,multiple_or: None,target: [],xpath_usage: None,xpath: None,expression: None,type_:,base: [],code:,purpose: None,jurisdiction: [],use_context: [],description:,contact: [],publisher: None,date: None,experimental: None,status:,derived_from: None,name:,version: None,url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SearchParameter#resource
pub type SearchparameterComponent
{
SearchparameterComponent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
definition: String,
expression: String,
)
}

pub fn searchparameter_component_new(expression expression: String,definition definition: String,) ->SearchparameterComponent{SearchparameterComponent(expression:,definition:,modifier_extension: [],extension: [],id: None,)
}

pub fn searchparameter_component_to_json(searchparameter_component: SearchparameterComponent) -> Json {
    let SearchparameterComponent(expression:,definition:,modifier_extension:,extension:,id:,) = searchparameter_component
    let fields = [#("expression", json.string(expression)),#("definition", json.string(definition)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn searchparameter_component_decoder() -> Decoder(SearchparameterComponent) {use expression <- decode.field("expression",decode.string)
use definition <- decode.field("definition",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SearchparameterComponent(expression:,definition:,modifier_extension:,extension:,id:,))}
pub fn searchparameter_to_json(searchparameter: Searchparameter) -> Json {
    let Searchparameter(component:,chain:,modifier:,comparator:,multiple_and:,multiple_or:,target:,xpath_usage:,xpath:,expression:,type_:,base:,code:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,derived_from:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = searchparameter
    let fields = [#("type", r4valuesets.searchparamtype_to_json(type_)),#("code", json.string(code)),#("description", json.string(description)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case component {
                        [] -> fields
                        _ -> [#("component", json.array(component,searchparameter_component_to_json)), ..fields]
                          }
let fields = case chain {
                        [] -> fields
                        _ -> [#("chain", json.array(chain,json.string)), ..fields]
                          }
let fields = case modifier {
                        [] -> fields
                        _ -> [#("modifier", json.array(modifier,r4valuesets.searchmodifiercode_to_json)), ..fields]
                          }
let fields = case comparator {
                        [] -> fields
                        _ -> [#("comparator", json.array(comparator,r4valuesets.searchcomparator_to_json)), ..fields]
                          }
let fields = case multiple_and {
                          Some(v) -> [#("multipleAnd", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case multiple_or {
                          Some(v) -> [#("multipleOr", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,r4valuesets.resourcetypes_to_json)), ..fields]
                          }
let fields = case xpath_usage {
                          Some(v) -> [#("xpathUsage", r4valuesets.searchxpathusage_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case xpath {
                          Some(v) -> [#("xpath", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case base {
                        [] -> fields
                        _ -> [#("base", json.array(base,r4valuesets.resourcetypes_to_json)), ..fields]
                          }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case derived_from {
                          Some(v) -> [#("derivedFrom", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn searchparameter_decoder() -> Decoder(Searchparameter) {use component <- decode.optional_field("component", [], decode.list(searchparameter_component_decoder()))
use chain <- decode.optional_field("chain", [], decode.list(decode.string))
use modifier <- decode.optional_field("modifier", [], decode.list(r4valuesets.searchmodifiercode_decoder()))
use comparator <- decode.optional_field("comparator", [], decode.list(r4valuesets.searchcomparator_decoder()))
use multiple_and <- decode.optional_field("multipleAnd", None, decode.optional(decode.bool))
use multiple_or <- decode.optional_field("multipleOr", None, decode.optional(decode.bool))
use target <- decode.optional_field("target", [], decode.list(r4valuesets.resourcetypes_decoder()))
use xpath_usage <- decode.optional_field("xpathUsage", None, decode.optional(r4valuesets.searchxpathusage_decoder()))
use xpath <- decode.optional_field("xpath", None, decode.optional(decode.string))
use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.searchparamtype_decoder())
use base <- decode.optional_field("base", [], decode.list(r4valuesets.resourcetypes_decoder()))
use code <- decode.field("code",decode.string)
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.field("description",decode.string)
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use derived_from <- decode.optional_field("derivedFrom", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Searchparameter(component:,chain:,modifier:,comparator:,multiple_and:,multiple_or:,target:,xpath_usage:,xpath:,expression:,type_:,base:,code:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,derived_from:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ServiceRequest#resource
pub type Servicerequest
{
Servicerequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: List(String),
instantiates_uri: List(String),
based_on: List(Reference),
replaces: List(Reference),
requisition: Option(Identifier),
status: r4valuesets.Requeststatus,
intent: r4valuesets.Requestintent,
category: List(Codeableconcept),
priority: Option(r4valuesets.Requestpriority),
do_not_perform: Option(Bool),
code: Option(Codeableconcept),
order_detail: List(Codeableconcept),
quantity: Option(ServicerequestQuantity),
subject: Reference,
encounter: Option(Reference),
occurrence: Option(ServicerequestOccurrence),
as_needed: Option(ServicerequestAsneeded),
authored_on: Option(String),
requester: Option(Reference),
performer_type: Option(Codeableconcept),
performer: List(Reference),
location_code: List(Codeableconcept),
location_reference: List(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
insurance: List(Reference),
supporting_info: List(Reference),
specimen: List(Reference),
body_site: List(Codeableconcept),
note: List(Annotation),
patient_instruction: Option(String),
relevant_history: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ServiceRequest#resource
pub type ServicerequestQuantity{
ServicerequestQuantityQuantity(quantity: Quantity)
ServicerequestQuantityRatio(quantity: Ratio)
ServicerequestQuantityRange(quantity: Range)}
pub fn servicerequest_quantity_to_json(elt: ServicerequestQuantity) -> Json {case elt{ServicerequestQuantityQuantity(v) -> quantity_to_json(v)
ServicerequestQuantityRatio(v) -> ratio_to_json(v)
ServicerequestQuantityRange(v) -> range_to_json(v)
}}
pub fn servicerequest_quantity_decoder() -> Decoder(ServicerequestQuantity){decode.one_of(decode.field("quantityQuantity", quantity_decoder(), decode.success) |> decode.map(ServicerequestQuantityQuantity),[decode.field("quantityRatio", ratio_decoder(), decode.success) |> decode.map(ServicerequestQuantityRatio),decode.field("quantityRange", range_decoder(), decode.success) |> decode.map(ServicerequestQuantityRange),])}

///http://hl7.org/fhir/r4/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOccurrence{
ServicerequestOccurrenceDatetime(occurrence: String)
ServicerequestOccurrencePeriod(occurrence: Period)
ServicerequestOccurrenceTiming(occurrence: Timing)}
pub fn servicerequest_occurrence_to_json(elt: ServicerequestOccurrence) -> Json {case elt{ServicerequestOccurrenceDatetime(v) -> json.string(v)
ServicerequestOccurrencePeriod(v) -> period_to_json(v)
ServicerequestOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn servicerequest_occurrence_decoder() -> Decoder(ServicerequestOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(ServicerequestOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(ServicerequestOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(ServicerequestOccurrenceTiming),])}

///http://hl7.org/fhir/r4/StructureDefinition/ServiceRequest#resource
pub type ServicerequestAsneeded{
ServicerequestAsneededBoolean(as_needed: Bool)
ServicerequestAsneededCodeableconcept(as_needed: Codeableconcept)}
pub fn servicerequest_asneeded_to_json(elt: ServicerequestAsneeded) -> Json {case elt{ServicerequestAsneededBoolean(v) -> json.bool(v)
ServicerequestAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn servicerequest_asneeded_decoder() -> Decoder(ServicerequestAsneeded){decode.one_of(decode.field("asNeededBoolean", decode.bool, decode.success) |> decode.map(ServicerequestAsneededBoolean),[decode.field("asNeededCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(ServicerequestAsneededCodeableconcept),])}
pub fn servicerequest_new(subject subject: Reference,intent intent: r4valuesets.Requestintent,status status: r4valuesets.Requeststatus,) ->Servicerequest{Servicerequest(relevant_history: [],patient_instruction: None,note: [],body_site: [],specimen: [],supporting_info: [],insurance: [],reason_reference: [],reason_code: [],location_reference: [],location_code: [],performer: [],performer_type: None,requester: None,authored_on: None,as_needed: None,occurrence: None,encounter: None,subject:,quantity: None,order_detail: [],code: None,do_not_perform: None,priority: None,category: [],intent:,status:,requisition: None,replaces: [],based_on: [],instantiates_uri: [],instantiates_canonical: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn servicerequest_to_json(servicerequest: Servicerequest) -> Json {
    let Servicerequest(relevant_history:,patient_instruction:,note:,body_site:,specimen:,supporting_info:,insurance:,reason_reference:,reason_code:,location_reference:,location_code:,performer:,performer_type:,requester:,authored_on:,as_needed:,occurrence:,encounter:,subject:,quantity:,order_detail:,code:,do_not_perform:,priority:,category:,intent:,status:,requisition:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = servicerequest
    let fields = [#("subject", reference_to_json(subject)),#("intent", r4valuesets.requestintent_to_json(intent)),#("status", r4valuesets.requeststatus_to_json(status)),]
let fields = case relevant_history {
                        [] -> fields
                        _ -> [#("relevantHistory", json.array(relevant_history,reference_to_json)), ..fields]
                          }
let fields = case patient_instruction {
                          Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case body_site {
                        [] -> fields
                        _ -> [#("bodySite", json.array(body_site,codeableconcept_to_json)), ..fields]
                          }
let fields = case specimen {
                        [] -> fields
                        _ -> [#("specimen", json.array(specimen,reference_to_json)), ..fields]
                          }
let fields = case supporting_info {
                        [] -> fields
                        _ -> [#("supportingInfo", json.array(supporting_info,reference_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case location_reference {
                        [] -> fields
                        _ -> [#("locationReference", json.array(location_reference,reference_to_json)), ..fields]
                          }
let fields = case location_code {
                        [] -> fields
                        _ -> [#("locationCode", json.array(location_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case performer {
                        [] -> fields
                        _ -> [#("performer", json.array(performer,reference_to_json)), ..fields]
                          }
let fields = case performer_type {
                          Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case as_needed {
                          Some(v) -> [#("asNeeded", servicerequest_asneeded_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", servicerequest_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", servicerequest_quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case order_detail {
                        [] -> fields
                        _ -> [#("orderDetail", json.array(order_detail,codeableconcept_to_json)), ..fields]
                          }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case do_not_perform {
                          Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case requisition {
                          Some(v) -> [#("requisition", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case replaces {
                        [] -> fields
                        _ -> [#("replaces", json.array(replaces,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                        [] -> fields
                        _ -> [#("instantiatesUri", json.array(instantiates_uri,json.string)), ..fields]
                          }
let fields = case instantiates_canonical {
                        [] -> fields
                        _ -> [#("instantiatesCanonical", json.array(instantiates_canonical,json.string)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn servicerequest_decoder() -> Decoder(Servicerequest) {use relevant_history <- decode.optional_field("relevantHistory", [], decode.list(reference_decoder()))
use patient_instruction <- decode.optional_field("patientInstruction", None, decode.optional(decode.string))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use body_site <- decode.optional_field("bodySite", [], decode.list(codeableconcept_decoder()))
use specimen <- decode.optional_field("specimen", [], decode.list(reference_decoder()))
use supporting_info <- decode.optional_field("supportingInfo", [], decode.list(reference_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use location_reference <- decode.optional_field("locationReference", [], decode.list(reference_decoder()))
use location_code <- decode.optional_field("locationCode", [], decode.list(codeableconcept_decoder()))
use performer <- decode.optional_field("performer", [], decode.list(reference_decoder()))
use performer_type <- decode.optional_field("performerType", None, decode.optional(codeableconcept_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use as_needed <- decode.then(none_if_omitted(servicerequest_asneeded_decoder()))
use occurrence <- decode.then(none_if_omitted(servicerequest_occurrence_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use subject <- decode.field("subject",reference_decoder())
use quantity <- decode.then(none_if_omitted(servicerequest_quantity_decoder()))
use order_detail <- decode.optional_field("orderDetail", [], decode.list(codeableconcept_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use do_not_perform <- decode.optional_field("doNotPerform", None, decode.optional(decode.bool))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use intent <- decode.field("intent",r4valuesets.requestintent_decoder())
use status <- decode.field("status",r4valuesets.requeststatus_decoder())
use requisition <- decode.optional_field("requisition", None, decode.optional(identifier_decoder()))
use replaces <- decode.optional_field("replaces", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", [], decode.list(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", [], decode.list(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Servicerequest(relevant_history:,patient_instruction:,note:,body_site:,specimen:,supporting_info:,insurance:,reason_reference:,reason_code:,location_reference:,location_code:,performer:,performer_type:,requester:,authored_on:,as_needed:,occurrence:,encounter:,subject:,quantity:,order_detail:,code:,do_not_perform:,priority:,category:,intent:,status:,requisition:,replaces:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Slot#resource
pub type Slot
{
Slot(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
service_category: List(Codeableconcept),
service_type: List(Codeableconcept),
specialty: List(Codeableconcept),
appointment_type: Option(Codeableconcept),
schedule: Reference,
status: r4valuesets.Slotstatus,
start: String,
end: String,
overbooked: Option(Bool),
comment: Option(String),
)
}

pub fn slot_new(end end: String,start start: String,status status: r4valuesets.Slotstatus,schedule schedule: Reference,) ->Slot{Slot(comment: None,overbooked: None,end:,start:,status:,schedule:,appointment_type: None,specialty: [],service_type: [],service_category: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}

pub fn slot_to_json(slot: Slot) -> Json {
    let Slot(comment:,overbooked:,end:,start:,status:,schedule:,appointment_type:,specialty:,service_type:,service_category:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = slot
    let fields = [#("end", json.string(end)),#("start", json.string(start)),#("status", r4valuesets.slotstatus_to_json(status)),#("schedule", reference_to_json(schedule)),]
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case overbooked {
                          Some(v) -> [#("overbooked", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case appointment_type {
                          Some(v) -> [#("appointmentType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specialty {
                        [] -> fields
                        _ -> [#("specialty", json.array(specialty,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_type {
                        [] -> fields
                        _ -> [#("serviceType", json.array(service_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case service_category {
                        [] -> fields
                        _ -> [#("serviceCategory", json.array(service_category,codeableconcept_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn slot_decoder() -> Decoder(Slot) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use overbooked <- decode.optional_field("overbooked", None, decode.optional(decode.bool))
use end <- decode.field("end",decode.string)
use start <- decode.field("start",decode.string)
use status <- decode.field("status",r4valuesets.slotstatus_decoder())
use schedule <- decode.field("schedule",reference_decoder())
use appointment_type <- decode.optional_field("appointmentType", None, decode.optional(codeableconcept_decoder()))
use specialty <- decode.optional_field("specialty", [], decode.list(codeableconcept_decoder()))
use service_type <- decode.optional_field("serviceType", [], decode.list(codeableconcept_decoder()))
use service_category <- decode.optional_field("serviceCategory", [], decode.list(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Slot(comment:,overbooked:,end:,start:,status:,schedule:,appointment_type:,specialty:,service_type:,service_category:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type Specimen
{
Specimen(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
accession_identifier: Option(Identifier),
status: Option(r4valuesets.Specimenstatus),
type_: Option(Codeableconcept),
subject: Option(Reference),
received_time: Option(String),
parent: List(Reference),
request: List(Reference),
collection: Option(SpecimenCollection),
processing: List(SpecimenProcessing),
container: List(SpecimenContainer),
condition: List(Codeableconcept),
note: List(Annotation),
)
}

pub fn specimen_new() ->Specimen{Specimen(note: [],condition: [],container: [],processing: [],collection: None,request: [],parent: [],received_time: None,subject: None,type_: None,status: None,accession_identifier: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenCollection
{
SpecimenCollection(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
collector: Option(Reference),
collected: Option(SpecimenCollectionCollected),
duration: Option(Duration),
quantity: Option(Quantity),
method: Option(Codeableconcept),
body_site: Option(Codeableconcept),
fasting_status: Option(SpecimenCollectionFastingstatus),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenCollectionCollected{
SpecimenCollectionCollectedDatetime(collected: String)
SpecimenCollectionCollectedPeriod(collected: Period)}
pub fn specimen_collection_collected_to_json(elt: SpecimenCollectionCollected) -> Json {case elt{SpecimenCollectionCollectedDatetime(v) -> json.string(v)
SpecimenCollectionCollectedPeriod(v) -> period_to_json(v)
}}
pub fn specimen_collection_collected_decoder() -> Decoder(SpecimenCollectionCollected){decode.one_of(decode.field("collectedDateTime", decode.string, decode.success) |> decode.map(SpecimenCollectionCollectedDatetime),[decode.field("collectedPeriod", period_decoder(), decode.success) |> decode.map(SpecimenCollectionCollectedPeriod),])}

///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenCollectionFastingstatus{
SpecimenCollectionFastingstatusCodeableconcept(fasting_status: Codeableconcept)
SpecimenCollectionFastingstatusDuration(fasting_status: Duration)}
pub fn specimen_collection_fastingstatus_to_json(elt: SpecimenCollectionFastingstatus) -> Json {case elt{SpecimenCollectionFastingstatusCodeableconcept(v) -> codeableconcept_to_json(v)
SpecimenCollectionFastingstatusDuration(v) -> duration_to_json(v)
}}
pub fn specimen_collection_fastingstatus_decoder() -> Decoder(SpecimenCollectionFastingstatus){decode.one_of(decode.field("fastingStatusCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SpecimenCollectionFastingstatusCodeableconcept),[decode.field("fastingStatusDuration", duration_decoder(), decode.success) |> decode.map(SpecimenCollectionFastingstatusDuration),])}
pub fn specimen_collection_new() ->SpecimenCollection{SpecimenCollection(fasting_status: None,body_site: None,method: None,quantity: None,duration: None,collected: None,collector: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenProcessing
{
SpecimenProcessing(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: Option(String),
procedure: Option(Codeableconcept),
additive: List(Reference),
time: Option(SpecimenProcessingTime),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenProcessingTime{
SpecimenProcessingTimeDatetime(time: String)
SpecimenProcessingTimePeriod(time: Period)}
pub fn specimen_processing_time_to_json(elt: SpecimenProcessingTime) -> Json {case elt{SpecimenProcessingTimeDatetime(v) -> json.string(v)
SpecimenProcessingTimePeriod(v) -> period_to_json(v)
}}
pub fn specimen_processing_time_decoder() -> Decoder(SpecimenProcessingTime){decode.one_of(decode.field("timeDateTime", decode.string, decode.success) |> decode.map(SpecimenProcessingTimeDatetime),[decode.field("timePeriod", period_decoder(), decode.success) |> decode.map(SpecimenProcessingTimePeriod),])}
pub fn specimen_processing_new() ->SpecimenProcessing{SpecimenProcessing(time: None,additive: [],procedure: None,description: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenContainer
{
SpecimenContainer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
description: Option(String),
type_: Option(Codeableconcept),
capacity: Option(Quantity),
specimen_quantity: Option(Quantity),
additive: Option(SpecimenContainerAdditive),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Specimen#resource
pub type SpecimenContainerAdditive{
SpecimenContainerAdditiveCodeableconcept(additive: Codeableconcept)
SpecimenContainerAdditiveReference(additive: Reference)}
pub fn specimen_container_additive_to_json(elt: SpecimenContainerAdditive) -> Json {case elt{SpecimenContainerAdditiveCodeableconcept(v) -> codeableconcept_to_json(v)
SpecimenContainerAdditiveReference(v) -> reference_to_json(v)
}}
pub fn specimen_container_additive_decoder() -> Decoder(SpecimenContainerAdditive){decode.one_of(decode.field("additiveCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SpecimenContainerAdditiveCodeableconcept),[decode.field("additiveReference", reference_decoder(), decode.success) |> decode.map(SpecimenContainerAdditiveReference),])}
pub fn specimen_container_new() ->SpecimenContainer{SpecimenContainer(additive: None,specimen_quantity: None,capacity: None,type_: None,description: None,identifier: [],modifier_extension: [],extension: [],id: None,)
}

pub fn specimen_container_to_json(specimen_container: SpecimenContainer) -> Json {
    let SpecimenContainer(additive:,specimen_quantity:,capacity:,type_:,description:,identifier:,modifier_extension:,extension:,id:,) = specimen_container
    let fields = []
let fields = case additive {
                          Some(v) -> [#("additive", specimen_container_additive_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case specimen_quantity {
                          Some(v) -> [#("specimenQuantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case capacity {
                          Some(v) -> [#("capacity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimen_container_decoder() -> Decoder(SpecimenContainer) {use additive <- decode.then(none_if_omitted(specimen_container_additive_decoder()))
use specimen_quantity <- decode.optional_field("specimenQuantity", None, decode.optional(quantity_decoder()))
use capacity <- decode.optional_field("capacity", None, decode.optional(quantity_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimenContainer(additive:,specimen_quantity:,capacity:,type_:,description:,identifier:,modifier_extension:,extension:,id:,))}
pub fn specimen_processing_to_json(specimen_processing: SpecimenProcessing) -> Json {
    let SpecimenProcessing(time:,additive:,procedure:,description:,modifier_extension:,extension:,id:,) = specimen_processing
    let fields = []
let fields = case time {
                          Some(v) -> [#("time", specimen_processing_time_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case additive {
                        [] -> fields
                        _ -> [#("additive", json.array(additive,reference_to_json)), ..fields]
                          }
let fields = case procedure {
                          Some(v) -> [#("procedure", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimen_processing_decoder() -> Decoder(SpecimenProcessing) {use time <- decode.then(none_if_omitted(specimen_processing_time_decoder()))
use additive <- decode.optional_field("additive", [], decode.list(reference_decoder()))
use procedure <- decode.optional_field("procedure", None, decode.optional(codeableconcept_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimenProcessing(time:,additive:,procedure:,description:,modifier_extension:,extension:,id:,))}
pub fn specimen_collection_to_json(specimen_collection: SpecimenCollection) -> Json {
    let SpecimenCollection(fasting_status:,body_site:,method:,quantity:,duration:,collected:,collector:,modifier_extension:,extension:,id:,) = specimen_collection
    let fields = []
let fields = case fasting_status {
                          Some(v) -> [#("fastingStatus", specimen_collection_fastingstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case body_site {
                          Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case duration {
                          Some(v) -> [#("duration", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case collected {
                          Some(v) -> [#("collected", specimen_collection_collected_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case collector {
                          Some(v) -> [#("collector", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimen_collection_decoder() -> Decoder(SpecimenCollection) {use fasting_status <- decode.then(none_if_omitted(specimen_collection_fastingstatus_decoder()))
use body_site <- decode.optional_field("bodySite", None, decode.optional(codeableconcept_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use duration <- decode.optional_field("duration", None, decode.optional(duration_decoder()))
use collected <- decode.then(none_if_omitted(specimen_collection_collected_decoder()))
use collector <- decode.optional_field("collector", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimenCollection(fasting_status:,body_site:,method:,quantity:,duration:,collected:,collector:,modifier_extension:,extension:,id:,))}
pub fn specimen_to_json(specimen: Specimen) -> Json {
    let Specimen(note:,condition:,container:,processing:,collection:,request:,parent:,received_time:,subject:,type_:,status:,accession_identifier:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = specimen
    let fields = []
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case condition {
                        [] -> fields
                        _ -> [#("condition", json.array(condition,codeableconcept_to_json)), ..fields]
                          }
let fields = case container {
                        [] -> fields
                        _ -> [#("container", json.array(container,specimen_container_to_json)), ..fields]
                          }
let fields = case processing {
                        [] -> fields
                        _ -> [#("processing", json.array(processing,specimen_processing_to_json)), ..fields]
                          }
let fields = case collection {
                          Some(v) -> [#("collection", specimen_collection_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request {
                        [] -> fields
                        _ -> [#("request", json.array(request,reference_to_json)), ..fields]
                          }
let fields = case parent {
                        [] -> fields
                        _ -> [#("parent", json.array(parent,reference_to_json)), ..fields]
                          }
let fields = case received_time {
                          Some(v) -> [#("receivedTime", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subject {
                          Some(v) -> [#("subject", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.specimenstatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case accession_identifier {
                          Some(v) -> [#("accessionIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimen_decoder() -> Decoder(Specimen) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use condition <- decode.optional_field("condition", [], decode.list(codeableconcept_decoder()))
use container <- decode.optional_field("container", [], decode.list(specimen_container_decoder()))
use processing <- decode.optional_field("processing", [], decode.list(specimen_processing_decoder()))
use collection <- decode.optional_field("collection", None, decode.optional(specimen_collection_decoder()))
use request <- decode.optional_field("request", [], decode.list(reference_decoder()))
use parent <- decode.optional_field("parent", [], decode.list(reference_decoder()))
use received_time <- decode.optional_field("receivedTime", None, decode.optional(decode.string))
use subject <- decode.optional_field("subject", None, decode.optional(reference_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.specimenstatus_decoder()))
use accession_identifier <- decode.optional_field("accessionIdentifier", None, decode.optional(identifier_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Specimen(note:,condition:,container:,processing:,collection:,request:,parent:,received_time:,subject:,type_:,status:,accession_identifier:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type Specimendefinition
{
Specimendefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
type_collected: Option(Codeableconcept),
patient_preparation: List(Codeableconcept),
time_aspect: Option(String),
collection: List(Codeableconcept),
type_tested: List(SpecimendefinitionTypetested),
)
}

pub fn specimendefinition_new() ->Specimendefinition{Specimendefinition(type_tested: [],collection: [],time_aspect: None,patient_preparation: [],type_collected: None,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetested
{
SpecimendefinitionTypetested(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
is_derived: Option(Bool),
type_: Option(Codeableconcept),
preference: r4valuesets.Specimencontainedpreference,
container: Option(SpecimendefinitionTypetestedContainer),
requirement: Option(String),
retention_time: Option(Duration),
rejection_criterion: List(Codeableconcept),
handling: List(SpecimendefinitionTypetestedHandling),
)
}

pub fn specimendefinition_typetested_new(preference preference: r4valuesets.Specimencontainedpreference,) ->SpecimendefinitionTypetested{SpecimendefinitionTypetested(handling: [],rejection_criterion: [],retention_time: None,requirement: None,container: None,preference:,type_: None,is_derived: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainer
{
SpecimendefinitionTypetestedContainer(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
material: Option(Codeableconcept),
type_: Option(Codeableconcept),
cap: Option(Codeableconcept),
description: Option(String),
capacity: Option(Quantity),
minimum_volume: Option(SpecimendefinitionTypetestedContainerMinimumvolume),
additive: List(SpecimendefinitionTypetestedContainerAdditive),
preparation: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerMinimumvolume{
SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(minimum_volume: Quantity)
SpecimendefinitionTypetestedContainerMinimumvolumeString(minimum_volume: String)}
pub fn specimendefinition_typetested_container_minimumvolume_to_json(elt: SpecimendefinitionTypetestedContainerMinimumvolume) -> Json {case elt{SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(v) -> quantity_to_json(v)
SpecimendefinitionTypetestedContainerMinimumvolumeString(v) -> json.string(v)
}}
pub fn specimendefinition_typetested_container_minimumvolume_decoder() -> Decoder(SpecimendefinitionTypetestedContainerMinimumvolume){decode.one_of(decode.field("minimumVolumeQuantity", quantity_decoder(), decode.success) |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeQuantity),[decode.field("minimumVolumeString", decode.string, decode.success) |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeString),])}
pub fn specimendefinition_typetested_container_new() ->SpecimendefinitionTypetestedContainer{SpecimendefinitionTypetestedContainer(preparation: None,additive: [],minimum_volume: None,capacity: None,description: None,cap: None,type_: None,material: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditive
{
SpecimendefinitionTypetestedContainerAdditive(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditiveAdditive{
SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(additive: Codeableconcept)
SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(additive: Reference)}
pub fn specimendefinition_typetested_container_additive_additive_to_json(elt: SpecimendefinitionTypetestedContainerAdditiveAdditive) -> Json {case elt{SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(v) -> codeableconcept_to_json(v)
SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(v) -> reference_to_json(v)
}}
pub fn specimendefinition_typetested_container_additive_additive_decoder() -> Decoder(SpecimendefinitionTypetestedContainerAdditiveAdditive){decode.one_of(decode.field("additiveCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept),[decode.field("additiveReference", reference_decoder(), decode.success) |> decode.map(SpecimendefinitionTypetestedContainerAdditiveAdditiveReference),])}
pub fn specimendefinition_typetested_container_additive_new(additive additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,) ->SpecimendefinitionTypetestedContainerAdditive{SpecimendefinitionTypetestedContainerAdditive(additive:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedHandling
{
SpecimendefinitionTypetestedHandling(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
temperature_qualifier: Option(Codeableconcept),
temperature_range: Option(Range),
max_duration: Option(Duration),
instruction: Option(String),
)
}

pub fn specimendefinition_typetested_handling_new() ->SpecimendefinitionTypetestedHandling{SpecimendefinitionTypetestedHandling(instruction: None,max_duration: None,temperature_range: None,temperature_qualifier: None,modifier_extension: [],extension: [],id: None,)
}

pub fn specimendefinition_typetested_handling_to_json(specimendefinition_typetested_handling: SpecimendefinitionTypetestedHandling) -> Json {
    let SpecimendefinitionTypetestedHandling(instruction:,max_duration:,temperature_range:,temperature_qualifier:,modifier_extension:,extension:,id:,) = specimendefinition_typetested_handling
    let fields = []
let fields = case instruction {
                          Some(v) -> [#("instruction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max_duration {
                          Some(v) -> [#("maxDuration", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case temperature_range {
                          Some(v) -> [#("temperatureRange", range_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case temperature_qualifier {
                          Some(v) -> [#("temperatureQualifier", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimendefinition_typetested_handling_decoder() -> Decoder(SpecimendefinitionTypetestedHandling) {use instruction <- decode.optional_field("instruction", None, decode.optional(decode.string))
use max_duration <- decode.optional_field("maxDuration", None, decode.optional(duration_decoder()))
use temperature_range <- decode.optional_field("temperatureRange", None, decode.optional(range_decoder()))
use temperature_qualifier <- decode.optional_field("temperatureQualifier", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimendefinitionTypetestedHandling(instruction:,max_duration:,temperature_range:,temperature_qualifier:,modifier_extension:,extension:,id:,))}
pub fn specimendefinition_typetested_container_additive_to_json(specimendefinition_typetested_container_additive: SpecimendefinitionTypetestedContainerAdditive) -> Json {
    let SpecimendefinitionTypetestedContainerAdditive(additive:,modifier_extension:,extension:,id:,) = specimendefinition_typetested_container_additive
    let fields = [#("additive", specimendefinition_typetested_container_additive_additive_to_json(additive)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimendefinition_typetested_container_additive_decoder() -> Decoder(SpecimendefinitionTypetestedContainerAdditive) {use additive <- decode.then(specimendefinition_typetested_container_additive_additive_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimendefinitionTypetestedContainerAdditive(additive:,modifier_extension:,extension:,id:,))}
pub fn specimendefinition_typetested_container_to_json(specimendefinition_typetested_container: SpecimendefinitionTypetestedContainer) -> Json {
    let SpecimendefinitionTypetestedContainer(preparation:,additive:,minimum_volume:,capacity:,description:,cap:,type_:,material:,modifier_extension:,extension:,id:,) = specimendefinition_typetested_container
    let fields = []
let fields = case preparation {
                          Some(v) -> [#("preparation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case additive {
                        [] -> fields
                        _ -> [#("additive", json.array(additive,specimendefinition_typetested_container_additive_to_json)), ..fields]
                          }
let fields = case minimum_volume {
                          Some(v) -> [#("minimumVolume", specimendefinition_typetested_container_minimumvolume_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case capacity {
                          Some(v) -> [#("capacity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case cap {
                          Some(v) -> [#("cap", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case material {
                          Some(v) -> [#("material", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimendefinition_typetested_container_decoder() -> Decoder(SpecimendefinitionTypetestedContainer) {use preparation <- decode.optional_field("preparation", None, decode.optional(decode.string))
use additive <- decode.optional_field("additive", [], decode.list(specimendefinition_typetested_container_additive_decoder()))
use minimum_volume <- decode.then(none_if_omitted(specimendefinition_typetested_container_minimumvolume_decoder()))
use capacity <- decode.optional_field("capacity", None, decode.optional(quantity_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use cap <- decode.optional_field("cap", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use material <- decode.optional_field("material", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimendefinitionTypetestedContainer(preparation:,additive:,minimum_volume:,capacity:,description:,cap:,type_:,material:,modifier_extension:,extension:,id:,))}
pub fn specimendefinition_typetested_to_json(specimendefinition_typetested: SpecimendefinitionTypetested) -> Json {
    let SpecimendefinitionTypetested(handling:,rejection_criterion:,retention_time:,requirement:,container:,preference:,type_:,is_derived:,modifier_extension:,extension:,id:,) = specimendefinition_typetested
    let fields = [#("preference", r4valuesets.specimencontainedpreference_to_json(preference)),]
let fields = case handling {
                        [] -> fields
                        _ -> [#("handling", json.array(handling,specimendefinition_typetested_handling_to_json)), ..fields]
                          }
let fields = case rejection_criterion {
                        [] -> fields
                        _ -> [#("rejectionCriterion", json.array(rejection_criterion,codeableconcept_to_json)), ..fields]
                          }
let fields = case retention_time {
                          Some(v) -> [#("retentionTime", duration_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case requirement {
                          Some(v) -> [#("requirement", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case container {
                          Some(v) -> [#("container", specimendefinition_typetested_container_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_derived {
                          Some(v) -> [#("isDerived", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimendefinition_typetested_decoder() -> Decoder(SpecimendefinitionTypetested) {use handling <- decode.optional_field("handling", [], decode.list(specimendefinition_typetested_handling_decoder()))
use rejection_criterion <- decode.optional_field("rejectionCriterion", [], decode.list(codeableconcept_decoder()))
use retention_time <- decode.optional_field("retentionTime", None, decode.optional(duration_decoder()))
use requirement <- decode.optional_field("requirement", None, decode.optional(decode.string))
use container <- decode.optional_field("container", None, decode.optional(specimendefinition_typetested_container_decoder()))
use preference <- decode.field("preference",r4valuesets.specimencontainedpreference_decoder())
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use is_derived <- decode.optional_field("isDerived", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SpecimendefinitionTypetested(handling:,rejection_criterion:,retention_time:,requirement:,container:,preference:,type_:,is_derived:,modifier_extension:,extension:,id:,))}
pub fn specimendefinition_to_json(specimendefinition: Specimendefinition) -> Json {
    let Specimendefinition(type_tested:,collection:,time_aspect:,patient_preparation:,type_collected:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = specimendefinition
    let fields = []
let fields = case type_tested {
                        [] -> fields
                        _ -> [#("typeTested", json.array(type_tested,specimendefinition_typetested_to_json)), ..fields]
                          }
let fields = case collection {
                        [] -> fields
                        _ -> [#("collection", json.array(collection,codeableconcept_to_json)), ..fields]
                          }
let fields = case time_aspect {
                          Some(v) -> [#("timeAspect", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case patient_preparation {
                        [] -> fields
                        _ -> [#("patientPreparation", json.array(patient_preparation,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_collected {
                          Some(v) -> [#("typeCollected", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn specimendefinition_decoder() -> Decoder(Specimendefinition) {use type_tested <- decode.optional_field("typeTested", [], decode.list(specimendefinition_typetested_decoder()))
use collection <- decode.optional_field("collection", [], decode.list(codeableconcept_decoder()))
use time_aspect <- decode.optional_field("timeAspect", None, decode.optional(decode.string))
use patient_preparation <- decode.optional_field("patientPreparation", [], decode.list(codeableconcept_decoder()))
use type_collected <- decode.optional_field("typeCollected", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Specimendefinition(type_tested:,collection:,time_aspect:,patient_preparation:,type_collected:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/StructureDefinition#resource
pub type Structuredefinition
{
Structuredefinition(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
identifier: List(Identifier),
version: Option(String),
name: String,
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
keyword: List(Coding),
fhir_version: Option(r4valuesets.Fhirversion),
mapping: List(StructuredefinitionMapping),
kind: r4valuesets.Structuredefinitionkind,
abstract: Bool,
context: List(StructuredefinitionContext),
context_invariant: List(String),
type_: String,
base_definition: Option(String),
derivation: Option(r4valuesets.Typederivationrule),
snapshot: Option(StructuredefinitionSnapshot),
differential: Option(StructuredefinitionDifferential),
)
}

pub fn structuredefinition_new(type_ type_: String,abstract abstract: Bool,kind kind: r4valuesets.Structuredefinitionkind,status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Structuredefinition{Structuredefinition(differential: None,snapshot: None,derivation: None,base_definition: None,type_:,context_invariant: [],context: [],abstract:,kind:,mapping: [],fhir_version: None,keyword: [],copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name:,version: None,identifier: [],url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionMapping
{
StructuredefinitionMapping(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identity: String,
uri: Option(String),
name: Option(String),
comment: Option(String),
)
}

pub fn structuredefinition_mapping_new(identity identity: String,) ->StructuredefinitionMapping{StructuredefinitionMapping(comment: None,name: None,uri: None,identity:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionContext
{
StructuredefinitionContext(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Extensioncontexttype,
expression: String,
)
}

pub fn structuredefinition_context_new(expression expression: String,type_ type_: r4valuesets.Extensioncontexttype,) ->StructuredefinitionContext{StructuredefinitionContext(expression:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionSnapshot
{
StructuredefinitionSnapshot(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
element: List(Elementdefinition),
)
}

pub fn structuredefinition_snapshot_new() ->StructuredefinitionSnapshot{StructuredefinitionSnapshot(element: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionDifferential
{
StructuredefinitionDifferential(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
element: List(Elementdefinition),
)
}

pub fn structuredefinition_differential_new() ->StructuredefinitionDifferential{StructuredefinitionDifferential(element: [],modifier_extension: [],extension: [],id: None,)
}

pub fn structuredefinition_differential_to_json(structuredefinition_differential: StructuredefinitionDifferential) -> Json {
    let StructuredefinitionDifferential(element:,modifier_extension:,extension:,id:,) = structuredefinition_differential
    let fields = []
let fields = case element {
                        [] -> fields
                        _ -> [#("element", json.array(element,elementdefinition_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuredefinition_differential_decoder() -> Decoder(StructuredefinitionDifferential) {use element <- decode.optional_field("element", [], decode.list(elementdefinition_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuredefinitionDifferential(element:,modifier_extension:,extension:,id:,))}
pub fn structuredefinition_snapshot_to_json(structuredefinition_snapshot: StructuredefinitionSnapshot) -> Json {
    let StructuredefinitionSnapshot(element:,modifier_extension:,extension:,id:,) = structuredefinition_snapshot
    let fields = []
let fields = case element {
                        [] -> fields
                        _ -> [#("element", json.array(element,elementdefinition_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuredefinition_snapshot_decoder() -> Decoder(StructuredefinitionSnapshot) {use element <- decode.optional_field("element", [], decode.list(elementdefinition_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuredefinitionSnapshot(element:,modifier_extension:,extension:,id:,))}
pub fn structuredefinition_context_to_json(structuredefinition_context: StructuredefinitionContext) -> Json {
    let StructuredefinitionContext(expression:,type_:,modifier_extension:,extension:,id:,) = structuredefinition_context
    let fields = [#("expression", json.string(expression)),#("type", r4valuesets.extensioncontexttype_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuredefinition_context_decoder() -> Decoder(StructuredefinitionContext) {use expression <- decode.field("expression",decode.string)
use type_ <- decode.field("type",r4valuesets.extensioncontexttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuredefinitionContext(expression:,type_:,modifier_extension:,extension:,id:,))}
pub fn structuredefinition_mapping_to_json(structuredefinition_mapping: StructuredefinitionMapping) -> Json {
    let StructuredefinitionMapping(comment:,name:,uri:,identity:,modifier_extension:,extension:,id:,) = structuredefinition_mapping
    let fields = [#("identity", json.string(identity)),]
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case uri {
                          Some(v) -> [#("uri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuredefinition_mapping_decoder() -> Decoder(StructuredefinitionMapping) {use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
use identity <- decode.field("identity",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuredefinitionMapping(comment:,name:,uri:,identity:,modifier_extension:,extension:,id:,))}
pub fn structuredefinition_to_json(structuredefinition: Structuredefinition) -> Json {
    let Structuredefinition(differential:,snapshot:,derivation:,base_definition:,type_:,context_invariant:,context:,abstract:,kind:,mapping:,fhir_version:,keyword:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = structuredefinition
    let fields = [#("type", json.string(type_)),#("abstract", json.bool(abstract)),#("kind", r4valuesets.structuredefinitionkind_to_json(kind)),#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case differential {
                          Some(v) -> [#("differential", structuredefinition_differential_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case snapshot {
                          Some(v) -> [#("snapshot", structuredefinition_snapshot_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case derivation {
                          Some(v) -> [#("derivation", r4valuesets.typederivationrule_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case base_definition {
                          Some(v) -> [#("baseDefinition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case context_invariant {
                        [] -> fields
                        _ -> [#("contextInvariant", json.array(context_invariant,json.string)), ..fields]
                          }
let fields = case context {
                        [] -> fields
                        _ -> [#("context", json.array(context,structuredefinition_context_to_json)), ..fields]
                          }
let fields = case mapping {
                        [] -> fields
                        _ -> [#("mapping", json.array(mapping,structuredefinition_mapping_to_json)), ..fields]
                          }
let fields = case fhir_version {
                          Some(v) -> [#("fhirVersion", r4valuesets.fhirversion_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case keyword {
                        [] -> fields
                        _ -> [#("keyword", json.array(keyword,coding_to_json)), ..fields]
                          }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuredefinition_decoder() -> Decoder(Structuredefinition) {use differential <- decode.optional_field("differential", None, decode.optional(structuredefinition_differential_decoder()))
use snapshot <- decode.optional_field("snapshot", None, decode.optional(structuredefinition_snapshot_decoder()))
use derivation <- decode.optional_field("derivation", None, decode.optional(r4valuesets.typederivationrule_decoder()))
use base_definition <- decode.optional_field("baseDefinition", None, decode.optional(decode.string))
use type_ <- decode.field("type",decode.string)
use context_invariant <- decode.optional_field("contextInvariant", [], decode.list(decode.string))
use context <- decode.optional_field("context", [], decode.list(structuredefinition_context_decoder()))
use abstract <- decode.field("abstract",decode.bool)
use kind <- decode.field("kind",r4valuesets.structuredefinitionkind_decoder())
use mapping <- decode.optional_field("mapping", [], decode.list(structuredefinition_mapping_decoder()))
use fhir_version <- decode.optional_field("fhirVersion", None, decode.optional(r4valuesets.fhirversion_decoder()))
use keyword <- decode.optional_field("keyword", [], decode.list(coding_decoder()))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Structuredefinition(differential:,snapshot:,derivation:,base_definition:,type_:,context_invariant:,context:,abstract:,kind:,mapping:,fhir_version:,keyword:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type Structuremap
{
Structuremap(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
identifier: List(Identifier),
version: Option(String),
name: String,
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
structure: List(StructuremapStructure),
import_: List(String),
group: List(StructuremapGroup),
)
}

pub fn structuremap_new(status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Structuremap{Structuremap(group: [],import_: [],structure: [],copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name:,version: None,identifier: [],url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapStructure
{
StructuremapStructure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
mode: r4valuesets.Mapmodelmode,
alias: Option(String),
documentation: Option(String),
)
}

pub fn structuremap_structure_new(mode mode: r4valuesets.Mapmodelmode,url url: String,) ->StructuremapStructure{StructuremapStructure(documentation: None,alias: None,mode:,url:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroup
{
StructuremapGroup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
extends: Option(String),
type_mode: r4valuesets.Mapgrouptypemode,
documentation: Option(String),
input: List(StructuremapGroupInput),
rule: List(StructuremapGroupRule),
)
}

pub fn structuremap_group_new(type_mode type_mode: r4valuesets.Mapgrouptypemode,name name: String,) ->StructuremapGroup{StructuremapGroup(rule: [],input: [],documentation: None,type_mode:,extends: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupInput
{
StructuremapGroupInput(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
type_: Option(String),
mode: r4valuesets.Mapinputmode,
documentation: Option(String),
)
}

pub fn structuremap_group_input_new(mode mode: r4valuesets.Mapinputmode,name name: String,) ->StructuremapGroupInput{StructuremapGroupInput(documentation: None,mode:,type_: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRule
{
StructuremapGroupRule(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
source: List(StructuremapGroupRuleSource),
target: List(StructuremapGroupRuleTarget),
dependent: List(StructuremapGroupRuleDependent),
documentation: Option(String),
)
}

pub fn structuremap_group_rule_new(name name: String,) ->StructuremapGroupRule{StructuremapGroupRule(documentation: None,dependent: [],target: [],source: [],name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleSource
{
StructuremapGroupRuleSource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
context: String,
min: Option(Int),
max: Option(String),
type_: Option(String),
default_value: Option(StructuremapGroupRuleSourceDefaultvalue),
element: Option(String),
list_mode: Option(r4valuesets.Mapsourcelistmode),
variable: Option(String),
condition: Option(String),
check: Option(String),
log_message: Option(String),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleSourceDefaultvalue{
StructuremapGroupRuleSourceDefaultvalueBase64binary(default_value: String)
StructuremapGroupRuleSourceDefaultvalueBoolean(default_value: Bool)
StructuremapGroupRuleSourceDefaultvalueCanonical(default_value: String)
StructuremapGroupRuleSourceDefaultvalueCode(default_value: String)
StructuremapGroupRuleSourceDefaultvalueDate(default_value: String)
StructuremapGroupRuleSourceDefaultvalueDatetime(default_value: String)
StructuremapGroupRuleSourceDefaultvalueDecimal(default_value: Float)
StructuremapGroupRuleSourceDefaultvalueId(default_value: String)
StructuremapGroupRuleSourceDefaultvalueInstant(default_value: String)
StructuremapGroupRuleSourceDefaultvalueInteger(default_value: Int)
StructuremapGroupRuleSourceDefaultvalueMarkdown(default_value: String)
StructuremapGroupRuleSourceDefaultvalueOid(default_value: String)
StructuremapGroupRuleSourceDefaultvaluePositiveint(default_value: Int)
StructuremapGroupRuleSourceDefaultvalueString(default_value: String)
StructuremapGroupRuleSourceDefaultvalueTime(default_value: String)
StructuremapGroupRuleSourceDefaultvalueUnsignedint(default_value: Int)
StructuremapGroupRuleSourceDefaultvalueUri(default_value: String)
StructuremapGroupRuleSourceDefaultvalueUrl(default_value: String)
StructuremapGroupRuleSourceDefaultvalueUuid(default_value: String)
StructuremapGroupRuleSourceDefaultvalueAddress(default_value: Address)
StructuremapGroupRuleSourceDefaultvalueAge(default_value: Age)
StructuremapGroupRuleSourceDefaultvalueAnnotation(default_value: Annotation)
StructuremapGroupRuleSourceDefaultvalueAttachment(default_value: Attachment)
StructuremapGroupRuleSourceDefaultvalueCodeableconcept(default_value: Codeableconcept)
StructuremapGroupRuleSourceDefaultvalueCoding(default_value: Coding)
StructuremapGroupRuleSourceDefaultvalueContactpoint(default_value: Contactpoint)
StructuremapGroupRuleSourceDefaultvalueCount(default_value: Count)
StructuremapGroupRuleSourceDefaultvalueDistance(default_value: Distance)
StructuremapGroupRuleSourceDefaultvalueDuration(default_value: Duration)
StructuremapGroupRuleSourceDefaultvalueHumanname(default_value: Humanname)
StructuremapGroupRuleSourceDefaultvalueIdentifier(default_value: Identifier)
StructuremapGroupRuleSourceDefaultvalueMoney(default_value: Money)
StructuremapGroupRuleSourceDefaultvaluePeriod(default_value: Period)
StructuremapGroupRuleSourceDefaultvalueQuantity(default_value: Quantity)
StructuremapGroupRuleSourceDefaultvalueRange(default_value: Range)
StructuremapGroupRuleSourceDefaultvalueRatio(default_value: Ratio)
StructuremapGroupRuleSourceDefaultvalueReference(default_value: Reference)
StructuremapGroupRuleSourceDefaultvalueSampleddata(default_value: Sampleddata)
StructuremapGroupRuleSourceDefaultvalueSignature(default_value: Signature)
StructuremapGroupRuleSourceDefaultvalueTiming(default_value: Timing)
StructuremapGroupRuleSourceDefaultvalueContactdetail(default_value: Contactdetail)
StructuremapGroupRuleSourceDefaultvalueContributor(default_value: Contributor)
StructuremapGroupRuleSourceDefaultvalueDatarequirement(default_value: Datarequirement)
StructuremapGroupRuleSourceDefaultvalueExpression(default_value: Expression)
StructuremapGroupRuleSourceDefaultvalueParameterdefinition(default_value: Parameterdefinition)
StructuremapGroupRuleSourceDefaultvalueRelatedartifact(default_value: Relatedartifact)
StructuremapGroupRuleSourceDefaultvalueTriggerdefinition(default_value: Triggerdefinition)
StructuremapGroupRuleSourceDefaultvalueUsagecontext(default_value: Usagecontext)
StructuremapGroupRuleSourceDefaultvalueDosage(default_value: Dosage)
StructuremapGroupRuleSourceDefaultvalueMeta(default_value: Meta)}
pub fn structuremap_group_rule_source_defaultvalue_to_json(elt: StructuremapGroupRuleSourceDefaultvalue) -> Json {case elt{StructuremapGroupRuleSourceDefaultvalueBase64binary(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueBoolean(v) -> json.bool(v)
StructuremapGroupRuleSourceDefaultvalueCanonical(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueCode(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueDate(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueDatetime(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueDecimal(v) -> json.float(v)
StructuremapGroupRuleSourceDefaultvalueId(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueInstant(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueInteger(v) -> json.int(v)
StructuremapGroupRuleSourceDefaultvalueMarkdown(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueOid(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvaluePositiveint(v) -> json.int(v)
StructuremapGroupRuleSourceDefaultvalueString(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueTime(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueUnsignedint(v) -> json.int(v)
StructuremapGroupRuleSourceDefaultvalueUri(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueUrl(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueUuid(v) -> json.string(v)
StructuremapGroupRuleSourceDefaultvalueAddress(v) -> address_to_json(v)
StructuremapGroupRuleSourceDefaultvalueAge(v) -> age_to_json(v)
StructuremapGroupRuleSourceDefaultvalueAnnotation(v) -> annotation_to_json(v)
StructuremapGroupRuleSourceDefaultvalueAttachment(v) -> attachment_to_json(v)
StructuremapGroupRuleSourceDefaultvalueCodeableconcept(v) -> codeableconcept_to_json(v)
StructuremapGroupRuleSourceDefaultvalueCoding(v) -> coding_to_json(v)
StructuremapGroupRuleSourceDefaultvalueContactpoint(v) -> contactpoint_to_json(v)
StructuremapGroupRuleSourceDefaultvalueCount(v) -> count_to_json(v)
StructuremapGroupRuleSourceDefaultvalueDistance(v) -> distance_to_json(v)
StructuremapGroupRuleSourceDefaultvalueDuration(v) -> duration_to_json(v)
StructuremapGroupRuleSourceDefaultvalueHumanname(v) -> humanname_to_json(v)
StructuremapGroupRuleSourceDefaultvalueIdentifier(v) -> identifier_to_json(v)
StructuremapGroupRuleSourceDefaultvalueMoney(v) -> money_to_json(v)
StructuremapGroupRuleSourceDefaultvaluePeriod(v) -> period_to_json(v)
StructuremapGroupRuleSourceDefaultvalueQuantity(v) -> quantity_to_json(v)
StructuremapGroupRuleSourceDefaultvalueRange(v) -> range_to_json(v)
StructuremapGroupRuleSourceDefaultvalueRatio(v) -> ratio_to_json(v)
StructuremapGroupRuleSourceDefaultvalueReference(v) -> reference_to_json(v)
StructuremapGroupRuleSourceDefaultvalueSampleddata(v) -> sampleddata_to_json(v)
StructuremapGroupRuleSourceDefaultvalueSignature(v) -> signature_to_json(v)
StructuremapGroupRuleSourceDefaultvalueTiming(v) -> timing_to_json(v)
StructuremapGroupRuleSourceDefaultvalueContactdetail(v) -> contactdetail_to_json(v)
StructuremapGroupRuleSourceDefaultvalueContributor(v) -> contributor_to_json(v)
StructuremapGroupRuleSourceDefaultvalueDatarequirement(v) -> datarequirement_to_json(v)
StructuremapGroupRuleSourceDefaultvalueExpression(v) -> expression_to_json(v)
StructuremapGroupRuleSourceDefaultvalueParameterdefinition(v) -> parameterdefinition_to_json(v)
StructuremapGroupRuleSourceDefaultvalueRelatedartifact(v) -> relatedartifact_to_json(v)
StructuremapGroupRuleSourceDefaultvalueTriggerdefinition(v) -> triggerdefinition_to_json(v)
StructuremapGroupRuleSourceDefaultvalueUsagecontext(v) -> usagecontext_to_json(v)
StructuremapGroupRuleSourceDefaultvalueDosage(v) -> dosage_to_json(v)
StructuremapGroupRuleSourceDefaultvalueMeta(v) -> meta_to_json(v)
}}
pub fn structuremap_group_rule_source_defaultvalue_decoder() -> Decoder(StructuremapGroupRuleSourceDefaultvalue){decode.one_of(decode.field("defaultValueBase64Binary", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueBase64binary),[decode.field("defaultValueBoolean", decode.bool, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueBoolean),decode.field("defaultValueCanonical", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueCanonical),decode.field("defaultValueCode", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueCode),decode.field("defaultValueDate", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDate),decode.field("defaultValueDateTime", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDatetime),decode.field("defaultValueDecimal", decode.float, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDecimal),decode.field("defaultValueId", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueId),decode.field("defaultValueInstant", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueInstant),decode.field("defaultValueInteger", decode.int, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueInteger),decode.field("defaultValueMarkdown", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueMarkdown),decode.field("defaultValueOid", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueOid),decode.field("defaultValuePositiveInt", decode.int, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvaluePositiveint),decode.field("defaultValueString", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueString),decode.field("defaultValueTime", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueTime),decode.field("defaultValueUnsignedInt", decode.int, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueUnsignedint),decode.field("defaultValueUri", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueUri),decode.field("defaultValueUrl", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueUrl),decode.field("defaultValueUuid", decode.string, decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueUuid),decode.field("defaultValueAddress", address_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueAddress),decode.field("defaultValueAge", age_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueAge),decode.field("defaultValueAnnotation", annotation_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueAnnotation),decode.field("defaultValueAttachment", attachment_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueAttachment),decode.field("defaultValueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueCodeableconcept),decode.field("defaultValueCoding", coding_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueCoding),decode.field("defaultValueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueContactpoint),decode.field("defaultValueCount", count_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueCount),decode.field("defaultValueDistance", distance_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDistance),decode.field("defaultValueDuration", duration_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDuration),decode.field("defaultValueHumanName", humanname_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueHumanname),decode.field("defaultValueIdentifier", identifier_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueIdentifier),decode.field("defaultValueMoney", money_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueMoney),decode.field("defaultValuePeriod", period_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvaluePeriod),decode.field("defaultValueQuantity", quantity_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueQuantity),decode.field("defaultValueRange", range_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueRange),decode.field("defaultValueRatio", ratio_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueRatio),decode.field("defaultValueReference", reference_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueReference),decode.field("defaultValueSampledData", sampleddata_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueSampleddata),decode.field("defaultValueSignature", signature_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueSignature),decode.field("defaultValueTiming", timing_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueTiming),decode.field("defaultValueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueContactdetail),decode.field("defaultValueContributor", contributor_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueContributor),decode.field("defaultValueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDatarequirement),decode.field("defaultValueExpression", expression_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueExpression),decode.field("defaultValueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueParameterdefinition),decode.field("defaultValueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueRelatedartifact),decode.field("defaultValueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueTriggerdefinition),decode.field("defaultValueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueUsagecontext),decode.field("defaultValueDosage", dosage_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueDosage),decode.field("defaultValueMeta", meta_decoder(), decode.success) |> decode.map(StructuremapGroupRuleSourceDefaultvalueMeta),])}
pub fn structuremap_group_rule_source_new(context context: String,) ->StructuremapGroupRuleSource{StructuremapGroupRuleSource(log_message: None,check: None,condition: None,variable: None,list_mode: None,element: None,default_value: None,type_: None,max: None,min: None,context:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTarget
{
StructuremapGroupRuleTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
context: Option(String),
context_type: Option(r4valuesets.Mapcontexttype),
element: Option(String),
variable: Option(String),
list_mode: List(r4valuesets.Maptargetlistmode),
list_rule_id: Option(String),
transform: Option(r4valuesets.Maptransform),
parameter: List(StructuremapGroupRuleTargetParameter),
)
}

pub fn structuremap_group_rule_target_new() ->StructuremapGroupRuleTarget{StructuremapGroupRuleTarget(parameter: [],transform: None,list_rule_id: None,list_mode: [],variable: None,element: None,context_type: None,context: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameter
{
StructuremapGroupRuleTargetParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
value: StructuremapGroupRuleTargetParameterValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameterValue{
StructuremapGroupRuleTargetParameterValueId(value: String)
StructuremapGroupRuleTargetParameterValueString(value: String)
StructuremapGroupRuleTargetParameterValueBoolean(value: Bool)
StructuremapGroupRuleTargetParameterValueInteger(value: Int)
StructuremapGroupRuleTargetParameterValueDecimal(value: Float)}
pub fn structuremap_group_rule_target_parameter_value_to_json(elt: StructuremapGroupRuleTargetParameterValue) -> Json {case elt{StructuremapGroupRuleTargetParameterValueId(v) -> json.string(v)
StructuremapGroupRuleTargetParameterValueString(v) -> json.string(v)
StructuremapGroupRuleTargetParameterValueBoolean(v) -> json.bool(v)
StructuremapGroupRuleTargetParameterValueInteger(v) -> json.int(v)
StructuremapGroupRuleTargetParameterValueDecimal(v) -> json.float(v)
}}
pub fn structuremap_group_rule_target_parameter_value_decoder() -> Decoder(StructuremapGroupRuleTargetParameterValue){decode.one_of(decode.field("valueId", decode.string, decode.success) |> decode.map(StructuremapGroupRuleTargetParameterValueId),[decode.field("valueString", decode.string, decode.success) |> decode.map(StructuremapGroupRuleTargetParameterValueString),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(StructuremapGroupRuleTargetParameterValueBoolean),decode.field("valueInteger", decode.int, decode.success) |> decode.map(StructuremapGroupRuleTargetParameterValueInteger),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(StructuremapGroupRuleTargetParameterValueDecimal),])}
pub fn structuremap_group_rule_target_parameter_new(value value: StructuremapGroupRuleTargetParameterValue,) ->StructuremapGroupRuleTargetParameter{StructuremapGroupRuleTargetParameter(value:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleDependent
{
StructuremapGroupRuleDependent(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
variable: List(String),
)
}

pub fn structuremap_group_rule_dependent_new(name name: String,) ->StructuremapGroupRuleDependent{StructuremapGroupRuleDependent(variable: [],name:,modifier_extension: [],extension: [],id: None,)
}

pub fn structuremap_group_rule_dependent_to_json(structuremap_group_rule_dependent: StructuremapGroupRuleDependent) -> Json {
    let StructuremapGroupRuleDependent(variable:,name:,modifier_extension:,extension:,id:,) = structuremap_group_rule_dependent
    let fields = [#("name", json.string(name)),]
let fields = case variable {
                        [] -> fields
                        _ -> [#("variable", json.array(variable,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_rule_dependent_decoder() -> Decoder(StructuremapGroupRuleDependent) {use variable <- decode.optional_field("variable", [], decode.list(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupRuleDependent(variable:,name:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_rule_target_parameter_to_json(structuremap_group_rule_target_parameter: StructuremapGroupRuleTargetParameter) -> Json {
    let StructuremapGroupRuleTargetParameter(value:,modifier_extension:,extension:,id:,) = structuremap_group_rule_target_parameter
    let fields = [#("value", structuremap_group_rule_target_parameter_value_to_json(value)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_rule_target_parameter_decoder() -> Decoder(StructuremapGroupRuleTargetParameter) {use value <- decode.then(structuremap_group_rule_target_parameter_value_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupRuleTargetParameter(value:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_rule_target_to_json(structuremap_group_rule_target: StructuremapGroupRuleTarget) -> Json {
    let StructuremapGroupRuleTarget(parameter:,transform:,list_rule_id:,list_mode:,variable:,element:,context_type:,context:,modifier_extension:,extension:,id:,) = structuremap_group_rule_target
    let fields = []
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,structuremap_group_rule_target_parameter_to_json)), ..fields]
                          }
let fields = case transform {
                          Some(v) -> [#("transform", r4valuesets.maptransform_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case list_rule_id {
                          Some(v) -> [#("listRuleId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case list_mode {
                        [] -> fields
                        _ -> [#("listMode", json.array(list_mode,r4valuesets.maptargetlistmode_to_json)), ..fields]
                          }
let fields = case variable {
                          Some(v) -> [#("variable", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case element {
                          Some(v) -> [#("element", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case context_type {
                          Some(v) -> [#("contextType", r4valuesets.mapcontexttype_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case context {
                          Some(v) -> [#("context", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_rule_target_decoder() -> Decoder(StructuremapGroupRuleTarget) {use parameter <- decode.optional_field("parameter", [], decode.list(structuremap_group_rule_target_parameter_decoder()))
use transform <- decode.optional_field("transform", None, decode.optional(r4valuesets.maptransform_decoder()))
use list_rule_id <- decode.optional_field("listRuleId", None, decode.optional(decode.string))
use list_mode <- decode.optional_field("listMode", [], decode.list(r4valuesets.maptargetlistmode_decoder()))
use variable <- decode.optional_field("variable", None, decode.optional(decode.string))
use element <- decode.optional_field("element", None, decode.optional(decode.string))
use context_type <- decode.optional_field("contextType", None, decode.optional(r4valuesets.mapcontexttype_decoder()))
use context <- decode.optional_field("context", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupRuleTarget(parameter:,transform:,list_rule_id:,list_mode:,variable:,element:,context_type:,context:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_rule_source_to_json(structuremap_group_rule_source: StructuremapGroupRuleSource) -> Json {
    let StructuremapGroupRuleSource(log_message:,check:,condition:,variable:,list_mode:,element:,default_value:,type_:,max:,min:,context:,modifier_extension:,extension:,id:,) = structuremap_group_rule_source
    let fields = [#("context", json.string(context)),]
let fields = case log_message {
                          Some(v) -> [#("logMessage", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case check {
                          Some(v) -> [#("check", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case condition {
                          Some(v) -> [#("condition", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case variable {
                          Some(v) -> [#("variable", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case list_mode {
                          Some(v) -> [#("listMode", r4valuesets.mapsourcelistmode_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case element {
                          Some(v) -> [#("element", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case default_value {
                          Some(v) -> [#("defaultValue", structuremap_group_rule_source_defaultvalue_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case max {
                          Some(v) -> [#("max", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case min {
                          Some(v) -> [#("min", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_rule_source_decoder() -> Decoder(StructuremapGroupRuleSource) {use log_message <- decode.optional_field("logMessage", None, decode.optional(decode.string))
use check <- decode.optional_field("check", None, decode.optional(decode.string))
use condition <- decode.optional_field("condition", None, decode.optional(decode.string))
use variable <- decode.optional_field("variable", None, decode.optional(decode.string))
use list_mode <- decode.optional_field("listMode", None, decode.optional(r4valuesets.mapsourcelistmode_decoder()))
use element <- decode.optional_field("element", None, decode.optional(decode.string))
use default_value <- decode.then(none_if_omitted(structuremap_group_rule_source_defaultvalue_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(decode.string))
use max <- decode.optional_field("max", None, decode.optional(decode.string))
use min <- decode.optional_field("min", None, decode.optional(decode.int))
use context <- decode.field("context",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupRuleSource(log_message:,check:,condition:,variable:,list_mode:,element:,default_value:,type_:,max:,min:,context:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_rule_to_json(structuremap_group_rule: StructuremapGroupRule) -> Json {
    let StructuremapGroupRule(documentation:,dependent:,target:,source:,name:,modifier_extension:,extension:,id:,) = structuremap_group_rule
    let fields = [#("name", json.string(name)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case dependent {
                        [] -> fields
                        _ -> [#("dependent", json.array(dependent,structuremap_group_rule_dependent_to_json)), ..fields]
                          }
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,structuremap_group_rule_target_to_json)), ..fields]
                          }
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,structuremap_group_rule_source_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_rule_decoder() -> Decoder(StructuremapGroupRule) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use dependent <- decode.optional_field("dependent", [], decode.list(structuremap_group_rule_dependent_decoder()))
use target <- decode.optional_field("target", [], decode.list(structuremap_group_rule_target_decoder()))
use source <- decode.optional_field("source", [], decode.list(structuremap_group_rule_source_decoder()))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupRule(documentation:,dependent:,target:,source:,name:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_input_to_json(structuremap_group_input: StructuremapGroupInput) -> Json {
    let StructuremapGroupInput(documentation:,mode:,type_:,name:,modifier_extension:,extension:,id:,) = structuremap_group_input
    let fields = [#("mode", r4valuesets.mapinputmode_to_json(mode)),#("name", json.string(name)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_input_decoder() -> Decoder(StructuremapGroupInput) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.mapinputmode_decoder())
use type_ <- decode.optional_field("type", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroupInput(documentation:,mode:,type_:,name:,modifier_extension:,extension:,id:,))}
pub fn structuremap_group_to_json(structuremap_group: StructuremapGroup) -> Json {
    let StructuremapGroup(rule:,input:,documentation:,type_mode:,extends:,name:,modifier_extension:,extension:,id:,) = structuremap_group
    let fields = [#("typeMode", r4valuesets.mapgrouptypemode_to_json(type_mode)),#("name", json.string(name)),]
let fields = case rule {
                        [] -> fields
                        _ -> [#("rule", json.array(rule,structuremap_group_rule_to_json)), ..fields]
                          }
let fields = case input {
                        [] -> fields
                        _ -> [#("input", json.array(input,structuremap_group_input_to_json)), ..fields]
                          }
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case extends {
                          Some(v) -> [#("extends", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_group_decoder() -> Decoder(StructuremapGroup) {use rule <- decode.optional_field("rule", [], decode.list(structuremap_group_rule_decoder()))
use input <- decode.optional_field("input", [], decode.list(structuremap_group_input_decoder()))
use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use type_mode <- decode.field("typeMode",r4valuesets.mapgrouptypemode_decoder())
use extends <- decode.optional_field("extends", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapGroup(rule:,input:,documentation:,type_mode:,extends:,name:,modifier_extension:,extension:,id:,))}
pub fn structuremap_structure_to_json(structuremap_structure: StructuremapStructure) -> Json {
    let StructuremapStructure(documentation:,alias:,mode:,url:,modifier_extension:,extension:,id:,) = structuremap_structure
    let fields = [#("mode", r4valuesets.mapmodelmode_to_json(mode)),#("url", json.string(url)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case alias {
                          Some(v) -> [#("alias", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_structure_decoder() -> Decoder(StructuremapStructure) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use alias <- decode.optional_field("alias", None, decode.optional(decode.string))
use mode <- decode.field("mode",r4valuesets.mapmodelmode_decoder())
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(StructuremapStructure(documentation:,alias:,mode:,url:,modifier_extension:,extension:,id:,))}
pub fn structuremap_to_json(structuremap: Structuremap) -> Json {
    let Structuremap(group:,import_:,structure:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = structuremap
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case group {
                        [] -> fields
                        _ -> [#("group", json.array(group,structuremap_group_to_json)), ..fields]
                          }
let fields = case import_ {
                        [] -> fields
                        _ -> [#("import", json.array(import_,json.string)), ..fields]
                          }
let fields = case structure {
                        [] -> fields
                        _ -> [#("structure", json.array(structure,structuremap_structure_to_json)), ..fields]
                          }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn structuremap_decoder() -> Decoder(Structuremap) {use group <- decode.optional_field("group", [], decode.list(structuremap_group_decoder()))
use import_ <- decode.optional_field("import", [], decode.list(decode.string))
use structure <- decode.optional_field("structure", [], decode.list(structuremap_structure_decoder()))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Structuremap(group:,import_:,structure:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Subscription#resource
pub type Subscription
{
Subscription(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
status: r4valuesets.Subscriptionstatus,
contact: List(Contactpoint),
end: Option(String),
reason: String,
criteria: String,
error: Option(String),
channel: SubscriptionChannel,
)
}

pub fn subscription_new(channel channel: SubscriptionChannel,criteria criteria: String,reason reason: String,status status: r4valuesets.Subscriptionstatus,) ->Subscription{Subscription(channel:,error: None,criteria:,reason:,end: None,contact: [],status:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Subscription#resource
pub type SubscriptionChannel
{
SubscriptionChannel(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Subscriptionchanneltype,
endpoint: Option(String),
payload: Option(String),
header: List(String),
)
}

pub fn subscription_channel_new(type_ type_: r4valuesets.Subscriptionchanneltype,) ->SubscriptionChannel{SubscriptionChannel(header: [],payload: None,endpoint: None,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn subscription_channel_to_json(subscription_channel: SubscriptionChannel) -> Json {
    let SubscriptionChannel(header:,payload:,endpoint:,type_:,modifier_extension:,extension:,id:,) = subscription_channel
    let fields = [#("type", r4valuesets.subscriptionchanneltype_to_json(type_)),]
let fields = case header {
                        [] -> fields
                        _ -> [#("header", json.array(header,json.string)), ..fields]
                          }
let fields = case payload {
                          Some(v) -> [#("payload", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case endpoint {
                          Some(v) -> [#("endpoint", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn subscription_channel_decoder() -> Decoder(SubscriptionChannel) {use header <- decode.optional_field("header", [], decode.list(decode.string))
use payload <- decode.optional_field("payload", None, decode.optional(decode.string))
use endpoint <- decode.optional_field("endpoint", None, decode.optional(decode.string))
use type_ <- decode.field("type",r4valuesets.subscriptionchanneltype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubscriptionChannel(header:,payload:,endpoint:,type_:,modifier_extension:,extension:,id:,))}
pub fn subscription_to_json(subscription: Subscription) -> Json {
    let Subscription(channel:,error:,criteria:,reason:,end:,contact:,status:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = subscription
    let fields = [#("channel", subscription_channel_to_json(channel)),#("criteria", json.string(criteria)),#("reason", json.string(reason)),#("status", r4valuesets.subscriptionstatus_to_json(status)),]
let fields = case error {
                          Some(v) -> [#("error", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case end {
                          Some(v) -> [#("end", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactpoint_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn subscription_decoder() -> Decoder(Subscription) {use channel <- decode.field("channel",subscription_channel_decoder())
use error <- decode.optional_field("error", None, decode.optional(decode.string))
use criteria <- decode.field("criteria",decode.string)
use reason <- decode.field("reason",decode.string)
use end <- decode.optional_field("end", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactpoint_decoder()))
use status <- decode.field("status",r4valuesets.subscriptionstatus_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Subscription(channel:,error:,criteria:,reason:,end:,contact:,status:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Substance#resource
pub type Substance
{
Substance(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Substancestatus),
category: List(Codeableconcept),
code: Codeableconcept,
description: Option(String),
instance: List(SubstanceInstance),
ingredient: List(SubstanceIngredient),
)
}

pub fn substance_new(code code: Codeableconcept,) ->Substance{Substance(ingredient: [],instance: [],description: None,code:,category: [],status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Substance#resource
pub type SubstanceInstance
{
SubstanceInstance(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
expiry: Option(String),
quantity: Option(Quantity),
)
}

pub fn substance_instance_new() ->SubstanceInstance{SubstanceInstance(quantity: None,expiry: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Substance#resource
pub type SubstanceIngredient
{
SubstanceIngredient(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
quantity: Option(Ratio),
substance: SubstanceIngredientSubstance,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Substance#resource
pub type SubstanceIngredientSubstance{
SubstanceIngredientSubstanceCodeableconcept(substance: Codeableconcept)
SubstanceIngredientSubstanceReference(substance: Reference)}
pub fn substance_ingredient_substance_to_json(elt: SubstanceIngredientSubstance) -> Json {case elt{SubstanceIngredientSubstanceCodeableconcept(v) -> codeableconcept_to_json(v)
SubstanceIngredientSubstanceReference(v) -> reference_to_json(v)
}}
pub fn substance_ingredient_substance_decoder() -> Decoder(SubstanceIngredientSubstance){decode.one_of(decode.field("substanceCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SubstanceIngredientSubstanceCodeableconcept),[decode.field("substanceReference", reference_decoder(), decode.success) |> decode.map(SubstanceIngredientSubstanceReference),])}
pub fn substance_ingredient_new(substance substance: SubstanceIngredientSubstance,) ->SubstanceIngredient{SubstanceIngredient(substance:,quantity: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substance_ingredient_to_json(substance_ingredient: SubstanceIngredient) -> Json {
    let SubstanceIngredient(substance:,quantity:,modifier_extension:,extension:,id:,) = substance_ingredient
    let fields = [#("substance", substance_ingredient_substance_to_json(substance)),]
let fields = case quantity {
                          Some(v) -> [#("quantity", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substance_ingredient_decoder() -> Decoder(SubstanceIngredient) {use substance <- decode.then(substance_ingredient_substance_decoder())
use quantity <- decode.optional_field("quantity", None, decode.optional(ratio_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstanceIngredient(substance:,quantity:,modifier_extension:,extension:,id:,))}
pub fn substance_instance_to_json(substance_instance: SubstanceInstance) -> Json {
    let SubstanceInstance(quantity:,expiry:,identifier:,modifier_extension:,extension:,id:,) = substance_instance
    let fields = []
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case expiry {
                          Some(v) -> [#("expiry", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substance_instance_decoder() -> Decoder(SubstanceInstance) {use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use expiry <- decode.optional_field("expiry", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstanceInstance(quantity:,expiry:,identifier:,modifier_extension:,extension:,id:,))}
pub fn substance_to_json(substance: Substance) -> Json {
    let Substance(ingredient:,instance:,description:,code:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substance
    let fields = [#("code", codeableconcept_to_json(code)),]
let fields = case ingredient {
                        [] -> fields
                        _ -> [#("ingredient", json.array(ingredient,substance_ingredient_to_json)), ..fields]
                          }
let fields = case instance {
                        [] -> fields
                        _ -> [#("instance", json.array(instance,substance_instance_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                        [] -> fields
                        _ -> [#("category", json.array(category,codeableconcept_to_json)), ..fields]
                          }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.substancestatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substance_decoder() -> Decoder(Substance) {use ingredient <- decode.optional_field("ingredient", [], decode.list(substance_ingredient_decoder()))
use instance <- decode.optional_field("instance", [], decode.list(substance_instance_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.field("code",codeableconcept_decoder())
use category <- decode.optional_field("category", [], decode.list(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.substancestatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substance(ingredient:,instance:,description:,code:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceNucleicAcid#resource
pub type Substancenucleicacid
{
Substancenucleicacid(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
sequence_type: Option(Codeableconcept),
number_of_subunits: Option(Int),
area_of_hybridisation: Option(String),
oligo_nucleotide_type: Option(Codeableconcept),
subunit: List(SubstancenucleicacidSubunit),
)
}

pub fn substancenucleicacid_new() ->Substancenucleicacid{Substancenucleicacid(subunit: [],oligo_nucleotide_type: None,area_of_hybridisation: None,number_of_subunits: None,sequence_type: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunit
{
SubstancenucleicacidSubunit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
subunit: Option(Int),
sequence: Option(String),
length: Option(Int),
sequence_attachment: Option(Attachment),
five_prime: Option(Codeableconcept),
three_prime: Option(Codeableconcept),
linkage: List(SubstancenucleicacidSubunitLinkage),
sugar: List(SubstancenucleicacidSubunitSugar),
)
}

pub fn substancenucleicacid_subunit_new() ->SubstancenucleicacidSubunit{SubstancenucleicacidSubunit(sugar: [],linkage: [],three_prime: None,five_prime: None,sequence_attachment: None,length: None,sequence: None,subunit: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunitLinkage
{
SubstancenucleicacidSubunitLinkage(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
connectivity: Option(String),
identifier: Option(Identifier),
name: Option(String),
residue_site: Option(String),
)
}

pub fn substancenucleicacid_subunit_linkage_new() ->SubstancenucleicacidSubunitLinkage{SubstancenucleicacidSubunitLinkage(residue_site: None,name: None,identifier: None,connectivity: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunitSugar
{
SubstancenucleicacidSubunitSugar(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
name: Option(String),
residue_site: Option(String),
)
}

pub fn substancenucleicacid_subunit_sugar_new() ->SubstancenucleicacidSubunitSugar{SubstancenucleicacidSubunitSugar(residue_site: None,name: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substancenucleicacid_subunit_sugar_to_json(substancenucleicacid_subunit_sugar: SubstancenucleicacidSubunitSugar) -> Json {
    let SubstancenucleicacidSubunitSugar(residue_site:,name:,identifier:,modifier_extension:,extension:,id:,) = substancenucleicacid_subunit_sugar
    let fields = []
let fields = case residue_site {
                          Some(v) -> [#("residueSite", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancenucleicacid_subunit_sugar_decoder() -> Decoder(SubstancenucleicacidSubunitSugar) {use residue_site <- decode.optional_field("residueSite", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancenucleicacidSubunitSugar(residue_site:,name:,identifier:,modifier_extension:,extension:,id:,))}
pub fn substancenucleicacid_subunit_linkage_to_json(substancenucleicacid_subunit_linkage: SubstancenucleicacidSubunitLinkage) -> Json {
    let SubstancenucleicacidSubunitLinkage(residue_site:,name:,identifier:,connectivity:,modifier_extension:,extension:,id:,) = substancenucleicacid_subunit_linkage
    let fields = []
let fields = case residue_site {
                          Some(v) -> [#("residueSite", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case connectivity {
                          Some(v) -> [#("connectivity", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancenucleicacid_subunit_linkage_decoder() -> Decoder(SubstancenucleicacidSubunitLinkage) {use residue_site <- decode.optional_field("residueSite", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use connectivity <- decode.optional_field("connectivity", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancenucleicacidSubunitLinkage(residue_site:,name:,identifier:,connectivity:,modifier_extension:,extension:,id:,))}
pub fn substancenucleicacid_subunit_to_json(substancenucleicacid_subunit: SubstancenucleicacidSubunit) -> Json {
    let SubstancenucleicacidSubunit(sugar:,linkage:,three_prime:,five_prime:,sequence_attachment:,length:,sequence:,subunit:,modifier_extension:,extension:,id:,) = substancenucleicacid_subunit
    let fields = []
let fields = case sugar {
                        [] -> fields
                        _ -> [#("sugar", json.array(sugar,substancenucleicacid_subunit_sugar_to_json)), ..fields]
                          }
let fields = case linkage {
                        [] -> fields
                        _ -> [#("linkage", json.array(linkage,substancenucleicacid_subunit_linkage_to_json)), ..fields]
                          }
let fields = case three_prime {
                          Some(v) -> [#("threePrime", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case five_prime {
                          Some(v) -> [#("fivePrime", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence_attachment {
                          Some(v) -> [#("sequenceAttachment", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case length {
                          Some(v) -> [#("length", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence {
                          Some(v) -> [#("sequence", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subunit {
                          Some(v) -> [#("subunit", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancenucleicacid_subunit_decoder() -> Decoder(SubstancenucleicacidSubunit) {use sugar <- decode.optional_field("sugar", [], decode.list(substancenucleicacid_subunit_sugar_decoder()))
use linkage <- decode.optional_field("linkage", [], decode.list(substancenucleicacid_subunit_linkage_decoder()))
use three_prime <- decode.optional_field("threePrime", None, decode.optional(codeableconcept_decoder()))
use five_prime <- decode.optional_field("fivePrime", None, decode.optional(codeableconcept_decoder()))
use sequence_attachment <- decode.optional_field("sequenceAttachment", None, decode.optional(attachment_decoder()))
use length <- decode.optional_field("length", None, decode.optional(decode.int))
use sequence <- decode.optional_field("sequence", None, decode.optional(decode.string))
use subunit <- decode.optional_field("subunit", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancenucleicacidSubunit(sugar:,linkage:,three_prime:,five_prime:,sequence_attachment:,length:,sequence:,subunit:,modifier_extension:,extension:,id:,))}
pub fn substancenucleicacid_to_json(substancenucleicacid: Substancenucleicacid) -> Json {
    let Substancenucleicacid(subunit:,oligo_nucleotide_type:,area_of_hybridisation:,number_of_subunits:,sequence_type:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substancenucleicacid
    let fields = []
let fields = case subunit {
                        [] -> fields
                        _ -> [#("subunit", json.array(subunit,substancenucleicacid_subunit_to_json)), ..fields]
                          }
let fields = case oligo_nucleotide_type {
                          Some(v) -> [#("oligoNucleotideType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case area_of_hybridisation {
                          Some(v) -> [#("areaOfHybridisation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_subunits {
                          Some(v) -> [#("numberOfSubunits", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence_type {
                          Some(v) -> [#("sequenceType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancenucleicacid_decoder() -> Decoder(Substancenucleicacid) {use subunit <- decode.optional_field("subunit", [], decode.list(substancenucleicacid_subunit_decoder()))
use oligo_nucleotide_type <- decode.optional_field("oligoNucleotideType", None, decode.optional(codeableconcept_decoder()))
use area_of_hybridisation <- decode.optional_field("areaOfHybridisation", None, decode.optional(decode.string))
use number_of_subunits <- decode.optional_field("numberOfSubunits", None, decode.optional(decode.int))
use sequence_type <- decode.optional_field("sequenceType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substancenucleicacid(subunit:,oligo_nucleotide_type:,area_of_hybridisation:,number_of_subunits:,sequence_type:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type Substancepolymer
{
Substancepolymer(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
class: Option(Codeableconcept),
geometry: Option(Codeableconcept),
copolymer_connectivity: List(Codeableconcept),
modification: List(String),
monomer_set: List(SubstancepolymerMonomerset),
repeat: List(SubstancepolymerRepeat),
)
}

pub fn substancepolymer_new() ->Substancepolymer{Substancepolymer(repeat: [],monomer_set: [],modification: [],copolymer_connectivity: [],geometry: None,class: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerMonomerset
{
SubstancepolymerMonomerset(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
ratio_type: Option(Codeableconcept),
starting_material: List(SubstancepolymerMonomersetStartingmaterial),
)
}

pub fn substancepolymer_monomerset_new() ->SubstancepolymerMonomerset{SubstancepolymerMonomerset(starting_material: [],ratio_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerMonomersetStartingmaterial
{
SubstancepolymerMonomersetStartingmaterial(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
material: Option(Codeableconcept),
type_: Option(Codeableconcept),
is_defining: Option(Bool),
amount: Option(Substanceamount),
)
}

pub fn substancepolymer_monomerset_startingmaterial_new() ->SubstancepolymerMonomersetStartingmaterial{SubstancepolymerMonomersetStartingmaterial(amount: None,is_defining: None,type_: None,material: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeat
{
SubstancepolymerRepeat(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
number_of_units: Option(Int),
average_molecular_formula: Option(String),
repeat_unit_amount_type: Option(Codeableconcept),
repeat_unit: List(SubstancepolymerRepeatRepeatunit),
)
}

pub fn substancepolymer_repeat_new() ->SubstancepolymerRepeat{SubstancepolymerRepeat(repeat_unit: [],repeat_unit_amount_type: None,average_molecular_formula: None,number_of_units: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunit
{
SubstancepolymerRepeatRepeatunit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
orientation_of_polymerisation: Option(Codeableconcept),
repeat_unit: Option(String),
amount: Option(Substanceamount),
degree_of_polymerisation: List(SubstancepolymerRepeatRepeatunitDegreeofpolymerisation),
structural_representation: List(SubstancepolymerRepeatRepeatunitStructuralrepresentation),
)
}

pub fn substancepolymer_repeat_repeatunit_new() ->SubstancepolymerRepeatRepeatunit{SubstancepolymerRepeatRepeatunit(structural_representation: [],degree_of_polymerisation: [],amount: None,repeat_unit: None,orientation_of_polymerisation: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunitDegreeofpolymerisation
{
SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
degree: Option(Codeableconcept),
amount: Option(Substanceamount),
)
}

pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_new() ->SubstancepolymerRepeatRepeatunitDegreeofpolymerisation{SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(amount: None,degree: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunitStructuralrepresentation
{
SubstancepolymerRepeatRepeatunitStructuralrepresentation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
representation: Option(String),
attachment: Option(Attachment),
)
}

pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_new() ->SubstancepolymerRepeatRepeatunitStructuralrepresentation{SubstancepolymerRepeatRepeatunitStructuralrepresentation(attachment: None,representation: None,type_: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_to_json(substancepolymer_repeat_repeatunit_structuralrepresentation: SubstancepolymerRepeatRepeatunitStructuralrepresentation) -> Json {
    let SubstancepolymerRepeatRepeatunitStructuralrepresentation(attachment:,representation:,type_:,modifier_extension:,extension:,id:,) = substancepolymer_repeat_repeatunit_structuralrepresentation
    let fields = []
let fields = case attachment {
                          Some(v) -> [#("attachment", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case representation {
                          Some(v) -> [#("representation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_decoder() -> Decoder(SubstancepolymerRepeatRepeatunitStructuralrepresentation) {use attachment <- decode.optional_field("attachment", None, decode.optional(attachment_decoder()))
use representation <- decode.optional_field("representation", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerRepeatRepeatunitStructuralrepresentation(attachment:,representation:,type_:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_to_json(substancepolymer_repeat_repeatunit_degreeofpolymerisation: SubstancepolymerRepeatRepeatunitDegreeofpolymerisation) -> Json {
    let SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(amount:,degree:,modifier_extension:,extension:,id:,) = substancepolymer_repeat_repeatunit_degreeofpolymerisation
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", substanceamount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case degree {
                          Some(v) -> [#("degree", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_decoder() -> Decoder(SubstancepolymerRepeatRepeatunitDegreeofpolymerisation) {use amount <- decode.optional_field("amount", None, decode.optional(substanceamount_decoder()))
use degree <- decode.optional_field("degree", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(amount:,degree:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_repeat_repeatunit_to_json(substancepolymer_repeat_repeatunit: SubstancepolymerRepeatRepeatunit) -> Json {
    let SubstancepolymerRepeatRepeatunit(structural_representation:,degree_of_polymerisation:,amount:,repeat_unit:,orientation_of_polymerisation:,modifier_extension:,extension:,id:,) = substancepolymer_repeat_repeatunit
    let fields = []
let fields = case structural_representation {
                        [] -> fields
                        _ -> [#("structuralRepresentation", json.array(structural_representation,substancepolymer_repeat_repeatunit_structuralrepresentation_to_json)), ..fields]
                          }
let fields = case degree_of_polymerisation {
                        [] -> fields
                        _ -> [#("degreeOfPolymerisation", json.array(degree_of_polymerisation,substancepolymer_repeat_repeatunit_degreeofpolymerisation_to_json)), ..fields]
                          }
let fields = case amount {
                          Some(v) -> [#("amount", substanceamount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case repeat_unit {
                          Some(v) -> [#("repeatUnit", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case orientation_of_polymerisation {
                          Some(v) -> [#("orientationOfPolymerisation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_repeat_repeatunit_decoder() -> Decoder(SubstancepolymerRepeatRepeatunit) {use structural_representation <- decode.optional_field("structuralRepresentation", [], decode.list(substancepolymer_repeat_repeatunit_structuralrepresentation_decoder()))
use degree_of_polymerisation <- decode.optional_field("degreeOfPolymerisation", [], decode.list(substancepolymer_repeat_repeatunit_degreeofpolymerisation_decoder()))
use amount <- decode.optional_field("amount", None, decode.optional(substanceamount_decoder()))
use repeat_unit <- decode.optional_field("repeatUnit", None, decode.optional(decode.string))
use orientation_of_polymerisation <- decode.optional_field("orientationOfPolymerisation", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerRepeatRepeatunit(structural_representation:,degree_of_polymerisation:,amount:,repeat_unit:,orientation_of_polymerisation:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_repeat_to_json(substancepolymer_repeat: SubstancepolymerRepeat) -> Json {
    let SubstancepolymerRepeat(repeat_unit:,repeat_unit_amount_type:,average_molecular_formula:,number_of_units:,modifier_extension:,extension:,id:,) = substancepolymer_repeat
    let fields = []
let fields = case repeat_unit {
                        [] -> fields
                        _ -> [#("repeatUnit", json.array(repeat_unit,substancepolymer_repeat_repeatunit_to_json)), ..fields]
                          }
let fields = case repeat_unit_amount_type {
                          Some(v) -> [#("repeatUnitAmountType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case average_molecular_formula {
                          Some(v) -> [#("averageMolecularFormula", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case number_of_units {
                          Some(v) -> [#("numberOfUnits", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_repeat_decoder() -> Decoder(SubstancepolymerRepeat) {use repeat_unit <- decode.optional_field("repeatUnit", [], decode.list(substancepolymer_repeat_repeatunit_decoder()))
use repeat_unit_amount_type <- decode.optional_field("repeatUnitAmountType", None, decode.optional(codeableconcept_decoder()))
use average_molecular_formula <- decode.optional_field("averageMolecularFormula", None, decode.optional(decode.string))
use number_of_units <- decode.optional_field("numberOfUnits", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerRepeat(repeat_unit:,repeat_unit_amount_type:,average_molecular_formula:,number_of_units:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_monomerset_startingmaterial_to_json(substancepolymer_monomerset_startingmaterial: SubstancepolymerMonomersetStartingmaterial) -> Json {
    let SubstancepolymerMonomersetStartingmaterial(amount:,is_defining:,type_:,material:,modifier_extension:,extension:,id:,) = substancepolymer_monomerset_startingmaterial
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", substanceamount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_defining {
                          Some(v) -> [#("isDefining", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case material {
                          Some(v) -> [#("material", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_monomerset_startingmaterial_decoder() -> Decoder(SubstancepolymerMonomersetStartingmaterial) {use amount <- decode.optional_field("amount", None, decode.optional(substanceamount_decoder()))
use is_defining <- decode.optional_field("isDefining", None, decode.optional(decode.bool))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use material <- decode.optional_field("material", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerMonomersetStartingmaterial(amount:,is_defining:,type_:,material:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_monomerset_to_json(substancepolymer_monomerset: SubstancepolymerMonomerset) -> Json {
    let SubstancepolymerMonomerset(starting_material:,ratio_type:,modifier_extension:,extension:,id:,) = substancepolymer_monomerset
    let fields = []
let fields = case starting_material {
                        [] -> fields
                        _ -> [#("startingMaterial", json.array(starting_material,substancepolymer_monomerset_startingmaterial_to_json)), ..fields]
                          }
let fields = case ratio_type {
                          Some(v) -> [#("ratioType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_monomerset_decoder() -> Decoder(SubstancepolymerMonomerset) {use starting_material <- decode.optional_field("startingMaterial", [], decode.list(substancepolymer_monomerset_startingmaterial_decoder()))
use ratio_type <- decode.optional_field("ratioType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancepolymerMonomerset(starting_material:,ratio_type:,modifier_extension:,extension:,id:,))}
pub fn substancepolymer_to_json(substancepolymer: Substancepolymer) -> Json {
    let Substancepolymer(repeat:,monomer_set:,modification:,copolymer_connectivity:,geometry:,class:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substancepolymer
    let fields = []
let fields = case repeat {
                        [] -> fields
                        _ -> [#("repeat", json.array(repeat,substancepolymer_repeat_to_json)), ..fields]
                          }
let fields = case monomer_set {
                        [] -> fields
                        _ -> [#("monomerSet", json.array(monomer_set,substancepolymer_monomerset_to_json)), ..fields]
                          }
let fields = case modification {
                        [] -> fields
                        _ -> [#("modification", json.array(modification,json.string)), ..fields]
                          }
let fields = case copolymer_connectivity {
                        [] -> fields
                        _ -> [#("copolymerConnectivity", json.array(copolymer_connectivity,codeableconcept_to_json)), ..fields]
                          }
let fields = case geometry {
                          Some(v) -> [#("geometry", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case class {
                          Some(v) -> [#("class", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancepolymer_decoder() -> Decoder(Substancepolymer) {use repeat <- decode.optional_field("repeat", [], decode.list(substancepolymer_repeat_decoder()))
use monomer_set <- decode.optional_field("monomerSet", [], decode.list(substancepolymer_monomerset_decoder()))
use modification <- decode.optional_field("modification", [], decode.list(decode.string))
use copolymer_connectivity <- decode.optional_field("copolymerConnectivity", [], decode.list(codeableconcept_decoder()))
use geometry <- decode.optional_field("geometry", None, decode.optional(codeableconcept_decoder()))
use class <- decode.optional_field("class", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substancepolymer(repeat:,monomer_set:,modification:,copolymer_connectivity:,geometry:,class:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceProtein#resource
pub type Substanceprotein
{
Substanceprotein(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
sequence_type: Option(Codeableconcept),
number_of_subunits: Option(Int),
disulfide_linkage: List(String),
subunit: List(SubstanceproteinSubunit),
)
}

pub fn substanceprotein_new() ->Substanceprotein{Substanceprotein(subunit: [],disulfide_linkage: [],number_of_subunits: None,sequence_type: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceProtein#resource
pub type SubstanceproteinSubunit
{
SubstanceproteinSubunit(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
subunit: Option(Int),
sequence: Option(String),
length: Option(Int),
sequence_attachment: Option(Attachment),
n_terminal_modification_id: Option(Identifier),
n_terminal_modification: Option(String),
c_terminal_modification_id: Option(Identifier),
c_terminal_modification: Option(String),
)
}

pub fn substanceprotein_subunit_new() ->SubstanceproteinSubunit{SubstanceproteinSubunit(c_terminal_modification: None,c_terminal_modification_id: None,n_terminal_modification: None,n_terminal_modification_id: None,sequence_attachment: None,length: None,sequence: None,subunit: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substanceprotein_subunit_to_json(substanceprotein_subunit: SubstanceproteinSubunit) -> Json {
    let SubstanceproteinSubunit(c_terminal_modification:,c_terminal_modification_id:,n_terminal_modification:,n_terminal_modification_id:,sequence_attachment:,length:,sequence:,subunit:,modifier_extension:,extension:,id:,) = substanceprotein_subunit
    let fields = []
let fields = case c_terminal_modification {
                          Some(v) -> [#("cTerminalModification", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case c_terminal_modification_id {
                          Some(v) -> [#("cTerminalModificationId", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case n_terminal_modification {
                          Some(v) -> [#("nTerminalModification", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case n_terminal_modification_id {
                          Some(v) -> [#("nTerminalModificationId", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence_attachment {
                          Some(v) -> [#("sequenceAttachment", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case length {
                          Some(v) -> [#("length", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence {
                          Some(v) -> [#("sequence", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case subunit {
                          Some(v) -> [#("subunit", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substanceprotein_subunit_decoder() -> Decoder(SubstanceproteinSubunit) {use c_terminal_modification <- decode.optional_field("cTerminalModification", None, decode.optional(decode.string))
use c_terminal_modification_id <- decode.optional_field("cTerminalModificationId", None, decode.optional(identifier_decoder()))
use n_terminal_modification <- decode.optional_field("nTerminalModification", None, decode.optional(decode.string))
use n_terminal_modification_id <- decode.optional_field("nTerminalModificationId", None, decode.optional(identifier_decoder()))
use sequence_attachment <- decode.optional_field("sequenceAttachment", None, decode.optional(attachment_decoder()))
use length <- decode.optional_field("length", None, decode.optional(decode.int))
use sequence <- decode.optional_field("sequence", None, decode.optional(decode.string))
use subunit <- decode.optional_field("subunit", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstanceproteinSubunit(c_terminal_modification:,c_terminal_modification_id:,n_terminal_modification:,n_terminal_modification_id:,sequence_attachment:,length:,sequence:,subunit:,modifier_extension:,extension:,id:,))}
pub fn substanceprotein_to_json(substanceprotein: Substanceprotein) -> Json {
    let Substanceprotein(subunit:,disulfide_linkage:,number_of_subunits:,sequence_type:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substanceprotein
    let fields = []
let fields = case subunit {
                        [] -> fields
                        _ -> [#("subunit", json.array(subunit,substanceprotein_subunit_to_json)), ..fields]
                          }
let fields = case disulfide_linkage {
                        [] -> fields
                        _ -> [#("disulfideLinkage", json.array(disulfide_linkage,json.string)), ..fields]
                          }
let fields = case number_of_subunits {
                          Some(v) -> [#("numberOfSubunits", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case sequence_type {
                          Some(v) -> [#("sequenceType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substanceprotein_decoder() -> Decoder(Substanceprotein) {use subunit <- decode.optional_field("subunit", [], decode.list(substanceprotein_subunit_decoder()))
use disulfide_linkage <- decode.optional_field("disulfideLinkage", [], decode.list(decode.string))
use number_of_subunits <- decode.optional_field("numberOfSubunits", None, decode.optional(decode.int))
use sequence_type <- decode.optional_field("sequenceType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substanceprotein(subunit:,disulfide_linkage:,number_of_subunits:,sequence_type:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type Substancereferenceinformation
{
Substancereferenceinformation(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
comment: Option(String),
gene: List(SubstancereferenceinformationGene),
gene_element: List(SubstancereferenceinformationGeneelement),
classification: List(SubstancereferenceinformationClassification),
target: List(SubstancereferenceinformationTarget),
)
}

pub fn substancereferenceinformation_new() ->Substancereferenceinformation{Substancereferenceinformation(target: [],classification: [],gene_element: [],gene: [],comment: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationGene
{
SubstancereferenceinformationGene(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
gene_sequence_origin: Option(Codeableconcept),
gene: Option(Codeableconcept),
source: List(Reference),
)
}

pub fn substancereferenceinformation_gene_new() ->SubstancereferenceinformationGene{SubstancereferenceinformationGene(source: [],gene: None,gene_sequence_origin: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationGeneelement
{
SubstancereferenceinformationGeneelement(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
element: Option(Identifier),
source: List(Reference),
)
}

pub fn substancereferenceinformation_geneelement_new() ->SubstancereferenceinformationGeneelement{SubstancereferenceinformationGeneelement(source: [],element: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationClassification
{
SubstancereferenceinformationClassification(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
domain: Option(Codeableconcept),
classification: Option(Codeableconcept),
subtype: List(Codeableconcept),
source: List(Reference),
)
}

pub fn substancereferenceinformation_classification_new() ->SubstancereferenceinformationClassification{SubstancereferenceinformationClassification(source: [],subtype: [],classification: None,domain: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationTarget
{
SubstancereferenceinformationTarget(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
target: Option(Identifier),
type_: Option(Codeableconcept),
interaction: Option(Codeableconcept),
organism: Option(Codeableconcept),
organism_type: Option(Codeableconcept),
amount: Option(SubstancereferenceinformationTargetAmount),
amount_type: Option(Codeableconcept),
source: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationTargetAmount{
SubstancereferenceinformationTargetAmountQuantity(amount: Quantity)
SubstancereferenceinformationTargetAmountRange(amount: Range)
SubstancereferenceinformationTargetAmountString(amount: String)}
pub fn substancereferenceinformation_target_amount_to_json(elt: SubstancereferenceinformationTargetAmount) -> Json {case elt{SubstancereferenceinformationTargetAmountQuantity(v) -> quantity_to_json(v)
SubstancereferenceinformationTargetAmountRange(v) -> range_to_json(v)
SubstancereferenceinformationTargetAmountString(v) -> json.string(v)
}}
pub fn substancereferenceinformation_target_amount_decoder() -> Decoder(SubstancereferenceinformationTargetAmount){decode.one_of(decode.field("amountQuantity", quantity_decoder(), decode.success) |> decode.map(SubstancereferenceinformationTargetAmountQuantity),[decode.field("amountRange", range_decoder(), decode.success) |> decode.map(SubstancereferenceinformationTargetAmountRange),decode.field("amountString", decode.string, decode.success) |> decode.map(SubstancereferenceinformationTargetAmountString),])}
pub fn substancereferenceinformation_target_new() ->SubstancereferenceinformationTarget{SubstancereferenceinformationTarget(source: [],amount_type: None,amount: None,organism_type: None,organism: None,interaction: None,type_: None,target: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substancereferenceinformation_target_to_json(substancereferenceinformation_target: SubstancereferenceinformationTarget) -> Json {
    let SubstancereferenceinformationTarget(source:,amount_type:,amount:,organism_type:,organism:,interaction:,type_:,target:,modifier_extension:,extension:,id:,) = substancereferenceinformation_target
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case amount_type {
                          Some(v) -> [#("amountType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", substancereferenceinformation_target_amount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organism_type {
                          Some(v) -> [#("organismType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case organism {
                          Some(v) -> [#("organism", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case interaction {
                          Some(v) -> [#("interaction", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target {
                          Some(v) -> [#("target", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancereferenceinformation_target_decoder() -> Decoder(SubstancereferenceinformationTarget) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use amount_type <- decode.optional_field("amountType", None, decode.optional(codeableconcept_decoder()))
use amount <- decode.then(none_if_omitted(substancereferenceinformation_target_amount_decoder()))
use organism_type <- decode.optional_field("organismType", None, decode.optional(codeableconcept_decoder()))
use organism <- decode.optional_field("organism", None, decode.optional(codeableconcept_decoder()))
use interaction <- decode.optional_field("interaction", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use target <- decode.optional_field("target", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancereferenceinformationTarget(source:,amount_type:,amount:,organism_type:,organism:,interaction:,type_:,target:,modifier_extension:,extension:,id:,))}
pub fn substancereferenceinformation_classification_to_json(substancereferenceinformation_classification: SubstancereferenceinformationClassification) -> Json {
    let SubstancereferenceinformationClassification(source:,subtype:,classification:,domain:,modifier_extension:,extension:,id:,) = substancereferenceinformation_classification
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case subtype {
                        [] -> fields
                        _ -> [#("subtype", json.array(subtype,codeableconcept_to_json)), ..fields]
                          }
let fields = case classification {
                          Some(v) -> [#("classification", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case domain {
                          Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancereferenceinformation_classification_decoder() -> Decoder(SubstancereferenceinformationClassification) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use subtype <- decode.optional_field("subtype", [], decode.list(codeableconcept_decoder()))
use classification <- decode.optional_field("classification", None, decode.optional(codeableconcept_decoder()))
use domain <- decode.optional_field("domain", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancereferenceinformationClassification(source:,subtype:,classification:,domain:,modifier_extension:,extension:,id:,))}
pub fn substancereferenceinformation_geneelement_to_json(substancereferenceinformation_geneelement: SubstancereferenceinformationGeneelement) -> Json {
    let SubstancereferenceinformationGeneelement(source:,element:,type_:,modifier_extension:,extension:,id:,) = substancereferenceinformation_geneelement
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case element {
                          Some(v) -> [#("element", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancereferenceinformation_geneelement_decoder() -> Decoder(SubstancereferenceinformationGeneelement) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use element <- decode.optional_field("element", None, decode.optional(identifier_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancereferenceinformationGeneelement(source:,element:,type_:,modifier_extension:,extension:,id:,))}
pub fn substancereferenceinformation_gene_to_json(substancereferenceinformation_gene: SubstancereferenceinformationGene) -> Json {
    let SubstancereferenceinformationGene(source:,gene:,gene_sequence_origin:,modifier_extension:,extension:,id:,) = substancereferenceinformation_gene
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case gene {
                          Some(v) -> [#("gene", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case gene_sequence_origin {
                          Some(v) -> [#("geneSequenceOrigin", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancereferenceinformation_gene_decoder() -> Decoder(SubstancereferenceinformationGene) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use gene <- decode.optional_field("gene", None, decode.optional(codeableconcept_decoder()))
use gene_sequence_origin <- decode.optional_field("geneSequenceOrigin", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancereferenceinformationGene(source:,gene:,gene_sequence_origin:,modifier_extension:,extension:,id:,))}
pub fn substancereferenceinformation_to_json(substancereferenceinformation: Substancereferenceinformation) -> Json {
    let Substancereferenceinformation(target:,classification:,gene_element:,gene:,comment:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substancereferenceinformation
    let fields = []
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,substancereferenceinformation_target_to_json)), ..fields]
                          }
let fields = case classification {
                        [] -> fields
                        _ -> [#("classification", json.array(classification,substancereferenceinformation_classification_to_json)), ..fields]
                          }
let fields = case gene_element {
                        [] -> fields
                        _ -> [#("geneElement", json.array(gene_element,substancereferenceinformation_geneelement_to_json)), ..fields]
                          }
let fields = case gene {
                        [] -> fields
                        _ -> [#("gene", json.array(gene,substancereferenceinformation_gene_to_json)), ..fields]
                          }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancereferenceinformation_decoder() -> Decoder(Substancereferenceinformation) {use target <- decode.optional_field("target", [], decode.list(substancereferenceinformation_target_decoder()))
use classification <- decode.optional_field("classification", [], decode.list(substancereferenceinformation_classification_decoder()))
use gene_element <- decode.optional_field("geneElement", [], decode.list(substancereferenceinformation_geneelement_decoder()))
use gene <- decode.optional_field("gene", [], decode.list(substancereferenceinformation_gene_decoder()))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substancereferenceinformation(target:,classification:,gene_element:,gene:,comment:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type Substancesourcematerial
{
Substancesourcematerial(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
source_material_class: Option(Codeableconcept),
source_material_type: Option(Codeableconcept),
source_material_state: Option(Codeableconcept),
organism_id: Option(Identifier),
organism_name: Option(String),
parent_substance_id: List(Identifier),
parent_substance_name: List(String),
country_of_origin: List(Codeableconcept),
geographical_location: List(String),
development_stage: Option(Codeableconcept),
fraction_description: List(SubstancesourcematerialFractiondescription),
organism: Option(SubstancesourcematerialOrganism),
part_description: List(SubstancesourcematerialPartdescription),
)
}

pub fn substancesourcematerial_new() ->Substancesourcematerial{Substancesourcematerial(part_description: [],organism: None,fraction_description: [],development_stage: None,geographical_location: [],country_of_origin: [],parent_substance_name: [],parent_substance_id: [],organism_name: None,organism_id: None,source_material_state: None,source_material_type: None,source_material_class: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialFractiondescription
{
SubstancesourcematerialFractiondescription(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
fraction: Option(String),
material_type: Option(Codeableconcept),
)
}

pub fn substancesourcematerial_fractiondescription_new() ->SubstancesourcematerialFractiondescription{SubstancesourcematerialFractiondescription(material_type: None,fraction: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganism
{
SubstancesourcematerialOrganism(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
family: Option(Codeableconcept),
genus: Option(Codeableconcept),
species: Option(Codeableconcept),
intraspecific_type: Option(Codeableconcept),
intraspecific_description: Option(String),
author: List(SubstancesourcematerialOrganismAuthor),
hybrid: Option(SubstancesourcematerialOrganismHybrid),
organism_general: Option(SubstancesourcematerialOrganismOrganismgeneral),
)
}

pub fn substancesourcematerial_organism_new() ->SubstancesourcematerialOrganism{SubstancesourcematerialOrganism(organism_general: None,hybrid: None,author: [],intraspecific_description: None,intraspecific_type: None,species: None,genus: None,family: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismAuthor
{
SubstancesourcematerialOrganismAuthor(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
author_type: Option(Codeableconcept),
author_description: Option(String),
)
}

pub fn substancesourcematerial_organism_author_new() ->SubstancesourcematerialOrganismAuthor{SubstancesourcematerialOrganismAuthor(author_description: None,author_type: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismHybrid
{
SubstancesourcematerialOrganismHybrid(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
maternal_organism_id: Option(String),
maternal_organism_name: Option(String),
paternal_organism_id: Option(String),
paternal_organism_name: Option(String),
hybrid_type: Option(Codeableconcept),
)
}

pub fn substancesourcematerial_organism_hybrid_new() ->SubstancesourcematerialOrganismHybrid{SubstancesourcematerialOrganismHybrid(hybrid_type: None,paternal_organism_name: None,paternal_organism_id: None,maternal_organism_name: None,maternal_organism_id: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismOrganismgeneral
{
SubstancesourcematerialOrganismOrganismgeneral(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
kingdom: Option(Codeableconcept),
phylum: Option(Codeableconcept),
class: Option(Codeableconcept),
order: Option(Codeableconcept),
)
}

pub fn substancesourcematerial_organism_organismgeneral_new() ->SubstancesourcematerialOrganismOrganismgeneral{SubstancesourcematerialOrganismOrganismgeneral(order: None,class: None,phylum: None,kingdom: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialPartdescription
{
SubstancesourcematerialPartdescription(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
part: Option(Codeableconcept),
part_location: Option(Codeableconcept),
)
}

pub fn substancesourcematerial_partdescription_new() ->SubstancesourcematerialPartdescription{SubstancesourcematerialPartdescription(part_location: None,part: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substancesourcematerial_partdescription_to_json(substancesourcematerial_partdescription: SubstancesourcematerialPartdescription) -> Json {
    let SubstancesourcematerialPartdescription(part_location:,part:,modifier_extension:,extension:,id:,) = substancesourcematerial_partdescription
    let fields = []
let fields = case part_location {
                          Some(v) -> [#("partLocation", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part {
                          Some(v) -> [#("part", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_partdescription_decoder() -> Decoder(SubstancesourcematerialPartdescription) {use part_location <- decode.optional_field("partLocation", None, decode.optional(codeableconcept_decoder()))
use part <- decode.optional_field("part", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialPartdescription(part_location:,part:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_organism_organismgeneral_to_json(substancesourcematerial_organism_organismgeneral: SubstancesourcematerialOrganismOrganismgeneral) -> Json {
    let SubstancesourcematerialOrganismOrganismgeneral(order:,class:,phylum:,kingdom:,modifier_extension:,extension:,id:,) = substancesourcematerial_organism_organismgeneral
    let fields = []
let fields = case order {
                          Some(v) -> [#("order", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case class {
                          Some(v) -> [#("class", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case phylum {
                          Some(v) -> [#("phylum", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case kingdom {
                          Some(v) -> [#("kingdom", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_organism_organismgeneral_decoder() -> Decoder(SubstancesourcematerialOrganismOrganismgeneral) {use order <- decode.optional_field("order", None, decode.optional(codeableconcept_decoder()))
use class <- decode.optional_field("class", None, decode.optional(codeableconcept_decoder()))
use phylum <- decode.optional_field("phylum", None, decode.optional(codeableconcept_decoder()))
use kingdom <- decode.optional_field("kingdom", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialOrganismOrganismgeneral(order:,class:,phylum:,kingdom:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_organism_hybrid_to_json(substancesourcematerial_organism_hybrid: SubstancesourcematerialOrganismHybrid) -> Json {
    let SubstancesourcematerialOrganismHybrid(hybrid_type:,paternal_organism_name:,paternal_organism_id:,maternal_organism_name:,maternal_organism_id:,modifier_extension:,extension:,id:,) = substancesourcematerial_organism_hybrid
    let fields = []
let fields = case hybrid_type {
                          Some(v) -> [#("hybridType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case paternal_organism_name {
                          Some(v) -> [#("paternalOrganismName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case paternal_organism_id {
                          Some(v) -> [#("paternalOrganismId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case maternal_organism_name {
                          Some(v) -> [#("maternalOrganismName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case maternal_organism_id {
                          Some(v) -> [#("maternalOrganismId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_organism_hybrid_decoder() -> Decoder(SubstancesourcematerialOrganismHybrid) {use hybrid_type <- decode.optional_field("hybridType", None, decode.optional(codeableconcept_decoder()))
use paternal_organism_name <- decode.optional_field("paternalOrganismName", None, decode.optional(decode.string))
use paternal_organism_id <- decode.optional_field("paternalOrganismId", None, decode.optional(decode.string))
use maternal_organism_name <- decode.optional_field("maternalOrganismName", None, decode.optional(decode.string))
use maternal_organism_id <- decode.optional_field("maternalOrganismId", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialOrganismHybrid(hybrid_type:,paternal_organism_name:,paternal_organism_id:,maternal_organism_name:,maternal_organism_id:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_organism_author_to_json(substancesourcematerial_organism_author: SubstancesourcematerialOrganismAuthor) -> Json {
    let SubstancesourcematerialOrganismAuthor(author_description:,author_type:,modifier_extension:,extension:,id:,) = substancesourcematerial_organism_author
    let fields = []
let fields = case author_description {
                          Some(v) -> [#("authorDescription", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case author_type {
                          Some(v) -> [#("authorType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_organism_author_decoder() -> Decoder(SubstancesourcematerialOrganismAuthor) {use author_description <- decode.optional_field("authorDescription", None, decode.optional(decode.string))
use author_type <- decode.optional_field("authorType", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialOrganismAuthor(author_description:,author_type:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_organism_to_json(substancesourcematerial_organism: SubstancesourcematerialOrganism) -> Json {
    let SubstancesourcematerialOrganism(organism_general:,hybrid:,author:,intraspecific_description:,intraspecific_type:,species:,genus:,family:,modifier_extension:,extension:,id:,) = substancesourcematerial_organism
    let fields = []
let fields = case organism_general {
                          Some(v) -> [#("organismGeneral", substancesourcematerial_organism_organismgeneral_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case hybrid {
                          Some(v) -> [#("hybrid", substancesourcematerial_organism_hybrid_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case author {
                        [] -> fields
                        _ -> [#("author", json.array(author,substancesourcematerial_organism_author_to_json)), ..fields]
                          }
let fields = case intraspecific_description {
                          Some(v) -> [#("intraspecificDescription", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case intraspecific_type {
                          Some(v) -> [#("intraspecificType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case species {
                          Some(v) -> [#("species", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case genus {
                          Some(v) -> [#("genus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case family {
                          Some(v) -> [#("family", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_organism_decoder() -> Decoder(SubstancesourcematerialOrganism) {use organism_general <- decode.optional_field("organismGeneral", None, decode.optional(substancesourcematerial_organism_organismgeneral_decoder()))
use hybrid <- decode.optional_field("hybrid", None, decode.optional(substancesourcematerial_organism_hybrid_decoder()))
use author <- decode.optional_field("author", [], decode.list(substancesourcematerial_organism_author_decoder()))
use intraspecific_description <- decode.optional_field("intraspecificDescription", None, decode.optional(decode.string))
use intraspecific_type <- decode.optional_field("intraspecificType", None, decode.optional(codeableconcept_decoder()))
use species <- decode.optional_field("species", None, decode.optional(codeableconcept_decoder()))
use genus <- decode.optional_field("genus", None, decode.optional(codeableconcept_decoder()))
use family <- decode.optional_field("family", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialOrganism(organism_general:,hybrid:,author:,intraspecific_description:,intraspecific_type:,species:,genus:,family:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_fractiondescription_to_json(substancesourcematerial_fractiondescription: SubstancesourcematerialFractiondescription) -> Json {
    let SubstancesourcematerialFractiondescription(material_type:,fraction:,modifier_extension:,extension:,id:,) = substancesourcematerial_fractiondescription
    let fields = []
let fields = case material_type {
                          Some(v) -> [#("materialType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case fraction {
                          Some(v) -> [#("fraction", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_fractiondescription_decoder() -> Decoder(SubstancesourcematerialFractiondescription) {use material_type <- decode.optional_field("materialType", None, decode.optional(codeableconcept_decoder()))
use fraction <- decode.optional_field("fraction", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancesourcematerialFractiondescription(material_type:,fraction:,modifier_extension:,extension:,id:,))}
pub fn substancesourcematerial_to_json(substancesourcematerial: Substancesourcematerial) -> Json {
    let Substancesourcematerial(part_description:,organism:,fraction_description:,development_stage:,geographical_location:,country_of_origin:,parent_substance_name:,parent_substance_id:,organism_name:,organism_id:,source_material_state:,source_material_type:,source_material_class:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substancesourcematerial
    let fields = []
let fields = case part_description {
                        [] -> fields
                        _ -> [#("partDescription", json.array(part_description,substancesourcematerial_partdescription_to_json)), ..fields]
                          }
let fields = case organism {
                          Some(v) -> [#("organism", substancesourcematerial_organism_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case fraction_description {
                        [] -> fields
                        _ -> [#("fractionDescription", json.array(fraction_description,substancesourcematerial_fractiondescription_to_json)), ..fields]
                          }
let fields = case development_stage {
                          Some(v) -> [#("developmentStage", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case geographical_location {
                        [] -> fields
                        _ -> [#("geographicalLocation", json.array(geographical_location,json.string)), ..fields]
                          }
let fields = case country_of_origin {
                        [] -> fields
                        _ -> [#("countryOfOrigin", json.array(country_of_origin,codeableconcept_to_json)), ..fields]
                          }
let fields = case parent_substance_name {
                        [] -> fields
                        _ -> [#("parentSubstanceName", json.array(parent_substance_name,json.string)), ..fields]
                          }
let fields = case parent_substance_id {
                        [] -> fields
                        _ -> [#("parentSubstanceId", json.array(parent_substance_id,identifier_to_json)), ..fields]
                          }
let fields = case organism_name {
                          Some(v) -> [#("organismName", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case organism_id {
                          Some(v) -> [#("organismId", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source_material_state {
                          Some(v) -> [#("sourceMaterialState", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source_material_type {
                          Some(v) -> [#("sourceMaterialType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case source_material_class {
                          Some(v) -> [#("sourceMaterialClass", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancesourcematerial_decoder() -> Decoder(Substancesourcematerial) {use part_description <- decode.optional_field("partDescription", [], decode.list(substancesourcematerial_partdescription_decoder()))
use organism <- decode.optional_field("organism", None, decode.optional(substancesourcematerial_organism_decoder()))
use fraction_description <- decode.optional_field("fractionDescription", [], decode.list(substancesourcematerial_fractiondescription_decoder()))
use development_stage <- decode.optional_field("developmentStage", None, decode.optional(codeableconcept_decoder()))
use geographical_location <- decode.optional_field("geographicalLocation", [], decode.list(decode.string))
use country_of_origin <- decode.optional_field("countryOfOrigin", [], decode.list(codeableconcept_decoder()))
use parent_substance_name <- decode.optional_field("parentSubstanceName", [], decode.list(decode.string))
use parent_substance_id <- decode.optional_field("parentSubstanceId", [], decode.list(identifier_decoder()))
use organism_name <- decode.optional_field("organismName", None, decode.optional(decode.string))
use organism_id <- decode.optional_field("organismId", None, decode.optional(identifier_decoder()))
use source_material_state <- decode.optional_field("sourceMaterialState", None, decode.optional(codeableconcept_decoder()))
use source_material_type <- decode.optional_field("sourceMaterialType", None, decode.optional(codeableconcept_decoder()))
use source_material_class <- decode.optional_field("sourceMaterialClass", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substancesourcematerial(part_description:,organism:,fraction_description:,development_stage:,geographical_location:,country_of_origin:,parent_substance_name:,parent_substance_id:,organism_name:,organism_id:,source_material_state:,source_material_type:,source_material_class:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type Substancespecification
{
Substancespecification(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
type_: Option(Codeableconcept),
status: Option(Codeableconcept),
domain: Option(Codeableconcept),
description: Option(String),
source: List(Reference),
comment: Option(String),
moiety: List(SubstancespecificationMoiety),
property: List(SubstancespecificationProperty),
reference_information: Option(Reference),
structure: Option(SubstancespecificationStructure),
code: List(SubstancespecificationCode),
name: List(SubstancespecificationName),
relationship: List(SubstancespecificationRelationship),
nucleic_acid: Option(Reference),
polymer: Option(Reference),
protein: Option(Reference),
source_material: Option(Reference),
)
}

pub fn substancespecification_new() ->Substancespecification{Substancespecification(source_material: None,protein: None,polymer: None,nucleic_acid: None,relationship: [],name: [],code: [],structure: None,reference_information: None,property: [],moiety: [],comment: None,source: [],description: None,domain: None,status: None,type_: None,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationMoiety
{
SubstancespecificationMoiety(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
role: Option(Codeableconcept),
identifier: Option(Identifier),
name: Option(String),
stereochemistry: Option(Codeableconcept),
optical_activity: Option(Codeableconcept),
molecular_formula: Option(String),
amount: Option(SubstancespecificationMoietyAmount),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationMoietyAmount{
SubstancespecificationMoietyAmountQuantity(amount: Quantity)
SubstancespecificationMoietyAmountString(amount: String)}
pub fn substancespecification_moiety_amount_to_json(elt: SubstancespecificationMoietyAmount) -> Json {case elt{SubstancespecificationMoietyAmountQuantity(v) -> quantity_to_json(v)
SubstancespecificationMoietyAmountString(v) -> json.string(v)
}}
pub fn substancespecification_moiety_amount_decoder() -> Decoder(SubstancespecificationMoietyAmount){decode.one_of(decode.field("amountQuantity", quantity_decoder(), decode.success) |> decode.map(SubstancespecificationMoietyAmountQuantity),[decode.field("amountString", decode.string, decode.success) |> decode.map(SubstancespecificationMoietyAmountString),])}
pub fn substancespecification_moiety_new() ->SubstancespecificationMoiety{SubstancespecificationMoiety(amount: None,molecular_formula: None,optical_activity: None,stereochemistry: None,name: None,identifier: None,role: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationProperty
{
SubstancespecificationProperty(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
category: Option(Codeableconcept),
code: Option(Codeableconcept),
parameters: Option(String),
defining_substance: Option(SubstancespecificationPropertyDefiningsubstance),
amount: Option(SubstancespecificationPropertyAmount),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationPropertyDefiningsubstance{
SubstancespecificationPropertyDefiningsubstanceReference(defining_substance: Reference)
SubstancespecificationPropertyDefiningsubstanceCodeableconcept(defining_substance: Codeableconcept)}
pub fn substancespecification_property_definingsubstance_to_json(elt: SubstancespecificationPropertyDefiningsubstance) -> Json {case elt{SubstancespecificationPropertyDefiningsubstanceReference(v) -> reference_to_json(v)
SubstancespecificationPropertyDefiningsubstanceCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn substancespecification_property_definingsubstance_decoder() -> Decoder(SubstancespecificationPropertyDefiningsubstance){decode.one_of(decode.field("definingSubstanceReference", reference_decoder(), decode.success) |> decode.map(SubstancespecificationPropertyDefiningsubstanceReference),[decode.field("definingSubstanceCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SubstancespecificationPropertyDefiningsubstanceCodeableconcept),])}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationPropertyAmount{
SubstancespecificationPropertyAmountQuantity(amount: Quantity)
SubstancespecificationPropertyAmountString(amount: String)}
pub fn substancespecification_property_amount_to_json(elt: SubstancespecificationPropertyAmount) -> Json {case elt{SubstancespecificationPropertyAmountQuantity(v) -> quantity_to_json(v)
SubstancespecificationPropertyAmountString(v) -> json.string(v)
}}
pub fn substancespecification_property_amount_decoder() -> Decoder(SubstancespecificationPropertyAmount){decode.one_of(decode.field("amountQuantity", quantity_decoder(), decode.success) |> decode.map(SubstancespecificationPropertyAmountQuantity),[decode.field("amountString", decode.string, decode.success) |> decode.map(SubstancespecificationPropertyAmountString),])}
pub fn substancespecification_property_new() ->SubstancespecificationProperty{SubstancespecificationProperty(amount: None,defining_substance: None,parameters: None,code: None,category: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationStructure
{
SubstancespecificationStructure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
stereochemistry: Option(Codeableconcept),
optical_activity: Option(Codeableconcept),
molecular_formula: Option(String),
molecular_formula_by_moiety: Option(String),
isotope: List(SubstancespecificationStructureIsotope),
source: List(Reference),
representation: List(SubstancespecificationStructureRepresentation),
)
}

pub fn substancespecification_structure_new() ->SubstancespecificationStructure{SubstancespecificationStructure(representation: [],source: [],isotope: [],molecular_formula_by_moiety: None,molecular_formula: None,optical_activity: None,stereochemistry: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationStructureIsotope
{
SubstancespecificationStructureIsotope(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
name: Option(Codeableconcept),
substitution: Option(Codeableconcept),
half_life: Option(Quantity),
molecular_weight: Option(SubstancespecificationStructureIsotopeMolecularweight),
)
}

pub fn substancespecification_structure_isotope_new() ->SubstancespecificationStructureIsotope{SubstancespecificationStructureIsotope(molecular_weight: None,half_life: None,substitution: None,name: None,identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationStructureIsotopeMolecularweight
{
SubstancespecificationStructureIsotopeMolecularweight(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
method: Option(Codeableconcept),
type_: Option(Codeableconcept),
amount: Option(Quantity),
)
}

pub fn substancespecification_structure_isotope_molecularweight_new() ->SubstancespecificationStructureIsotopeMolecularweight{SubstancespecificationStructureIsotopeMolecularweight(amount: None,type_: None,method: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationStructureRepresentation
{
SubstancespecificationStructureRepresentation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Codeableconcept),
representation: Option(String),
attachment: Option(Attachment),
)
}

pub fn substancespecification_structure_representation_new() ->SubstancespecificationStructureRepresentation{SubstancespecificationStructureRepresentation(attachment: None,representation: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationCode
{
SubstancespecificationCode(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
status: Option(Codeableconcept),
status_date: Option(String),
comment: Option(String),
source: List(Reference),
)
}

pub fn substancespecification_code_new() ->SubstancespecificationCode{SubstancespecificationCode(source: [],comment: None,status_date: None,status: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationName
{
SubstancespecificationName(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
type_: Option(Codeableconcept),
status: Option(Codeableconcept),
preferred: Option(Bool),
language: List(Codeableconcept),
domain: List(Codeableconcept),
jurisdiction: List(Codeableconcept),
official: List(SubstancespecificationNameOfficial),
source: List(Reference),
)
}

pub fn substancespecification_name_new(name name: String,) ->SubstancespecificationName{SubstancespecificationName(source: [],official: [],jurisdiction: [],domain: [],language: [],preferred: None,status: None,type_: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationNameOfficial
{
SubstancespecificationNameOfficial(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
authority: Option(Codeableconcept),
status: Option(Codeableconcept),
date: Option(String),
)
}

pub fn substancespecification_name_official_new() ->SubstancespecificationNameOfficial{SubstancespecificationNameOfficial(date: None,status: None,authority: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationRelationship
{
SubstancespecificationRelationship(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
substance: Option(SubstancespecificationRelationshipSubstance),
relationship: Option(Codeableconcept),
is_defining: Option(Bool),
amount: Option(SubstancespecificationRelationshipAmount),
amount_ratio_low_limit: Option(Ratio),
amount_type: Option(Codeableconcept),
source: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationRelationshipSubstance{
SubstancespecificationRelationshipSubstanceReference(substance: Reference)
SubstancespecificationRelationshipSubstanceCodeableconcept(substance: Codeableconcept)}
pub fn substancespecification_relationship_substance_to_json(elt: SubstancespecificationRelationshipSubstance) -> Json {case elt{SubstancespecificationRelationshipSubstanceReference(v) -> reference_to_json(v)
SubstancespecificationRelationshipSubstanceCodeableconcept(v) -> codeableconcept_to_json(v)
}}
pub fn substancespecification_relationship_substance_decoder() -> Decoder(SubstancespecificationRelationshipSubstance){decode.one_of(decode.field("substanceReference", reference_decoder(), decode.success) |> decode.map(SubstancespecificationRelationshipSubstanceReference),[decode.field("substanceCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SubstancespecificationRelationshipSubstanceCodeableconcept),])}

///http://hl7.org/fhir/r4/StructureDefinition/SubstanceSpecification#resource
pub type SubstancespecificationRelationshipAmount{
SubstancespecificationRelationshipAmountQuantity(amount: Quantity)
SubstancespecificationRelationshipAmountRange(amount: Range)
SubstancespecificationRelationshipAmountRatio(amount: Ratio)
SubstancespecificationRelationshipAmountString(amount: String)}
pub fn substancespecification_relationship_amount_to_json(elt: SubstancespecificationRelationshipAmount) -> Json {case elt{SubstancespecificationRelationshipAmountQuantity(v) -> quantity_to_json(v)
SubstancespecificationRelationshipAmountRange(v) -> range_to_json(v)
SubstancespecificationRelationshipAmountRatio(v) -> ratio_to_json(v)
SubstancespecificationRelationshipAmountString(v) -> json.string(v)
}}
pub fn substancespecification_relationship_amount_decoder() -> Decoder(SubstancespecificationRelationshipAmount){decode.one_of(decode.field("amountQuantity", quantity_decoder(), decode.success) |> decode.map(SubstancespecificationRelationshipAmountQuantity),[decode.field("amountRange", range_decoder(), decode.success) |> decode.map(SubstancespecificationRelationshipAmountRange),decode.field("amountRatio", ratio_decoder(), decode.success) |> decode.map(SubstancespecificationRelationshipAmountRatio),decode.field("amountString", decode.string, decode.success) |> decode.map(SubstancespecificationRelationshipAmountString),])}
pub fn substancespecification_relationship_new() ->SubstancespecificationRelationship{SubstancespecificationRelationship(source: [],amount_type: None,amount_ratio_low_limit: None,amount: None,is_defining: None,relationship: None,substance: None,modifier_extension: [],extension: [],id: None,)
}

pub fn substancespecification_relationship_to_json(substancespecification_relationship: SubstancespecificationRelationship) -> Json {
    let SubstancespecificationRelationship(source:,amount_type:,amount_ratio_low_limit:,amount:,is_defining:,relationship:,substance:,modifier_extension:,extension:,id:,) = substancespecification_relationship
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case amount_type {
                          Some(v) -> [#("amountType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount_ratio_low_limit {
                          Some(v) -> [#("amountRatioLowLimit", ratio_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case amount {
                          Some(v) -> [#("amount", substancespecification_relationship_amount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case is_defining {
                          Some(v) -> [#("isDefining", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                          Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case substance {
                          Some(v) -> [#("substance", substancespecification_relationship_substance_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_relationship_decoder() -> Decoder(SubstancespecificationRelationship) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use amount_type <- decode.optional_field("amountType", None, decode.optional(codeableconcept_decoder()))
use amount_ratio_low_limit <- decode.optional_field("amountRatioLowLimit", None, decode.optional(ratio_decoder()))
use amount <- decode.then(none_if_omitted(substancespecification_relationship_amount_decoder()))
use is_defining <- decode.optional_field("isDefining", None, decode.optional(decode.bool))
use relationship <- decode.optional_field("relationship", None, decode.optional(codeableconcept_decoder()))
use substance <- decode.then(none_if_omitted(substancespecification_relationship_substance_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationRelationship(source:,amount_type:,amount_ratio_low_limit:,amount:,is_defining:,relationship:,substance:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_name_official_to_json(substancespecification_name_official: SubstancespecificationNameOfficial) -> Json {
    let SubstancespecificationNameOfficial(date:,status:,authority:,modifier_extension:,extension:,id:,) = substancespecification_name_official
    let fields = []
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authority {
                          Some(v) -> [#("authority", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_name_official_decoder() -> Decoder(SubstancespecificationNameOfficial) {use date <- decode.optional_field("date", None, decode.optional(decode.string))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use authority <- decode.optional_field("authority", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationNameOfficial(date:,status:,authority:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_name_to_json(substancespecification_name: SubstancespecificationName) -> Json {
    let SubstancespecificationName(source:,official:,jurisdiction:,domain:,language:,preferred:,status:,type_:,name:,modifier_extension:,extension:,id:,) = substancespecification_name
    let fields = [#("name", json.string(name)),]
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case official {
                        [] -> fields
                        _ -> [#("official", json.array(official,substancespecification_name_official_to_json)), ..fields]
                          }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case domain {
                        [] -> fields
                        _ -> [#("domain", json.array(domain,codeableconcept_to_json)), ..fields]
                          }
let fields = case language {
                        [] -> fields
                        _ -> [#("language", json.array(language,codeableconcept_to_json)), ..fields]
                          }
let fields = case preferred {
                          Some(v) -> [#("preferred", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_name_decoder() -> Decoder(SubstancespecificationName) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use official <- decode.optional_field("official", [], decode.list(substancespecification_name_official_decoder()))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use domain <- decode.optional_field("domain", [], decode.list(codeableconcept_decoder()))
use language <- decode.optional_field("language", [], decode.list(codeableconcept_decoder()))
use preferred <- decode.optional_field("preferred", None, decode.optional(decode.bool))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationName(source:,official:,jurisdiction:,domain:,language:,preferred:,status:,type_:,name:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_code_to_json(substancespecification_code: SubstancespecificationCode) -> Json {
    let SubstancespecificationCode(source:,comment:,status_date:,status:,code:,modifier_extension:,extension:,id:,) = substancespecification_code
    let fields = []
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status_date {
                          Some(v) -> [#("statusDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_code_decoder() -> Decoder(SubstancespecificationCode) {use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use status_date <- decode.optional_field("statusDate", None, decode.optional(decode.string))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationCode(source:,comment:,status_date:,status:,code:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_structure_representation_to_json(substancespecification_structure_representation: SubstancespecificationStructureRepresentation) -> Json {
    let SubstancespecificationStructureRepresentation(attachment:,representation:,type_:,modifier_extension:,extension:,id:,) = substancespecification_structure_representation
    let fields = []
let fields = case attachment {
                          Some(v) -> [#("attachment", attachment_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case representation {
                          Some(v) -> [#("representation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_structure_representation_decoder() -> Decoder(SubstancespecificationStructureRepresentation) {use attachment <- decode.optional_field("attachment", None, decode.optional(attachment_decoder()))
use representation <- decode.optional_field("representation", None, decode.optional(decode.string))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationStructureRepresentation(attachment:,representation:,type_:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_structure_isotope_molecularweight_to_json(substancespecification_structure_isotope_molecularweight: SubstancespecificationStructureIsotopeMolecularweight) -> Json {
    let SubstancespecificationStructureIsotopeMolecularweight(amount:,type_:,method:,modifier_extension:,extension:,id:,) = substancespecification_structure_isotope_molecularweight
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_structure_isotope_molecularweight_decoder() -> Decoder(SubstancespecificationStructureIsotopeMolecularweight) {use amount <- decode.optional_field("amount", None, decode.optional(quantity_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use method <- decode.optional_field("method", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationStructureIsotopeMolecularweight(amount:,type_:,method:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_structure_isotope_to_json(substancespecification_structure_isotope: SubstancespecificationStructureIsotope) -> Json {
    let SubstancespecificationStructureIsotope(molecular_weight:,half_life:,substitution:,name:,identifier:,modifier_extension:,extension:,id:,) = substancespecification_structure_isotope
    let fields = []
let fields = case molecular_weight {
                          Some(v) -> [#("molecularWeight", substancespecification_structure_isotope_molecularweight_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case half_life {
                          Some(v) -> [#("halfLife", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case substitution {
                          Some(v) -> [#("substitution", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_structure_isotope_decoder() -> Decoder(SubstancespecificationStructureIsotope) {use molecular_weight <- decode.optional_field("molecularWeight", None, decode.optional(substancespecification_structure_isotope_molecularweight_decoder()))
use half_life <- decode.optional_field("halfLife", None, decode.optional(quantity_decoder()))
use substitution <- decode.optional_field("substitution", None, decode.optional(codeableconcept_decoder()))
use name <- decode.optional_field("name", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationStructureIsotope(molecular_weight:,half_life:,substitution:,name:,identifier:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_structure_to_json(substancespecification_structure: SubstancespecificationStructure) -> Json {
    let SubstancespecificationStructure(representation:,source:,isotope:,molecular_formula_by_moiety:,molecular_formula:,optical_activity:,stereochemistry:,modifier_extension:,extension:,id:,) = substancespecification_structure
    let fields = []
let fields = case representation {
                        [] -> fields
                        _ -> [#("representation", json.array(representation,substancespecification_structure_representation_to_json)), ..fields]
                          }
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case isotope {
                        [] -> fields
                        _ -> [#("isotope", json.array(isotope,substancespecification_structure_isotope_to_json)), ..fields]
                          }
let fields = case molecular_formula_by_moiety {
                          Some(v) -> [#("molecularFormulaByMoiety", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case molecular_formula {
                          Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case optical_activity {
                          Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case stereochemistry {
                          Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_structure_decoder() -> Decoder(SubstancespecificationStructure) {use representation <- decode.optional_field("representation", [], decode.list(substancespecification_structure_representation_decoder()))
use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use isotope <- decode.optional_field("isotope", [], decode.list(substancespecification_structure_isotope_decoder()))
use molecular_formula_by_moiety <- decode.optional_field("molecularFormulaByMoiety", None, decode.optional(decode.string))
use molecular_formula <- decode.optional_field("molecularFormula", None, decode.optional(decode.string))
use optical_activity <- decode.optional_field("opticalActivity", None, decode.optional(codeableconcept_decoder()))
use stereochemistry <- decode.optional_field("stereochemistry", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationStructure(representation:,source:,isotope:,molecular_formula_by_moiety:,molecular_formula:,optical_activity:,stereochemistry:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_property_to_json(substancespecification_property: SubstancespecificationProperty) -> Json {
    let SubstancespecificationProperty(amount:,defining_substance:,parameters:,code:,category:,modifier_extension:,extension:,id:,) = substancespecification_property
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", substancespecification_property_amount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case defining_substance {
                          Some(v) -> [#("definingSubstance", substancespecification_property_definingsubstance_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parameters {
                          Some(v) -> [#("parameters", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_property_decoder() -> Decoder(SubstancespecificationProperty) {use amount <- decode.then(none_if_omitted(substancespecification_property_amount_decoder()))
use defining_substance <- decode.then(none_if_omitted(substancespecification_property_definingsubstance_decoder()))
use parameters <- decode.optional_field("parameters", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationProperty(amount:,defining_substance:,parameters:,code:,category:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_moiety_to_json(substancespecification_moiety: SubstancespecificationMoiety) -> Json {
    let SubstancespecificationMoiety(amount:,molecular_formula:,optical_activity:,stereochemistry:,name:,identifier:,role:,modifier_extension:,extension:,id:,) = substancespecification_moiety
    let fields = []
let fields = case amount {
                          Some(v) -> [#("amount", substancespecification_moiety_amount_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case molecular_formula {
                          Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case optical_activity {
                          Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case stereochemistry {
                          Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case role {
                          Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_moiety_decoder() -> Decoder(SubstancespecificationMoiety) {use amount <- decode.then(none_if_omitted(substancespecification_moiety_amount_decoder()))
use molecular_formula <- decode.optional_field("molecularFormula", None, decode.optional(decode.string))
use optical_activity <- decode.optional_field("opticalActivity", None, decode.optional(codeableconcept_decoder()))
use stereochemistry <- decode.optional_field("stereochemistry", None, decode.optional(codeableconcept_decoder()))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use role <- decode.optional_field("role", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SubstancespecificationMoiety(amount:,molecular_formula:,optical_activity:,stereochemistry:,name:,identifier:,role:,modifier_extension:,extension:,id:,))}
pub fn substancespecification_to_json(substancespecification: Substancespecification) -> Json {
    let Substancespecification(source_material:,protein:,polymer:,nucleic_acid:,relationship:,name:,code:,structure:,reference_information:,property:,moiety:,comment:,source:,description:,domain:,status:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = substancespecification
    let fields = []
let fields = case source_material {
                          Some(v) -> [#("sourceMaterial", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case protein {
                          Some(v) -> [#("protein", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case polymer {
                          Some(v) -> [#("polymer", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case nucleic_acid {
                          Some(v) -> [#("nucleicAcid", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relationship {
                        [] -> fields
                        _ -> [#("relationship", json.array(relationship,substancespecification_relationship_to_json)), ..fields]
                          }
let fields = case name {
                        [] -> fields
                        _ -> [#("name", json.array(name,substancespecification_name_to_json)), ..fields]
                          }
let fields = case code {
                        [] -> fields
                        _ -> [#("code", json.array(code,substancespecification_code_to_json)), ..fields]
                          }
let fields = case structure {
                          Some(v) -> [#("structure", substancespecification_structure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reference_information {
                          Some(v) -> [#("referenceInformation", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,substancespecification_property_to_json)), ..fields]
                          }
let fields = case moiety {
                        [] -> fields
                        _ -> [#("moiety", json.array(moiety,substancespecification_moiety_to_json)), ..fields]
                          }
let fields = case comment {
                          Some(v) -> [#("comment", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source {
                        [] -> fields
                        _ -> [#("source", json.array(source,reference_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case domain {
                          Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn substancespecification_decoder() -> Decoder(Substancespecification) {use source_material <- decode.optional_field("sourceMaterial", None, decode.optional(reference_decoder()))
use protein <- decode.optional_field("protein", None, decode.optional(reference_decoder()))
use polymer <- decode.optional_field("polymer", None, decode.optional(reference_decoder()))
use nucleic_acid <- decode.optional_field("nucleicAcid", None, decode.optional(reference_decoder()))
use relationship <- decode.optional_field("relationship", [], decode.list(substancespecification_relationship_decoder()))
use name <- decode.optional_field("name", [], decode.list(substancespecification_name_decoder()))
use code <- decode.optional_field("code", [], decode.list(substancespecification_code_decoder()))
use structure <- decode.optional_field("structure", None, decode.optional(substancespecification_structure_decoder()))
use reference_information <- decode.optional_field("referenceInformation", None, decode.optional(reference_decoder()))
use property <- decode.optional_field("property", [], decode.list(substancespecification_property_decoder()))
use moiety <- decode.optional_field("moiety", [], decode.list(substancespecification_moiety_decoder()))
use comment <- decode.optional_field("comment", None, decode.optional(decode.string))
use source <- decode.optional_field("source", [], decode.list(reference_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use domain <- decode.optional_field("domain", None, decode.optional(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Substancespecification(source_material:,protein:,polymer:,nucleic_acid:,relationship:,name:,code:,structure:,reference_information:,property:,moiety:,comment:,source:,description:,domain:,status:,type_:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SupplyDelivery#resource
pub type Supplydelivery
{
Supplydelivery(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
based_on: List(Reference),
part_of: List(Reference),
status: Option(r4valuesets.Supplydeliverystatus),
patient: Option(Reference),
type_: Option(Codeableconcept),
supplied_item: Option(SupplydeliverySupplieditem),
occurrence: Option(SupplydeliveryOccurrence),
supplier: Option(Reference),
destination: Option(Reference),
receiver: List(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliveryOccurrence{
SupplydeliveryOccurrenceDatetime(occurrence: String)
SupplydeliveryOccurrencePeriod(occurrence: Period)
SupplydeliveryOccurrenceTiming(occurrence: Timing)}
pub fn supplydelivery_occurrence_to_json(elt: SupplydeliveryOccurrence) -> Json {case elt{SupplydeliveryOccurrenceDatetime(v) -> json.string(v)
SupplydeliveryOccurrencePeriod(v) -> period_to_json(v)
SupplydeliveryOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn supplydelivery_occurrence_decoder() -> Decoder(SupplydeliveryOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(SupplydeliveryOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(SupplydeliveryOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(SupplydeliveryOccurrenceTiming),])}
pub fn supplydelivery_new() ->Supplydelivery{Supplydelivery(receiver: [],destination: None,supplier: None,occurrence: None,supplied_item: None,type_: None,patient: None,status: None,part_of: [],based_on: [],identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditem
{
SupplydeliverySupplieditem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
quantity: Option(Quantity),
item: Option(SupplydeliverySupplieditemItem),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditemItem{
SupplydeliverySupplieditemItemCodeableconcept(item: Codeableconcept)
SupplydeliverySupplieditemItemReference(item: Reference)}
pub fn supplydelivery_supplieditem_item_to_json(elt: SupplydeliverySupplieditemItem) -> Json {case elt{SupplydeliverySupplieditemItemCodeableconcept(v) -> codeableconcept_to_json(v)
SupplydeliverySupplieditemItemReference(v) -> reference_to_json(v)
}}
pub fn supplydelivery_supplieditem_item_decoder() -> Decoder(SupplydeliverySupplieditemItem){decode.one_of(decode.field("itemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SupplydeliverySupplieditemItemCodeableconcept),[decode.field("itemReference", reference_decoder(), decode.success) |> decode.map(SupplydeliverySupplieditemItemReference),])}
pub fn supplydelivery_supplieditem_new() ->SupplydeliverySupplieditem{SupplydeliverySupplieditem(item: None,quantity: None,modifier_extension: [],extension: [],id: None,)
}

pub fn supplydelivery_supplieditem_to_json(supplydelivery_supplieditem: SupplydeliverySupplieditem) -> Json {
    let SupplydeliverySupplieditem(item:,quantity:,modifier_extension:,extension:,id:,) = supplydelivery_supplieditem
    let fields = []
let fields = case item {
                          Some(v) -> [#("item", supplydelivery_supplieditem_item_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case quantity {
                          Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn supplydelivery_supplieditem_decoder() -> Decoder(SupplydeliverySupplieditem) {use item <- decode.then(none_if_omitted(supplydelivery_supplieditem_item_decoder()))
use quantity <- decode.optional_field("quantity", None, decode.optional(quantity_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SupplydeliverySupplieditem(item:,quantity:,modifier_extension:,extension:,id:,))}
pub fn supplydelivery_to_json(supplydelivery: Supplydelivery) -> Json {
    let Supplydelivery(receiver:,destination:,supplier:,occurrence:,supplied_item:,type_:,patient:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = supplydelivery
    let fields = []
let fields = case receiver {
                        [] -> fields
                        _ -> [#("receiver", json.array(receiver,reference_to_json)), ..fields]
                          }
let fields = case destination {
                          Some(v) -> [#("destination", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case supplier {
                          Some(v) -> [#("supplier", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", supplydelivery_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case supplied_item {
                          Some(v) -> [#("suppliedItem", supplydelivery_supplieditem_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case patient {
                          Some(v) -> [#("patient", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.supplydeliverystatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn supplydelivery_decoder() -> Decoder(Supplydelivery) {use receiver <- decode.optional_field("receiver", [], decode.list(reference_decoder()))
use destination <- decode.optional_field("destination", None, decode.optional(reference_decoder()))
use supplier <- decode.optional_field("supplier", None, decode.optional(reference_decoder()))
use occurrence <- decode.then(none_if_omitted(supplydelivery_occurrence_decoder()))
use supplied_item <- decode.optional_field("suppliedItem", None, decode.optional(supplydelivery_supplieditem_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(codeableconcept_decoder()))
use patient <- decode.optional_field("patient", None, decode.optional(reference_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.supplydeliverystatus_decoder()))
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Supplydelivery(receiver:,destination:,supplier:,occurrence:,supplied_item:,type_:,patient:,status:,part_of:,based_on:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/SupplyRequest#resource
pub type Supplyrequest
{
Supplyrequest(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: Option(r4valuesets.Supplyrequeststatus),
category: Option(Codeableconcept),
priority: Option(r4valuesets.Requestpriority),
item: SupplyrequestItem,
quantity: Quantity,
parameter: List(SupplyrequestParameter),
occurrence: Option(SupplyrequestOccurrence),
authored_on: Option(String),
requester: Option(Reference),
supplier: List(Reference),
reason_code: List(Codeableconcept),
reason_reference: List(Reference),
deliver_from: Option(Reference),
deliver_to: Option(Reference),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestItem{
SupplyrequestItemCodeableconcept(item: Codeableconcept)
SupplyrequestItemReference(item: Reference)}
pub fn supplyrequest_item_to_json(elt: SupplyrequestItem) -> Json {case elt{SupplyrequestItemCodeableconcept(v) -> codeableconcept_to_json(v)
SupplyrequestItemReference(v) -> reference_to_json(v)
}}
pub fn supplyrequest_item_decoder() -> Decoder(SupplyrequestItem){decode.one_of(decode.field("itemCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SupplyrequestItemCodeableconcept),[decode.field("itemReference", reference_decoder(), decode.success) |> decode.map(SupplyrequestItemReference),])}

///http://hl7.org/fhir/r4/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestOccurrence{
SupplyrequestOccurrenceDatetime(occurrence: String)
SupplyrequestOccurrencePeriod(occurrence: Period)
SupplyrequestOccurrenceTiming(occurrence: Timing)}
pub fn supplyrequest_occurrence_to_json(elt: SupplyrequestOccurrence) -> Json {case elt{SupplyrequestOccurrenceDatetime(v) -> json.string(v)
SupplyrequestOccurrencePeriod(v) -> period_to_json(v)
SupplyrequestOccurrenceTiming(v) -> timing_to_json(v)
}}
pub fn supplyrequest_occurrence_decoder() -> Decoder(SupplyrequestOccurrence){decode.one_of(decode.field("occurrenceDateTime", decode.string, decode.success) |> decode.map(SupplyrequestOccurrenceDatetime),[decode.field("occurrencePeriod", period_decoder(), decode.success) |> decode.map(SupplyrequestOccurrencePeriod),decode.field("occurrenceTiming", timing_decoder(), decode.success) |> decode.map(SupplyrequestOccurrenceTiming),])}
pub fn supplyrequest_new(quantity quantity: Quantity,item item: SupplyrequestItem,) ->Supplyrequest{Supplyrequest(deliver_to: None,deliver_from: None,reason_reference: [],reason_code: [],supplier: [],requester: None,authored_on: None,occurrence: None,parameter: [],quantity:,item:,priority: None,category: None,status: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameter
{
SupplyrequestParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(Codeableconcept),
value: Option(SupplyrequestParameterValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameterValue{
SupplyrequestParameterValueCodeableconcept(value: Codeableconcept)
SupplyrequestParameterValueQuantity(value: Quantity)
SupplyrequestParameterValueRange(value: Range)
SupplyrequestParameterValueBoolean(value: Bool)}
pub fn supplyrequest_parameter_value_to_json(elt: SupplyrequestParameterValue) -> Json {case elt{SupplyrequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
SupplyrequestParameterValueQuantity(v) -> quantity_to_json(v)
SupplyrequestParameterValueRange(v) -> range_to_json(v)
SupplyrequestParameterValueBoolean(v) -> json.bool(v)
}}
pub fn supplyrequest_parameter_value_decoder() -> Decoder(SupplyrequestParameterValue){decode.one_of(decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(SupplyrequestParameterValueCodeableconcept),[decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(SupplyrequestParameterValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(SupplyrequestParameterValueRange),decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(SupplyrequestParameterValueBoolean),])}
pub fn supplyrequest_parameter_new() ->SupplyrequestParameter{SupplyrequestParameter(value: None,code: None,modifier_extension: [],extension: [],id: None,)
}

pub fn supplyrequest_parameter_to_json(supplyrequest_parameter: SupplyrequestParameter) -> Json {
    let SupplyrequestParameter(value:,code:,modifier_extension:,extension:,id:,) = supplyrequest_parameter
    let fields = []
let fields = case value {
                          Some(v) -> [#("value", supplyrequest_parameter_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn supplyrequest_parameter_decoder() -> Decoder(SupplyrequestParameter) {use value <- decode.then(none_if_omitted(supplyrequest_parameter_value_decoder()))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(SupplyrequestParameter(value:,code:,modifier_extension:,extension:,id:,))}
pub fn supplyrequest_to_json(supplyrequest: Supplyrequest) -> Json {
    let Supplyrequest(deliver_to:,deliver_from:,reason_reference:,reason_code:,supplier:,requester:,authored_on:,occurrence:,parameter:,quantity:,item:,priority:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = supplyrequest
    let fields = [#("quantity", quantity_to_json(quantity)),#("item", supplyrequest_item_to_json(item)),]
let fields = case deliver_to {
                          Some(v) -> [#("deliverTo", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case deliver_from {
                          Some(v) -> [#("deliverFrom", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_reference {
                        [] -> fields
                        _ -> [#("reasonReference", json.array(reason_reference,reference_to_json)), ..fields]
                          }
let fields = case reason_code {
                        [] -> fields
                        _ -> [#("reasonCode", json.array(reason_code,codeableconcept_to_json)), ..fields]
                          }
let fields = case supplier {
                        [] -> fields
                        _ -> [#("supplier", json.array(supplier,reference_to_json)), ..fields]
                          }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case occurrence {
                          Some(v) -> [#("occurrence", supplyrequest_occurrence_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,supplyrequest_parameter_to_json)), ..fields]
                          }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case category {
                          Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status {
                          Some(v) -> [#("status", r4valuesets.supplyrequeststatus_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn supplyrequest_decoder() -> Decoder(Supplyrequest) {use deliver_to <- decode.optional_field("deliverTo", None, decode.optional(reference_decoder()))
use deliver_from <- decode.optional_field("deliverFrom", None, decode.optional(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", [], decode.list(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", [], decode.list(codeableconcept_decoder()))
use supplier <- decode.optional_field("supplier", [], decode.list(reference_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use occurrence <- decode.then(none_if_omitted(supplyrequest_occurrence_decoder()))
use parameter <- decode.optional_field("parameter", [], decode.list(supplyrequest_parameter_decoder()))
use quantity <- decode.field("quantity",quantity_decoder())
use item <- decode.then(supplyrequest_item_decoder())
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use category <- decode.optional_field("category", None, decode.optional(codeableconcept_decoder()))
use status <- decode.optional_field("status", None, decode.optional(r4valuesets.supplyrequeststatus_decoder()))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Supplyrequest(deliver_to:,deliver_from:,reason_reference:,reason_code:,supplier:,requester:,authored_on:,occurrence:,parameter:,quantity:,item:,priority:,category:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type Task
{
Task(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
instantiates_canonical: Option(String),
instantiates_uri: Option(String),
based_on: List(Reference),
group_identifier: Option(Identifier),
part_of: List(Reference),
status: r4valuesets.Taskstatus,
status_reason: Option(Codeableconcept),
business_status: Option(Codeableconcept),
intent: r4valuesets.Taskintent,
priority: Option(r4valuesets.Requestpriority),
code: Option(Codeableconcept),
description: Option(String),
focus: Option(Reference),
for: Option(Reference),
encounter: Option(Reference),
execution_period: Option(Period),
authored_on: Option(String),
last_modified: Option(String),
requester: Option(Reference),
performer_type: List(Codeableconcept),
owner: Option(Reference),
location: Option(Reference),
reason_code: Option(Codeableconcept),
reason_reference: Option(Reference),
insurance: List(Reference),
note: List(Annotation),
relevant_history: List(Reference),
restriction: Option(TaskRestriction),
input: List(TaskInput),
output: List(TaskOutput),
)
}

pub fn task_new(intent intent: r4valuesets.Taskintent,status status: r4valuesets.Taskstatus,) ->Task{Task(output: [],input: [],restriction: None,relevant_history: [],note: [],insurance: [],reason_reference: None,reason_code: None,location: None,owner: None,performer_type: [],requester: None,last_modified: None,authored_on: None,execution_period: None,encounter: None,for: None,focus: None,description: None,code: None,priority: None,intent:,business_status: None,status_reason: None,status:,part_of: [],group_identifier: None,based_on: [],instantiates_uri: None,instantiates_canonical: None,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type TaskRestriction
{
TaskRestriction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
repetitions: Option(Int),
period: Option(Period),
recipient: List(Reference),
)
}

pub fn task_restriction_new() ->TaskRestriction{TaskRestriction(recipient: [],period: None,repetitions: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type TaskInput
{
TaskInput(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
value: TaskInputValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type TaskInputValue{
TaskInputValueBase64binary(value: String)
TaskInputValueBoolean(value: Bool)
TaskInputValueCanonical(value: String)
TaskInputValueCode(value: String)
TaskInputValueDate(value: String)
TaskInputValueDatetime(value: String)
TaskInputValueDecimal(value: Float)
TaskInputValueId(value: String)
TaskInputValueInstant(value: String)
TaskInputValueInteger(value: Int)
TaskInputValueMarkdown(value: String)
TaskInputValueOid(value: String)
TaskInputValuePositiveint(value: Int)
TaskInputValueString(value: String)
TaskInputValueTime(value: String)
TaskInputValueUnsignedint(value: Int)
TaskInputValueUri(value: String)
TaskInputValueUrl(value: String)
TaskInputValueUuid(value: String)
TaskInputValueAddress(value: Address)
TaskInputValueAge(value: Age)
TaskInputValueAnnotation(value: Annotation)
TaskInputValueAttachment(value: Attachment)
TaskInputValueCodeableconcept(value: Codeableconcept)
TaskInputValueCoding(value: Coding)
TaskInputValueContactpoint(value: Contactpoint)
TaskInputValueCount(value: Count)
TaskInputValueDistance(value: Distance)
TaskInputValueDuration(value: Duration)
TaskInputValueHumanname(value: Humanname)
TaskInputValueIdentifier(value: Identifier)
TaskInputValueMoney(value: Money)
TaskInputValuePeriod(value: Period)
TaskInputValueQuantity(value: Quantity)
TaskInputValueRange(value: Range)
TaskInputValueRatio(value: Ratio)
TaskInputValueReference(value: Reference)
TaskInputValueSampleddata(value: Sampleddata)
TaskInputValueSignature(value: Signature)
TaskInputValueTiming(value: Timing)
TaskInputValueContactdetail(value: Contactdetail)
TaskInputValueContributor(value: Contributor)
TaskInputValueDatarequirement(value: Datarequirement)
TaskInputValueExpression(value: Expression)
TaskInputValueParameterdefinition(value: Parameterdefinition)
TaskInputValueRelatedartifact(value: Relatedartifact)
TaskInputValueTriggerdefinition(value: Triggerdefinition)
TaskInputValueUsagecontext(value: Usagecontext)
TaskInputValueDosage(value: Dosage)
TaskInputValueMeta(value: Meta)}
pub fn task_input_value_to_json(elt: TaskInputValue) -> Json {case elt{TaskInputValueBase64binary(v) -> json.string(v)
TaskInputValueBoolean(v) -> json.bool(v)
TaskInputValueCanonical(v) -> json.string(v)
TaskInputValueCode(v) -> json.string(v)
TaskInputValueDate(v) -> json.string(v)
TaskInputValueDatetime(v) -> json.string(v)
TaskInputValueDecimal(v) -> json.float(v)
TaskInputValueId(v) -> json.string(v)
TaskInputValueInstant(v) -> json.string(v)
TaskInputValueInteger(v) -> json.int(v)
TaskInputValueMarkdown(v) -> json.string(v)
TaskInputValueOid(v) -> json.string(v)
TaskInputValuePositiveint(v) -> json.int(v)
TaskInputValueString(v) -> json.string(v)
TaskInputValueTime(v) -> json.string(v)
TaskInputValueUnsignedint(v) -> json.int(v)
TaskInputValueUri(v) -> json.string(v)
TaskInputValueUrl(v) -> json.string(v)
TaskInputValueUuid(v) -> json.string(v)
TaskInputValueAddress(v) -> address_to_json(v)
TaskInputValueAge(v) -> age_to_json(v)
TaskInputValueAnnotation(v) -> annotation_to_json(v)
TaskInputValueAttachment(v) -> attachment_to_json(v)
TaskInputValueCodeableconcept(v) -> codeableconcept_to_json(v)
TaskInputValueCoding(v) -> coding_to_json(v)
TaskInputValueContactpoint(v) -> contactpoint_to_json(v)
TaskInputValueCount(v) -> count_to_json(v)
TaskInputValueDistance(v) -> distance_to_json(v)
TaskInputValueDuration(v) -> duration_to_json(v)
TaskInputValueHumanname(v) -> humanname_to_json(v)
TaskInputValueIdentifier(v) -> identifier_to_json(v)
TaskInputValueMoney(v) -> money_to_json(v)
TaskInputValuePeriod(v) -> period_to_json(v)
TaskInputValueQuantity(v) -> quantity_to_json(v)
TaskInputValueRange(v) -> range_to_json(v)
TaskInputValueRatio(v) -> ratio_to_json(v)
TaskInputValueReference(v) -> reference_to_json(v)
TaskInputValueSampleddata(v) -> sampleddata_to_json(v)
TaskInputValueSignature(v) -> signature_to_json(v)
TaskInputValueTiming(v) -> timing_to_json(v)
TaskInputValueContactdetail(v) -> contactdetail_to_json(v)
TaskInputValueContributor(v) -> contributor_to_json(v)
TaskInputValueDatarequirement(v) -> datarequirement_to_json(v)
TaskInputValueExpression(v) -> expression_to_json(v)
TaskInputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
TaskInputValueRelatedartifact(v) -> relatedartifact_to_json(v)
TaskInputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
TaskInputValueUsagecontext(v) -> usagecontext_to_json(v)
TaskInputValueDosage(v) -> dosage_to_json(v)
TaskInputValueMeta(v) -> meta_to_json(v)
}}
pub fn task_input_value_decoder() -> Decoder(TaskInputValue){decode.one_of(decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(TaskInputValueBase64binary),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(TaskInputValueBoolean),decode.field("valueCanonical", decode.string, decode.success) |> decode.map(TaskInputValueCanonical),decode.field("valueCode", decode.string, decode.success) |> decode.map(TaskInputValueCode),decode.field("valueDate", decode.string, decode.success) |> decode.map(TaskInputValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(TaskInputValueDatetime),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(TaskInputValueDecimal),decode.field("valueId", decode.string, decode.success) |> decode.map(TaskInputValueId),decode.field("valueInstant", decode.string, decode.success) |> decode.map(TaskInputValueInstant),decode.field("valueInteger", decode.int, decode.success) |> decode.map(TaskInputValueInteger),decode.field("valueMarkdown", decode.string, decode.success) |> decode.map(TaskInputValueMarkdown),decode.field("valueOid", decode.string, decode.success) |> decode.map(TaskInputValueOid),decode.field("valuePositiveInt", decode.int, decode.success) |> decode.map(TaskInputValuePositiveint),decode.field("valueString", decode.string, decode.success) |> decode.map(TaskInputValueString),decode.field("valueTime", decode.string, decode.success) |> decode.map(TaskInputValueTime),decode.field("valueUnsignedInt", decode.int, decode.success) |> decode.map(TaskInputValueUnsignedint),decode.field("valueUri", decode.string, decode.success) |> decode.map(TaskInputValueUri),decode.field("valueUrl", decode.string, decode.success) |> decode.map(TaskInputValueUrl),decode.field("valueUuid", decode.string, decode.success) |> decode.map(TaskInputValueUuid),decode.field("valueAddress", address_decoder(), decode.success) |> decode.map(TaskInputValueAddress),decode.field("valueAge", age_decoder(), decode.success) |> decode.map(TaskInputValueAge),decode.field("valueAnnotation", annotation_decoder(), decode.success) |> decode.map(TaskInputValueAnnotation),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(TaskInputValueAttachment),decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(TaskInputValueCodeableconcept),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(TaskInputValueCoding),decode.field("valueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(TaskInputValueContactpoint),decode.field("valueCount", count_decoder(), decode.success) |> decode.map(TaskInputValueCount),decode.field("valueDistance", distance_decoder(), decode.success) |> decode.map(TaskInputValueDistance),decode.field("valueDuration", duration_decoder(), decode.success) |> decode.map(TaskInputValueDuration),decode.field("valueHumanName", humanname_decoder(), decode.success) |> decode.map(TaskInputValueHumanname),decode.field("valueIdentifier", identifier_decoder(), decode.success) |> decode.map(TaskInputValueIdentifier),decode.field("valueMoney", money_decoder(), decode.success) |> decode.map(TaskInputValueMoney),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(TaskInputValuePeriod),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(TaskInputValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(TaskInputValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(TaskInputValueRatio),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(TaskInputValueReference),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(TaskInputValueSampleddata),decode.field("valueSignature", signature_decoder(), decode.success) |> decode.map(TaskInputValueSignature),decode.field("valueTiming", timing_decoder(), decode.success) |> decode.map(TaskInputValueTiming),decode.field("valueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(TaskInputValueContactdetail),decode.field("valueContributor", contributor_decoder(), decode.success) |> decode.map(TaskInputValueContributor),decode.field("valueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(TaskInputValueDatarequirement),decode.field("valueExpression", expression_decoder(), decode.success) |> decode.map(TaskInputValueExpression),decode.field("valueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(TaskInputValueParameterdefinition),decode.field("valueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(TaskInputValueRelatedartifact),decode.field("valueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(TaskInputValueTriggerdefinition),decode.field("valueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(TaskInputValueUsagecontext),decode.field("valueDosage", dosage_decoder(), decode.success) |> decode.map(TaskInputValueDosage),decode.field("valueMeta", meta_decoder(), decode.success) |> decode.map(TaskInputValueMeta),])}
pub fn task_input_new(value value: TaskInputValue,type_ type_: Codeableconcept,) ->TaskInput{TaskInput(value:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type TaskOutput
{
TaskOutput(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Codeableconcept,
value: TaskOutputValue,
)
}

///http://hl7.org/fhir/r4/StructureDefinition/Task#resource
pub type TaskOutputValue{
TaskOutputValueBase64binary(value: String)
TaskOutputValueBoolean(value: Bool)
TaskOutputValueCanonical(value: String)
TaskOutputValueCode(value: String)
TaskOutputValueDate(value: String)
TaskOutputValueDatetime(value: String)
TaskOutputValueDecimal(value: Float)
TaskOutputValueId(value: String)
TaskOutputValueInstant(value: String)
TaskOutputValueInteger(value: Int)
TaskOutputValueMarkdown(value: String)
TaskOutputValueOid(value: String)
TaskOutputValuePositiveint(value: Int)
TaskOutputValueString(value: String)
TaskOutputValueTime(value: String)
TaskOutputValueUnsignedint(value: Int)
TaskOutputValueUri(value: String)
TaskOutputValueUrl(value: String)
TaskOutputValueUuid(value: String)
TaskOutputValueAddress(value: Address)
TaskOutputValueAge(value: Age)
TaskOutputValueAnnotation(value: Annotation)
TaskOutputValueAttachment(value: Attachment)
TaskOutputValueCodeableconcept(value: Codeableconcept)
TaskOutputValueCoding(value: Coding)
TaskOutputValueContactpoint(value: Contactpoint)
TaskOutputValueCount(value: Count)
TaskOutputValueDistance(value: Distance)
TaskOutputValueDuration(value: Duration)
TaskOutputValueHumanname(value: Humanname)
TaskOutputValueIdentifier(value: Identifier)
TaskOutputValueMoney(value: Money)
TaskOutputValuePeriod(value: Period)
TaskOutputValueQuantity(value: Quantity)
TaskOutputValueRange(value: Range)
TaskOutputValueRatio(value: Ratio)
TaskOutputValueReference(value: Reference)
TaskOutputValueSampleddata(value: Sampleddata)
TaskOutputValueSignature(value: Signature)
TaskOutputValueTiming(value: Timing)
TaskOutputValueContactdetail(value: Contactdetail)
TaskOutputValueContributor(value: Contributor)
TaskOutputValueDatarequirement(value: Datarequirement)
TaskOutputValueExpression(value: Expression)
TaskOutputValueParameterdefinition(value: Parameterdefinition)
TaskOutputValueRelatedartifact(value: Relatedartifact)
TaskOutputValueTriggerdefinition(value: Triggerdefinition)
TaskOutputValueUsagecontext(value: Usagecontext)
TaskOutputValueDosage(value: Dosage)
TaskOutputValueMeta(value: Meta)}
pub fn task_output_value_to_json(elt: TaskOutputValue) -> Json {case elt{TaskOutputValueBase64binary(v) -> json.string(v)
TaskOutputValueBoolean(v) -> json.bool(v)
TaskOutputValueCanonical(v) -> json.string(v)
TaskOutputValueCode(v) -> json.string(v)
TaskOutputValueDate(v) -> json.string(v)
TaskOutputValueDatetime(v) -> json.string(v)
TaskOutputValueDecimal(v) -> json.float(v)
TaskOutputValueId(v) -> json.string(v)
TaskOutputValueInstant(v) -> json.string(v)
TaskOutputValueInteger(v) -> json.int(v)
TaskOutputValueMarkdown(v) -> json.string(v)
TaskOutputValueOid(v) -> json.string(v)
TaskOutputValuePositiveint(v) -> json.int(v)
TaskOutputValueString(v) -> json.string(v)
TaskOutputValueTime(v) -> json.string(v)
TaskOutputValueUnsignedint(v) -> json.int(v)
TaskOutputValueUri(v) -> json.string(v)
TaskOutputValueUrl(v) -> json.string(v)
TaskOutputValueUuid(v) -> json.string(v)
TaskOutputValueAddress(v) -> address_to_json(v)
TaskOutputValueAge(v) -> age_to_json(v)
TaskOutputValueAnnotation(v) -> annotation_to_json(v)
TaskOutputValueAttachment(v) -> attachment_to_json(v)
TaskOutputValueCodeableconcept(v) -> codeableconcept_to_json(v)
TaskOutputValueCoding(v) -> coding_to_json(v)
TaskOutputValueContactpoint(v) -> contactpoint_to_json(v)
TaskOutputValueCount(v) -> count_to_json(v)
TaskOutputValueDistance(v) -> distance_to_json(v)
TaskOutputValueDuration(v) -> duration_to_json(v)
TaskOutputValueHumanname(v) -> humanname_to_json(v)
TaskOutputValueIdentifier(v) -> identifier_to_json(v)
TaskOutputValueMoney(v) -> money_to_json(v)
TaskOutputValuePeriod(v) -> period_to_json(v)
TaskOutputValueQuantity(v) -> quantity_to_json(v)
TaskOutputValueRange(v) -> range_to_json(v)
TaskOutputValueRatio(v) -> ratio_to_json(v)
TaskOutputValueReference(v) -> reference_to_json(v)
TaskOutputValueSampleddata(v) -> sampleddata_to_json(v)
TaskOutputValueSignature(v) -> signature_to_json(v)
TaskOutputValueTiming(v) -> timing_to_json(v)
TaskOutputValueContactdetail(v) -> contactdetail_to_json(v)
TaskOutputValueContributor(v) -> contributor_to_json(v)
TaskOutputValueDatarequirement(v) -> datarequirement_to_json(v)
TaskOutputValueExpression(v) -> expression_to_json(v)
TaskOutputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
TaskOutputValueRelatedartifact(v) -> relatedartifact_to_json(v)
TaskOutputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
TaskOutputValueUsagecontext(v) -> usagecontext_to_json(v)
TaskOutputValueDosage(v) -> dosage_to_json(v)
TaskOutputValueMeta(v) -> meta_to_json(v)
}}
pub fn task_output_value_decoder() -> Decoder(TaskOutputValue){decode.one_of(decode.field("valueBase64Binary", decode.string, decode.success) |> decode.map(TaskOutputValueBase64binary),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(TaskOutputValueBoolean),decode.field("valueCanonical", decode.string, decode.success) |> decode.map(TaskOutputValueCanonical),decode.field("valueCode", decode.string, decode.success) |> decode.map(TaskOutputValueCode),decode.field("valueDate", decode.string, decode.success) |> decode.map(TaskOutputValueDate),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(TaskOutputValueDatetime),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(TaskOutputValueDecimal),decode.field("valueId", decode.string, decode.success) |> decode.map(TaskOutputValueId),decode.field("valueInstant", decode.string, decode.success) |> decode.map(TaskOutputValueInstant),decode.field("valueInteger", decode.int, decode.success) |> decode.map(TaskOutputValueInteger),decode.field("valueMarkdown", decode.string, decode.success) |> decode.map(TaskOutputValueMarkdown),decode.field("valueOid", decode.string, decode.success) |> decode.map(TaskOutputValueOid),decode.field("valuePositiveInt", decode.int, decode.success) |> decode.map(TaskOutputValuePositiveint),decode.field("valueString", decode.string, decode.success) |> decode.map(TaskOutputValueString),decode.field("valueTime", decode.string, decode.success) |> decode.map(TaskOutputValueTime),decode.field("valueUnsignedInt", decode.int, decode.success) |> decode.map(TaskOutputValueUnsignedint),decode.field("valueUri", decode.string, decode.success) |> decode.map(TaskOutputValueUri),decode.field("valueUrl", decode.string, decode.success) |> decode.map(TaskOutputValueUrl),decode.field("valueUuid", decode.string, decode.success) |> decode.map(TaskOutputValueUuid),decode.field("valueAddress", address_decoder(), decode.success) |> decode.map(TaskOutputValueAddress),decode.field("valueAge", age_decoder(), decode.success) |> decode.map(TaskOutputValueAge),decode.field("valueAnnotation", annotation_decoder(), decode.success) |> decode.map(TaskOutputValueAnnotation),decode.field("valueAttachment", attachment_decoder(), decode.success) |> decode.map(TaskOutputValueAttachment),decode.field("valueCodeableConcept", codeableconcept_decoder(), decode.success) |> decode.map(TaskOutputValueCodeableconcept),decode.field("valueCoding", coding_decoder(), decode.success) |> decode.map(TaskOutputValueCoding),decode.field("valueContactPoint", contactpoint_decoder(), decode.success) |> decode.map(TaskOutputValueContactpoint),decode.field("valueCount", count_decoder(), decode.success) |> decode.map(TaskOutputValueCount),decode.field("valueDistance", distance_decoder(), decode.success) |> decode.map(TaskOutputValueDistance),decode.field("valueDuration", duration_decoder(), decode.success) |> decode.map(TaskOutputValueDuration),decode.field("valueHumanName", humanname_decoder(), decode.success) |> decode.map(TaskOutputValueHumanname),decode.field("valueIdentifier", identifier_decoder(), decode.success) |> decode.map(TaskOutputValueIdentifier),decode.field("valueMoney", money_decoder(), decode.success) |> decode.map(TaskOutputValueMoney),decode.field("valuePeriod", period_decoder(), decode.success) |> decode.map(TaskOutputValuePeriod),decode.field("valueQuantity", quantity_decoder(), decode.success) |> decode.map(TaskOutputValueQuantity),decode.field("valueRange", range_decoder(), decode.success) |> decode.map(TaskOutputValueRange),decode.field("valueRatio", ratio_decoder(), decode.success) |> decode.map(TaskOutputValueRatio),decode.field("valueReference", reference_decoder(), decode.success) |> decode.map(TaskOutputValueReference),decode.field("valueSampledData", sampleddata_decoder(), decode.success) |> decode.map(TaskOutputValueSampleddata),decode.field("valueSignature", signature_decoder(), decode.success) |> decode.map(TaskOutputValueSignature),decode.field("valueTiming", timing_decoder(), decode.success) |> decode.map(TaskOutputValueTiming),decode.field("valueContactDetail", contactdetail_decoder(), decode.success) |> decode.map(TaskOutputValueContactdetail),decode.field("valueContributor", contributor_decoder(), decode.success) |> decode.map(TaskOutputValueContributor),decode.field("valueDataRequirement", datarequirement_decoder(), decode.success) |> decode.map(TaskOutputValueDatarequirement),decode.field("valueExpression", expression_decoder(), decode.success) |> decode.map(TaskOutputValueExpression),decode.field("valueParameterDefinition", parameterdefinition_decoder(), decode.success) |> decode.map(TaskOutputValueParameterdefinition),decode.field("valueRelatedArtifact", relatedartifact_decoder(), decode.success) |> decode.map(TaskOutputValueRelatedartifact),decode.field("valueTriggerDefinition", triggerdefinition_decoder(), decode.success) |> decode.map(TaskOutputValueTriggerdefinition),decode.field("valueUsageContext", usagecontext_decoder(), decode.success) |> decode.map(TaskOutputValueUsagecontext),decode.field("valueDosage", dosage_decoder(), decode.success) |> decode.map(TaskOutputValueDosage),decode.field("valueMeta", meta_decoder(), decode.success) |> decode.map(TaskOutputValueMeta),])}
pub fn task_output_new(value value: TaskOutputValue,type_ type_: Codeableconcept,) ->TaskOutput{TaskOutput(value:,type_:,modifier_extension: [],extension: [],id: None,)
}

pub fn task_output_to_json(task_output: TaskOutput) -> Json {
    let TaskOutput(value:,type_:,modifier_extension:,extension:,id:,) = task_output
    let fields = [#("value", task_output_value_to_json(value)),#("type", codeableconcept_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn task_output_decoder() -> Decoder(TaskOutput) {use value <- decode.then(task_output_value_decoder())
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TaskOutput(value:,type_:,modifier_extension:,extension:,id:,))}
pub fn task_input_to_json(task_input: TaskInput) -> Json {
    let TaskInput(value:,type_:,modifier_extension:,extension:,id:,) = task_input
    let fields = [#("value", task_input_value_to_json(value)),#("type", codeableconcept_to_json(type_)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn task_input_decoder() -> Decoder(TaskInput) {use value <- decode.then(task_input_value_decoder())
use type_ <- decode.field("type",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TaskInput(value:,type_:,modifier_extension:,extension:,id:,))}
pub fn task_restriction_to_json(task_restriction: TaskRestriction) -> Json {
    let TaskRestriction(recipient:,period:,repetitions:,modifier_extension:,extension:,id:,) = task_restriction
    let fields = []
let fields = case recipient {
                        [] -> fields
                        _ -> [#("recipient", json.array(recipient,reference_to_json)), ..fields]
                          }
let fields = case period {
                          Some(v) -> [#("period", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case repetitions {
                          Some(v) -> [#("repetitions", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn task_restriction_decoder() -> Decoder(TaskRestriction) {use recipient <- decode.optional_field("recipient", [], decode.list(reference_decoder()))
use period <- decode.optional_field("period", None, decode.optional(period_decoder()))
use repetitions <- decode.optional_field("repetitions", None, decode.optional(decode.int))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TaskRestriction(recipient:,period:,repetitions:,modifier_extension:,extension:,id:,))}
pub fn task_to_json(task: Task) -> Json {
    let Task(output:,input:,restriction:,relevant_history:,note:,insurance:,reason_reference:,reason_code:,location:,owner:,performer_type:,requester:,last_modified:,authored_on:,execution_period:,encounter:,for:,focus:,description:,code:,priority:,intent:,business_status:,status_reason:,status:,part_of:,group_identifier:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = task
    let fields = [#("intent", r4valuesets.taskintent_to_json(intent)),#("status", r4valuesets.taskstatus_to_json(status)),]
let fields = case output {
                        [] -> fields
                        _ -> [#("output", json.array(output,task_output_to_json)), ..fields]
                          }
let fields = case input {
                        [] -> fields
                        _ -> [#("input", json.array(input,task_input_to_json)), ..fields]
                          }
let fields = case restriction {
                          Some(v) -> [#("restriction", task_restriction_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case relevant_history {
                        [] -> fields
                        _ -> [#("relevantHistory", json.array(relevant_history,reference_to_json)), ..fields]
                          }
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case insurance {
                        [] -> fields
                        _ -> [#("insurance", json.array(insurance,reference_to_json)), ..fields]
                          }
let fields = case reason_reference {
                          Some(v) -> [#("reasonReference", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case reason_code {
                          Some(v) -> [#("reasonCode", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case location {
                          Some(v) -> [#("location", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case owner {
                          Some(v) -> [#("owner", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case performer_type {
                        [] -> fields
                        _ -> [#("performerType", json.array(performer_type,codeableconcept_to_json)), ..fields]
                          }
let fields = case requester {
                          Some(v) -> [#("requester", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case last_modified {
                          Some(v) -> [#("lastModified", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case authored_on {
                          Some(v) -> [#("authoredOn", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case execution_period {
                          Some(v) -> [#("executionPeriod", period_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case for {
                          Some(v) -> [#("for", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case focus {
                          Some(v) -> [#("focus", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case priority {
                          Some(v) -> [#("priority", r4valuesets.requestpriority_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case business_status {
                          Some(v) -> [#("businessStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_reason {
                          Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case part_of {
                        [] -> fields
                        _ -> [#("partOf", json.array(part_of,reference_to_json)), ..fields]
                          }
let fields = case group_identifier {
                          Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case based_on {
                        [] -> fields
                        _ -> [#("basedOn", json.array(based_on,reference_to_json)), ..fields]
                          }
let fields = case instantiates_uri {
                          Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case instantiates_canonical {
                          Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn task_decoder() -> Decoder(Task) {use output <- decode.optional_field("output", [], decode.list(task_output_decoder()))
use input <- decode.optional_field("input", [], decode.list(task_input_decoder()))
use restriction <- decode.optional_field("restriction", None, decode.optional(task_restriction_decoder()))
use relevant_history <- decode.optional_field("relevantHistory", [], decode.list(reference_decoder()))
use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use insurance <- decode.optional_field("insurance", [], decode.list(reference_decoder()))
use reason_reference <- decode.optional_field("reasonReference", None, decode.optional(reference_decoder()))
use reason_code <- decode.optional_field("reasonCode", None, decode.optional(codeableconcept_decoder()))
use location <- decode.optional_field("location", None, decode.optional(reference_decoder()))
use owner <- decode.optional_field("owner", None, decode.optional(reference_decoder()))
use performer_type <- decode.optional_field("performerType", [], decode.list(codeableconcept_decoder()))
use requester <- decode.optional_field("requester", None, decode.optional(reference_decoder()))
use last_modified <- decode.optional_field("lastModified", None, decode.optional(decode.string))
use authored_on <- decode.optional_field("authoredOn", None, decode.optional(decode.string))
use execution_period <- decode.optional_field("executionPeriod", None, decode.optional(period_decoder()))
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use for <- decode.optional_field("for", None, decode.optional(reference_decoder()))
use focus <- decode.optional_field("focus", None, decode.optional(reference_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(codeableconcept_decoder()))
use priority <- decode.optional_field("priority", None, decode.optional(r4valuesets.requestpriority_decoder()))
use intent <- decode.field("intent",r4valuesets.taskintent_decoder())
use business_status <- decode.optional_field("businessStatus", None, decode.optional(codeableconcept_decoder()))
use status_reason <- decode.optional_field("statusReason", None, decode.optional(codeableconcept_decoder()))
use status <- decode.field("status",r4valuesets.taskstatus_decoder())
use part_of <- decode.optional_field("partOf", [], decode.list(reference_decoder()))
use group_identifier <- decode.optional_field("groupIdentifier", None, decode.optional(identifier_decoder()))
use based_on <- decode.optional_field("basedOn", [], decode.list(reference_decoder()))
use instantiates_uri <- decode.optional_field("instantiatesUri", None, decode.optional(decode.string))
use instantiates_canonical <- decode.optional_field("instantiatesCanonical", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Task(output:,input:,restriction:,relevant_history:,note:,insurance:,reason_reference:,reason_code:,location:,owner:,performer_type:,requester:,last_modified:,authored_on:,execution_period:,encounter:,for:,focus:,description:,code:,priority:,intent:,business_status:,status_reason:,status:,part_of:,group_identifier:,based_on:,instantiates_uri:,instantiates_canonical:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type Terminologycapabilities
{
Terminologycapabilities(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: String,
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
kind: r4valuesets.Capabilitystatementkind,
software: Option(TerminologycapabilitiesSoftware),
implementation: Option(TerminologycapabilitiesImplementation),
locked_date: Option(Bool),
code_system: List(TerminologycapabilitiesCodesystem),
expansion: Option(TerminologycapabilitiesExpansion),
code_search: Option(r4valuesets.Codesearchsupport),
validate_code: Option(TerminologycapabilitiesValidatecode),
translation: Option(TerminologycapabilitiesTranslation),
closure: Option(TerminologycapabilitiesClosure),
)
}

pub fn terminologycapabilities_new(kind kind: r4valuesets.Capabilitystatementkind,date date: String,status status: r4valuesets.Publicationstatus,) ->Terminologycapabilities{Terminologycapabilities(closure: None,translation: None,validate_code: None,code_search: None,expansion: None,code_system: [],locked_date: None,implementation: None,software: None,kind:,copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date:,experimental: None,status:,title: None,name: None,version: None,url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesSoftware
{
TerminologycapabilitiesSoftware(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
version: Option(String),
)
}

pub fn terminologycapabilities_software_new(name name: String,) ->TerminologycapabilitiesSoftware{TerminologycapabilitiesSoftware(version: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesImplementation
{
TerminologycapabilitiesImplementation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
description: String,
url: Option(String),
)
}

pub fn terminologycapabilities_implementation_new(description description: String,) ->TerminologycapabilitiesImplementation{TerminologycapabilitiesImplementation(url: None,description:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystem
{
TerminologycapabilitiesCodesystem(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
uri: Option(String),
version: List(TerminologycapabilitiesCodesystemVersion),
subsumption: Option(Bool),
)
}

pub fn terminologycapabilities_codesystem_new() ->TerminologycapabilitiesCodesystem{TerminologycapabilitiesCodesystem(subsumption: None,version: [],uri: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersion
{
TerminologycapabilitiesCodesystemVersion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: Option(String),
is_default: Option(Bool),
compositional: Option(Bool),
language: List(String),
filter: List(TerminologycapabilitiesCodesystemVersionFilter),
property: List(String),
)
}

pub fn terminologycapabilities_codesystem_version_new() ->TerminologycapabilitiesCodesystemVersion{TerminologycapabilitiesCodesystemVersion(property: [],filter: [],language: [],compositional: None,is_default: None,code: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersionFilter
{
TerminologycapabilitiesCodesystemVersionFilter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
op: List(String),
)
}

pub fn terminologycapabilities_codesystem_version_filter_new(code code: String,) ->TerminologycapabilitiesCodesystemVersionFilter{TerminologycapabilitiesCodesystemVersionFilter(op: [],code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansion
{
TerminologycapabilitiesExpansion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
hierarchical: Option(Bool),
paging: Option(Bool),
incomplete: Option(Bool),
parameter: List(TerminologycapabilitiesExpansionParameter),
text_filter: Option(String),
)
}

pub fn terminologycapabilities_expansion_new() ->TerminologycapabilitiesExpansion{TerminologycapabilitiesExpansion(text_filter: None,parameter: [],incomplete: None,paging: None,hierarchical: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansionParameter
{
TerminologycapabilitiesExpansionParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
documentation: Option(String),
)
}

pub fn terminologycapabilities_expansion_parameter_new(name name: String,) ->TerminologycapabilitiesExpansionParameter{TerminologycapabilitiesExpansionParameter(documentation: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesValidatecode
{
TerminologycapabilitiesValidatecode(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
translations: Bool,
)
}

pub fn terminologycapabilities_validatecode_new(translations translations: Bool,) ->TerminologycapabilitiesValidatecode{TerminologycapabilitiesValidatecode(translations:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesTranslation
{
TerminologycapabilitiesTranslation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
needs_map: Bool,
)
}

pub fn terminologycapabilities_translation_new(needs_map needs_map: Bool,) ->TerminologycapabilitiesTranslation{TerminologycapabilitiesTranslation(needs_map:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesClosure
{
TerminologycapabilitiesClosure(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
translation: Option(Bool),
)
}

pub fn terminologycapabilities_closure_new() ->TerminologycapabilitiesClosure{TerminologycapabilitiesClosure(translation: None,modifier_extension: [],extension: [],id: None,)
}

pub fn terminologycapabilities_closure_to_json(terminologycapabilities_closure: TerminologycapabilitiesClosure) -> Json {
    let TerminologycapabilitiesClosure(translation:,modifier_extension:,extension:,id:,) = terminologycapabilities_closure
    let fields = []
let fields = case translation {
                          Some(v) -> [#("translation", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_closure_decoder() -> Decoder(TerminologycapabilitiesClosure) {use translation <- decode.optional_field("translation", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesClosure(translation:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_translation_to_json(terminologycapabilities_translation: TerminologycapabilitiesTranslation) -> Json {
    let TerminologycapabilitiesTranslation(needs_map:,modifier_extension:,extension:,id:,) = terminologycapabilities_translation
    let fields = [#("needsMap", json.bool(needs_map)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_translation_decoder() -> Decoder(TerminologycapabilitiesTranslation) {use needs_map <- decode.field("needsMap",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesTranslation(needs_map:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_validatecode_to_json(terminologycapabilities_validatecode: TerminologycapabilitiesValidatecode) -> Json {
    let TerminologycapabilitiesValidatecode(translations:,modifier_extension:,extension:,id:,) = terminologycapabilities_validatecode
    let fields = [#("translations", json.bool(translations)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_validatecode_decoder() -> Decoder(TerminologycapabilitiesValidatecode) {use translations <- decode.field("translations",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesValidatecode(translations:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_expansion_parameter_to_json(terminologycapabilities_expansion_parameter: TerminologycapabilitiesExpansionParameter) -> Json {
    let TerminologycapabilitiesExpansionParameter(documentation:,name:,modifier_extension:,extension:,id:,) = terminologycapabilities_expansion_parameter
    let fields = [#("name", json.string(name)),]
let fields = case documentation {
                          Some(v) -> [#("documentation", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_expansion_parameter_decoder() -> Decoder(TerminologycapabilitiesExpansionParameter) {use documentation <- decode.optional_field("documentation", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesExpansionParameter(documentation:,name:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_expansion_to_json(terminologycapabilities_expansion: TerminologycapabilitiesExpansion) -> Json {
    let TerminologycapabilitiesExpansion(text_filter:,parameter:,incomplete:,paging:,hierarchical:,modifier_extension:,extension:,id:,) = terminologycapabilities_expansion
    let fields = []
let fields = case text_filter {
                          Some(v) -> [#("textFilter", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,terminologycapabilities_expansion_parameter_to_json)), ..fields]
                          }
let fields = case incomplete {
                          Some(v) -> [#("incomplete", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case paging {
                          Some(v) -> [#("paging", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case hierarchical {
                          Some(v) -> [#("hierarchical", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_expansion_decoder() -> Decoder(TerminologycapabilitiesExpansion) {use text_filter <- decode.optional_field("textFilter", None, decode.optional(decode.string))
use parameter <- decode.optional_field("parameter", [], decode.list(terminologycapabilities_expansion_parameter_decoder()))
use incomplete <- decode.optional_field("incomplete", None, decode.optional(decode.bool))
use paging <- decode.optional_field("paging", None, decode.optional(decode.bool))
use hierarchical <- decode.optional_field("hierarchical", None, decode.optional(decode.bool))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesExpansion(text_filter:,parameter:,incomplete:,paging:,hierarchical:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_codesystem_version_filter_to_json(terminologycapabilities_codesystem_version_filter: TerminologycapabilitiesCodesystemVersionFilter) -> Json {
    let TerminologycapabilitiesCodesystemVersionFilter(op:,code:,modifier_extension:,extension:,id:,) = terminologycapabilities_codesystem_version_filter
    let fields = [#("code", json.string(code)),]
let fields = case op {
                        [] -> fields
                        _ -> [#("op", json.array(op,json.string)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_codesystem_version_filter_decoder() -> Decoder(TerminologycapabilitiesCodesystemVersionFilter) {use op <- decode.optional_field("op", [], decode.list(decode.string))
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesCodesystemVersionFilter(op:,code:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_codesystem_version_to_json(terminologycapabilities_codesystem_version: TerminologycapabilitiesCodesystemVersion) -> Json {
    let TerminologycapabilitiesCodesystemVersion(property:,filter:,language:,compositional:,is_default:,code:,modifier_extension:,extension:,id:,) = terminologycapabilities_codesystem_version
    let fields = []
let fields = case property {
                        [] -> fields
                        _ -> [#("property", json.array(property,json.string)), ..fields]
                          }
let fields = case filter {
                        [] -> fields
                        _ -> [#("filter", json.array(filter,terminologycapabilities_codesystem_version_filter_to_json)), ..fields]
                          }
let fields = case language {
                        [] -> fields
                        _ -> [#("language", json.array(language,json.string)), ..fields]
                          }
let fields = case compositional {
                          Some(v) -> [#("compositional", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case is_default {
                          Some(v) -> [#("isDefault", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_codesystem_version_decoder() -> Decoder(TerminologycapabilitiesCodesystemVersion) {use property <- decode.optional_field("property", [], decode.list(decode.string))
use filter <- decode.optional_field("filter", [], decode.list(terminologycapabilities_codesystem_version_filter_decoder()))
use language <- decode.optional_field("language", [], decode.list(decode.string))
use compositional <- decode.optional_field("compositional", None, decode.optional(decode.bool))
use is_default <- decode.optional_field("isDefault", None, decode.optional(decode.bool))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesCodesystemVersion(property:,filter:,language:,compositional:,is_default:,code:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_codesystem_to_json(terminologycapabilities_codesystem: TerminologycapabilitiesCodesystem) -> Json {
    let TerminologycapabilitiesCodesystem(subsumption:,version:,uri:,modifier_extension:,extension:,id:,) = terminologycapabilities_codesystem
    let fields = []
let fields = case subsumption {
                          Some(v) -> [#("subsumption", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                        [] -> fields
                        _ -> [#("version", json.array(version,terminologycapabilities_codesystem_version_to_json)), ..fields]
                          }
let fields = case uri {
                          Some(v) -> [#("uri", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_codesystem_decoder() -> Decoder(TerminologycapabilitiesCodesystem) {use subsumption <- decode.optional_field("subsumption", None, decode.optional(decode.bool))
use version <- decode.optional_field("version", [], decode.list(terminologycapabilities_codesystem_version_decoder()))
use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesCodesystem(subsumption:,version:,uri:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_implementation_to_json(terminologycapabilities_implementation: TerminologycapabilitiesImplementation) -> Json {
    let TerminologycapabilitiesImplementation(url:,description:,modifier_extension:,extension:,id:,) = terminologycapabilities_implementation
    let fields = [#("description", json.string(description)),]
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_implementation_decoder() -> Decoder(TerminologycapabilitiesImplementation) {use url <- decode.optional_field("url", None, decode.optional(decode.string))
use description <- decode.field("description",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesImplementation(url:,description:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_software_to_json(terminologycapabilities_software: TerminologycapabilitiesSoftware) -> Json {
    let TerminologycapabilitiesSoftware(version:,name:,modifier_extension:,extension:,id:,) = terminologycapabilities_software
    let fields = [#("name", json.string(name)),]
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_software_decoder() -> Decoder(TerminologycapabilitiesSoftware) {use version <- decode.optional_field("version", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TerminologycapabilitiesSoftware(version:,name:,modifier_extension:,extension:,id:,))}
pub fn terminologycapabilities_to_json(terminologycapabilities: Terminologycapabilities) -> Json {
    let Terminologycapabilities(closure:,translation:,validate_code:,code_search:,expansion:,code_system:,locked_date:,implementation:,software:,kind:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = terminologycapabilities
    let fields = [#("kind", r4valuesets.capabilitystatementkind_to_json(kind)),#("date", json.string(date)),#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case closure {
                          Some(v) -> [#("closure", terminologycapabilities_closure_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case translation {
                          Some(v) -> [#("translation", terminologycapabilities_translation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case validate_code {
                          Some(v) -> [#("validateCode", terminologycapabilities_validatecode_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code_search {
                          Some(v) -> [#("codeSearch", r4valuesets.codesearchsupport_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case expansion {
                          Some(v) -> [#("expansion", terminologycapabilities_expansion_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case code_system {
                        [] -> fields
                        _ -> [#("codeSystem", json.array(code_system,terminologycapabilities_codesystem_to_json)), ..fields]
                          }
let fields = case locked_date {
                          Some(v) -> [#("lockedDate", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case implementation {
                          Some(v) -> [#("implementation", terminologycapabilities_implementation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case software {
                          Some(v) -> [#("software", terminologycapabilities_software_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn terminologycapabilities_decoder() -> Decoder(Terminologycapabilities) {use closure <- decode.optional_field("closure", None, decode.optional(terminologycapabilities_closure_decoder()))
use translation <- decode.optional_field("translation", None, decode.optional(terminologycapabilities_translation_decoder()))
use validate_code <- decode.optional_field("validateCode", None, decode.optional(terminologycapabilities_validatecode_decoder()))
use code_search <- decode.optional_field("codeSearch", None, decode.optional(r4valuesets.codesearchsupport_decoder()))
use expansion <- decode.optional_field("expansion", None, decode.optional(terminologycapabilities_expansion_decoder()))
use code_system <- decode.optional_field("codeSystem", [], decode.list(terminologycapabilities_codesystem_decoder()))
use locked_date <- decode.optional_field("lockedDate", None, decode.optional(decode.bool))
use implementation <- decode.optional_field("implementation", None, decode.optional(terminologycapabilities_implementation_decoder()))
use software <- decode.optional_field("software", None, decode.optional(terminologycapabilities_software_decoder()))
use kind <- decode.field("kind",r4valuesets.capabilitystatementkind_decoder())
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.field("date",decode.string)
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Terminologycapabilities(closure:,translation:,validate_code:,code_search:,expansion:,code_system:,locked_date:,implementation:,software:,kind:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type Testreport
{
Testreport(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(Identifier),
name: Option(String),
status: r4valuesets.Reportstatuscodes,
test_script: Reference,
result: r4valuesets.Reportresultcodes,
score: Option(Float),
tester: Option(String),
issued: Option(String),
participant: List(TestreportParticipant),
setup: Option(TestreportSetup),
test_: List(TestreportTest),
teardown: Option(TestreportTeardown),
)
}

pub fn testreport_new(result result: r4valuesets.Reportresultcodes,test_script test_script: Reference,status status: r4valuesets.Reportstatuscodes,) ->Testreport{Testreport(teardown: None,test_: [],setup: None,participant: [],issued: None,tester: None,score: None,result:,test_script:,status:,name: None,identifier: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportParticipant
{
TestreportParticipant(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: r4valuesets.Reportparticipanttype,
uri: String,
display: Option(String),
)
}

pub fn testreport_participant_new(uri uri: String,type_ type_: r4valuesets.Reportparticipanttype,) ->TestreportParticipant{TestreportParticipant(display: None,uri:,type_:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportSetup
{
TestreportSetup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: List(TestreportSetupAction),
)
}

pub fn testreport_setup_new() ->TestreportSetup{TestreportSetup(action: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportSetupAction
{
TestreportSetupAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
operation: Option(TestreportSetupActionOperation),
assert_: Option(TestreportSetupActionAssert),
)
}

pub fn testreport_setup_action_new() ->TestreportSetupAction{TestreportSetupAction(assert_: None,operation: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportSetupActionOperation
{
TestreportSetupActionOperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
result: r4valuesets.Reportactionresultcodes,
message: Option(String),
detail: Option(String),
)
}

pub fn testreport_setup_action_operation_new(result result: r4valuesets.Reportactionresultcodes,) ->TestreportSetupActionOperation{TestreportSetupActionOperation(detail: None,message: None,result:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportSetupActionAssert
{
TestreportSetupActionAssert(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
result: r4valuesets.Reportactionresultcodes,
message: Option(String),
detail: Option(String),
)
}

pub fn testreport_setup_action_assert_new(result result: r4valuesets.Reportactionresultcodes,) ->TestreportSetupActionAssert{TestreportSetupActionAssert(detail: None,message: None,result:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportTest
{
TestreportTest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: Option(String),
description: Option(String),
action: List(TestreportTestAction),
)
}

pub fn testreport_test_new() ->TestreportTest{TestreportTest(action: [],description: None,name: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportTestAction
{
TestreportTestAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
)
}

pub fn testreport_test_action_new() ->TestreportTestAction{TestreportTestAction(modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportTeardown
{
TestreportTeardown(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: List(TestreportTeardownAction),
)
}

pub fn testreport_teardown_new() ->TestreportTeardown{TestreportTeardown(action: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestReport#resource
pub type TestreportTeardownAction
{
TestreportTeardownAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
)
}

pub fn testreport_teardown_action_new() ->TestreportTeardownAction{TestreportTeardownAction(modifier_extension: [],extension: [],id: None,)
}

pub fn testreport_teardown_action_to_json(testreport_teardown_action: TestreportTeardownAction) -> Json {
    let TestreportTeardownAction(modifier_extension:,extension:,id:,) = testreport_teardown_action
    let fields = []
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_teardown_action_decoder() -> Decoder(TestreportTeardownAction) {use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportTeardownAction(modifier_extension:,extension:,id:,))}
pub fn testreport_teardown_to_json(testreport_teardown: TestreportTeardown) -> Json {
    let TestreportTeardown(action:,modifier_extension:,extension:,id:,) = testreport_teardown
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testreport_teardown_action_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_teardown_decoder() -> Decoder(TestreportTeardown) {use action <- decode.optional_field("action", [], decode.list(testreport_teardown_action_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportTeardown(action:,modifier_extension:,extension:,id:,))}
pub fn testreport_test_action_to_json(testreport_test_action: TestreportTestAction) -> Json {
    let TestreportTestAction(modifier_extension:,extension:,id:,) = testreport_test_action
    let fields = []
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_test_action_decoder() -> Decoder(TestreportTestAction) {use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportTestAction(modifier_extension:,extension:,id:,))}
pub fn testreport_test_to_json(testreport_test: TestreportTest) -> Json {
    let TestreportTest(action:,description:,name:,modifier_extension:,extension:,id:,) = testreport_test
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testreport_test_action_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_test_decoder() -> Decoder(TestreportTest) {use action <- decode.optional_field("action", [], decode.list(testreport_test_action_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportTest(action:,description:,name:,modifier_extension:,extension:,id:,))}
pub fn testreport_setup_action_assert_to_json(testreport_setup_action_assert: TestreportSetupActionAssert) -> Json {
    let TestreportSetupActionAssert(detail:,message:,result:,modifier_extension:,extension:,id:,) = testreport_setup_action_assert
    let fields = [#("result", r4valuesets.reportactionresultcodes_to_json(result)),]
let fields = case detail {
                          Some(v) -> [#("detail", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case message {
                          Some(v) -> [#("message", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_setup_action_assert_decoder() -> Decoder(TestreportSetupActionAssert) {use detail <- decode.optional_field("detail", None, decode.optional(decode.string))
use message <- decode.optional_field("message", None, decode.optional(decode.string))
use result <- decode.field("result",r4valuesets.reportactionresultcodes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportSetupActionAssert(detail:,message:,result:,modifier_extension:,extension:,id:,))}
pub fn testreport_setup_action_operation_to_json(testreport_setup_action_operation: TestreportSetupActionOperation) -> Json {
    let TestreportSetupActionOperation(detail:,message:,result:,modifier_extension:,extension:,id:,) = testreport_setup_action_operation
    let fields = [#("result", r4valuesets.reportactionresultcodes_to_json(result)),]
let fields = case detail {
                          Some(v) -> [#("detail", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case message {
                          Some(v) -> [#("message", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_setup_action_operation_decoder() -> Decoder(TestreportSetupActionOperation) {use detail <- decode.optional_field("detail", None, decode.optional(decode.string))
use message <- decode.optional_field("message", None, decode.optional(decode.string))
use result <- decode.field("result",r4valuesets.reportactionresultcodes_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportSetupActionOperation(detail:,message:,result:,modifier_extension:,extension:,id:,))}
pub fn testreport_setup_action_to_json(testreport_setup_action: TestreportSetupAction) -> Json {
    let TestreportSetupAction(assert_:,operation:,modifier_extension:,extension:,id:,) = testreport_setup_action
    let fields = []
let fields = case assert_ {
                          Some(v) -> [#("assert", testreport_setup_action_assert_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case operation {
                          Some(v) -> [#("operation", testreport_setup_action_operation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_setup_action_decoder() -> Decoder(TestreportSetupAction) {use assert_ <- decode.optional_field("assert", None, decode.optional(testreport_setup_action_assert_decoder()))
use operation <- decode.optional_field("operation", None, decode.optional(testreport_setup_action_operation_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportSetupAction(assert_:,operation:,modifier_extension:,extension:,id:,))}
pub fn testreport_setup_to_json(testreport_setup: TestreportSetup) -> Json {
    let TestreportSetup(action:,modifier_extension:,extension:,id:,) = testreport_setup
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testreport_setup_action_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_setup_decoder() -> Decoder(TestreportSetup) {use action <- decode.optional_field("action", [], decode.list(testreport_setup_action_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportSetup(action:,modifier_extension:,extension:,id:,))}
pub fn testreport_participant_to_json(testreport_participant: TestreportParticipant) -> Json {
    let TestreportParticipant(display:,uri:,type_:,modifier_extension:,extension:,id:,) = testreport_participant
    let fields = [#("uri", json.string(uri)),#("type", r4valuesets.reportparticipanttype_to_json(type_)),]
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_participant_decoder() -> Decoder(TestreportParticipant) {use display <- decode.optional_field("display", None, decode.optional(decode.string))
use uri <- decode.field("uri",decode.string)
use type_ <- decode.field("type",r4valuesets.reportparticipanttype_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestreportParticipant(display:,uri:,type_:,modifier_extension:,extension:,id:,))}
pub fn testreport_to_json(testreport: Testreport) -> Json {
    let Testreport(teardown:,test_:,setup:,participant:,issued:,tester:,score:,result:,test_script:,status:,name:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = testreport
    let fields = [#("result", r4valuesets.reportresultcodes_to_json(result)),#("testScript", reference_to_json(test_script)),#("status", r4valuesets.reportstatuscodes_to_json(status)),]
let fields = case teardown {
                          Some(v) -> [#("teardown", testreport_teardown_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case test_ {
                        [] -> fields
                        _ -> [#("test", json.array(test_,testreport_test_to_json)), ..fields]
                          }
let fields = case setup {
                          Some(v) -> [#("setup", testreport_setup_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case participant {
                        [] -> fields
                        _ -> [#("participant", json.array(participant,testreport_participant_to_json)), ..fields]
                          }
let fields = case issued {
                          Some(v) -> [#("issued", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case tester {
                          Some(v) -> [#("tester", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case score {
                          Some(v) -> [#("score", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testreport_decoder() -> Decoder(Testreport) {use teardown <- decode.optional_field("teardown", None, decode.optional(testreport_teardown_decoder()))
use test_ <- decode.optional_field("test", [], decode.list(testreport_test_decoder()))
use setup <- decode.optional_field("setup", None, decode.optional(testreport_setup_decoder()))
use participant <- decode.optional_field("participant", [], decode.list(testreport_participant_decoder()))
use issued <- decode.optional_field("issued", None, decode.optional(decode.string))
use tester <- decode.optional_field("tester", None, decode.optional(decode.string))
use score <- decode.optional_field("score", None, decode.optional(decode.float))
use result <- decode.field("result",r4valuesets.reportresultcodes_decoder())
use test_script <- decode.field("testScript",reference_decoder())
use status <- decode.field("status",r4valuesets.reportstatuscodes_decoder())
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Testreport(teardown:,test_:,setup:,participant:,issued:,tester:,score:,result:,test_script:,status:,name:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type Testscript
{
Testscript(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
identifier: Option(Identifier),
version: Option(String),
name: String,
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
purpose: Option(String),
copyright: Option(String),
origin: List(TestscriptOrigin),
destination: List(TestscriptDestination),
metadata: Option(TestscriptMetadata),
fixture: List(TestscriptFixture),
profile: List(Reference),
variable: List(TestscriptVariable),
setup: Option(TestscriptSetup),
test_: List(TestscriptTest),
teardown: Option(TestscriptTeardown),
)
}

pub fn testscript_new(status status: r4valuesets.Publicationstatus,name name: String,url url: String,) ->Testscript{Testscript(teardown: None,test_: [],setup: None,variable: [],profile: [],fixture: [],metadata: None,destination: [],origin: [],copyright: None,purpose: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name:,version: None,identifier: None,url:,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptOrigin
{
TestscriptOrigin(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
index: Int,
profile: Coding,
)
}

pub fn testscript_origin_new(profile profile: Coding,index index: Int,) ->TestscriptOrigin{TestscriptOrigin(profile:,index:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptDestination
{
TestscriptDestination(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
index: Int,
profile: Coding,
)
}

pub fn testscript_destination_new(profile profile: Coding,index index: Int,) ->TestscriptDestination{TestscriptDestination(profile:,index:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptMetadata
{
TestscriptMetadata(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
link: List(TestscriptMetadataLink),
capability: List(TestscriptMetadataCapability),
)
}

pub fn testscript_metadata_new() ->TestscriptMetadata{TestscriptMetadata(capability: [],link: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptMetadataLink
{
TestscriptMetadataLink(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
url: String,
description: Option(String),
)
}

pub fn testscript_metadata_link_new(url url: String,) ->TestscriptMetadataLink{TestscriptMetadataLink(description: None,url:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptMetadataCapability
{
TestscriptMetadataCapability(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
required: Bool,
validated: Bool,
description: Option(String),
origin: List(Int),
destination: Option(Int),
link: List(String),
capabilities: String,
)
}

pub fn testscript_metadata_capability_new(capabilities capabilities: String,validated validated: Bool,required required: Bool,) ->TestscriptMetadataCapability{TestscriptMetadataCapability(capabilities:,link: [],destination: None,origin: [],description: None,validated:,required:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptFixture
{
TestscriptFixture(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
autocreate: Bool,
autodelete: Bool,
resource: Option(Reference),
)
}

pub fn testscript_fixture_new(autodelete autodelete: Bool,autocreate autocreate: Bool,) ->TestscriptFixture{TestscriptFixture(resource: None,autodelete:,autocreate:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptVariable
{
TestscriptVariable(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
default_value: Option(String),
description: Option(String),
expression: Option(String),
header_field: Option(String),
hint: Option(String),
path: Option(String),
source_id: Option(String),
)
}

pub fn testscript_variable_new(name name: String,) ->TestscriptVariable{TestscriptVariable(source_id: None,path: None,hint: None,header_field: None,expression: None,description: None,default_value: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptSetup
{
TestscriptSetup(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: List(TestscriptSetupAction),
)
}

pub fn testscript_setup_new() ->TestscriptSetup{TestscriptSetup(action: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptSetupAction
{
TestscriptSetupAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
operation: Option(TestscriptSetupActionOperation),
assert_: Option(TestscriptSetupActionAssert),
)
}

pub fn testscript_setup_action_new() ->TestscriptSetupAction{TestscriptSetupAction(assert_: None,operation: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperation
{
TestscriptSetupActionOperation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
type_: Option(Coding),
resource: Option(r4valuesets.Definedtypes),
label: Option(String),
description: Option(String),
accept: Option(String),
content_type: Option(String),
destination: Option(Int),
encode_request_url: Bool,
method: Option(r4valuesets.Httpoperations),
origin: Option(Int),
params: Option(String),
request_header: List(TestscriptSetupActionOperationRequestheader),
request_id: Option(String),
response_id: Option(String),
source_id: Option(String),
target_id: Option(String),
url: Option(String),
)
}

pub fn testscript_setup_action_operation_new(encode_request_url encode_request_url: Bool,) ->TestscriptSetupActionOperation{TestscriptSetupActionOperation(url: None,target_id: None,source_id: None,response_id: None,request_id: None,request_header: [],params: None,origin: None,method: None,encode_request_url:,destination: None,content_type: None,accept: None,description: None,label: None,resource: None,type_: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperationRequestheader
{
TestscriptSetupActionOperationRequestheader(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
field: String,
value: String,
)
}

pub fn testscript_setup_action_operation_requestheader_new(value value: String,field field: String,) ->TestscriptSetupActionOperationRequestheader{TestscriptSetupActionOperationRequestheader(value:,field:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionAssert
{
TestscriptSetupActionAssert(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
label: Option(String),
description: Option(String),
direction: Option(r4valuesets.Assertdirectioncodes),
compare_to_source_id: Option(String),
compare_to_source_expression: Option(String),
compare_to_source_path: Option(String),
content_type: Option(String),
expression: Option(String),
header_field: Option(String),
minimum_id: Option(String),
navigation_links: Option(Bool),
operator: Option(r4valuesets.Assertoperatorcodes),
path: Option(String),
request_method: Option(r4valuesets.Httpoperations),
request_url: Option(String),
resource: Option(r4valuesets.Definedtypes),
response: Option(r4valuesets.Assertresponsecodetypes),
response_code: Option(String),
source_id: Option(String),
validate_profile_id: Option(String),
value: Option(String),
warning_only: Bool,
)
}

pub fn testscript_setup_action_assert_new(warning_only warning_only: Bool,) ->TestscriptSetupActionAssert{TestscriptSetupActionAssert(warning_only:,value: None,validate_profile_id: None,source_id: None,response_code: None,response: None,resource: None,request_url: None,request_method: None,path: None,operator: None,navigation_links: None,minimum_id: None,header_field: None,expression: None,content_type: None,compare_to_source_path: None,compare_to_source_expression: None,compare_to_source_id: None,direction: None,description: None,label: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptTest
{
TestscriptTest(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: Option(String),
description: Option(String),
action: List(TestscriptTestAction),
)
}

pub fn testscript_test_new() ->TestscriptTest{TestscriptTest(action: [],description: None,name: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptTestAction
{
TestscriptTestAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
)
}

pub fn testscript_test_action_new() ->TestscriptTestAction{TestscriptTestAction(modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptTeardown
{
TestscriptTeardown(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
action: List(TestscriptTeardownAction),
)
}

pub fn testscript_teardown_new() ->TestscriptTeardown{TestscriptTeardown(action: [],modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/TestScript#resource
pub type TestscriptTeardownAction
{
TestscriptTeardownAction(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
)
}

pub fn testscript_teardown_action_new() ->TestscriptTeardownAction{TestscriptTeardownAction(modifier_extension: [],extension: [],id: None,)
}

pub fn testscript_teardown_action_to_json(testscript_teardown_action: TestscriptTeardownAction) -> Json {
    let TestscriptTeardownAction(modifier_extension:,extension:,id:,) = testscript_teardown_action
    let fields = []
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_teardown_action_decoder() -> Decoder(TestscriptTeardownAction) {use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptTeardownAction(modifier_extension:,extension:,id:,))}
pub fn testscript_teardown_to_json(testscript_teardown: TestscriptTeardown) -> Json {
    let TestscriptTeardown(action:,modifier_extension:,extension:,id:,) = testscript_teardown
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testscript_teardown_action_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_teardown_decoder() -> Decoder(TestscriptTeardown) {use action <- decode.optional_field("action", [], decode.list(testscript_teardown_action_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptTeardown(action:,modifier_extension:,extension:,id:,))}
pub fn testscript_test_action_to_json(testscript_test_action: TestscriptTestAction) -> Json {
    let TestscriptTestAction(modifier_extension:,extension:,id:,) = testscript_test_action
    let fields = []
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_test_action_decoder() -> Decoder(TestscriptTestAction) {use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptTestAction(modifier_extension:,extension:,id:,))}
pub fn testscript_test_to_json(testscript_test: TestscriptTest) -> Json {
    let TestscriptTest(action:,description:,name:,modifier_extension:,extension:,id:,) = testscript_test
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testscript_test_action_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_test_decoder() -> Decoder(TestscriptTest) {use action <- decode.optional_field("action", [], decode.list(testscript_test_action_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptTest(action:,description:,name:,modifier_extension:,extension:,id:,))}
pub fn testscript_setup_action_assert_to_json(testscript_setup_action_assert: TestscriptSetupActionAssert) -> Json {
    let TestscriptSetupActionAssert(warning_only:,value:,validate_profile_id:,source_id:,response_code:,response:,resource:,request_url:,request_method:,path:,operator:,navigation_links:,minimum_id:,header_field:,expression:,content_type:,compare_to_source_path:,compare_to_source_expression:,compare_to_source_id:,direction:,description:,label:,modifier_extension:,extension:,id:,) = testscript_setup_action_assert
    let fields = [#("warningOnly", json.bool(warning_only)),]
let fields = case value {
                          Some(v) -> [#("value", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case validate_profile_id {
                          Some(v) -> [#("validateProfileId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source_id {
                          Some(v) -> [#("sourceId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case response_code {
                          Some(v) -> [#("responseCode", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case response {
                          Some(v) -> [#("response", r4valuesets.assertresponsecodetypes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case resource {
                          Some(v) -> [#("resource", r4valuesets.definedtypes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case request_url {
                          Some(v) -> [#("requestURL", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case request_method {
                          Some(v) -> [#("requestMethod", r4valuesets.httpoperations_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case path {
                          Some(v) -> [#("path", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case operator {
                          Some(v) -> [#("operator", r4valuesets.assertoperatorcodes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case navigation_links {
                          Some(v) -> [#("navigationLinks", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case minimum_id {
                          Some(v) -> [#("minimumId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case header_field {
                          Some(v) -> [#("headerField", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case content_type {
                          Some(v) -> [#("contentType", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case compare_to_source_path {
                          Some(v) -> [#("compareToSourcePath", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case compare_to_source_expression {
                          Some(v) -> [#("compareToSourceExpression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case compare_to_source_id {
                          Some(v) -> [#("compareToSourceId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case direction {
                          Some(v) -> [#("direction", r4valuesets.assertdirectioncodes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case label {
                          Some(v) -> [#("label", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_setup_action_assert_decoder() -> Decoder(TestscriptSetupActionAssert) {use warning_only <- decode.field("warningOnly",decode.bool)
use value <- decode.optional_field("value", None, decode.optional(decode.string))
use validate_profile_id <- decode.optional_field("validateProfileId", None, decode.optional(decode.string))
use source_id <- decode.optional_field("sourceId", None, decode.optional(decode.string))
use response_code <- decode.optional_field("responseCode", None, decode.optional(decode.string))
use response <- decode.optional_field("response", None, decode.optional(r4valuesets.assertresponsecodetypes_decoder()))
use resource <- decode.optional_field("resource", None, decode.optional(r4valuesets.definedtypes_decoder()))
use request_url <- decode.optional_field("requestURL", None, decode.optional(decode.string))
use request_method <- decode.optional_field("requestMethod", None, decode.optional(r4valuesets.httpoperations_decoder()))
use path <- decode.optional_field("path", None, decode.optional(decode.string))
use operator <- decode.optional_field("operator", None, decode.optional(r4valuesets.assertoperatorcodes_decoder()))
use navigation_links <- decode.optional_field("navigationLinks", None, decode.optional(decode.bool))
use minimum_id <- decode.optional_field("minimumId", None, decode.optional(decode.string))
use header_field <- decode.optional_field("headerField", None, decode.optional(decode.string))
use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use content_type <- decode.optional_field("contentType", None, decode.optional(decode.string))
use compare_to_source_path <- decode.optional_field("compareToSourcePath", None, decode.optional(decode.string))
use compare_to_source_expression <- decode.optional_field("compareToSourceExpression", None, decode.optional(decode.string))
use compare_to_source_id <- decode.optional_field("compareToSourceId", None, decode.optional(decode.string))
use direction <- decode.optional_field("direction", None, decode.optional(r4valuesets.assertdirectioncodes_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use label <- decode.optional_field("label", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptSetupActionAssert(warning_only:,value:,validate_profile_id:,source_id:,response_code:,response:,resource:,request_url:,request_method:,path:,operator:,navigation_links:,minimum_id:,header_field:,expression:,content_type:,compare_to_source_path:,compare_to_source_expression:,compare_to_source_id:,direction:,description:,label:,modifier_extension:,extension:,id:,))}
pub fn testscript_setup_action_operation_requestheader_to_json(testscript_setup_action_operation_requestheader: TestscriptSetupActionOperationRequestheader) -> Json {
    let TestscriptSetupActionOperationRequestheader(value:,field:,modifier_extension:,extension:,id:,) = testscript_setup_action_operation_requestheader
    let fields = [#("value", json.string(value)),#("field", json.string(field)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_setup_action_operation_requestheader_decoder() -> Decoder(TestscriptSetupActionOperationRequestheader) {use value <- decode.field("value",decode.string)
use field <- decode.field("field",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptSetupActionOperationRequestheader(value:,field:,modifier_extension:,extension:,id:,))}
pub fn testscript_setup_action_operation_to_json(testscript_setup_action_operation: TestscriptSetupActionOperation) -> Json {
    let TestscriptSetupActionOperation(url:,target_id:,source_id:,response_id:,request_id:,request_header:,params:,origin:,method:,encode_request_url:,destination:,content_type:,accept:,description:,label:,resource:,type_:,modifier_extension:,extension:,id:,) = testscript_setup_action_operation
    let fields = [#("encodeRequestUrl", json.bool(encode_request_url)),]
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case target_id {
                          Some(v) -> [#("targetId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source_id {
                          Some(v) -> [#("sourceId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case response_id {
                          Some(v) -> [#("responseId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case request_id {
                          Some(v) -> [#("requestId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case request_header {
                        [] -> fields
                        _ -> [#("requestHeader", json.array(request_header,testscript_setup_action_operation_requestheader_to_json)), ..fields]
                          }
let fields = case params {
                          Some(v) -> [#("params", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case origin {
                          Some(v) -> [#("origin", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case method {
                          Some(v) -> [#("method", r4valuesets.httpoperations_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case destination {
                          Some(v) -> [#("destination", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case content_type {
                          Some(v) -> [#("contentType", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case accept {
                          Some(v) -> [#("accept", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case label {
                          Some(v) -> [#("label", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case resource {
                          Some(v) -> [#("resource", r4valuesets.definedtypes_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case type_ {
                          Some(v) -> [#("type", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_setup_action_operation_decoder() -> Decoder(TestscriptSetupActionOperation) {use url <- decode.optional_field("url", None, decode.optional(decode.string))
use target_id <- decode.optional_field("targetId", None, decode.optional(decode.string))
use source_id <- decode.optional_field("sourceId", None, decode.optional(decode.string))
use response_id <- decode.optional_field("responseId", None, decode.optional(decode.string))
use request_id <- decode.optional_field("requestId", None, decode.optional(decode.string))
use request_header <- decode.optional_field("requestHeader", [], decode.list(testscript_setup_action_operation_requestheader_decoder()))
use params <- decode.optional_field("params", None, decode.optional(decode.string))
use origin <- decode.optional_field("origin", None, decode.optional(decode.int))
use method <- decode.optional_field("method", None, decode.optional(r4valuesets.httpoperations_decoder()))
use encode_request_url <- decode.field("encodeRequestUrl",decode.bool)
use destination <- decode.optional_field("destination", None, decode.optional(decode.int))
use content_type <- decode.optional_field("contentType", None, decode.optional(decode.string))
use accept <- decode.optional_field("accept", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use label <- decode.optional_field("label", None, decode.optional(decode.string))
use resource <- decode.optional_field("resource", None, decode.optional(r4valuesets.definedtypes_decoder()))
use type_ <- decode.optional_field("type", None, decode.optional(coding_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptSetupActionOperation(url:,target_id:,source_id:,response_id:,request_id:,request_header:,params:,origin:,method:,encode_request_url:,destination:,content_type:,accept:,description:,label:,resource:,type_:,modifier_extension:,extension:,id:,))}
pub fn testscript_setup_action_to_json(testscript_setup_action: TestscriptSetupAction) -> Json {
    let TestscriptSetupAction(assert_:,operation:,modifier_extension:,extension:,id:,) = testscript_setup_action
    let fields = []
let fields = case assert_ {
                          Some(v) -> [#("assert", testscript_setup_action_assert_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case operation {
                          Some(v) -> [#("operation", testscript_setup_action_operation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_setup_action_decoder() -> Decoder(TestscriptSetupAction) {use assert_ <- decode.optional_field("assert", None, decode.optional(testscript_setup_action_assert_decoder()))
use operation <- decode.optional_field("operation", None, decode.optional(testscript_setup_action_operation_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptSetupAction(assert_:,operation:,modifier_extension:,extension:,id:,))}
pub fn testscript_setup_to_json(testscript_setup: TestscriptSetup) -> Json {
    let TestscriptSetup(action:,modifier_extension:,extension:,id:,) = testscript_setup
    let fields = []
let fields = case action {
                        [] -> fields
                        _ -> [#("action", json.array(action,testscript_setup_action_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_setup_decoder() -> Decoder(TestscriptSetup) {use action <- decode.optional_field("action", [], decode.list(testscript_setup_action_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptSetup(action:,modifier_extension:,extension:,id:,))}
pub fn testscript_variable_to_json(testscript_variable: TestscriptVariable) -> Json {
    let TestscriptVariable(source_id:,path:,hint:,header_field:,expression:,description:,default_value:,name:,modifier_extension:,extension:,id:,) = testscript_variable
    let fields = [#("name", json.string(name)),]
let fields = case source_id {
                          Some(v) -> [#("sourceId", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case path {
                          Some(v) -> [#("path", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case hint {
                          Some(v) -> [#("hint", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case header_field {
                          Some(v) -> [#("headerField", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case expression {
                          Some(v) -> [#("expression", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case default_value {
                          Some(v) -> [#("defaultValue", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_variable_decoder() -> Decoder(TestscriptVariable) {use source_id <- decode.optional_field("sourceId", None, decode.optional(decode.string))
use path <- decode.optional_field("path", None, decode.optional(decode.string))
use hint <- decode.optional_field("hint", None, decode.optional(decode.string))
use header_field <- decode.optional_field("headerField", None, decode.optional(decode.string))
use expression <- decode.optional_field("expression", None, decode.optional(decode.string))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use default_value <- decode.optional_field("defaultValue", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptVariable(source_id:,path:,hint:,header_field:,expression:,description:,default_value:,name:,modifier_extension:,extension:,id:,))}
pub fn testscript_fixture_to_json(testscript_fixture: TestscriptFixture) -> Json {
    let TestscriptFixture(resource:,autodelete:,autocreate:,modifier_extension:,extension:,id:,) = testscript_fixture
    let fields = [#("autodelete", json.bool(autodelete)),#("autocreate", json.bool(autocreate)),]
let fields = case resource {
                          Some(v) -> [#("resource", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_fixture_decoder() -> Decoder(TestscriptFixture) {use resource <- decode.optional_field("resource", None, decode.optional(reference_decoder()))
use autodelete <- decode.field("autodelete",decode.bool)
use autocreate <- decode.field("autocreate",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptFixture(resource:,autodelete:,autocreate:,modifier_extension:,extension:,id:,))}
pub fn testscript_metadata_capability_to_json(testscript_metadata_capability: TestscriptMetadataCapability) -> Json {
    let TestscriptMetadataCapability(capabilities:,link:,destination:,origin:,description:,validated:,required:,modifier_extension:,extension:,id:,) = testscript_metadata_capability
    let fields = [#("capabilities", json.string(capabilities)),#("validated", json.bool(validated)),#("required", json.bool(required)),]
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,json.string)), ..fields]
                          }
let fields = case destination {
                          Some(v) -> [#("destination", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case origin {
                        [] -> fields
                        _ -> [#("origin", json.array(origin,json.int)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_metadata_capability_decoder() -> Decoder(TestscriptMetadataCapability) {use capabilities <- decode.field("capabilities",decode.string)
use link <- decode.optional_field("link", [], decode.list(decode.string))
use destination <- decode.optional_field("destination", None, decode.optional(decode.int))
use origin <- decode.optional_field("origin", [], decode.list(decode.int))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use validated <- decode.field("validated",decode.bool)
use required <- decode.field("required",decode.bool)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptMetadataCapability(capabilities:,link:,destination:,origin:,description:,validated:,required:,modifier_extension:,extension:,id:,))}
pub fn testscript_metadata_link_to_json(testscript_metadata_link: TestscriptMetadataLink) -> Json {
    let TestscriptMetadataLink(description:,url:,modifier_extension:,extension:,id:,) = testscript_metadata_link
    let fields = [#("url", json.string(url)),]
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_metadata_link_decoder() -> Decoder(TestscriptMetadataLink) {use description <- decode.optional_field("description", None, decode.optional(decode.string))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptMetadataLink(description:,url:,modifier_extension:,extension:,id:,))}
pub fn testscript_metadata_to_json(testscript_metadata: TestscriptMetadata) -> Json {
    let TestscriptMetadata(capability:,link:,modifier_extension:,extension:,id:,) = testscript_metadata
    let fields = []
let fields = case capability {
                        [] -> fields
                        _ -> [#("capability", json.array(capability,testscript_metadata_capability_to_json)), ..fields]
                          }
let fields = case link {
                        [] -> fields
                        _ -> [#("link", json.array(link,testscript_metadata_link_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_metadata_decoder() -> Decoder(TestscriptMetadata) {use capability <- decode.optional_field("capability", [], decode.list(testscript_metadata_capability_decoder()))
use link <- decode.optional_field("link", [], decode.list(testscript_metadata_link_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptMetadata(capability:,link:,modifier_extension:,extension:,id:,))}
pub fn testscript_destination_to_json(testscript_destination: TestscriptDestination) -> Json {
    let TestscriptDestination(profile:,index:,modifier_extension:,extension:,id:,) = testscript_destination
    let fields = [#("profile", coding_to_json(profile)),#("index", json.int(index)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_destination_decoder() -> Decoder(TestscriptDestination) {use profile <- decode.field("profile",coding_decoder())
use index <- decode.field("index",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptDestination(profile:,index:,modifier_extension:,extension:,id:,))}
pub fn testscript_origin_to_json(testscript_origin: TestscriptOrigin) -> Json {
    let TestscriptOrigin(profile:,index:,modifier_extension:,extension:,id:,) = testscript_origin
    let fields = [#("profile", coding_to_json(profile)),#("index", json.int(index)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_origin_decoder() -> Decoder(TestscriptOrigin) {use profile <- decode.field("profile",coding_decoder())
use index <- decode.field("index",decode.int)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(TestscriptOrigin(profile:,index:,modifier_extension:,extension:,id:,))}
pub fn testscript_to_json(testscript: Testscript) -> Json {
    let Testscript(teardown:,test_:,setup:,variable:,profile:,fixture:,metadata:,destination:,origin:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = testscript
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),#("name", json.string(name)),#("url", json.string(url)),]
let fields = case teardown {
                          Some(v) -> [#("teardown", testscript_teardown_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case test_ {
                        [] -> fields
                        _ -> [#("test", json.array(test_,testscript_test_to_json)), ..fields]
                          }
let fields = case setup {
                          Some(v) -> [#("setup", testscript_setup_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case variable {
                        [] -> fields
                        _ -> [#("variable", json.array(variable,testscript_variable_to_json)), ..fields]
                          }
let fields = case profile {
                        [] -> fields
                        _ -> [#("profile", json.array(profile,reference_to_json)), ..fields]
                          }
let fields = case fixture {
                        [] -> fields
                        _ -> [#("fixture", json.array(fixture,testscript_fixture_to_json)), ..fields]
                          }
let fields = case metadata {
                          Some(v) -> [#("metadata", testscript_metadata_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case destination {
                        [] -> fields
                        _ -> [#("destination", json.array(destination,testscript_destination_to_json)), ..fields]
                          }
let fields = case origin {
                        [] -> fields
                        _ -> [#("origin", json.array(origin,testscript_origin_to_json)), ..fields]
                          }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn testscript_decoder() -> Decoder(Testscript) {use teardown <- decode.optional_field("teardown", None, decode.optional(testscript_teardown_decoder()))
use test_ <- decode.optional_field("test", [], decode.list(testscript_test_decoder()))
use setup <- decode.optional_field("setup", None, decode.optional(testscript_setup_decoder()))
use variable <- decode.optional_field("variable", [], decode.list(testscript_variable_decoder()))
use profile <- decode.optional_field("profile", [], decode.list(reference_decoder()))
use fixture <- decode.optional_field("fixture", [], decode.list(testscript_fixture_decoder()))
use metadata <- decode.optional_field("metadata", None, decode.optional(testscript_metadata_decoder()))
use destination <- decode.optional_field("destination", [], decode.list(testscript_destination_decoder()))
use origin <- decode.optional_field("origin", [], decode.list(testscript_origin_decoder()))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.field("name",decode.string)
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", None, decode.optional(identifier_decoder()))
use url <- decode.field("url",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Testscript(teardown:,test_:,setup:,variable:,profile:,fixture:,metadata:,destination:,origin:,copyright:,purpose:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type Valueset
{
Valueset(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
url: Option(String),
identifier: List(Identifier),
version: Option(String),
name: Option(String),
title: Option(String),
status: r4valuesets.Publicationstatus,
experimental: Option(Bool),
date: Option(String),
publisher: Option(String),
contact: List(Contactdetail),
description: Option(String),
use_context: List(Usagecontext),
jurisdiction: List(Codeableconcept),
immutable: Option(Bool),
purpose: Option(String),
copyright: Option(String),
compose: Option(ValuesetCompose),
expansion: Option(ValuesetExpansion),
)
}

pub fn valueset_new(status status: r4valuesets.Publicationstatus,) ->Valueset{Valueset(expansion: None,compose: None,copyright: None,purpose: None,immutable: None,jurisdiction: [],use_context: [],description: None,contact: [],publisher: None,date: None,experimental: None,status:,title: None,name: None,version: None,identifier: [],url: None,modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetCompose
{
ValuesetCompose(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
locked_date: Option(String),
inactive: Option(Bool),
include: List(ValuesetComposeInclude),
)
}

pub fn valueset_compose_new() ->ValuesetCompose{ValuesetCompose(include: [],inactive: None,locked_date: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetComposeInclude
{
ValuesetComposeInclude(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
system: Option(String),
version: Option(String),
concept: List(ValuesetComposeIncludeConcept),
filter: List(ValuesetComposeIncludeFilter),
value_set: List(String),
)
}

pub fn valueset_compose_include_new() ->ValuesetComposeInclude{ValuesetComposeInclude(value_set: [],filter: [],concept: [],version: None,system: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConcept
{
ValuesetComposeIncludeConcept(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
code: String,
display: Option(String),
designation: List(ValuesetComposeIncludeConceptDesignation),
)
}

pub fn valueset_compose_include_concept_new(code code: String,) ->ValuesetComposeIncludeConcept{ValuesetComposeIncludeConcept(designation: [],display: None,code:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConceptDesignation
{
ValuesetComposeIncludeConceptDesignation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
language: Option(String),
use_: Option(Coding),
value: String,
)
}

pub fn valueset_compose_include_concept_designation_new(value value: String,) ->ValuesetComposeIncludeConceptDesignation{ValuesetComposeIncludeConceptDesignation(value:,use_: None,language: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeFilter
{
ValuesetComposeIncludeFilter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
property: String,
op: r4valuesets.Filteroperator,
value: String,
)
}

pub fn valueset_compose_include_filter_new(value value: String,op op: r4valuesets.Filteroperator,property property: String,) ->ValuesetComposeIncludeFilter{ValuesetComposeIncludeFilter(value:,op:,property:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetExpansion
{
ValuesetExpansion(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: Option(String),
timestamp: String,
total: Option(Int),
offset: Option(Int),
parameter: List(ValuesetExpansionParameter),
contains: List(ValuesetExpansionContains),
)
}

pub fn valueset_expansion_new(timestamp timestamp: String,) ->ValuesetExpansion{ValuesetExpansion(contains: [],parameter: [],offset: None,total: None,timestamp:,identifier: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameter
{
ValuesetExpansionParameter(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
name: String,
value: Option(ValuesetExpansionParameterValue),
)
}

///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameterValue{
ValuesetExpansionParameterValueString(value: String)
ValuesetExpansionParameterValueBoolean(value: Bool)
ValuesetExpansionParameterValueInteger(value: Int)
ValuesetExpansionParameterValueDecimal(value: Float)
ValuesetExpansionParameterValueUri(value: String)
ValuesetExpansionParameterValueCode(value: String)
ValuesetExpansionParameterValueDatetime(value: String)}
pub fn valueset_expansion_parameter_value_to_json(elt: ValuesetExpansionParameterValue) -> Json {case elt{ValuesetExpansionParameterValueString(v) -> json.string(v)
ValuesetExpansionParameterValueBoolean(v) -> json.bool(v)
ValuesetExpansionParameterValueInteger(v) -> json.int(v)
ValuesetExpansionParameterValueDecimal(v) -> json.float(v)
ValuesetExpansionParameterValueUri(v) -> json.string(v)
ValuesetExpansionParameterValueCode(v) -> json.string(v)
ValuesetExpansionParameterValueDatetime(v) -> json.string(v)
}}
pub fn valueset_expansion_parameter_value_decoder() -> Decoder(ValuesetExpansionParameterValue){decode.one_of(decode.field("valueString", decode.string, decode.success) |> decode.map(ValuesetExpansionParameterValueString),[decode.field("valueBoolean", decode.bool, decode.success) |> decode.map(ValuesetExpansionParameterValueBoolean),decode.field("valueInteger", decode.int, decode.success) |> decode.map(ValuesetExpansionParameterValueInteger),decode.field("valueDecimal", decode.float, decode.success) |> decode.map(ValuesetExpansionParameterValueDecimal),decode.field("valueUri", decode.string, decode.success) |> decode.map(ValuesetExpansionParameterValueUri),decode.field("valueCode", decode.string, decode.success) |> decode.map(ValuesetExpansionParameterValueCode),decode.field("valueDateTime", decode.string, decode.success) |> decode.map(ValuesetExpansionParameterValueDatetime),])}
pub fn valueset_expansion_parameter_new(name name: String,) ->ValuesetExpansionParameter{ValuesetExpansionParameter(value: None,name:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContains
{
ValuesetExpansionContains(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
system: Option(String),
abstract: Option(Bool),
inactive: Option(Bool),
version: Option(String),
code: Option(String),
display: Option(String),
)
}

pub fn valueset_expansion_contains_new() ->ValuesetExpansionContains{ValuesetExpansionContains(display: None,code: None,version: None,inactive: None,abstract: None,system: None,modifier_extension: [],extension: [],id: None,)
}

pub fn valueset_expansion_contains_to_json(valueset_expansion_contains: ValuesetExpansionContains) -> Json {
    let ValuesetExpansionContains(display:,code:,version:,inactive:,abstract:,system:,modifier_extension:,extension:,id:,) = valueset_expansion_contains
    let fields = []
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case code {
                          Some(v) -> [#("code", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case inactive {
                          Some(v) -> [#("inactive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case abstract {
                          Some(v) -> [#("abstract", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_expansion_contains_decoder() -> Decoder(ValuesetExpansionContains) {use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.optional_field("code", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use inactive <- decode.optional_field("inactive", None, decode.optional(decode.bool))
use abstract <- decode.optional_field("abstract", None, decode.optional(decode.bool))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetExpansionContains(display:,code:,version:,inactive:,abstract:,system:,modifier_extension:,extension:,id:,))}
pub fn valueset_expansion_parameter_to_json(valueset_expansion_parameter: ValuesetExpansionParameter) -> Json {
    let ValuesetExpansionParameter(value:,name:,modifier_extension:,extension:,id:,) = valueset_expansion_parameter
    let fields = [#("name", json.string(name)),]
let fields = case value {
                          Some(v) -> [#("value", valueset_expansion_parameter_value_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_expansion_parameter_decoder() -> Decoder(ValuesetExpansionParameter) {use value <- decode.then(none_if_omitted(valueset_expansion_parameter_value_decoder()))
use name <- decode.field("name",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetExpansionParameter(value:,name:,modifier_extension:,extension:,id:,))}
pub fn valueset_expansion_to_json(valueset_expansion: ValuesetExpansion) -> Json {
    let ValuesetExpansion(contains:,parameter:,offset:,total:,timestamp:,identifier:,modifier_extension:,extension:,id:,) = valueset_expansion
    let fields = [#("timestamp", json.string(timestamp)),]
let fields = case contains {
                        [] -> fields
                        _ -> [#("contains", json.array(contains,valueset_expansion_contains_to_json)), ..fields]
                          }
let fields = case parameter {
                        [] -> fields
                        _ -> [#("parameter", json.array(parameter,valueset_expansion_parameter_to_json)), ..fields]
                          }
let fields = case offset {
                          Some(v) -> [#("offset", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case total {
                          Some(v) -> [#("total", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                          Some(v) -> [#("identifier", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_expansion_decoder() -> Decoder(ValuesetExpansion) {use contains <- decode.optional_field("contains", [], decode.list(valueset_expansion_contains_decoder()))
use parameter <- decode.optional_field("parameter", [], decode.list(valueset_expansion_parameter_decoder()))
use offset <- decode.optional_field("offset", None, decode.optional(decode.int))
use total <- decode.optional_field("total", None, decode.optional(decode.int))
use timestamp <- decode.field("timestamp",decode.string)
use identifier <- decode.optional_field("identifier", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetExpansion(contains:,parameter:,offset:,total:,timestamp:,identifier:,modifier_extension:,extension:,id:,))}
pub fn valueset_compose_include_filter_to_json(valueset_compose_include_filter: ValuesetComposeIncludeFilter) -> Json {
    let ValuesetComposeIncludeFilter(value:,op:,property:,modifier_extension:,extension:,id:,) = valueset_compose_include_filter
    let fields = [#("value", json.string(value)),#("op", r4valuesets.filteroperator_to_json(op)),#("property", json.string(property)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_compose_include_filter_decoder() -> Decoder(ValuesetComposeIncludeFilter) {use value <- decode.field("value",decode.string)
use op <- decode.field("op",r4valuesets.filteroperator_decoder())
use property <- decode.field("property",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetComposeIncludeFilter(value:,op:,property:,modifier_extension:,extension:,id:,))}
pub fn valueset_compose_include_concept_designation_to_json(valueset_compose_include_concept_designation: ValuesetComposeIncludeConceptDesignation) -> Json {
    let ValuesetComposeIncludeConceptDesignation(value:,use_:,language:,modifier_extension:,extension:,id:,) = valueset_compose_include_concept_designation
    let fields = [#("value", json.string(value)),]
let fields = case use_ {
                          Some(v) -> [#("use", coding_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_compose_include_concept_designation_decoder() -> Decoder(ValuesetComposeIncludeConceptDesignation) {use value <- decode.field("value",decode.string)
use use_ <- decode.optional_field("use", None, decode.optional(coding_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetComposeIncludeConceptDesignation(value:,use_:,language:,modifier_extension:,extension:,id:,))}
pub fn valueset_compose_include_concept_to_json(valueset_compose_include_concept: ValuesetComposeIncludeConcept) -> Json {
    let ValuesetComposeIncludeConcept(designation:,display:,code:,modifier_extension:,extension:,id:,) = valueset_compose_include_concept
    let fields = [#("code", json.string(code)),]
let fields = case designation {
                        [] -> fields
                        _ -> [#("designation", json.array(designation,valueset_compose_include_concept_designation_to_json)), ..fields]
                          }
let fields = case display {
                          Some(v) -> [#("display", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_compose_include_concept_decoder() -> Decoder(ValuesetComposeIncludeConcept) {use designation <- decode.optional_field("designation", [], decode.list(valueset_compose_include_concept_designation_decoder()))
use display <- decode.optional_field("display", None, decode.optional(decode.string))
use code <- decode.field("code",decode.string)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetComposeIncludeConcept(designation:,display:,code:,modifier_extension:,extension:,id:,))}
pub fn valueset_compose_include_to_json(valueset_compose_include: ValuesetComposeInclude) -> Json {
    let ValuesetComposeInclude(value_set:,filter:,concept:,version:,system:,modifier_extension:,extension:,id:,) = valueset_compose_include
    let fields = []
let fields = case value_set {
                        [] -> fields
                        _ -> [#("valueSet", json.array(value_set,json.string)), ..fields]
                          }
let fields = case filter {
                        [] -> fields
                        _ -> [#("filter", json.array(filter,valueset_compose_include_filter_to_json)), ..fields]
                          }
let fields = case concept {
                        [] -> fields
                        _ -> [#("concept", json.array(concept,valueset_compose_include_concept_to_json)), ..fields]
                          }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case system {
                          Some(v) -> [#("system", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_compose_include_decoder() -> Decoder(ValuesetComposeInclude) {use value_set <- decode.optional_field("valueSet", [], decode.list(decode.string))
use filter <- decode.optional_field("filter", [], decode.list(valueset_compose_include_filter_decoder()))
use concept <- decode.optional_field("concept", [], decode.list(valueset_compose_include_concept_decoder()))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use system <- decode.optional_field("system", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetComposeInclude(value_set:,filter:,concept:,version:,system:,modifier_extension:,extension:,id:,))}
pub fn valueset_compose_to_json(valueset_compose: ValuesetCompose) -> Json {
    let ValuesetCompose(include:,inactive:,locked_date:,modifier_extension:,extension:,id:,) = valueset_compose
    let fields = []
let fields = case include {
                        [] -> fields
                        _ -> [#("include", json.array(include,valueset_compose_include_to_json)), ..fields]
                          }
let fields = case inactive {
                          Some(v) -> [#("inactive", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case locked_date {
                          Some(v) -> [#("lockedDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_compose_decoder() -> Decoder(ValuesetCompose) {use include <- decode.optional_field("include", [], decode.list(valueset_compose_include_decoder()))
use inactive <- decode.optional_field("inactive", None, decode.optional(decode.bool))
use locked_date <- decode.optional_field("lockedDate", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(ValuesetCompose(include:,inactive:,locked_date:,modifier_extension:,extension:,id:,))}
pub fn valueset_to_json(valueset: Valueset) -> Json {
    let Valueset(expansion:,compose:,copyright:,purpose:,immutable:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = valueset
    let fields = [#("status", r4valuesets.publicationstatus_to_json(status)),]
let fields = case expansion {
                          Some(v) -> [#("expansion", valueset_expansion_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case compose {
                          Some(v) -> [#("compose", valueset_compose_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case copyright {
                          Some(v) -> [#("copyright", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case purpose {
                          Some(v) -> [#("purpose", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case immutable {
                          Some(v) -> [#("immutable", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case jurisdiction {
                        [] -> fields
                        _ -> [#("jurisdiction", json.array(jurisdiction,codeableconcept_to_json)), ..fields]
                          }
let fields = case use_context {
                        [] -> fields
                        _ -> [#("useContext", json.array(use_context,usagecontext_to_json)), ..fields]
                          }
let fields = case description {
                          Some(v) -> [#("description", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case contact {
                        [] -> fields
                        _ -> [#("contact", json.array(contact,contactdetail_to_json)), ..fields]
                          }
let fields = case publisher {
                          Some(v) -> [#("publisher", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case experimental {
                          Some(v) -> [#("experimental", json.bool(v)), ..fields]
                          None -> fields
                        }
let fields = case title {
                          Some(v) -> [#("title", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case name {
                          Some(v) -> [#("name", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case version {
                          Some(v) -> [#("version", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case url {
                          Some(v) -> [#("url", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn valueset_decoder() -> Decoder(Valueset) {use expansion <- decode.optional_field("expansion", None, decode.optional(valueset_expansion_decoder()))
use compose <- decode.optional_field("compose", None, decode.optional(valueset_compose_decoder()))
use copyright <- decode.optional_field("copyright", None, decode.optional(decode.string))
use purpose <- decode.optional_field("purpose", None, decode.optional(decode.string))
use immutable <- decode.optional_field("immutable", None, decode.optional(decode.bool))
use jurisdiction <- decode.optional_field("jurisdiction", [], decode.list(codeableconcept_decoder()))
use use_context <- decode.optional_field("useContext", [], decode.list(usagecontext_decoder()))
use description <- decode.optional_field("description", None, decode.optional(decode.string))
use contact <- decode.optional_field("contact", [], decode.list(contactdetail_decoder()))
use publisher <- decode.optional_field("publisher", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use experimental <- decode.optional_field("experimental", None, decode.optional(decode.bool))
use status <- decode.field("status",r4valuesets.publicationstatus_decoder())
use title <- decode.optional_field("title", None, decode.optional(decode.string))
use name <- decode.optional_field("name", None, decode.optional(decode.string))
use version <- decode.optional_field("version", None, decode.optional(decode.string))
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use url <- decode.optional_field("url", None, decode.optional(decode.string))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Valueset(expansion:,compose:,copyright:,purpose:,immutable:,jurisdiction:,use_context:,description:,contact:,publisher:,date:,experimental:,status:,title:,name:,version:,identifier:,url:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/VerificationResult#resource
pub type Verificationresult
{
Verificationresult(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
target: List(Reference),
target_location: List(String),
need: Option(Codeableconcept),
status: r4valuesets.Verificationresultstatus,
status_date: Option(String),
validation_type: Option(Codeableconcept),
validation_process: List(Codeableconcept),
frequency: Option(Timing),
last_performed: Option(String),
next_scheduled: Option(String),
failure_action: Option(Codeableconcept),
primary_source: List(VerificationresultPrimarysource),
attestation: Option(VerificationresultAttestation),
validator: List(VerificationresultValidator),
)
}

pub fn verificationresult_new(status status: r4valuesets.Verificationresultstatus,) ->Verificationresult{Verificationresult(validator: [],attestation: None,primary_source: [],failure_action: None,next_scheduled: None,last_performed: None,frequency: None,validation_process: [],validation_type: None,status_date: None,status:,need: None,target_location: [],target: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/VerificationResult#resource
pub type VerificationresultPrimarysource
{
VerificationresultPrimarysource(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
who: Option(Reference),
type_: List(Codeableconcept),
communication_method: List(Codeableconcept),
validation_status: Option(Codeableconcept),
validation_date: Option(String),
can_push_updates: Option(Codeableconcept),
push_type_available: List(Codeableconcept),
)
}

pub fn verificationresult_primarysource_new() ->VerificationresultPrimarysource{VerificationresultPrimarysource(push_type_available: [],can_push_updates: None,validation_date: None,validation_status: None,communication_method: [],type_: [],who: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/VerificationResult#resource
pub type VerificationresultAttestation
{
VerificationresultAttestation(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
who: Option(Reference),
on_behalf_of: Option(Reference),
communication_method: Option(Codeableconcept),
date: Option(String),
source_identity_certificate: Option(String),
proxy_identity_certificate: Option(String),
proxy_signature: Option(Signature),
source_signature: Option(Signature),
)
}

pub fn verificationresult_attestation_new() ->VerificationresultAttestation{VerificationresultAttestation(source_signature: None,proxy_signature: None,proxy_identity_certificate: None,source_identity_certificate: None,date: None,communication_method: None,on_behalf_of: None,who: None,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/VerificationResult#resource
pub type VerificationresultValidator
{
VerificationresultValidator(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
organization: Reference,
identity_certificate: Option(String),
attestation_signature: Option(Signature),
)
}

pub fn verificationresult_validator_new(organization organization: Reference,) ->VerificationresultValidator{VerificationresultValidator(attestation_signature: None,identity_certificate: None,organization:,modifier_extension: [],extension: [],id: None,)
}

pub fn verificationresult_validator_to_json(verificationresult_validator: VerificationresultValidator) -> Json {
    let VerificationresultValidator(attestation_signature:,identity_certificate:,organization:,modifier_extension:,extension:,id:,) = verificationresult_validator
    let fields = [#("organization", reference_to_json(organization)),]
let fields = case attestation_signature {
                          Some(v) -> [#("attestationSignature", signature_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identity_certificate {
                          Some(v) -> [#("identityCertificate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn verificationresult_validator_decoder() -> Decoder(VerificationresultValidator) {use attestation_signature <- decode.optional_field("attestationSignature", None, decode.optional(signature_decoder()))
use identity_certificate <- decode.optional_field("identityCertificate", None, decode.optional(decode.string))
use organization <- decode.field("organization",reference_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(VerificationresultValidator(attestation_signature:,identity_certificate:,organization:,modifier_extension:,extension:,id:,))}
pub fn verificationresult_attestation_to_json(verificationresult_attestation: VerificationresultAttestation) -> Json {
    let VerificationresultAttestation(source_signature:,proxy_signature:,proxy_identity_certificate:,source_identity_certificate:,date:,communication_method:,on_behalf_of:,who:,modifier_extension:,extension:,id:,) = verificationresult_attestation
    let fields = []
let fields = case source_signature {
                          Some(v) -> [#("sourceSignature", signature_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case proxy_signature {
                          Some(v) -> [#("proxySignature", signature_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case proxy_identity_certificate {
                          Some(v) -> [#("proxyIdentityCertificate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case source_identity_certificate {
                          Some(v) -> [#("sourceIdentityCertificate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case date {
                          Some(v) -> [#("date", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case communication_method {
                          Some(v) -> [#("communicationMethod", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case on_behalf_of {
                          Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case who {
                          Some(v) -> [#("who", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn verificationresult_attestation_decoder() -> Decoder(VerificationresultAttestation) {use source_signature <- decode.optional_field("sourceSignature", None, decode.optional(signature_decoder()))
use proxy_signature <- decode.optional_field("proxySignature", None, decode.optional(signature_decoder()))
use proxy_identity_certificate <- decode.optional_field("proxyIdentityCertificate", None, decode.optional(decode.string))
use source_identity_certificate <- decode.optional_field("sourceIdentityCertificate", None, decode.optional(decode.string))
use date <- decode.optional_field("date", None, decode.optional(decode.string))
use communication_method <- decode.optional_field("communicationMethod", None, decode.optional(codeableconcept_decoder()))
use on_behalf_of <- decode.optional_field("onBehalfOf", None, decode.optional(reference_decoder()))
use who <- decode.optional_field("who", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(VerificationresultAttestation(source_signature:,proxy_signature:,proxy_identity_certificate:,source_identity_certificate:,date:,communication_method:,on_behalf_of:,who:,modifier_extension:,extension:,id:,))}
pub fn verificationresult_primarysource_to_json(verificationresult_primarysource: VerificationresultPrimarysource) -> Json {
    let VerificationresultPrimarysource(push_type_available:,can_push_updates:,validation_date:,validation_status:,communication_method:,type_:,who:,modifier_extension:,extension:,id:,) = verificationresult_primarysource
    let fields = []
let fields = case push_type_available {
                        [] -> fields
                        _ -> [#("pushTypeAvailable", json.array(push_type_available,codeableconcept_to_json)), ..fields]
                          }
let fields = case can_push_updates {
                          Some(v) -> [#("canPushUpdates", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case validation_date {
                          Some(v) -> [#("validationDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case validation_status {
                          Some(v) -> [#("validationStatus", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case communication_method {
                        [] -> fields
                        _ -> [#("communicationMethod", json.array(communication_method,codeableconcept_to_json)), ..fields]
                          }
let fields = case type_ {
                        [] -> fields
                        _ -> [#("type", json.array(type_,codeableconcept_to_json)), ..fields]
                          }
let fields = case who {
                          Some(v) -> [#("who", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn verificationresult_primarysource_decoder() -> Decoder(VerificationresultPrimarysource) {use push_type_available <- decode.optional_field("pushTypeAvailable", [], decode.list(codeableconcept_decoder()))
use can_push_updates <- decode.optional_field("canPushUpdates", None, decode.optional(codeableconcept_decoder()))
use validation_date <- decode.optional_field("validationDate", None, decode.optional(decode.string))
use validation_status <- decode.optional_field("validationStatus", None, decode.optional(codeableconcept_decoder()))
use communication_method <- decode.optional_field("communicationMethod", [], decode.list(codeableconcept_decoder()))
use type_ <- decode.optional_field("type", [], decode.list(codeableconcept_decoder()))
use who <- decode.optional_field("who", None, decode.optional(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(VerificationresultPrimarysource(push_type_available:,can_push_updates:,validation_date:,validation_status:,communication_method:,type_:,who:,modifier_extension:,extension:,id:,))}
pub fn verificationresult_to_json(verificationresult: Verificationresult) -> Json {
    let Verificationresult(validator:,attestation:,primary_source:,failure_action:,next_scheduled:,last_performed:,frequency:,validation_process:,validation_type:,status_date:,status:,need:,target_location:,target:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = verificationresult
    let fields = [#("status", r4valuesets.verificationresultstatus_to_json(status)),]
let fields = case validator {
                        [] -> fields
                        _ -> [#("validator", json.array(validator,verificationresult_validator_to_json)), ..fields]
                          }
let fields = case attestation {
                          Some(v) -> [#("attestation", verificationresult_attestation_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case primary_source {
                        [] -> fields
                        _ -> [#("primarySource", json.array(primary_source,verificationresult_primarysource_to_json)), ..fields]
                          }
let fields = case failure_action {
                          Some(v) -> [#("failureAction", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case next_scheduled {
                          Some(v) -> [#("nextScheduled", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case last_performed {
                          Some(v) -> [#("lastPerformed", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case frequency {
                          Some(v) -> [#("frequency", timing_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case validation_process {
                        [] -> fields
                        _ -> [#("validationProcess", json.array(validation_process,codeableconcept_to_json)), ..fields]
                          }
let fields = case validation_type {
                          Some(v) -> [#("validationType", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case status_date {
                          Some(v) -> [#("statusDate", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case need {
                          Some(v) -> [#("need", codeableconcept_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case target_location {
                        [] -> fields
                        _ -> [#("targetLocation", json.array(target_location,json.string)), ..fields]
                          }
let fields = case target {
                        [] -> fields
                        _ -> [#("target", json.array(target,reference_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn verificationresult_decoder() -> Decoder(Verificationresult) {use validator <- decode.optional_field("validator", [], decode.list(verificationresult_validator_decoder()))
use attestation <- decode.optional_field("attestation", None, decode.optional(verificationresult_attestation_decoder()))
use primary_source <- decode.optional_field("primarySource", [], decode.list(verificationresult_primarysource_decoder()))
use failure_action <- decode.optional_field("failureAction", None, decode.optional(codeableconcept_decoder()))
use next_scheduled <- decode.optional_field("nextScheduled", None, decode.optional(decode.string))
use last_performed <- decode.optional_field("lastPerformed", None, decode.optional(decode.string))
use frequency <- decode.optional_field("frequency", None, decode.optional(timing_decoder()))
use validation_process <- decode.optional_field("validationProcess", [], decode.list(codeableconcept_decoder()))
use validation_type <- decode.optional_field("validationType", None, decode.optional(codeableconcept_decoder()))
use status_date <- decode.optional_field("statusDate", None, decode.optional(decode.string))
use status <- decode.field("status",r4valuesets.verificationresultstatus_decoder())
use need <- decode.optional_field("need", None, decode.optional(codeableconcept_decoder()))
use target_location <- decode.optional_field("targetLocation", [], decode.list(decode.string))
use target <- decode.optional_field("target", [], decode.list(reference_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Verificationresult(validator:,attestation:,primary_source:,failure_action:,next_scheduled:,last_performed:,frequency:,validation_process:,validation_type:,status_date:,status:,need:,target_location:,target:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
///http://hl7.org/fhir/r4/StructureDefinition/VisionPrescription#resource
pub type Visionprescription
{
Visionprescription(id: Option(String),
meta: Option(Meta),
implicit_rules: Option(String),
language: Option(String),
text: Option(Narrative),
contained: List(Resource),
extension: List(Extension),
modifier_extension: List(Extension),
identifier: List(Identifier),
status: r4valuesets.Fmstatus,
created: String,
patient: Reference,
encounter: Option(Reference),
date_written: String,
prescriber: Reference,
lens_specification: List(VisionprescriptionLensspecification),
)
}

pub fn visionprescription_new(prescriber prescriber: Reference,date_written date_written: String,patient patient: Reference,created created: String,status status: r4valuesets.Fmstatus,) ->Visionprescription{Visionprescription(lens_specification: [],prescriber:,date_written:,encounter: None,patient:,created:,status:,identifier: [],modifier_extension: [],extension: [],contained: [],text: None,language: None,implicit_rules: None,meta: None,id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecification
{
VisionprescriptionLensspecification(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
product: Codeableconcept,
eye: r4valuesets.Visioneyecodes,
sphere: Option(Float),
cylinder: Option(Float),
axis: Option(Int),
prism: List(VisionprescriptionLensspecificationPrism),
add: Option(Float),
power: Option(Float),
back_curve: Option(Float),
diameter: Option(Float),
duration: Option(Quantity),
color: Option(String),
brand: Option(String),
note: List(Annotation),
)
}

pub fn visionprescription_lensspecification_new(eye eye: r4valuesets.Visioneyecodes,product product: Codeableconcept,) ->VisionprescriptionLensspecification{VisionprescriptionLensspecification(note: [],brand: None,color: None,duration: None,diameter: None,back_curve: None,power: None,add: None,prism: [],axis: None,cylinder: None,sphere: None,eye:,product:,modifier_extension: [],extension: [],id: None,)
}
///http://hl7.org/fhir/r4/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecificationPrism
{
VisionprescriptionLensspecificationPrism(id: Option(String),
extension: List(Extension),
modifier_extension: List(Extension),
amount: Float,
base: r4valuesets.Visionbasecodes,
)
}

pub fn visionprescription_lensspecification_prism_new(base base: r4valuesets.Visionbasecodes,amount amount: Float,) ->VisionprescriptionLensspecificationPrism{VisionprescriptionLensspecificationPrism(base:,amount:,modifier_extension: [],extension: [],id: None,)
}

pub fn visionprescription_lensspecification_prism_to_json(visionprescription_lensspecification_prism: VisionprescriptionLensspecificationPrism) -> Json {
    let VisionprescriptionLensspecificationPrism(base:,amount:,modifier_extension:,extension:,id:,) = visionprescription_lensspecification_prism
    let fields = [#("base", r4valuesets.visionbasecodes_to_json(base)),#("amount", json.float(amount)),]
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn visionprescription_lensspecification_prism_decoder() -> Decoder(VisionprescriptionLensspecificationPrism) {use base <- decode.field("base",r4valuesets.visionbasecodes_decoder())
use amount <- decode.field("amount",decode.float)
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(VisionprescriptionLensspecificationPrism(base:,amount:,modifier_extension:,extension:,id:,))}
pub fn visionprescription_lensspecification_to_json(visionprescription_lensspecification: VisionprescriptionLensspecification) -> Json {
    let VisionprescriptionLensspecification(note:,brand:,color:,duration:,diameter:,back_curve:,power:,add:,prism:,axis:,cylinder:,sphere:,eye:,product:,modifier_extension:,extension:,id:,) = visionprescription_lensspecification
    let fields = [#("eye", r4valuesets.visioneyecodes_to_json(eye)),#("product", codeableconcept_to_json(product)),]
let fields = case note {
                        [] -> fields
                        _ -> [#("note", json.array(note,annotation_to_json)), ..fields]
                          }
let fields = case brand {
                          Some(v) -> [#("brand", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case color {
                          Some(v) -> [#("color", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case duration {
                          Some(v) -> [#("duration", quantity_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case diameter {
                          Some(v) -> [#("diameter", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case back_curve {
                          Some(v) -> [#("backCurve", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case power {
                          Some(v) -> [#("power", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case add {
                          Some(v) -> [#("add", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case prism {
                        [] -> fields
                        _ -> [#("prism", json.array(prism,visionprescription_lensspecification_prism_to_json)), ..fields]
                          }
let fields = case axis {
                          Some(v) -> [#("axis", json.int(v)), ..fields]
                          None -> fields
                        }
let fields = case cylinder {
                          Some(v) -> [#("cylinder", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case sphere {
                          Some(v) -> [#("sphere", json.float(v)), ..fields]
                          None -> fields
                        }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn visionprescription_lensspecification_decoder() -> Decoder(VisionprescriptionLensspecification) {use note <- decode.optional_field("note", [], decode.list(annotation_decoder()))
use brand <- decode.optional_field("brand", None, decode.optional(decode.string))
use color <- decode.optional_field("color", None, decode.optional(decode.string))
use duration <- decode.optional_field("duration", None, decode.optional(quantity_decoder()))
use diameter <- decode.optional_field("diameter", None, decode.optional(decode.float))
use back_curve <- decode.optional_field("backCurve", None, decode.optional(decode.float))
use power <- decode.optional_field("power", None, decode.optional(decode.float))
use add <- decode.optional_field("add", None, decode.optional(decode.float))
use prism <- decode.optional_field("prism", [], decode.list(visionprescription_lensspecification_prism_decoder()))
use axis <- decode.optional_field("axis", None, decode.optional(decode.int))
use cylinder <- decode.optional_field("cylinder", None, decode.optional(decode.float))
use sphere <- decode.optional_field("sphere", None, decode.optional(decode.float))
use eye <- decode.field("eye",r4valuesets.visioneyecodes_decoder())
use product <- decode.field("product",codeableconcept_decoder())
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(VisionprescriptionLensspecification(note:,brand:,color:,duration:,diameter:,back_curve:,power:,add:,prism:,axis:,cylinder:,sphere:,eye:,product:,modifier_extension:,extension:,id:,))}
pub fn visionprescription_to_json(visionprescription: Visionprescription) -> Json {
    let Visionprescription(lens_specification:,prescriber:,date_written:,encounter:,patient:,created:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,) = visionprescription
    let fields = [#("prescriber", reference_to_json(prescriber)),#("dateWritten", json.string(date_written)),#("patient", reference_to_json(patient)),#("created", json.string(created)),#("status", r4valuesets.fmstatus_to_json(status)),]
let fields = case lens_specification {
                        [] -> fields
                        _ -> [#("lensSpecification", json.array(lens_specification,visionprescription_lensspecification_to_json)), ..fields]
                          }
let fields = case encounter {
                          Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case identifier {
                        [] -> fields
                        _ -> [#("identifier", json.array(identifier,identifier_to_json)), ..fields]
                          }
let fields = case modifier_extension {
                        [] -> fields
                        _ -> [#("modifierExtension", json.array(modifier_extension,extension_to_json)), ..fields]
                          }
let fields = case extension {
                        [] -> fields
                        _ -> [#("extension", json.array(extension,extension_to_json)), ..fields]
                          }
let fields = case contained {
                        [] -> fields
                        _ -> [#("contained", json.array(contained,resource_to_json)), ..fields]
                          }
let fields = case text {
                          Some(v) -> [#("text", narrative_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case language {
                          Some(v) -> [#("language", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case implicit_rules {
                          Some(v) -> [#("implicitRules", json.string(v)), ..fields]
                          None -> fields
                        }
let fields = case meta {
                          Some(v) -> [#("meta", meta_to_json(v)), ..fields]
                          None -> fields
                        }
let fields = case id {
                          Some(v) -> [#("id", json.string(v)), ..fields]
                          None -> fields
                        }
json.object(fields)}
  
pub fn visionprescription_decoder() -> Decoder(Visionprescription) {use lens_specification <- decode.optional_field("lensSpecification", [], decode.list(visionprescription_lensspecification_decoder()))
use prescriber <- decode.field("prescriber",reference_decoder())
use date_written <- decode.field("dateWritten",decode.string)
use encounter <- decode.optional_field("encounter", None, decode.optional(reference_decoder()))
use patient <- decode.field("patient",reference_decoder())
use created <- decode.field("created",decode.string)
use status <- decode.field("status",r4valuesets.fmstatus_decoder())
use identifier <- decode.optional_field("identifier", [], decode.list(identifier_decoder()))
use modifier_extension <- decode.optional_field("modifierExtension", [], decode.list(extension_decoder()))
use extension <- decode.optional_field("extension", [], decode.list(extension_decoder()))
use contained <- decode.optional_field("contained", [], decode.list(resource_decoder()))
use text <- decode.optional_field("text", None, decode.optional(narrative_decoder()))
use language <- decode.optional_field("language", None, decode.optional(decode.string))
use implicit_rules <- decode.optional_field("implicitRules", None, decode.optional(decode.string))
use meta <- decode.optional_field("meta", None, decode.optional(meta_decoder()))
use id <- decode.optional_field("id", None, decode.optional(decode.string))
decode.success(Visionprescription(lens_specification:,prescriber:,date_written:,encounter:,patient:,created:,status:,identifier:,modifier_extension:,extension:,contained:,text:,language:,implicit_rules:,meta:,id:,))}
      //std lib decode.optional supports myfield: null but what if myfield is omitted from json entirely?
      fn none_if_omitted(d: decode.Decoder(a)) -> decode.Decoder(Option(a)) {
        decode.one_of(d |> decode.map(Some), [decode.success(None)])
      }