////FHIR r5 types
////https://hl7.org/fhir/r5

import fhir/r5valuesets
import gleam/bool
import gleam/dynamic/decode.{type Decoder}
import gleam/json.{type Json}
import gleam/option.{type Option, None, Some}

///http://hl7.org/fhir/r5/StructureDefinition/Address#resource
pub type Address {
  Address(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r5valuesets.Addressuse),
    type_: Option(r5valuesets.Addresstype),
    text: Option(String),
    line: List(String),
    city: Option(String),
    district: Option(String),
    state: Option(String),
    postal_code: Option(String),
    country: Option(String),
    period: Option(Period),
  )
}

pub fn address_new() -> Address {
  Address(
    period: None,
    country: None,
    postal_code: None,
    state: None,
    district: None,
    city: None,
    line: [],
    text: None,
    type_: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn address_to_json(address: Address) -> Json {
  let Address(
    period:,
    country:,
    postal_code:,
    state:,
    district:,
    city:,
    line:,
    text:,
    type_:,
    use_:,
    extension:,
    id:,
  ) = address
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case country {
    Some(v) -> [#("country", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case postal_code {
    Some(v) -> [#("postalCode", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case state {
    Some(v) -> [#("state", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case district {
    Some(v) -> [#("district", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case city {
    Some(v) -> [#("city", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case line {
    [] -> fields
    _ -> [#("line", json.array(line, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r5valuesets.addresstype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r5valuesets.addressuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn address_decoder() -> Decoder(Address) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    None,
    decode.optional(decode.string),
  )
  use postal_code <- decode.optional_field(
    "postalCode",
    None,
    decode.optional(decode.string),
  )
  use state <- decode.optional_field(
    "state",
    None,
    decode.optional(decode.string),
  )
  use district <- decode.optional_field(
    "district",
    None,
    decode.optional(decode.string),
  )
  use city <- decode.optional_field(
    "city",
    None,
    decode.optional(decode.string),
  )
  use line <- decode.optional_field("line", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.addresstype_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r5valuesets.addressuse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Address(
    period:,
    country:,
    postal_code:,
    state:,
    district:,
    city:,
    line:,
    text:,
    type_:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Age#resource
pub type Age {
  Age(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn age_new() -> Age {
  Age(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn age_to_json(age: Age) -> Json {
  let Age(code:, system:, unit:, comparator:, value:, extension:, id:) = age
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn age_decoder() -> Decoder(Age) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Age(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Annotation#resource
pub type Annotation {
  Annotation(
    id: Option(String),
    extension: List(Extension),
    author: Option(AnnotationAuthor),
    time: Option(String),
    text: String,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Annotation#resource
pub type AnnotationAuthor {
  AnnotationAuthorReference(author: Reference)
  AnnotationAuthorString(author: String)
}

pub fn annotation_author_to_json(elt: AnnotationAuthor) -> Json {
  case elt {
    AnnotationAuthorReference(v) -> reference_to_json(v)
    AnnotationAuthorString(v) -> json.string(v)
  }
}

pub fn annotation_author_decoder() -> Decoder(AnnotationAuthor) {
  decode.one_of(
    decode.field("authorReference", reference_decoder(), decode.success)
      |> decode.map(AnnotationAuthorReference),
    [
      decode.field("authorString", decode.string, decode.success)
      |> decode.map(AnnotationAuthorString),
    ],
  )
}

pub fn annotation_new(text text: String) -> Annotation {
  Annotation(text:, time: None, author: None, extension: [], id: None)
}

pub fn annotation_to_json(annotation: Annotation) -> Json {
  let Annotation(text:, time:, author:, extension:, id:) = annotation
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [
      #(
        "author"
          <> case v {
          AnnotationAuthorReference(_) -> "Reference"
          AnnotationAuthorString(_) -> "String"
        },
        annotation_author_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn annotation_decoder() -> Decoder(Annotation) {
  use text <- decode.field("text", decode.string)
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use author <- decode.then(none_if_omitted(annotation_author_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Annotation(text:, time:, author:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Attachment#resource
pub type Attachment {
  Attachment(
    id: Option(String),
    extension: List(Extension),
    content_type: Option(String),
    language: Option(String),
    data: Option(String),
    url: Option(String),
    size: Option(Int),
    hash: Option(String),
    title: Option(String),
    creation: Option(String),
    height: Option(Int),
    width: Option(Int),
    frames: Option(Int),
    duration: Option(Float),
    pages: Option(Int),
  )
}

pub fn attachment_new() -> Attachment {
  Attachment(
    pages: None,
    duration: None,
    frames: None,
    width: None,
    height: None,
    creation: None,
    title: None,
    hash: None,
    size: None,
    url: None,
    data: None,
    language: None,
    content_type: None,
    extension: [],
    id: None,
  )
}

pub fn attachment_to_json(attachment: Attachment) -> Json {
  let Attachment(
    pages:,
    duration:,
    frames:,
    width:,
    height:,
    creation:,
    title:,
    hash:,
    size:,
    url:,
    data:,
    language:,
    content_type:,
    extension:,
    id:,
  ) = attachment
  let fields = []
  let fields = case pages {
    Some(v) -> [#("pages", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case frames {
    Some(v) -> [#("frames", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case width {
    Some(v) -> [#("width", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case height {
    Some(v) -> [#("height", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case creation {
    Some(v) -> [#("creation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case hash {
    Some(v) -> [#("hash", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case size {
    Some(v) -> [#("size", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn attachment_decoder() -> Decoder(Attachment) {
  use pages <- decode.optional_field("pages", None, decode.optional(decode.int))
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(decode.float),
  )
  use frames <- decode.optional_field(
    "frames",
    None,
    decode.optional(decode.int),
  )
  use width <- decode.optional_field("width", None, decode.optional(decode.int))
  use height <- decode.optional_field(
    "height",
    None,
    decode.optional(decode.int),
  )
  use creation <- decode.optional_field(
    "creation",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use hash <- decode.optional_field(
    "hash",
    None,
    decode.optional(decode.string),
  )
  use size <- decode.optional_field("size", None, decode.optional(decode.int))
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Attachment(
    pages:,
    duration:,
    frames:,
    width:,
    height:,
    creation:,
    title:,
    hash:,
    size:,
    url:,
    data:,
    language:,
    content_type:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Availability#resource
pub type Availability {
  Availability(
    id: Option(String),
    extension: List(Extension),
    available_time: List(AvailabilityAvailabletime),
    not_available_time: List(AvailabilityNotavailabletime),
  )
}

pub fn availability_new() -> Availability {
  Availability(
    not_available_time: [],
    available_time: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Availability#resource
pub type AvailabilityAvailabletime {
  AvailabilityAvailabletime(
    id: Option(String),
    extension: List(Extension),
    days_of_week: List(r5valuesets.Daysofweek),
    all_day: Option(Bool),
    available_start_time: Option(String),
    available_end_time: Option(String),
  )
}

pub fn availability_availabletime_new() -> AvailabilityAvailabletime {
  AvailabilityAvailabletime(
    available_end_time: None,
    available_start_time: None,
    all_day: None,
    days_of_week: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Availability#resource
pub type AvailabilityNotavailabletime {
  AvailabilityNotavailabletime(
    id: Option(String),
    extension: List(Extension),
    description: Option(String),
    during: Option(Period),
  )
}

pub fn availability_notavailabletime_new() -> AvailabilityNotavailabletime {
  AvailabilityNotavailabletime(
    during: None,
    description: None,
    extension: [],
    id: None,
  )
}

pub fn availability_notavailabletime_to_json(
  availability_notavailabletime: AvailabilityNotavailabletime,
) -> Json {
  let AvailabilityNotavailabletime(during:, description:, extension:, id:) =
    availability_notavailabletime
  let fields = []
  let fields = case during {
    Some(v) -> [#("during", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn availability_notavailabletime_decoder() -> Decoder(
  AvailabilityNotavailabletime,
) {
  use during <- decode.optional_field(
    "during",
    None,
    decode.optional(period_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AvailabilityNotavailabletime(
    during:,
    description:,
    extension:,
    id:,
  ))
}

pub fn availability_availabletime_to_json(
  availability_availabletime: AvailabilityAvailabletime,
) -> Json {
  let AvailabilityAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    extension:,
    id:,
  ) = availability_availabletime
  let fields = []
  let fields = case available_end_time {
    Some(v) -> [#("availableEndTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case available_start_time {
    Some(v) -> [#("availableStartTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case all_day {
    Some(v) -> [#("allDay", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case days_of_week {
    [] -> fields
    _ -> [
      #("daysOfWeek", json.array(days_of_week, r5valuesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn availability_availabletime_decoder() -> Decoder(
  AvailabilityAvailabletime,
) {
  use available_end_time <- decode.optional_field(
    "availableEndTime",
    None,
    decode.optional(decode.string),
  )
  use available_start_time <- decode.optional_field(
    "availableStartTime",
    None,
    decode.optional(decode.string),
  )
  use all_day <- decode.optional_field(
    "allDay",
    None,
    decode.optional(decode.bool),
  )
  use days_of_week <- decode.optional_field(
    "daysOfWeek",
    [],
    decode.list(r5valuesets.daysofweek_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AvailabilityAvailabletime(
    available_end_time:,
    available_start_time:,
    all_day:,
    days_of_week:,
    extension:,
    id:,
  ))
}

pub fn availability_to_json(availability: Availability) -> Json {
  let Availability(not_available_time:, available_time:, extension:, id:) =
    availability
  let fields = []
  let fields = case not_available_time {
    [] -> fields
    _ -> [
      #(
        "notAvailableTime",
        json.array(not_available_time, availability_notavailabletime_to_json),
      ),
      ..fields
    ]
  }
  let fields = case available_time {
    [] -> fields
    _ -> [
      #(
        "availableTime",
        json.array(available_time, availability_availabletime_to_json),
      ),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn availability_decoder() -> Decoder(Availability) {
  use not_available_time <- decode.optional_field(
    "notAvailableTime",
    [],
    decode.list(availability_notavailabletime_decoder()),
  )
  use available_time <- decode.optional_field(
    "availableTime",
    [],
    decode.list(availability_availabletime_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Availability(
    not_available_time:,
    available_time:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/BackboneType#resource
pub type Backbonetype {
  Backbonetype(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn backbonetype_new() -> Backbonetype {
  Backbonetype(modifier_extension: [], extension: [], id: None)
}

pub fn backbonetype_to_json(backbonetype: Backbonetype) -> Json {
  let Backbonetype(modifier_extension:, extension:, id:) = backbonetype
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn backbonetype_decoder() -> Decoder(Backbonetype) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Backbonetype(modifier_extension:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeableConcept#resource
pub type Codeableconcept {
  Codeableconcept(
    id: Option(String),
    extension: List(Extension),
    coding: List(Coding),
    text: Option(String),
  )
}

pub fn codeableconcept_new() -> Codeableconcept {
  Codeableconcept(text: None, coding: [], extension: [], id: None)
}

pub fn codeableconcept_to_json(codeableconcept: Codeableconcept) -> Json {
  let Codeableconcept(text:, coding:, extension:, id:) = codeableconcept
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case coding {
    [] -> fields
    _ -> [#("coding", json.array(coding, coding_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codeableconcept_decoder() -> Decoder(Codeableconcept) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use coding <- decode.optional_field(
    "coding",
    [],
    decode.list(coding_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Codeableconcept(text:, coding:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeableReference#resource
pub type Codeablereference {
  Codeablereference(
    id: Option(String),
    extension: List(Extension),
    concept: Option(Codeableconcept),
    reference: Option(Reference),
  )
}

pub fn codeablereference_new() -> Codeablereference {
  Codeablereference(reference: None, concept: None, extension: [], id: None)
}

pub fn codeablereference_to_json(codeablereference: Codeablereference) -> Json {
  let Codeablereference(reference:, concept:, extension:, id:) =
    codeablereference
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case concept {
    Some(v) -> [#("concept", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codeablereference_decoder() -> Decoder(Codeablereference) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use concept <- decode.optional_field(
    "concept",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Codeablereference(reference:, concept:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Coding#resource
pub type Coding {
  Coding(
    id: Option(String),
    extension: List(Extension),
    system: Option(String),
    version: Option(String),
    code: Option(String),
    display: Option(String),
    user_selected: Option(Bool),
  )
}

pub fn coding_new() -> Coding {
  Coding(
    user_selected: None,
    display: None,
    code: None,
    version: None,
    system: None,
    extension: [],
    id: None,
  )
}

pub fn coding_to_json(coding: Coding) -> Json {
  let Coding(
    user_selected:,
    display:,
    code:,
    version:,
    system:,
    extension:,
    id:,
  ) = coding
  let fields = []
  let fields = case user_selected {
    Some(v) -> [#("userSelected", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coding_decoder() -> Decoder(Coding) {
  use user_selected <- decode.optional_field(
    "userSelected",
    None,
    decode.optional(decode.bool),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Coding(
    user_selected:,
    display:,
    code:,
    version:,
    system:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ContactDetail#resource
pub type Contactdetail {
  Contactdetail(
    id: Option(String),
    extension: List(Extension),
    name: Option(String),
    telecom: List(Contactpoint),
  )
}

pub fn contactdetail_new() -> Contactdetail {
  Contactdetail(telecom: [], name: None, extension: [], id: None)
}

pub fn contactdetail_to_json(contactdetail: Contactdetail) -> Json {
  let Contactdetail(telecom:, name:, extension:, id:) = contactdetail
  let fields = []
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contactdetail_decoder() -> Decoder(Contactdetail) {
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contactdetail(telecom:, name:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/ContactPoint#resource
pub type Contactpoint {
  Contactpoint(
    id: Option(String),
    extension: List(Extension),
    system: Option(r5valuesets.Contactpointsystem),
    value: Option(String),
    use_: Option(r5valuesets.Contactpointuse),
    rank: Option(Int),
    period: Option(Period),
  )
}

pub fn contactpoint_new() -> Contactpoint {
  Contactpoint(
    period: None,
    rank: None,
    use_: None,
    value: None,
    system: None,
    extension: [],
    id: None,
  )
}

pub fn contactpoint_to_json(contactpoint: Contactpoint) -> Json {
  let Contactpoint(period:, rank:, use_:, value:, system:, extension:, id:) =
    contactpoint
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case rank {
    Some(v) -> [#("rank", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r5valuesets.contactpointuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [
      #("system", r5valuesets.contactpointsystem_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contactpoint_decoder() -> Decoder(Contactpoint) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use rank <- decode.optional_field("rank", None, decode.optional(decode.int))
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r5valuesets.contactpointuse_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(r5valuesets.contactpointsystem_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contactpoint(
    period:,
    rank:,
    use_:,
    value:,
    system:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Contributor#resource
pub type Contributor {
  Contributor(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Contributortype,
    name: String,
    contact: List(Contactdetail),
  )
}

pub fn contributor_new(
  name name: String,
  type_ type_: r5valuesets.Contributortype,
) -> Contributor {
  Contributor(contact: [], name:, type_:, extension: [], id: None)
}

pub fn contributor_to_json(contributor: Contributor) -> Json {
  let Contributor(contact:, name:, type_:, extension:, id:) = contributor
  let fields = [
    #("name", json.string(name)),
    #("type", r5valuesets.contributortype_to_json(type_)),
  ]
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contributor_decoder() -> Decoder(Contributor) {
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use type_ <- decode.field("type", r5valuesets.contributortype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Contributor(contact:, name:, type_:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Count#resource
pub type Count {
  Count(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn count_new() -> Count {
  Count(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn count_to_json(count: Count) -> Json {
  let Count(code:, system:, unit:, comparator:, value:, extension:, id:) = count
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn count_decoder() -> Decoder(Count) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Count(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type Datarequirement {
  Datarequirement(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Fhirtypes,
    profile: List(String),
    subject: Option(DatarequirementSubject),
    must_support: List(String),
    code_filter: List(DatarequirementCodefilter),
    date_filter: List(DatarequirementDatefilter),
    value_filter: List(DatarequirementValuefilter),
    limit: Option(Int),
    sort: List(DatarequirementSort),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementSubject {
  DatarequirementSubjectCodeableconcept(subject: Codeableconcept)
  DatarequirementSubjectReference(subject: Reference)
}

pub fn datarequirement_subject_to_json(elt: DatarequirementSubject) -> Json {
  case elt {
    DatarequirementSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    DatarequirementSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn datarequirement_subject_decoder() -> Decoder(DatarequirementSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(DatarequirementSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(DatarequirementSubjectReference),
    ],
  )
}

pub fn datarequirement_new(
  type_ type_: r5valuesets.Fhirtypes,
) -> Datarequirement {
  Datarequirement(
    sort: [],
    limit: None,
    value_filter: [],
    date_filter: [],
    code_filter: [],
    must_support: [],
    subject: None,
    profile: [],
    type_:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementCodefilter {
  DatarequirementCodefilter(
    id: Option(String),
    extension: List(Extension),
    path: Option(String),
    search_param: Option(String),
    value_set: Option(String),
    code: List(Coding),
  )
}

pub fn datarequirement_codefilter_new() -> DatarequirementCodefilter {
  DatarequirementCodefilter(
    code: [],
    value_set: None,
    search_param: None,
    path: None,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementDatefilter {
  DatarequirementDatefilter(
    id: Option(String),
    extension: List(Extension),
    path: Option(String),
    search_param: Option(String),
    value: Option(DatarequirementDatefilterValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementDatefilterValue {
  DatarequirementDatefilterValueDatetime(value: String)
  DatarequirementDatefilterValuePeriod(value: Period)
  DatarequirementDatefilterValueDuration(value: Duration)
}

pub fn datarequirement_datefilter_value_to_json(
  elt: DatarequirementDatefilterValue,
) -> Json {
  case elt {
    DatarequirementDatefilterValueDatetime(v) -> json.string(v)
    DatarequirementDatefilterValuePeriod(v) -> period_to_json(v)
    DatarequirementDatefilterValueDuration(v) -> duration_to_json(v)
  }
}

pub fn datarequirement_datefilter_value_decoder() -> Decoder(
  DatarequirementDatefilterValue,
) {
  decode.one_of(
    decode.field("valueDateTime", decode.string, decode.success)
      |> decode.map(DatarequirementDatefilterValueDatetime),
    [
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(DatarequirementDatefilterValuePeriod),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(DatarequirementDatefilterValueDuration),
    ],
  )
}

pub fn datarequirement_datefilter_new() -> DatarequirementDatefilter {
  DatarequirementDatefilter(
    value: None,
    search_param: None,
    path: None,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementValuefilter {
  DatarequirementValuefilter(
    id: Option(String),
    extension: List(Extension),
    path: Option(String),
    search_param: Option(String),
    comparator: Option(r5valuesets.Valuefiltercomparator),
    value: Option(DatarequirementValuefilterValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementValuefilterValue {
  DatarequirementValuefilterValueDatetime(value: String)
  DatarequirementValuefilterValuePeriod(value: Period)
  DatarequirementValuefilterValueDuration(value: Duration)
}

pub fn datarequirement_valuefilter_value_to_json(
  elt: DatarequirementValuefilterValue,
) -> Json {
  case elt {
    DatarequirementValuefilterValueDatetime(v) -> json.string(v)
    DatarequirementValuefilterValuePeriod(v) -> period_to_json(v)
    DatarequirementValuefilterValueDuration(v) -> duration_to_json(v)
  }
}

pub fn datarequirement_valuefilter_value_decoder() -> Decoder(
  DatarequirementValuefilterValue,
) {
  decode.one_of(
    decode.field("valueDateTime", decode.string, decode.success)
      |> decode.map(DatarequirementValuefilterValueDatetime),
    [
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(DatarequirementValuefilterValuePeriod),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(DatarequirementValuefilterValueDuration),
    ],
  )
}

pub fn datarequirement_valuefilter_new() -> DatarequirementValuefilter {
  DatarequirementValuefilter(
    value: None,
    comparator: None,
    search_param: None,
    path: None,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DataRequirement#resource
pub type DatarequirementSort {
  DatarequirementSort(
    id: Option(String),
    extension: List(Extension),
    path: String,
    direction: r5valuesets.Sortdirection,
  )
}

pub fn datarequirement_sort_new(
  direction direction: r5valuesets.Sortdirection,
  path path: String,
) -> DatarequirementSort {
  DatarequirementSort(direction:, path:, extension: [], id: None)
}

pub fn datarequirement_sort_to_json(
  datarequirement_sort: DatarequirementSort,
) -> Json {
  let DatarequirementSort(direction:, path:, extension:, id:) =
    datarequirement_sort
  let fields = [
    #("direction", r5valuesets.sortdirection_to_json(direction)),
    #("path", json.string(path)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_sort_decoder() -> Decoder(DatarequirementSort) {
  use direction <- decode.field(
    "direction",
    r5valuesets.sortdirection_decoder(),
  )
  use path <- decode.field("path", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementSort(direction:, path:, extension:, id:))
}

pub fn datarequirement_valuefilter_to_json(
  datarequirement_valuefilter: DatarequirementValuefilter,
) -> Json {
  let DatarequirementValuefilter(
    value:,
    comparator:,
    search_param:,
    path:,
    extension:,
    id:,
  ) = datarequirement_valuefilter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          DatarequirementValuefilterValueDatetime(_) -> "Datetime"
          DatarequirementValuefilterValuePeriod(_) -> "Period"
          DatarequirementValuefilterValueDuration(_) -> "Duration"
        },
        datarequirement_valuefilter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.valuefiltercomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case search_param {
    Some(v) -> [#("searchParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_valuefilter_decoder() -> Decoder(
  DatarequirementValuefilter,
) {
  use value <- decode.then(
    none_if_omitted(datarequirement_valuefilter_value_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.valuefiltercomparator_decoder()),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementValuefilter(
    value:,
    comparator:,
    search_param:,
    path:,
    extension:,
    id:,
  ))
}

pub fn datarequirement_datefilter_to_json(
  datarequirement_datefilter: DatarequirementDatefilter,
) -> Json {
  let DatarequirementDatefilter(value:, search_param:, path:, extension:, id:) =
    datarequirement_datefilter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          DatarequirementDatefilterValueDatetime(_) -> "Datetime"
          DatarequirementDatefilterValuePeriod(_) -> "Period"
          DatarequirementDatefilterValueDuration(_) -> "Duration"
        },
        datarequirement_datefilter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case search_param {
    Some(v) -> [#("searchParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_datefilter_decoder() -> Decoder(
  DatarequirementDatefilter,
) {
  use value <- decode.then(
    none_if_omitted(datarequirement_datefilter_value_decoder()),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementDatefilter(
    value:,
    search_param:,
    path:,
    extension:,
    id:,
  ))
}

pub fn datarequirement_codefilter_to_json(
  datarequirement_codefilter: DatarequirementCodefilter,
) -> Json {
  let DatarequirementCodefilter(
    code:,
    value_set:,
    search_param:,
    path:,
    extension:,
    id:,
  ) = datarequirement_codefilter
  let fields = []
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case search_param {
    Some(v) -> [#("searchParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_codefilter_decoder() -> Decoder(
  DatarequirementCodefilter,
) {
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DatarequirementCodefilter(
    code:,
    value_set:,
    search_param:,
    path:,
    extension:,
    id:,
  ))
}

pub fn datarequirement_to_json(datarequirement: Datarequirement) -> Json {
  let Datarequirement(
    sort:,
    limit:,
    value_filter:,
    date_filter:,
    code_filter:,
    must_support:,
    subject:,
    profile:,
    type_:,
    extension:,
    id:,
  ) = datarequirement
  let fields = [
    #("type", r5valuesets.fhirtypes_to_json(type_)),
  ]
  let fields = case sort {
    [] -> fields
    _ -> [#("sort", json.array(sort, datarequirement_sort_to_json)), ..fields]
  }
  let fields = case limit {
    Some(v) -> [#("limit", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case value_filter {
    [] -> fields
    _ -> [
      #(
        "valueFilter",
        json.array(value_filter, datarequirement_valuefilter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case date_filter {
    [] -> fields
    _ -> [
      #(
        "dateFilter",
        json.array(date_filter, datarequirement_datefilter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code_filter {
    [] -> fields
    _ -> [
      #(
        "codeFilter",
        json.array(code_filter, datarequirement_codefilter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case must_support {
    [] -> fields
    _ -> [#("mustSupport", json.array(must_support, json.string)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          DatarequirementSubjectCodeableconcept(_) -> "Codeableconcept"
          DatarequirementSubjectReference(_) -> "Reference"
        },
        datarequirement_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datarequirement_decoder() -> Decoder(Datarequirement) {
  use sort <- decode.optional_field(
    "sort",
    [],
    decode.list(datarequirement_sort_decoder()),
  )
  use limit <- decode.optional_field("limit", None, decode.optional(decode.int))
  use value_filter <- decode.optional_field(
    "valueFilter",
    [],
    decode.list(datarequirement_valuefilter_decoder()),
  )
  use date_filter <- decode.optional_field(
    "dateFilter",
    [],
    decode.list(datarequirement_datefilter_decoder()),
  )
  use code_filter <- decode.optional_field(
    "codeFilter",
    [],
    decode.list(datarequirement_codefilter_decoder()),
  )
  use must_support <- decode.optional_field(
    "mustSupport",
    [],
    decode.list(decode.string),
  )
  use subject <- decode.then(none_if_omitted(datarequirement_subject_decoder()))
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.fhirtypes_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Datarequirement(
    sort:,
    limit:,
    value_filter:,
    date_filter:,
    code_filter:,
    must_support:,
    subject:,
    profile:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DataType#resource
pub type Datatype {
  Datatype(id: Option(String), extension: List(Extension))
}

pub fn datatype_new() -> Datatype {
  Datatype(extension: [], id: None)
}

pub fn datatype_to_json(datatype: Datatype) -> Json {
  let Datatype(extension:, id:) = datatype
  let fields = []
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn datatype_decoder() -> Decoder(Datatype) {
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Datatype(extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Distance#resource
pub type Distance {
  Distance(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn distance_new() -> Distance {
  Distance(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn distance_to_json(distance: Distance) -> Json {
  let Distance(code:, system:, unit:, comparator:, value:, extension:, id:) =
    distance
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn distance_decoder() -> Decoder(Distance) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Distance(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Dosage#resource
pub type Dosage {
  Dosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    text: Option(String),
    additional_instruction: List(Codeableconcept),
    patient_instruction: Option(String),
    timing: Option(Timing),
    as_needed: Option(Bool),
    as_needed_for: List(Codeableconcept),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    method: Option(Codeableconcept),
    dose_and_rate: List(DosageDoseandrate),
    max_dose_per_period: List(Ratio),
    max_dose_per_administration: Option(Quantity),
    max_dose_per_lifetime: Option(Quantity),
  )
}

pub fn dosage_new() -> Dosage {
  Dosage(
    max_dose_per_lifetime: None,
    max_dose_per_administration: None,
    max_dose_per_period: [],
    dose_and_rate: [],
    method: None,
    route: None,
    site: None,
    as_needed_for: [],
    as_needed: None,
    timing: None,
    patient_instruction: None,
    additional_instruction: [],
    text: None,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Dosage#resource
pub type DosageDoseandrate {
  DosageDoseandrate(
    id: Option(String),
    extension: List(Extension),
    type_: Option(Codeableconcept),
    dose: Option(DosageDoseandrateDose),
    rate: Option(DosageDoseandrateRate),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Dosage#resource
pub type DosageDoseandrateDose {
  DosageDoseandrateDoseRange(dose: Range)
  DosageDoseandrateDoseQuantity(dose: Quantity)
}

pub fn dosage_doseandrate_dose_to_json(elt: DosageDoseandrateDose) -> Json {
  case elt {
    DosageDoseandrateDoseRange(v) -> range_to_json(v)
    DosageDoseandrateDoseQuantity(v) -> quantity_to_json(v)
  }
}

pub fn dosage_doseandrate_dose_decoder() -> Decoder(DosageDoseandrateDose) {
  decode.one_of(
    decode.field("doseRange", range_decoder(), decode.success)
      |> decode.map(DosageDoseandrateDoseRange),
    [
      decode.field("doseQuantity", quantity_decoder(), decode.success)
      |> decode.map(DosageDoseandrateDoseQuantity),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Dosage#resource
pub type DosageDoseandrateRate {
  DosageDoseandrateRateRatio(rate: Ratio)
  DosageDoseandrateRateRange(rate: Range)
  DosageDoseandrateRateQuantity(rate: Quantity)
}

pub fn dosage_doseandrate_rate_to_json(elt: DosageDoseandrateRate) -> Json {
  case elt {
    DosageDoseandrateRateRatio(v) -> ratio_to_json(v)
    DosageDoseandrateRateRange(v) -> range_to_json(v)
    DosageDoseandrateRateQuantity(v) -> quantity_to_json(v)
  }
}

pub fn dosage_doseandrate_rate_decoder() -> Decoder(DosageDoseandrateRate) {
  decode.one_of(
    decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(DosageDoseandrateRateRatio),
    [
      decode.field("rateRange", range_decoder(), decode.success)
        |> decode.map(DosageDoseandrateRateRange),
      decode.field("rateQuantity", quantity_decoder(), decode.success)
        |> decode.map(DosageDoseandrateRateQuantity),
    ],
  )
}

pub fn dosage_doseandrate_new() -> DosageDoseandrate {
  DosageDoseandrate(
    rate: None,
    dose: None,
    type_: None,
    extension: [],
    id: None,
  )
}

pub fn dosage_doseandrate_to_json(dosage_doseandrate: DosageDoseandrate) -> Json {
  let DosageDoseandrate(rate:, dose:, type_:, extension:, id:) =
    dosage_doseandrate
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          DosageDoseandrateRateRatio(_) -> "Ratio"
          DosageDoseandrateRateRange(_) -> "Range"
          DosageDoseandrateRateQuantity(_) -> "Quantity"
        },
        dosage_doseandrate_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose {
    Some(v) -> [
      #(
        "dose"
          <> case v {
          DosageDoseandrateDoseRange(_) -> "Range"
          DosageDoseandrateDoseQuantity(_) -> "Quantity"
        },
        dosage_doseandrate_dose_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn dosage_doseandrate_decoder() -> Decoder(DosageDoseandrate) {
  use rate <- decode.then(none_if_omitted(dosage_doseandrate_rate_decoder()))
  use dose <- decode.then(none_if_omitted(dosage_doseandrate_dose_decoder()))
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DosageDoseandrate(rate:, dose:, type_:, extension:, id:))
}

pub fn dosage_to_json(dosage: Dosage) -> Json {
  let Dosage(
    max_dose_per_lifetime:,
    max_dose_per_administration:,
    max_dose_per_period:,
    dose_and_rate:,
    method:,
    route:,
    site:,
    as_needed_for:,
    as_needed:,
    timing:,
    patient_instruction:,
    additional_instruction:,
    text:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = dosage
  let fields = []
  let fields = case max_dose_per_lifetime {
    Some(v) -> [#("maxDosePerLifetime", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_administration {
    Some(v) -> [#("maxDosePerAdministration", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_period {
    [] -> fields
    _ -> [
      #("maxDosePerPeriod", json.array(max_dose_per_period, ratio_to_json)),
      ..fields
    ]
  }
  let fields = case dose_and_rate {
    [] -> fields
    _ -> [
      #("doseAndRate", json.array(dose_and_rate, dosage_doseandrate_to_json)),
      ..fields
    ]
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed_for {
    [] -> fields
    _ -> [
      #("asNeededFor", json.array(as_needed_for, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case as_needed {
    Some(v) -> [#("asNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [#("timing", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_instruction {
    Some(v) -> [#("patientInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case additional_instruction {
    [] -> fields
    _ -> [
      #(
        "additionalInstruction",
        json.array(additional_instruction, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn dosage_decoder() -> Decoder(Dosage) {
  use max_dose_per_lifetime <- decode.optional_field(
    "maxDosePerLifetime",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_dose_per_administration <- decode.optional_field(
    "maxDosePerAdministration",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_dose_per_period <- decode.optional_field(
    "maxDosePerPeriod",
    [],
    decode.list(ratio_decoder()),
  )
  use dose_and_rate <- decode.optional_field(
    "doseAndRate",
    [],
    decode.list(dosage_doseandrate_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed_for <- decode.optional_field(
    "asNeededFor",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use as_needed <- decode.optional_field(
    "asNeeded",
    None,
    decode.optional(decode.bool),
  )
  use timing <- decode.optional_field(
    "timing",
    None,
    decode.optional(timing_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    None,
    decode.optional(decode.string),
  )
  use additional_instruction <- decode.optional_field(
    "additionalInstruction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Dosage(
    max_dose_per_lifetime:,
    max_dose_per_administration:,
    max_dose_per_period:,
    dose_and_rate:,
    method:,
    route:,
    site:,
    as_needed_for:,
    as_needed:,
    timing:,
    patient_instruction:,
    additional_instruction:,
    text:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Duration#resource
pub type Duration {
  Duration(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn duration_new() -> Duration {
  Duration(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn duration_to_json(duration: Duration) -> Json {
  let Duration(code:, system:, unit:, comparator:, value:, extension:, id:) =
    duration
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn duration_decoder() -> Decoder(Duration) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Duration(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type Elementdefinition {
  Elementdefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: String,
    representation: List(r5valuesets.Propertyrepresentation),
    slice_name: Option(String),
    slice_is_constraining: Option(Bool),
    label: Option(String),
    code: List(Coding),
    slicing: Option(ElementdefinitionSlicing),
    short: Option(String),
    definition: Option(String),
    comment: Option(String),
    requirements: Option(String),
    alias: List(String),
    min: Option(Int),
    max: Option(String),
    base: Option(ElementdefinitionBase),
    content_reference: Option(String),
    type_: List(ElementdefinitionType),
    default_value: Option(ElementdefinitionDefaultvalue),
    meaning_when_missing: Option(String),
    order_meaning: Option(String),
    fixed: Option(ElementdefinitionFixed),
    pattern: Option(ElementdefinitionPattern),
    example: List(ElementdefinitionExample),
    min_value: Option(ElementdefinitionMinvalue),
    max_value: Option(ElementdefinitionMaxvalue),
    max_length: Option(Int),
    condition: List(String),
    constraint: List(ElementdefinitionConstraint),
    must_have_value: Option(Bool),
    value_alternatives: List(String),
    must_support: Option(Bool),
    is_modifier: Option(Bool),
    is_modifier_reason: Option(String),
    is_summary: Option(Bool),
    binding: Option(ElementdefinitionBinding),
    mapping: List(ElementdefinitionMapping),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionDefaultvalue {
  ElementdefinitionDefaultvalueBase64binary(default_value: String)
  ElementdefinitionDefaultvalueBoolean(default_value: Bool)
  ElementdefinitionDefaultvalueCanonical(default_value: String)
  ElementdefinitionDefaultvalueCode(default_value: String)
  ElementdefinitionDefaultvalueDate(default_value: String)
  ElementdefinitionDefaultvalueDatetime(default_value: String)
  ElementdefinitionDefaultvalueDecimal(default_value: Float)
  ElementdefinitionDefaultvalueId(default_value: String)
  ElementdefinitionDefaultvalueInstant(default_value: String)
  ElementdefinitionDefaultvalueInteger(default_value: Int)
  ElementdefinitionDefaultvalueInteger64(default_value: Int)
  ElementdefinitionDefaultvalueMarkdown(default_value: String)
  ElementdefinitionDefaultvalueOid(default_value: String)
  ElementdefinitionDefaultvaluePositiveint(default_value: Int)
  ElementdefinitionDefaultvalueString(default_value: String)
  ElementdefinitionDefaultvalueTime(default_value: String)
  ElementdefinitionDefaultvalueUnsignedint(default_value: Int)
  ElementdefinitionDefaultvalueUri(default_value: String)
  ElementdefinitionDefaultvalueUrl(default_value: String)
  ElementdefinitionDefaultvalueUuid(default_value: String)
  ElementdefinitionDefaultvalueAddress(default_value: Address)
  ElementdefinitionDefaultvalueAge(default_value: Age)
  ElementdefinitionDefaultvalueAnnotation(default_value: Annotation)
  ElementdefinitionDefaultvalueAttachment(default_value: Attachment)
  ElementdefinitionDefaultvalueCodeableconcept(default_value: Codeableconcept)
  ElementdefinitionDefaultvalueCodeablereference(
    default_value: Codeablereference,
  )
  ElementdefinitionDefaultvalueCoding(default_value: Coding)
  ElementdefinitionDefaultvalueContactpoint(default_value: Contactpoint)
  ElementdefinitionDefaultvalueCount(default_value: Count)
  ElementdefinitionDefaultvalueDistance(default_value: Distance)
  ElementdefinitionDefaultvalueDuration(default_value: Duration)
  ElementdefinitionDefaultvalueHumanname(default_value: Humanname)
  ElementdefinitionDefaultvalueIdentifier(default_value: Identifier)
  ElementdefinitionDefaultvalueMoney(default_value: Money)
  ElementdefinitionDefaultvaluePeriod(default_value: Period)
  ElementdefinitionDefaultvalueQuantity(default_value: Quantity)
  ElementdefinitionDefaultvalueRange(default_value: Range)
  ElementdefinitionDefaultvalueRatio(default_value: Ratio)
  ElementdefinitionDefaultvalueRatiorange(default_value: Ratiorange)
  ElementdefinitionDefaultvalueReference(default_value: Reference)
  ElementdefinitionDefaultvalueSampleddata(default_value: Sampleddata)
  ElementdefinitionDefaultvalueSignature(default_value: Signature)
  ElementdefinitionDefaultvalueTiming(default_value: Timing)
  ElementdefinitionDefaultvalueContactdetail(default_value: Contactdetail)
  ElementdefinitionDefaultvalueDatarequirement(default_value: Datarequirement)
  ElementdefinitionDefaultvalueExpression(default_value: Expression)
  ElementdefinitionDefaultvalueParameterdefinition(
    default_value: Parameterdefinition,
  )
  ElementdefinitionDefaultvalueRelatedartifact(default_value: Relatedartifact)
  ElementdefinitionDefaultvalueTriggerdefinition(
    default_value: Triggerdefinition,
  )
  ElementdefinitionDefaultvalueUsagecontext(default_value: Usagecontext)
  ElementdefinitionDefaultvalueAvailability(default_value: Availability)
  ElementdefinitionDefaultvalueExtendedcontactdetail(
    default_value: Extendedcontactdetail,
  )
  ElementdefinitionDefaultvalueDosage(default_value: Dosage)
  ElementdefinitionDefaultvalueMeta(default_value: Meta)
}

pub fn elementdefinition_defaultvalue_to_json(
  elt: ElementdefinitionDefaultvalue,
) -> Json {
  case elt {
    ElementdefinitionDefaultvalueBase64binary(v) -> json.string(v)
    ElementdefinitionDefaultvalueBoolean(v) -> json.bool(v)
    ElementdefinitionDefaultvalueCanonical(v) -> json.string(v)
    ElementdefinitionDefaultvalueCode(v) -> json.string(v)
    ElementdefinitionDefaultvalueDate(v) -> json.string(v)
    ElementdefinitionDefaultvalueDatetime(v) -> json.string(v)
    ElementdefinitionDefaultvalueDecimal(v) -> json.float(v)
    ElementdefinitionDefaultvalueId(v) -> json.string(v)
    ElementdefinitionDefaultvalueInstant(v) -> json.string(v)
    ElementdefinitionDefaultvalueInteger(v) -> json.int(v)
    ElementdefinitionDefaultvalueInteger64(v) -> json.int(v)
    ElementdefinitionDefaultvalueMarkdown(v) -> json.string(v)
    ElementdefinitionDefaultvalueOid(v) -> json.string(v)
    ElementdefinitionDefaultvaluePositiveint(v) -> json.int(v)
    ElementdefinitionDefaultvalueString(v) -> json.string(v)
    ElementdefinitionDefaultvalueTime(v) -> json.string(v)
    ElementdefinitionDefaultvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionDefaultvalueUri(v) -> json.string(v)
    ElementdefinitionDefaultvalueUrl(v) -> json.string(v)
    ElementdefinitionDefaultvalueUuid(v) -> json.string(v)
    ElementdefinitionDefaultvalueAddress(v) -> address_to_json(v)
    ElementdefinitionDefaultvalueAge(v) -> age_to_json(v)
    ElementdefinitionDefaultvalueAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionDefaultvalueAttachment(v) -> attachment_to_json(v)
    ElementdefinitionDefaultvalueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ElementdefinitionDefaultvalueCodeablereference(v) ->
      codeablereference_to_json(v)
    ElementdefinitionDefaultvalueCoding(v) -> coding_to_json(v)
    ElementdefinitionDefaultvalueContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionDefaultvalueCount(v) -> count_to_json(v)
    ElementdefinitionDefaultvalueDistance(v) -> distance_to_json(v)
    ElementdefinitionDefaultvalueDuration(v) -> duration_to_json(v)
    ElementdefinitionDefaultvalueHumanname(v) -> humanname_to_json(v)
    ElementdefinitionDefaultvalueIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionDefaultvalueMoney(v) -> money_to_json(v)
    ElementdefinitionDefaultvaluePeriod(v) -> period_to_json(v)
    ElementdefinitionDefaultvalueQuantity(v) -> quantity_to_json(v)
    ElementdefinitionDefaultvalueRange(v) -> range_to_json(v)
    ElementdefinitionDefaultvalueRatio(v) -> ratio_to_json(v)
    ElementdefinitionDefaultvalueRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionDefaultvalueReference(v) -> reference_to_json(v)
    ElementdefinitionDefaultvalueSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionDefaultvalueSignature(v) -> signature_to_json(v)
    ElementdefinitionDefaultvalueTiming(v) -> timing_to_json(v)
    ElementdefinitionDefaultvalueContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionDefaultvalueDatarequirement(v) ->
      datarequirement_to_json(v)
    ElementdefinitionDefaultvalueExpression(v) -> expression_to_json(v)
    ElementdefinitionDefaultvalueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionDefaultvalueRelatedartifact(v) ->
      relatedartifact_to_json(v)
    ElementdefinitionDefaultvalueTriggerdefinition(v) ->
      triggerdefinition_to_json(v)
    ElementdefinitionDefaultvalueUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionDefaultvalueAvailability(v) -> availability_to_json(v)
    ElementdefinitionDefaultvalueExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    ElementdefinitionDefaultvalueDosage(v) -> dosage_to_json(v)
    ElementdefinitionDefaultvalueMeta(v) -> meta_to_json(v)
  }
}

pub fn elementdefinition_defaultvalue_decoder() -> Decoder(
  ElementdefinitionDefaultvalue,
) {
  decode.one_of(
    decode.field("defaultValueBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionDefaultvalueBase64binary),
    [
      decode.field("defaultValueBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueBoolean),
      decode.field("defaultValueCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCanonical),
      decode.field("defaultValueCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCode),
      decode.field("defaultValueDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDate),
      decode.field("defaultValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDatetime),
      decode.field("defaultValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDecimal),
      decode.field("defaultValueId", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueId),
      decode.field("defaultValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueInstant),
      decode.field("defaultValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueInteger),
      decode.field("defaultValueInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueInteger64),
      decode.field("defaultValueMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueMarkdown),
      decode.field("defaultValueOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueOid),
      decode.field("defaultValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvaluePositiveint),
      decode.field("defaultValueString", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueString),
      decode.field("defaultValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueTime),
      decode.field("defaultValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUnsignedint),
      decode.field("defaultValueUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUri),
      decode.field("defaultValueUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUrl),
      decode.field("defaultValueUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionDefaultvalueUuid),
      decode.field("defaultValueAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueAddress),
      decode.field("defaultValueAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueAge),
      decode.field(
        "defaultValueAnnotation",
        annotation_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueAnnotation),
      decode.field(
        "defaultValueAttachment",
        attachment_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueAttachment),
      decode.field(
        "defaultValueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueCodeableconcept),
      decode.field(
        "defaultValueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueCodeablereference),
      decode.field("defaultValueCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCoding),
      decode.field(
        "defaultValueContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueContactpoint),
      decode.field("defaultValueCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueCount),
      decode.field("defaultValueDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDistance),
      decode.field("defaultValueDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDuration),
      decode.field("defaultValueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueHumanname),
      decode.field(
        "defaultValueIdentifier",
        identifier_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueIdentifier),
      decode.field("defaultValueMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueMoney),
      decode.field("defaultValuePeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvaluePeriod),
      decode.field("defaultValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueQuantity),
      decode.field("defaultValueRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueRange),
      decode.field("defaultValueRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueRatio),
      decode.field(
        "defaultValueRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueRatiorange),
      decode.field("defaultValueReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueReference),
      decode.field(
        "defaultValueSampledData",
        sampleddata_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueSampleddata),
      decode.field("defaultValueSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueSignature),
      decode.field("defaultValueTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueTiming),
      decode.field(
        "defaultValueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueContactdetail),
      decode.field(
        "defaultValueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueDatarequirement),
      decode.field(
        "defaultValueExpression",
        expression_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueExpression),
      decode.field(
        "defaultValueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueParameterdefinition),
      decode.field(
        "defaultValueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueRelatedartifact),
      decode.field(
        "defaultValueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueTriggerdefinition),
      decode.field(
        "defaultValueUsageContext",
        usagecontext_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueUsagecontext),
      decode.field(
        "defaultValueAvailability",
        availability_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueAvailability),
      decode.field(
        "defaultValueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionDefaultvalueExtendedcontactdetail),
      decode.field("defaultValueDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueDosage),
      decode.field("defaultValueMeta", meta_decoder(), decode.success)
        |> decode.map(ElementdefinitionDefaultvalueMeta),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionFixed {
  ElementdefinitionFixedBase64binary(fixed: String)
  ElementdefinitionFixedBoolean(fixed: Bool)
  ElementdefinitionFixedCanonical(fixed: String)
  ElementdefinitionFixedCode(fixed: String)
  ElementdefinitionFixedDate(fixed: String)
  ElementdefinitionFixedDatetime(fixed: String)
  ElementdefinitionFixedDecimal(fixed: Float)
  ElementdefinitionFixedId(fixed: String)
  ElementdefinitionFixedInstant(fixed: String)
  ElementdefinitionFixedInteger(fixed: Int)
  ElementdefinitionFixedInteger64(fixed: Int)
  ElementdefinitionFixedMarkdown(fixed: String)
  ElementdefinitionFixedOid(fixed: String)
  ElementdefinitionFixedPositiveint(fixed: Int)
  ElementdefinitionFixedString(fixed: String)
  ElementdefinitionFixedTime(fixed: String)
  ElementdefinitionFixedUnsignedint(fixed: Int)
  ElementdefinitionFixedUri(fixed: String)
  ElementdefinitionFixedUrl(fixed: String)
  ElementdefinitionFixedUuid(fixed: String)
  ElementdefinitionFixedAddress(fixed: Address)
  ElementdefinitionFixedAge(fixed: Age)
  ElementdefinitionFixedAnnotation(fixed: Annotation)
  ElementdefinitionFixedAttachment(fixed: Attachment)
  ElementdefinitionFixedCodeableconcept(fixed: Codeableconcept)
  ElementdefinitionFixedCodeablereference(fixed: Codeablereference)
  ElementdefinitionFixedCoding(fixed: Coding)
  ElementdefinitionFixedContactpoint(fixed: Contactpoint)
  ElementdefinitionFixedCount(fixed: Count)
  ElementdefinitionFixedDistance(fixed: Distance)
  ElementdefinitionFixedDuration(fixed: Duration)
  ElementdefinitionFixedHumanname(fixed: Humanname)
  ElementdefinitionFixedIdentifier(fixed: Identifier)
  ElementdefinitionFixedMoney(fixed: Money)
  ElementdefinitionFixedPeriod(fixed: Period)
  ElementdefinitionFixedQuantity(fixed: Quantity)
  ElementdefinitionFixedRange(fixed: Range)
  ElementdefinitionFixedRatio(fixed: Ratio)
  ElementdefinitionFixedRatiorange(fixed: Ratiorange)
  ElementdefinitionFixedReference(fixed: Reference)
  ElementdefinitionFixedSampleddata(fixed: Sampleddata)
  ElementdefinitionFixedSignature(fixed: Signature)
  ElementdefinitionFixedTiming(fixed: Timing)
  ElementdefinitionFixedContactdetail(fixed: Contactdetail)
  ElementdefinitionFixedDatarequirement(fixed: Datarequirement)
  ElementdefinitionFixedExpression(fixed: Expression)
  ElementdefinitionFixedParameterdefinition(fixed: Parameterdefinition)
  ElementdefinitionFixedRelatedartifact(fixed: Relatedartifact)
  ElementdefinitionFixedTriggerdefinition(fixed: Triggerdefinition)
  ElementdefinitionFixedUsagecontext(fixed: Usagecontext)
  ElementdefinitionFixedAvailability(fixed: Availability)
  ElementdefinitionFixedExtendedcontactdetail(fixed: Extendedcontactdetail)
  ElementdefinitionFixedDosage(fixed: Dosage)
  ElementdefinitionFixedMeta(fixed: Meta)
}

pub fn elementdefinition_fixed_to_json(elt: ElementdefinitionFixed) -> Json {
  case elt {
    ElementdefinitionFixedBase64binary(v) -> json.string(v)
    ElementdefinitionFixedBoolean(v) -> json.bool(v)
    ElementdefinitionFixedCanonical(v) -> json.string(v)
    ElementdefinitionFixedCode(v) -> json.string(v)
    ElementdefinitionFixedDate(v) -> json.string(v)
    ElementdefinitionFixedDatetime(v) -> json.string(v)
    ElementdefinitionFixedDecimal(v) -> json.float(v)
    ElementdefinitionFixedId(v) -> json.string(v)
    ElementdefinitionFixedInstant(v) -> json.string(v)
    ElementdefinitionFixedInteger(v) -> json.int(v)
    ElementdefinitionFixedInteger64(v) -> json.int(v)
    ElementdefinitionFixedMarkdown(v) -> json.string(v)
    ElementdefinitionFixedOid(v) -> json.string(v)
    ElementdefinitionFixedPositiveint(v) -> json.int(v)
    ElementdefinitionFixedString(v) -> json.string(v)
    ElementdefinitionFixedTime(v) -> json.string(v)
    ElementdefinitionFixedUnsignedint(v) -> json.int(v)
    ElementdefinitionFixedUri(v) -> json.string(v)
    ElementdefinitionFixedUrl(v) -> json.string(v)
    ElementdefinitionFixedUuid(v) -> json.string(v)
    ElementdefinitionFixedAddress(v) -> address_to_json(v)
    ElementdefinitionFixedAge(v) -> age_to_json(v)
    ElementdefinitionFixedAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionFixedAttachment(v) -> attachment_to_json(v)
    ElementdefinitionFixedCodeableconcept(v) -> codeableconcept_to_json(v)
    ElementdefinitionFixedCodeablereference(v) -> codeablereference_to_json(v)
    ElementdefinitionFixedCoding(v) -> coding_to_json(v)
    ElementdefinitionFixedContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionFixedCount(v) -> count_to_json(v)
    ElementdefinitionFixedDistance(v) -> distance_to_json(v)
    ElementdefinitionFixedDuration(v) -> duration_to_json(v)
    ElementdefinitionFixedHumanname(v) -> humanname_to_json(v)
    ElementdefinitionFixedIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionFixedMoney(v) -> money_to_json(v)
    ElementdefinitionFixedPeriod(v) -> period_to_json(v)
    ElementdefinitionFixedQuantity(v) -> quantity_to_json(v)
    ElementdefinitionFixedRange(v) -> range_to_json(v)
    ElementdefinitionFixedRatio(v) -> ratio_to_json(v)
    ElementdefinitionFixedRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionFixedReference(v) -> reference_to_json(v)
    ElementdefinitionFixedSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionFixedSignature(v) -> signature_to_json(v)
    ElementdefinitionFixedTiming(v) -> timing_to_json(v)
    ElementdefinitionFixedContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionFixedDatarequirement(v) -> datarequirement_to_json(v)
    ElementdefinitionFixedExpression(v) -> expression_to_json(v)
    ElementdefinitionFixedParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionFixedRelatedartifact(v) -> relatedartifact_to_json(v)
    ElementdefinitionFixedTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ElementdefinitionFixedUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionFixedAvailability(v) -> availability_to_json(v)
    ElementdefinitionFixedExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    ElementdefinitionFixedDosage(v) -> dosage_to_json(v)
    ElementdefinitionFixedMeta(v) -> meta_to_json(v)
  }
}

pub fn elementdefinition_fixed_decoder() -> Decoder(ElementdefinitionFixed) {
  decode.one_of(
    decode.field("fixedBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionFixedBase64binary),
    [
      decode.field("fixedBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionFixedBoolean),
      decode.field("fixedCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedCanonical),
      decode.field("fixedCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedCode),
      decode.field("fixedDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedDate),
      decode.field("fixedDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedDatetime),
      decode.field("fixedDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionFixedDecimal),
      decode.field("fixedId", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedId),
      decode.field("fixedInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedInstant),
      decode.field("fixedInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedInteger),
      decode.field("fixedInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedInteger64),
      decode.field("fixedMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedMarkdown),
      decode.field("fixedOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedOid),
      decode.field("fixedPositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedPositiveint),
      decode.field("fixedString", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedString),
      decode.field("fixedTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedTime),
      decode.field("fixedUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionFixedUnsignedint),
      decode.field("fixedUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUri),
      decode.field("fixedUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUrl),
      decode.field("fixedUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionFixedUuid),
      decode.field("fixedAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAddress),
      decode.field("fixedAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAge),
      decode.field("fixedAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAnnotation),
      decode.field("fixedAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAttachment),
      decode.field(
        "fixedCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedCodeableconcept),
      decode.field(
        "fixedCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedCodeablereference),
      decode.field("fixedCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedCoding),
      decode.field("fixedContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedContactpoint),
      decode.field("fixedCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedCount),
      decode.field("fixedDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDistance),
      decode.field("fixedDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDuration),
      decode.field("fixedHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedHumanname),
      decode.field("fixedIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedIdentifier),
      decode.field("fixedMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedMoney),
      decode.field("fixedPeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedPeriod),
      decode.field("fixedQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedQuantity),
      decode.field("fixedRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRange),
      decode.field("fixedRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRatio),
      decode.field("fixedRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedRatiorange),
      decode.field("fixedReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedReference),
      decode.field("fixedSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedSampleddata),
      decode.field("fixedSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedSignature),
      decode.field("fixedTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedTiming),
      decode.field(
        "fixedContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedContactdetail),
      decode.field(
        "fixedDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedDatarequirement),
      decode.field("fixedExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedExpression),
      decode.field(
        "fixedParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedParameterdefinition),
      decode.field(
        "fixedRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedRelatedartifact),
      decode.field(
        "fixedTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedTriggerdefinition),
      decode.field("fixedUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedUsagecontext),
      decode.field("fixedAvailability", availability_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedAvailability),
      decode.field(
        "fixedExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionFixedExtendedcontactdetail),
      decode.field("fixedDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedDosage),
      decode.field("fixedMeta", meta_decoder(), decode.success)
        |> decode.map(ElementdefinitionFixedMeta),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionPattern {
  ElementdefinitionPatternBase64binary(pattern: String)
  ElementdefinitionPatternBoolean(pattern: Bool)
  ElementdefinitionPatternCanonical(pattern: String)
  ElementdefinitionPatternCode(pattern: String)
  ElementdefinitionPatternDate(pattern: String)
  ElementdefinitionPatternDatetime(pattern: String)
  ElementdefinitionPatternDecimal(pattern: Float)
  ElementdefinitionPatternId(pattern: String)
  ElementdefinitionPatternInstant(pattern: String)
  ElementdefinitionPatternInteger(pattern: Int)
  ElementdefinitionPatternInteger64(pattern: Int)
  ElementdefinitionPatternMarkdown(pattern: String)
  ElementdefinitionPatternOid(pattern: String)
  ElementdefinitionPatternPositiveint(pattern: Int)
  ElementdefinitionPatternString(pattern: String)
  ElementdefinitionPatternTime(pattern: String)
  ElementdefinitionPatternUnsignedint(pattern: Int)
  ElementdefinitionPatternUri(pattern: String)
  ElementdefinitionPatternUrl(pattern: String)
  ElementdefinitionPatternUuid(pattern: String)
  ElementdefinitionPatternAddress(pattern: Address)
  ElementdefinitionPatternAge(pattern: Age)
  ElementdefinitionPatternAnnotation(pattern: Annotation)
  ElementdefinitionPatternAttachment(pattern: Attachment)
  ElementdefinitionPatternCodeableconcept(pattern: Codeableconcept)
  ElementdefinitionPatternCodeablereference(pattern: Codeablereference)
  ElementdefinitionPatternCoding(pattern: Coding)
  ElementdefinitionPatternContactpoint(pattern: Contactpoint)
  ElementdefinitionPatternCount(pattern: Count)
  ElementdefinitionPatternDistance(pattern: Distance)
  ElementdefinitionPatternDuration(pattern: Duration)
  ElementdefinitionPatternHumanname(pattern: Humanname)
  ElementdefinitionPatternIdentifier(pattern: Identifier)
  ElementdefinitionPatternMoney(pattern: Money)
  ElementdefinitionPatternPeriod(pattern: Period)
  ElementdefinitionPatternQuantity(pattern: Quantity)
  ElementdefinitionPatternRange(pattern: Range)
  ElementdefinitionPatternRatio(pattern: Ratio)
  ElementdefinitionPatternRatiorange(pattern: Ratiorange)
  ElementdefinitionPatternReference(pattern: Reference)
  ElementdefinitionPatternSampleddata(pattern: Sampleddata)
  ElementdefinitionPatternSignature(pattern: Signature)
  ElementdefinitionPatternTiming(pattern: Timing)
  ElementdefinitionPatternContactdetail(pattern: Contactdetail)
  ElementdefinitionPatternDatarequirement(pattern: Datarequirement)
  ElementdefinitionPatternExpression(pattern: Expression)
  ElementdefinitionPatternParameterdefinition(pattern: Parameterdefinition)
  ElementdefinitionPatternRelatedartifact(pattern: Relatedartifact)
  ElementdefinitionPatternTriggerdefinition(pattern: Triggerdefinition)
  ElementdefinitionPatternUsagecontext(pattern: Usagecontext)
  ElementdefinitionPatternAvailability(pattern: Availability)
  ElementdefinitionPatternExtendedcontactdetail(pattern: Extendedcontactdetail)
  ElementdefinitionPatternDosage(pattern: Dosage)
  ElementdefinitionPatternMeta(pattern: Meta)
}

pub fn elementdefinition_pattern_to_json(elt: ElementdefinitionPattern) -> Json {
  case elt {
    ElementdefinitionPatternBase64binary(v) -> json.string(v)
    ElementdefinitionPatternBoolean(v) -> json.bool(v)
    ElementdefinitionPatternCanonical(v) -> json.string(v)
    ElementdefinitionPatternCode(v) -> json.string(v)
    ElementdefinitionPatternDate(v) -> json.string(v)
    ElementdefinitionPatternDatetime(v) -> json.string(v)
    ElementdefinitionPatternDecimal(v) -> json.float(v)
    ElementdefinitionPatternId(v) -> json.string(v)
    ElementdefinitionPatternInstant(v) -> json.string(v)
    ElementdefinitionPatternInteger(v) -> json.int(v)
    ElementdefinitionPatternInteger64(v) -> json.int(v)
    ElementdefinitionPatternMarkdown(v) -> json.string(v)
    ElementdefinitionPatternOid(v) -> json.string(v)
    ElementdefinitionPatternPositiveint(v) -> json.int(v)
    ElementdefinitionPatternString(v) -> json.string(v)
    ElementdefinitionPatternTime(v) -> json.string(v)
    ElementdefinitionPatternUnsignedint(v) -> json.int(v)
    ElementdefinitionPatternUri(v) -> json.string(v)
    ElementdefinitionPatternUrl(v) -> json.string(v)
    ElementdefinitionPatternUuid(v) -> json.string(v)
    ElementdefinitionPatternAddress(v) -> address_to_json(v)
    ElementdefinitionPatternAge(v) -> age_to_json(v)
    ElementdefinitionPatternAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionPatternAttachment(v) -> attachment_to_json(v)
    ElementdefinitionPatternCodeableconcept(v) -> codeableconcept_to_json(v)
    ElementdefinitionPatternCodeablereference(v) -> codeablereference_to_json(v)
    ElementdefinitionPatternCoding(v) -> coding_to_json(v)
    ElementdefinitionPatternContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionPatternCount(v) -> count_to_json(v)
    ElementdefinitionPatternDistance(v) -> distance_to_json(v)
    ElementdefinitionPatternDuration(v) -> duration_to_json(v)
    ElementdefinitionPatternHumanname(v) -> humanname_to_json(v)
    ElementdefinitionPatternIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionPatternMoney(v) -> money_to_json(v)
    ElementdefinitionPatternPeriod(v) -> period_to_json(v)
    ElementdefinitionPatternQuantity(v) -> quantity_to_json(v)
    ElementdefinitionPatternRange(v) -> range_to_json(v)
    ElementdefinitionPatternRatio(v) -> ratio_to_json(v)
    ElementdefinitionPatternRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionPatternReference(v) -> reference_to_json(v)
    ElementdefinitionPatternSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionPatternSignature(v) -> signature_to_json(v)
    ElementdefinitionPatternTiming(v) -> timing_to_json(v)
    ElementdefinitionPatternContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionPatternDatarequirement(v) -> datarequirement_to_json(v)
    ElementdefinitionPatternExpression(v) -> expression_to_json(v)
    ElementdefinitionPatternParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionPatternRelatedartifact(v) -> relatedartifact_to_json(v)
    ElementdefinitionPatternTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ElementdefinitionPatternUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionPatternAvailability(v) -> availability_to_json(v)
    ElementdefinitionPatternExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    ElementdefinitionPatternDosage(v) -> dosage_to_json(v)
    ElementdefinitionPatternMeta(v) -> meta_to_json(v)
  }
}

pub fn elementdefinition_pattern_decoder() -> Decoder(ElementdefinitionPattern) {
  decode.one_of(
    decode.field("patternBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionPatternBase64binary),
    [
      decode.field("patternBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionPatternBoolean),
      decode.field("patternCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternCanonical),
      decode.field("patternCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternCode),
      decode.field("patternDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternDate),
      decode.field("patternDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternDatetime),
      decode.field("patternDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionPatternDecimal),
      decode.field("patternId", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternId),
      decode.field("patternInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternInstant),
      decode.field("patternInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternInteger),
      decode.field("patternInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternInteger64),
      decode.field("patternMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternMarkdown),
      decode.field("patternOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternOid),
      decode.field("patternPositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternPositiveint),
      decode.field("patternString", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternString),
      decode.field("patternTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternTime),
      decode.field("patternUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionPatternUnsignedint),
      decode.field("patternUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUri),
      decode.field("patternUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUrl),
      decode.field("patternUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionPatternUuid),
      decode.field("patternAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAddress),
      decode.field("patternAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAge),
      decode.field("patternAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAnnotation),
      decode.field("patternAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternAttachment),
      decode.field(
        "patternCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternCodeableconcept),
      decode.field(
        "patternCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternCodeablereference),
      decode.field("patternCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternCoding),
      decode.field(
        "patternContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternContactpoint),
      decode.field("patternCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternCount),
      decode.field("patternDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDistance),
      decode.field("patternDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDuration),
      decode.field("patternHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternHumanname),
      decode.field("patternIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternIdentifier),
      decode.field("patternMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternMoney),
      decode.field("patternPeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternPeriod),
      decode.field("patternQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternQuantity),
      decode.field("patternRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRange),
      decode.field("patternRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRatio),
      decode.field("patternRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternRatiorange),
      decode.field("patternReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternReference),
      decode.field("patternSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternSampleddata),
      decode.field("patternSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternSignature),
      decode.field("patternTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternTiming),
      decode.field(
        "patternContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternContactdetail),
      decode.field(
        "patternDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternDatarequirement),
      decode.field("patternExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternExpression),
      decode.field(
        "patternParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternParameterdefinition),
      decode.field(
        "patternRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternRelatedartifact),
      decode.field(
        "patternTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternTriggerdefinition),
      decode.field(
        "patternUsageContext",
        usagecontext_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternUsagecontext),
      decode.field(
        "patternAvailability",
        availability_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternAvailability),
      decode.field(
        "patternExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionPatternExtendedcontactdetail),
      decode.field("patternDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternDosage),
      decode.field("patternMeta", meta_decoder(), decode.success)
        |> decode.map(ElementdefinitionPatternMeta),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMinvalue {
  ElementdefinitionMinvalueDate(min_value: String)
  ElementdefinitionMinvalueDatetime(min_value: String)
  ElementdefinitionMinvalueInstant(min_value: String)
  ElementdefinitionMinvalueTime(min_value: String)
  ElementdefinitionMinvalueDecimal(min_value: Float)
  ElementdefinitionMinvalueInteger(min_value: Int)
  ElementdefinitionMinvalueInteger64(min_value: Int)
  ElementdefinitionMinvaluePositiveint(min_value: Int)
  ElementdefinitionMinvalueUnsignedint(min_value: Int)
  ElementdefinitionMinvalueQuantity(min_value: Quantity)
}

pub fn elementdefinition_minvalue_to_json(
  elt: ElementdefinitionMinvalue,
) -> Json {
  case elt {
    ElementdefinitionMinvalueDate(v) -> json.string(v)
    ElementdefinitionMinvalueDatetime(v) -> json.string(v)
    ElementdefinitionMinvalueInstant(v) -> json.string(v)
    ElementdefinitionMinvalueTime(v) -> json.string(v)
    ElementdefinitionMinvalueDecimal(v) -> json.float(v)
    ElementdefinitionMinvalueInteger(v) -> json.int(v)
    ElementdefinitionMinvalueInteger64(v) -> json.int(v)
    ElementdefinitionMinvaluePositiveint(v) -> json.int(v)
    ElementdefinitionMinvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionMinvalueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn elementdefinition_minvalue_decoder() -> Decoder(
  ElementdefinitionMinvalue,
) {
  decode.one_of(
    decode.field("minValueDate", decode.string, decode.success)
      |> decode.map(ElementdefinitionMinvalueDate),
    [
      decode.field("minValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueDatetime),
      decode.field("minValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueInstant),
      decode.field("minValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMinvalueTime),
      decode.field("minValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionMinvalueDecimal),
      decode.field("minValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvalueInteger),
      decode.field("minValueInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvalueInteger64),
      decode.field("minValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvaluePositiveint),
      decode.field("minValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMinvalueUnsignedint),
      decode.field("minValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionMinvalueQuantity),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMaxvalue {
  ElementdefinitionMaxvalueDate(max_value: String)
  ElementdefinitionMaxvalueDatetime(max_value: String)
  ElementdefinitionMaxvalueInstant(max_value: String)
  ElementdefinitionMaxvalueTime(max_value: String)
  ElementdefinitionMaxvalueDecimal(max_value: Float)
  ElementdefinitionMaxvalueInteger(max_value: Int)
  ElementdefinitionMaxvalueInteger64(max_value: Int)
  ElementdefinitionMaxvaluePositiveint(max_value: Int)
  ElementdefinitionMaxvalueUnsignedint(max_value: Int)
  ElementdefinitionMaxvalueQuantity(max_value: Quantity)
}

pub fn elementdefinition_maxvalue_to_json(
  elt: ElementdefinitionMaxvalue,
) -> Json {
  case elt {
    ElementdefinitionMaxvalueDate(v) -> json.string(v)
    ElementdefinitionMaxvalueDatetime(v) -> json.string(v)
    ElementdefinitionMaxvalueInstant(v) -> json.string(v)
    ElementdefinitionMaxvalueTime(v) -> json.string(v)
    ElementdefinitionMaxvalueDecimal(v) -> json.float(v)
    ElementdefinitionMaxvalueInteger(v) -> json.int(v)
    ElementdefinitionMaxvalueInteger64(v) -> json.int(v)
    ElementdefinitionMaxvaluePositiveint(v) -> json.int(v)
    ElementdefinitionMaxvalueUnsignedint(v) -> json.int(v)
    ElementdefinitionMaxvalueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn elementdefinition_maxvalue_decoder() -> Decoder(
  ElementdefinitionMaxvalue,
) {
  decode.one_of(
    decode.field("maxValueDate", decode.string, decode.success)
      |> decode.map(ElementdefinitionMaxvalueDate),
    [
      decode.field("maxValueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueDatetime),
      decode.field("maxValueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueInstant),
      decode.field("maxValueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionMaxvalueTime),
      decode.field("maxValueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionMaxvalueDecimal),
      decode.field("maxValueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvalueInteger),
      decode.field("maxValueInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvalueInteger64),
      decode.field("maxValuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvaluePositiveint),
      decode.field("maxValueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionMaxvalueUnsignedint),
      decode.field("maxValueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionMaxvalueQuantity),
    ],
  )
}

pub fn elementdefinition_new(path path: String) -> Elementdefinition {
  Elementdefinition(
    mapping: [],
    binding: None,
    is_summary: None,
    is_modifier_reason: None,
    is_modifier: None,
    must_support: None,
    value_alternatives: [],
    must_have_value: None,
    constraint: [],
    condition: [],
    max_length: None,
    max_value: None,
    min_value: None,
    example: [],
    pattern: None,
    fixed: None,
    order_meaning: None,
    meaning_when_missing: None,
    default_value: None,
    type_: [],
    content_reference: None,
    base: None,
    max: None,
    min: None,
    alias: [],
    requirements: None,
    comment: None,
    definition: None,
    short: None,
    slicing: None,
    code: [],
    label: None,
    slice_is_constraining: None,
    slice_name: None,
    representation: [],
    path:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionSlicing {
  ElementdefinitionSlicing(
    id: Option(String),
    extension: List(Extension),
    discriminator: List(ElementdefinitionSlicingDiscriminator),
    description: Option(String),
    ordered: Option(Bool),
    rules: r5valuesets.Resourceslicingrules,
  )
}

pub fn elementdefinition_slicing_new(
  rules rules: r5valuesets.Resourceslicingrules,
) -> ElementdefinitionSlicing {
  ElementdefinitionSlicing(
    rules:,
    ordered: None,
    description: None,
    discriminator: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionSlicingDiscriminator {
  ElementdefinitionSlicingDiscriminator(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Discriminatortype,
    path: String,
  )
}

pub fn elementdefinition_slicing_discriminator_new(
  path path: String,
  type_ type_: r5valuesets.Discriminatortype,
) -> ElementdefinitionSlicingDiscriminator {
  ElementdefinitionSlicingDiscriminator(path:, type_:, extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionBase {
  ElementdefinitionBase(
    id: Option(String),
    extension: List(Extension),
    path: String,
    min: Int,
    max: String,
  )
}

pub fn elementdefinition_base_new(
  max max: String,
  min min: Int,
  path path: String,
) -> ElementdefinitionBase {
  ElementdefinitionBase(max:, min:, path:, extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionType {
  ElementdefinitionType(
    id: Option(String),
    extension: List(Extension),
    code: String,
    profile: List(String),
    target_profile: List(String),
    aggregation: List(r5valuesets.Resourceaggregationmode),
    versioning: Option(r5valuesets.Referenceversionrules),
  )
}

pub fn elementdefinition_type_new(code code: String) -> ElementdefinitionType {
  ElementdefinitionType(
    versioning: None,
    aggregation: [],
    target_profile: [],
    profile: [],
    code:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionExample {
  ElementdefinitionExample(
    id: Option(String),
    extension: List(Extension),
    label: String,
    value: ElementdefinitionExampleValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionExampleValue {
  ElementdefinitionExampleValueBase64binary(value: String)
  ElementdefinitionExampleValueBoolean(value: Bool)
  ElementdefinitionExampleValueCanonical(value: String)
  ElementdefinitionExampleValueCode(value: String)
  ElementdefinitionExampleValueDate(value: String)
  ElementdefinitionExampleValueDatetime(value: String)
  ElementdefinitionExampleValueDecimal(value: Float)
  ElementdefinitionExampleValueId(value: String)
  ElementdefinitionExampleValueInstant(value: String)
  ElementdefinitionExampleValueInteger(value: Int)
  ElementdefinitionExampleValueInteger64(value: Int)
  ElementdefinitionExampleValueMarkdown(value: String)
  ElementdefinitionExampleValueOid(value: String)
  ElementdefinitionExampleValuePositiveint(value: Int)
  ElementdefinitionExampleValueString(value: String)
  ElementdefinitionExampleValueTime(value: String)
  ElementdefinitionExampleValueUnsignedint(value: Int)
  ElementdefinitionExampleValueUri(value: String)
  ElementdefinitionExampleValueUrl(value: String)
  ElementdefinitionExampleValueUuid(value: String)
  ElementdefinitionExampleValueAddress(value: Address)
  ElementdefinitionExampleValueAge(value: Age)
  ElementdefinitionExampleValueAnnotation(value: Annotation)
  ElementdefinitionExampleValueAttachment(value: Attachment)
  ElementdefinitionExampleValueCodeableconcept(value: Codeableconcept)
  ElementdefinitionExampleValueCodeablereference(value: Codeablereference)
  ElementdefinitionExampleValueCoding(value: Coding)
  ElementdefinitionExampleValueContactpoint(value: Contactpoint)
  ElementdefinitionExampleValueCount(value: Count)
  ElementdefinitionExampleValueDistance(value: Distance)
  ElementdefinitionExampleValueDuration(value: Duration)
  ElementdefinitionExampleValueHumanname(value: Humanname)
  ElementdefinitionExampleValueIdentifier(value: Identifier)
  ElementdefinitionExampleValueMoney(value: Money)
  ElementdefinitionExampleValuePeriod(value: Period)
  ElementdefinitionExampleValueQuantity(value: Quantity)
  ElementdefinitionExampleValueRange(value: Range)
  ElementdefinitionExampleValueRatio(value: Ratio)
  ElementdefinitionExampleValueRatiorange(value: Ratiorange)
  ElementdefinitionExampleValueReference(value: Reference)
  ElementdefinitionExampleValueSampleddata(value: Sampleddata)
  ElementdefinitionExampleValueSignature(value: Signature)
  ElementdefinitionExampleValueTiming(value: Timing)
  ElementdefinitionExampleValueContactdetail(value: Contactdetail)
  ElementdefinitionExampleValueDatarequirement(value: Datarequirement)
  ElementdefinitionExampleValueExpression(value: Expression)
  ElementdefinitionExampleValueParameterdefinition(value: Parameterdefinition)
  ElementdefinitionExampleValueRelatedartifact(value: Relatedartifact)
  ElementdefinitionExampleValueTriggerdefinition(value: Triggerdefinition)
  ElementdefinitionExampleValueUsagecontext(value: Usagecontext)
  ElementdefinitionExampleValueAvailability(value: Availability)
  ElementdefinitionExampleValueExtendedcontactdetail(
    value: Extendedcontactdetail,
  )
  ElementdefinitionExampleValueDosage(value: Dosage)
  ElementdefinitionExampleValueMeta(value: Meta)
}

pub fn elementdefinition_example_value_to_json(
  elt: ElementdefinitionExampleValue,
) -> Json {
  case elt {
    ElementdefinitionExampleValueBase64binary(v) -> json.string(v)
    ElementdefinitionExampleValueBoolean(v) -> json.bool(v)
    ElementdefinitionExampleValueCanonical(v) -> json.string(v)
    ElementdefinitionExampleValueCode(v) -> json.string(v)
    ElementdefinitionExampleValueDate(v) -> json.string(v)
    ElementdefinitionExampleValueDatetime(v) -> json.string(v)
    ElementdefinitionExampleValueDecimal(v) -> json.float(v)
    ElementdefinitionExampleValueId(v) -> json.string(v)
    ElementdefinitionExampleValueInstant(v) -> json.string(v)
    ElementdefinitionExampleValueInteger(v) -> json.int(v)
    ElementdefinitionExampleValueInteger64(v) -> json.int(v)
    ElementdefinitionExampleValueMarkdown(v) -> json.string(v)
    ElementdefinitionExampleValueOid(v) -> json.string(v)
    ElementdefinitionExampleValuePositiveint(v) -> json.int(v)
    ElementdefinitionExampleValueString(v) -> json.string(v)
    ElementdefinitionExampleValueTime(v) -> json.string(v)
    ElementdefinitionExampleValueUnsignedint(v) -> json.int(v)
    ElementdefinitionExampleValueUri(v) -> json.string(v)
    ElementdefinitionExampleValueUrl(v) -> json.string(v)
    ElementdefinitionExampleValueUuid(v) -> json.string(v)
    ElementdefinitionExampleValueAddress(v) -> address_to_json(v)
    ElementdefinitionExampleValueAge(v) -> age_to_json(v)
    ElementdefinitionExampleValueAnnotation(v) -> annotation_to_json(v)
    ElementdefinitionExampleValueAttachment(v) -> attachment_to_json(v)
    ElementdefinitionExampleValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ElementdefinitionExampleValueCodeablereference(v) ->
      codeablereference_to_json(v)
    ElementdefinitionExampleValueCoding(v) -> coding_to_json(v)
    ElementdefinitionExampleValueContactpoint(v) -> contactpoint_to_json(v)
    ElementdefinitionExampleValueCount(v) -> count_to_json(v)
    ElementdefinitionExampleValueDistance(v) -> distance_to_json(v)
    ElementdefinitionExampleValueDuration(v) -> duration_to_json(v)
    ElementdefinitionExampleValueHumanname(v) -> humanname_to_json(v)
    ElementdefinitionExampleValueIdentifier(v) -> identifier_to_json(v)
    ElementdefinitionExampleValueMoney(v) -> money_to_json(v)
    ElementdefinitionExampleValuePeriod(v) -> period_to_json(v)
    ElementdefinitionExampleValueQuantity(v) -> quantity_to_json(v)
    ElementdefinitionExampleValueRange(v) -> range_to_json(v)
    ElementdefinitionExampleValueRatio(v) -> ratio_to_json(v)
    ElementdefinitionExampleValueRatiorange(v) -> ratiorange_to_json(v)
    ElementdefinitionExampleValueReference(v) -> reference_to_json(v)
    ElementdefinitionExampleValueSampleddata(v) -> sampleddata_to_json(v)
    ElementdefinitionExampleValueSignature(v) -> signature_to_json(v)
    ElementdefinitionExampleValueTiming(v) -> timing_to_json(v)
    ElementdefinitionExampleValueContactdetail(v) -> contactdetail_to_json(v)
    ElementdefinitionExampleValueDatarequirement(v) ->
      datarequirement_to_json(v)
    ElementdefinitionExampleValueExpression(v) -> expression_to_json(v)
    ElementdefinitionExampleValueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ElementdefinitionExampleValueRelatedartifact(v) ->
      relatedartifact_to_json(v)
    ElementdefinitionExampleValueTriggerdefinition(v) ->
      triggerdefinition_to_json(v)
    ElementdefinitionExampleValueUsagecontext(v) -> usagecontext_to_json(v)
    ElementdefinitionExampleValueAvailability(v) -> availability_to_json(v)
    ElementdefinitionExampleValueExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    ElementdefinitionExampleValueDosage(v) -> dosage_to_json(v)
    ElementdefinitionExampleValueMeta(v) -> meta_to_json(v)
  }
}

pub fn elementdefinition_example_value_decoder() -> Decoder(
  ElementdefinitionExampleValue,
) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ElementdefinitionExampleValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ElementdefinitionExampleValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ElementdefinitionExampleValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ElementdefinitionExampleValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ElementdefinitionExampleValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ElementdefinitionExampleValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(ElementdefinitionExampleValueMeta),
    ],
  )
}

pub fn elementdefinition_example_new(
  value value: ElementdefinitionExampleValue,
  label label: String,
) -> ElementdefinitionExample {
  ElementdefinitionExample(value:, label:, extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionConstraint {
  ElementdefinitionConstraint(
    id: Option(String),
    extension: List(Extension),
    key: String,
    requirements: Option(String),
    severity: r5valuesets.Constraintseverity,
    suppress: Option(Bool),
    human: String,
    expression: Option(String),
    source: Option(String),
  )
}

pub fn elementdefinition_constraint_new(
  human human: String,
  severity severity: r5valuesets.Constraintseverity,
  key key: String,
) -> ElementdefinitionConstraint {
  ElementdefinitionConstraint(
    source: None,
    expression: None,
    human:,
    suppress: None,
    severity:,
    requirements: None,
    key:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionBinding {
  ElementdefinitionBinding(
    id: Option(String),
    extension: List(Extension),
    strength: r5valuesets.Bindingstrength,
    description: Option(String),
    value_set: Option(String),
    additional: List(ElementdefinitionBindingAdditional),
  )
}

pub fn elementdefinition_binding_new(
  strength strength: r5valuesets.Bindingstrength,
) -> ElementdefinitionBinding {
  ElementdefinitionBinding(
    additional: [],
    value_set: None,
    description: None,
    strength:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionBindingAdditional {
  ElementdefinitionBindingAdditional(
    id: Option(String),
    extension: List(Extension),
    purpose: r5valuesets.Additionalbindingpurpose,
    value_set: String,
    documentation: Option(String),
    short_doco: Option(String),
    usage: List(Usagecontext),
    any: Option(Bool),
  )
}

pub fn elementdefinition_binding_additional_new(
  value_set value_set: String,
  purpose purpose: r5valuesets.Additionalbindingpurpose,
) -> ElementdefinitionBindingAdditional {
  ElementdefinitionBindingAdditional(
    any: None,
    usage: [],
    short_doco: None,
    documentation: None,
    value_set:,
    purpose:,
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ElementDefinition#resource
pub type ElementdefinitionMapping {
  ElementdefinitionMapping(
    id: Option(String),
    extension: List(Extension),
    identity: String,
    language: Option(String),
    map: String,
    comment: Option(String),
  )
}

pub fn elementdefinition_mapping_new(
  map map: String,
  identity identity: String,
) -> ElementdefinitionMapping {
  ElementdefinitionMapping(
    comment: None,
    map:,
    language: None,
    identity:,
    extension: [],
    id: None,
  )
}

pub fn elementdefinition_mapping_to_json(
  elementdefinition_mapping: ElementdefinitionMapping,
) -> Json {
  let ElementdefinitionMapping(
    comment:,
    map:,
    language:,
    identity:,
    extension:,
    id:,
  ) = elementdefinition_mapping
  let fields = [
    #("map", json.string(map)),
    #("identity", json.string(identity)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_mapping_decoder() -> Decoder(ElementdefinitionMapping) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use map <- decode.field("map", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use identity <- decode.field("identity", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionMapping(
    comment:,
    map:,
    language:,
    identity:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_binding_additional_to_json(
  elementdefinition_binding_additional: ElementdefinitionBindingAdditional,
) -> Json {
  let ElementdefinitionBindingAdditional(
    any:,
    usage:,
    short_doco:,
    documentation:,
    value_set:,
    purpose:,
    extension:,
    id:,
  ) = elementdefinition_binding_additional
  let fields = [
    #("valueSet", json.string(value_set)),
    #("purpose", r5valuesets.additionalbindingpurpose_to_json(purpose)),
  ]
  let fields = case any {
    Some(v) -> [#("any", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    [] -> fields
    _ -> [#("usage", json.array(usage, usagecontext_to_json)), ..fields]
  }
  let fields = case short_doco {
    Some(v) -> [#("shortDoco", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_binding_additional_decoder() -> Decoder(
  ElementdefinitionBindingAdditional,
) {
  use any <- decode.optional_field("any", None, decode.optional(decode.bool))
  use usage <- decode.optional_field(
    "usage",
    [],
    decode.list(usagecontext_decoder()),
  )
  use short_doco <- decode.optional_field(
    "shortDoco",
    None,
    decode.optional(decode.string),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use value_set <- decode.field("valueSet", decode.string)
  use purpose <- decode.field(
    "purpose",
    r5valuesets.additionalbindingpurpose_decoder(),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionBindingAdditional(
    any:,
    usage:,
    short_doco:,
    documentation:,
    value_set:,
    purpose:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_binding_to_json(
  elementdefinition_binding: ElementdefinitionBinding,
) -> Json {
  let ElementdefinitionBinding(
    additional:,
    value_set:,
    description:,
    strength:,
    extension:,
    id:,
  ) = elementdefinition_binding
  let fields = [
    #("strength", r5valuesets.bindingstrength_to_json(strength)),
  ]
  let fields = case additional {
    [] -> fields
    _ -> [
      #(
        "additional",
        json.array(additional, elementdefinition_binding_additional_to_json),
      ),
      ..fields
    ]
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_binding_decoder() -> Decoder(ElementdefinitionBinding) {
  use additional <- decode.optional_field(
    "additional",
    [],
    decode.list(elementdefinition_binding_additional_decoder()),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use strength <- decode.field(
    "strength",
    r5valuesets.bindingstrength_decoder(),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionBinding(
    additional:,
    value_set:,
    description:,
    strength:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_constraint_to_json(
  elementdefinition_constraint: ElementdefinitionConstraint,
) -> Json {
  let ElementdefinitionConstraint(
    source:,
    expression:,
    human:,
    suppress:,
    severity:,
    requirements:,
    key:,
    extension:,
    id:,
  ) = elementdefinition_constraint
  let fields = [
    #("human", json.string(human)),
    #("severity", r5valuesets.constraintseverity_to_json(severity)),
    #("key", json.string(key)),
  ]
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case suppress {
    Some(v) -> [#("suppress", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case requirements {
    Some(v) -> [#("requirements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_constraint_decoder() -> Decoder(
  ElementdefinitionConstraint,
) {
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use human <- decode.field("human", decode.string)
  use suppress <- decode.optional_field(
    "suppress",
    None,
    decode.optional(decode.bool),
  )
  use severity <- decode.field(
    "severity",
    r5valuesets.constraintseverity_decoder(),
  )
  use requirements <- decode.optional_field(
    "requirements",
    None,
    decode.optional(decode.string),
  )
  use key <- decode.field("key", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionConstraint(
    source:,
    expression:,
    human:,
    suppress:,
    severity:,
    requirements:,
    key:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_example_to_json(
  elementdefinition_example: ElementdefinitionExample,
) -> Json {
  let ElementdefinitionExample(value:, label:, extension:, id:) =
    elementdefinition_example
  let fields = [
    #("value", elementdefinition_example_value_to_json(value)),
    #("label", json.string(label)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_example_decoder() -> Decoder(ElementdefinitionExample) {
  use value <- decode.then(elementdefinition_example_value_decoder())
  use label <- decode.field("label", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionExample(value:, label:, extension:, id:))
}

pub fn elementdefinition_type_to_json(
  elementdefinition_type: ElementdefinitionType,
) -> Json {
  let ElementdefinitionType(
    versioning:,
    aggregation:,
    target_profile:,
    profile:,
    code:,
    extension:,
    id:,
  ) = elementdefinition_type
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case versioning {
    Some(v) -> [
      #("versioning", r5valuesets.referenceversionrules_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case aggregation {
    [] -> fields
    _ -> [
      #(
        "aggregation",
        json.array(aggregation, r5valuesets.resourceaggregationmode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target_profile {
    [] -> fields
    _ -> [#("targetProfile", json.array(target_profile, json.string)), ..fields]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_type_decoder() -> Decoder(ElementdefinitionType) {
  use versioning <- decode.optional_field(
    "versioning",
    None,
    decode.optional(r5valuesets.referenceversionrules_decoder()),
  )
  use aggregation <- decode.optional_field(
    "aggregation",
    [],
    decode.list(r5valuesets.resourceaggregationmode_decoder()),
  )
  use target_profile <- decode.optional_field(
    "targetProfile",
    [],
    decode.list(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionType(
    versioning:,
    aggregation:,
    target_profile:,
    profile:,
    code:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_base_to_json(
  elementdefinition_base: ElementdefinitionBase,
) -> Json {
  let ElementdefinitionBase(max:, min:, path:, extension:, id:) =
    elementdefinition_base
  let fields = [
    #("max", json.string(max)),
    #("min", json.int(min)),
    #("path", json.string(path)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_base_decoder() -> Decoder(ElementdefinitionBase) {
  use max <- decode.field("max", decode.string)
  use min <- decode.field("min", decode.int)
  use path <- decode.field("path", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionBase(max:, min:, path:, extension:, id:))
}

pub fn elementdefinition_slicing_discriminator_to_json(
  elementdefinition_slicing_discriminator: ElementdefinitionSlicingDiscriminator,
) -> Json {
  let ElementdefinitionSlicingDiscriminator(path:, type_:, extension:, id:) =
    elementdefinition_slicing_discriminator
  let fields = [
    #("path", json.string(path)),
    #("type", r5valuesets.discriminatortype_to_json(type_)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_slicing_discriminator_decoder() -> Decoder(
  ElementdefinitionSlicingDiscriminator,
) {
  use path <- decode.field("path", decode.string)
  use type_ <- decode.field("type", r5valuesets.discriminatortype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionSlicingDiscriminator(
    path:,
    type_:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_slicing_to_json(
  elementdefinition_slicing: ElementdefinitionSlicing,
) -> Json {
  let ElementdefinitionSlicing(
    rules:,
    ordered:,
    description:,
    discriminator:,
    extension:,
    id:,
  ) = elementdefinition_slicing
  let fields = [
    #("rules", r5valuesets.resourceslicingrules_to_json(rules)),
  ]
  let fields = case ordered {
    Some(v) -> [#("ordered", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case discriminator {
    [] -> fields
    _ -> [
      #(
        "discriminator",
        json.array(
          discriminator,
          elementdefinition_slicing_discriminator_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_slicing_decoder() -> Decoder(ElementdefinitionSlicing) {
  use rules <- decode.field("rules", r5valuesets.resourceslicingrules_decoder())
  use ordered <- decode.optional_field(
    "ordered",
    None,
    decode.optional(decode.bool),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use discriminator <- decode.optional_field(
    "discriminator",
    [],
    decode.list(elementdefinition_slicing_discriminator_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ElementdefinitionSlicing(
    rules:,
    ordered:,
    description:,
    discriminator:,
    extension:,
    id:,
  ))
}

pub fn elementdefinition_to_json(elementdefinition: Elementdefinition) -> Json {
  let Elementdefinition(
    mapping:,
    binding:,
    is_summary:,
    is_modifier_reason:,
    is_modifier:,
    must_support:,
    value_alternatives:,
    must_have_value:,
    constraint:,
    condition:,
    max_length:,
    max_value:,
    min_value:,
    example:,
    pattern:,
    fixed:,
    order_meaning:,
    meaning_when_missing:,
    default_value:,
    type_:,
    content_reference:,
    base:,
    max:,
    min:,
    alias:,
    requirements:,
    comment:,
    definition:,
    short:,
    slicing:,
    code:,
    label:,
    slice_is_constraining:,
    slice_name:,
    representation:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = elementdefinition
  let fields = [
    #("path", json.string(path)),
  ]
  let fields = case mapping {
    [] -> fields
    _ -> [
      #("mapping", json.array(mapping, elementdefinition_mapping_to_json)),
      ..fields
    ]
  }
  let fields = case binding {
    Some(v) -> [#("binding", elementdefinition_binding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_summary {
    Some(v) -> [#("isSummary", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case is_modifier_reason {
    Some(v) -> [#("isModifierReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case is_modifier {
    Some(v) -> [#("isModifier", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case must_support {
    Some(v) -> [#("mustSupport", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case value_alternatives {
    [] -> fields
    _ -> [
      #("valueAlternatives", json.array(value_alternatives, json.string)),
      ..fields
    ]
  }
  let fields = case must_have_value {
    Some(v) -> [#("mustHaveValue", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case constraint {
    [] -> fields
    _ -> [
      #(
        "constraint",
        json.array(constraint, elementdefinition_constraint_to_json),
      ),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [#("condition", json.array(condition, json.string)), ..fields]
  }
  let fields = case max_length {
    Some(v) -> [#("maxLength", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case max_value {
    Some(v) -> [
      #(
        "maxValue"
          <> case v {
          ElementdefinitionMaxvalueDate(_) -> "Date"
          ElementdefinitionMaxvalueDatetime(_) -> "Datetime"
          ElementdefinitionMaxvalueInstant(_) -> "Instant"
          ElementdefinitionMaxvalueTime(_) -> "Time"
          ElementdefinitionMaxvalueDecimal(_) -> "Decimal"
          ElementdefinitionMaxvalueInteger(_) -> "Integer"
          ElementdefinitionMaxvalueInteger64(_) -> "Integer64"
          ElementdefinitionMaxvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionMaxvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionMaxvalueQuantity(_) -> "Quantity"
        },
        elementdefinition_maxvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case min_value {
    Some(v) -> [
      #(
        "minValue"
          <> case v {
          ElementdefinitionMinvalueDate(_) -> "Date"
          ElementdefinitionMinvalueDatetime(_) -> "Datetime"
          ElementdefinitionMinvalueInstant(_) -> "Instant"
          ElementdefinitionMinvalueTime(_) -> "Time"
          ElementdefinitionMinvalueDecimal(_) -> "Decimal"
          ElementdefinitionMinvalueInteger(_) -> "Integer"
          ElementdefinitionMinvalueInteger64(_) -> "Integer64"
          ElementdefinitionMinvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionMinvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionMinvalueQuantity(_) -> "Quantity"
        },
        elementdefinition_minvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case example {
    [] -> fields
    _ -> [
      #("example", json.array(example, elementdefinition_example_to_json)),
      ..fields
    ]
  }
  let fields = case pattern {
    Some(v) -> [
      #(
        "pattern"
          <> case v {
          ElementdefinitionPatternBase64binary(_) -> "Base64binary"
          ElementdefinitionPatternBoolean(_) -> "Boolean"
          ElementdefinitionPatternCanonical(_) -> "Canonical"
          ElementdefinitionPatternCode(_) -> "Code"
          ElementdefinitionPatternDate(_) -> "Date"
          ElementdefinitionPatternDatetime(_) -> "Datetime"
          ElementdefinitionPatternDecimal(_) -> "Decimal"
          ElementdefinitionPatternId(_) -> "Id"
          ElementdefinitionPatternInstant(_) -> "Instant"
          ElementdefinitionPatternInteger(_) -> "Integer"
          ElementdefinitionPatternInteger64(_) -> "Integer64"
          ElementdefinitionPatternMarkdown(_) -> "Markdown"
          ElementdefinitionPatternOid(_) -> "Oid"
          ElementdefinitionPatternPositiveint(_) -> "Positiveint"
          ElementdefinitionPatternString(_) -> "String"
          ElementdefinitionPatternTime(_) -> "Time"
          ElementdefinitionPatternUnsignedint(_) -> "Unsignedint"
          ElementdefinitionPatternUri(_) -> "Uri"
          ElementdefinitionPatternUrl(_) -> "Url"
          ElementdefinitionPatternUuid(_) -> "Uuid"
          ElementdefinitionPatternAddress(_) -> "Address"
          ElementdefinitionPatternAge(_) -> "Age"
          ElementdefinitionPatternAnnotation(_) -> "Annotation"
          ElementdefinitionPatternAttachment(_) -> "Attachment"
          ElementdefinitionPatternCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionPatternCodeablereference(_) -> "Codeablereference"
          ElementdefinitionPatternCoding(_) -> "Coding"
          ElementdefinitionPatternContactpoint(_) -> "Contactpoint"
          ElementdefinitionPatternCount(_) -> "Count"
          ElementdefinitionPatternDistance(_) -> "Distance"
          ElementdefinitionPatternDuration(_) -> "Duration"
          ElementdefinitionPatternHumanname(_) -> "Humanname"
          ElementdefinitionPatternIdentifier(_) -> "Identifier"
          ElementdefinitionPatternMoney(_) -> "Money"
          ElementdefinitionPatternPeriod(_) -> "Period"
          ElementdefinitionPatternQuantity(_) -> "Quantity"
          ElementdefinitionPatternRange(_) -> "Range"
          ElementdefinitionPatternRatio(_) -> "Ratio"
          ElementdefinitionPatternRatiorange(_) -> "Ratiorange"
          ElementdefinitionPatternReference(_) -> "Reference"
          ElementdefinitionPatternSampleddata(_) -> "Sampleddata"
          ElementdefinitionPatternSignature(_) -> "Signature"
          ElementdefinitionPatternTiming(_) -> "Timing"
          ElementdefinitionPatternContactdetail(_) -> "Contactdetail"
          ElementdefinitionPatternDatarequirement(_) -> "Datarequirement"
          ElementdefinitionPatternExpression(_) -> "Expression"
          ElementdefinitionPatternParameterdefinition(_) ->
            "Parameterdefinition"
          ElementdefinitionPatternRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionPatternTriggerdefinition(_) -> "Triggerdefinition"
          ElementdefinitionPatternUsagecontext(_) -> "Usagecontext"
          ElementdefinitionPatternAvailability(_) -> "Availability"
          ElementdefinitionPatternExtendedcontactdetail(_) ->
            "Extendedcontactdetail"
          ElementdefinitionPatternDosage(_) -> "Dosage"
          ElementdefinitionPatternMeta(_) -> "Meta"
        },
        elementdefinition_pattern_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case fixed {
    Some(v) -> [
      #(
        "fixed"
          <> case v {
          ElementdefinitionFixedBase64binary(_) -> "Base64binary"
          ElementdefinitionFixedBoolean(_) -> "Boolean"
          ElementdefinitionFixedCanonical(_) -> "Canonical"
          ElementdefinitionFixedCode(_) -> "Code"
          ElementdefinitionFixedDate(_) -> "Date"
          ElementdefinitionFixedDatetime(_) -> "Datetime"
          ElementdefinitionFixedDecimal(_) -> "Decimal"
          ElementdefinitionFixedId(_) -> "Id"
          ElementdefinitionFixedInstant(_) -> "Instant"
          ElementdefinitionFixedInteger(_) -> "Integer"
          ElementdefinitionFixedInteger64(_) -> "Integer64"
          ElementdefinitionFixedMarkdown(_) -> "Markdown"
          ElementdefinitionFixedOid(_) -> "Oid"
          ElementdefinitionFixedPositiveint(_) -> "Positiveint"
          ElementdefinitionFixedString(_) -> "String"
          ElementdefinitionFixedTime(_) -> "Time"
          ElementdefinitionFixedUnsignedint(_) -> "Unsignedint"
          ElementdefinitionFixedUri(_) -> "Uri"
          ElementdefinitionFixedUrl(_) -> "Url"
          ElementdefinitionFixedUuid(_) -> "Uuid"
          ElementdefinitionFixedAddress(_) -> "Address"
          ElementdefinitionFixedAge(_) -> "Age"
          ElementdefinitionFixedAnnotation(_) -> "Annotation"
          ElementdefinitionFixedAttachment(_) -> "Attachment"
          ElementdefinitionFixedCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionFixedCodeablereference(_) -> "Codeablereference"
          ElementdefinitionFixedCoding(_) -> "Coding"
          ElementdefinitionFixedContactpoint(_) -> "Contactpoint"
          ElementdefinitionFixedCount(_) -> "Count"
          ElementdefinitionFixedDistance(_) -> "Distance"
          ElementdefinitionFixedDuration(_) -> "Duration"
          ElementdefinitionFixedHumanname(_) -> "Humanname"
          ElementdefinitionFixedIdentifier(_) -> "Identifier"
          ElementdefinitionFixedMoney(_) -> "Money"
          ElementdefinitionFixedPeriod(_) -> "Period"
          ElementdefinitionFixedQuantity(_) -> "Quantity"
          ElementdefinitionFixedRange(_) -> "Range"
          ElementdefinitionFixedRatio(_) -> "Ratio"
          ElementdefinitionFixedRatiorange(_) -> "Ratiorange"
          ElementdefinitionFixedReference(_) -> "Reference"
          ElementdefinitionFixedSampleddata(_) -> "Sampleddata"
          ElementdefinitionFixedSignature(_) -> "Signature"
          ElementdefinitionFixedTiming(_) -> "Timing"
          ElementdefinitionFixedContactdetail(_) -> "Contactdetail"
          ElementdefinitionFixedDatarequirement(_) -> "Datarequirement"
          ElementdefinitionFixedExpression(_) -> "Expression"
          ElementdefinitionFixedParameterdefinition(_) -> "Parameterdefinition"
          ElementdefinitionFixedRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionFixedTriggerdefinition(_) -> "Triggerdefinition"
          ElementdefinitionFixedUsagecontext(_) -> "Usagecontext"
          ElementdefinitionFixedAvailability(_) -> "Availability"
          ElementdefinitionFixedExtendedcontactdetail(_) ->
            "Extendedcontactdetail"
          ElementdefinitionFixedDosage(_) -> "Dosage"
          ElementdefinitionFixedMeta(_) -> "Meta"
        },
        elementdefinition_fixed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case order_meaning {
    Some(v) -> [#("orderMeaning", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meaning_when_missing {
    Some(v) -> [#("meaningWhenMissing", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [
      #(
        "defaultValue"
          <> case v {
          ElementdefinitionDefaultvalueBase64binary(_) -> "Base64binary"
          ElementdefinitionDefaultvalueBoolean(_) -> "Boolean"
          ElementdefinitionDefaultvalueCanonical(_) -> "Canonical"
          ElementdefinitionDefaultvalueCode(_) -> "Code"
          ElementdefinitionDefaultvalueDate(_) -> "Date"
          ElementdefinitionDefaultvalueDatetime(_) -> "Datetime"
          ElementdefinitionDefaultvalueDecimal(_) -> "Decimal"
          ElementdefinitionDefaultvalueId(_) -> "Id"
          ElementdefinitionDefaultvalueInstant(_) -> "Instant"
          ElementdefinitionDefaultvalueInteger(_) -> "Integer"
          ElementdefinitionDefaultvalueInteger64(_) -> "Integer64"
          ElementdefinitionDefaultvalueMarkdown(_) -> "Markdown"
          ElementdefinitionDefaultvalueOid(_) -> "Oid"
          ElementdefinitionDefaultvaluePositiveint(_) -> "Positiveint"
          ElementdefinitionDefaultvalueString(_) -> "String"
          ElementdefinitionDefaultvalueTime(_) -> "Time"
          ElementdefinitionDefaultvalueUnsignedint(_) -> "Unsignedint"
          ElementdefinitionDefaultvalueUri(_) -> "Uri"
          ElementdefinitionDefaultvalueUrl(_) -> "Url"
          ElementdefinitionDefaultvalueUuid(_) -> "Uuid"
          ElementdefinitionDefaultvalueAddress(_) -> "Address"
          ElementdefinitionDefaultvalueAge(_) -> "Age"
          ElementdefinitionDefaultvalueAnnotation(_) -> "Annotation"
          ElementdefinitionDefaultvalueAttachment(_) -> "Attachment"
          ElementdefinitionDefaultvalueCodeableconcept(_) -> "Codeableconcept"
          ElementdefinitionDefaultvalueCodeablereference(_) ->
            "Codeablereference"
          ElementdefinitionDefaultvalueCoding(_) -> "Coding"
          ElementdefinitionDefaultvalueContactpoint(_) -> "Contactpoint"
          ElementdefinitionDefaultvalueCount(_) -> "Count"
          ElementdefinitionDefaultvalueDistance(_) -> "Distance"
          ElementdefinitionDefaultvalueDuration(_) -> "Duration"
          ElementdefinitionDefaultvalueHumanname(_) -> "Humanname"
          ElementdefinitionDefaultvalueIdentifier(_) -> "Identifier"
          ElementdefinitionDefaultvalueMoney(_) -> "Money"
          ElementdefinitionDefaultvaluePeriod(_) -> "Period"
          ElementdefinitionDefaultvalueQuantity(_) -> "Quantity"
          ElementdefinitionDefaultvalueRange(_) -> "Range"
          ElementdefinitionDefaultvalueRatio(_) -> "Ratio"
          ElementdefinitionDefaultvalueRatiorange(_) -> "Ratiorange"
          ElementdefinitionDefaultvalueReference(_) -> "Reference"
          ElementdefinitionDefaultvalueSampleddata(_) -> "Sampleddata"
          ElementdefinitionDefaultvalueSignature(_) -> "Signature"
          ElementdefinitionDefaultvalueTiming(_) -> "Timing"
          ElementdefinitionDefaultvalueContactdetail(_) -> "Contactdetail"
          ElementdefinitionDefaultvalueDatarequirement(_) -> "Datarequirement"
          ElementdefinitionDefaultvalueExpression(_) -> "Expression"
          ElementdefinitionDefaultvalueParameterdefinition(_) ->
            "Parameterdefinition"
          ElementdefinitionDefaultvalueRelatedartifact(_) -> "Relatedartifact"
          ElementdefinitionDefaultvalueTriggerdefinition(_) ->
            "Triggerdefinition"
          ElementdefinitionDefaultvalueUsagecontext(_) -> "Usagecontext"
          ElementdefinitionDefaultvalueAvailability(_) -> "Availability"
          ElementdefinitionDefaultvalueExtendedcontactdetail(_) ->
            "Extendedcontactdetail"
          ElementdefinitionDefaultvalueDosage(_) -> "Dosage"
          ElementdefinitionDefaultvalueMeta(_) -> "Meta"
        },
        elementdefinition_defaultvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [
      #("type", json.array(type_, elementdefinition_type_to_json)),
      ..fields
    ]
  }
  let fields = case content_reference {
    Some(v) -> [#("contentReference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base {
    Some(v) -> [#("base", elementdefinition_base_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case requirements {
    Some(v) -> [#("requirements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case short {
    Some(v) -> [#("short", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slicing {
    Some(v) -> [#("slicing", elementdefinition_slicing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slice_is_constraining {
    Some(v) -> [#("sliceIsConstraining", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case slice_name {
    Some(v) -> [#("sliceName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case representation {
    [] -> fields
    _ -> [
      #(
        "representation",
        json.array(representation, r5valuesets.propertyrepresentation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn elementdefinition_decoder() -> Decoder(Elementdefinition) {
  use mapping <- decode.optional_field(
    "mapping",
    [],
    decode.list(elementdefinition_mapping_decoder()),
  )
  use binding <- decode.optional_field(
    "binding",
    None,
    decode.optional(elementdefinition_binding_decoder()),
  )
  use is_summary <- decode.optional_field(
    "isSummary",
    None,
    decode.optional(decode.bool),
  )
  use is_modifier_reason <- decode.optional_field(
    "isModifierReason",
    None,
    decode.optional(decode.string),
  )
  use is_modifier <- decode.optional_field(
    "isModifier",
    None,
    decode.optional(decode.bool),
  )
  use must_support <- decode.optional_field(
    "mustSupport",
    None,
    decode.optional(decode.bool),
  )
  use value_alternatives <- decode.optional_field(
    "valueAlternatives",
    [],
    decode.list(decode.string),
  )
  use must_have_value <- decode.optional_field(
    "mustHaveValue",
    None,
    decode.optional(decode.bool),
  )
  use constraint <- decode.optional_field(
    "constraint",
    [],
    decode.list(elementdefinition_constraint_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(decode.string),
  )
  use max_length <- decode.optional_field(
    "maxLength",
    None,
    decode.optional(decode.int),
  )
  use max_value <- decode.then(
    none_if_omitted(elementdefinition_maxvalue_decoder()),
  )
  use min_value <- decode.then(
    none_if_omitted(elementdefinition_minvalue_decoder()),
  )
  use example <- decode.optional_field(
    "example",
    [],
    decode.list(elementdefinition_example_decoder()),
  )
  use pattern <- decode.then(
    none_if_omitted(elementdefinition_pattern_decoder()),
  )
  use fixed <- decode.then(none_if_omitted(elementdefinition_fixed_decoder()))
  use order_meaning <- decode.optional_field(
    "orderMeaning",
    None,
    decode.optional(decode.string),
  )
  use meaning_when_missing <- decode.optional_field(
    "meaningWhenMissing",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.then(
    none_if_omitted(elementdefinition_defaultvalue_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(elementdefinition_type_decoder()),
  )
  use content_reference <- decode.optional_field(
    "contentReference",
    None,
    decode.optional(decode.string),
  )
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(elementdefinition_base_decoder()),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use requirements <- decode.optional_field(
    "requirements",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use short <- decode.optional_field(
    "short",
    None,
    decode.optional(decode.string),
  )
  use slicing <- decode.optional_field(
    "slicing",
    None,
    decode.optional(elementdefinition_slicing_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use slice_is_constraining <- decode.optional_field(
    "sliceIsConstraining",
    None,
    decode.optional(decode.bool),
  )
  use slice_name <- decode.optional_field(
    "sliceName",
    None,
    decode.optional(decode.string),
  )
  use representation <- decode.optional_field(
    "representation",
    [],
    decode.list(r5valuesets.propertyrepresentation_decoder()),
  )
  use path <- decode.field("path", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Elementdefinition(
    mapping:,
    binding:,
    is_summary:,
    is_modifier_reason:,
    is_modifier:,
    must_support:,
    value_alternatives:,
    must_have_value:,
    constraint:,
    condition:,
    max_length:,
    max_value:,
    min_value:,
    example:,
    pattern:,
    fixed:,
    order_meaning:,
    meaning_when_missing:,
    default_value:,
    type_:,
    content_reference:,
    base:,
    max:,
    min:,
    alias:,
    requirements:,
    comment:,
    definition:,
    short:,
    slicing:,
    code:,
    label:,
    slice_is_constraining:,
    slice_name:,
    representation:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Expression#resource
pub type Expression {
  Expression(
    id: Option(String),
    extension: List(Extension),
    description: Option(String),
    name: Option(String),
    language: Option(String),
    expression: Option(String),
    reference: Option(String),
  )
}

pub fn expression_new() -> Expression {
  Expression(
    reference: None,
    expression: None,
    language: None,
    name: None,
    description: None,
    extension: [],
    id: None,
  )
}

pub fn expression_to_json(expression: Expression) -> Json {
  let Expression(
    reference:,
    expression:,
    language:,
    name:,
    description:,
    extension:,
    id:,
  ) = expression
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn expression_decoder() -> Decoder(Expression) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Expression(
    reference:,
    expression:,
    language:,
    name:,
    description:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ExtendedContactDetail#resource
pub type Extendedcontactdetail {
  Extendedcontactdetail(
    id: Option(String),
    extension: List(Extension),
    purpose: Option(Codeableconcept),
    name: List(Humanname),
    telecom: List(Contactpoint),
    address: Option(Address),
    organization: Option(Reference),
    period: Option(Period),
  )
}

pub fn extendedcontactdetail_new() -> Extendedcontactdetail {
  Extendedcontactdetail(
    period: None,
    organization: None,
    address: None,
    telecom: [],
    name: [],
    purpose: None,
    extension: [],
    id: None,
  )
}

pub fn extendedcontactdetail_to_json(
  extendedcontactdetail: Extendedcontactdetail,
) -> Json {
  let Extendedcontactdetail(
    period:,
    organization:,
    address:,
    telecom:,
    name:,
    purpose:,
    extension:,
    id:,
  ) = extendedcontactdetail
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn extendedcontactdetail_decoder() -> Decoder(Extendedcontactdetail) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Extendedcontactdetail(
    period:,
    organization:,
    address:,
    telecom:,
    name:,
    purpose:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Extension#resource
pub type Extension {
  Extension(
    id: Option(String),
    extension: List(Extension),
    url: String,
    value: Option(ExtensionValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Extension#resource
pub type ExtensionValue {
  ExtensionValueBase64binary(value: String)
  ExtensionValueBoolean(value: Bool)
  ExtensionValueCanonical(value: String)
  ExtensionValueCode(value: String)
  ExtensionValueDate(value: String)
  ExtensionValueDatetime(value: String)
  ExtensionValueDecimal(value: Float)
  ExtensionValueId(value: String)
  ExtensionValueInstant(value: String)
  ExtensionValueInteger(value: Int)
  ExtensionValueInteger64(value: Int)
  ExtensionValueMarkdown(value: String)
  ExtensionValueOid(value: String)
  ExtensionValuePositiveint(value: Int)
  ExtensionValueString(value: String)
  ExtensionValueTime(value: String)
  ExtensionValueUnsignedint(value: Int)
  ExtensionValueUri(value: String)
  ExtensionValueUrl(value: String)
  ExtensionValueUuid(value: String)
  ExtensionValueAddress(value: Address)
  ExtensionValueAge(value: Age)
  ExtensionValueAnnotation(value: Annotation)
  ExtensionValueAttachment(value: Attachment)
  ExtensionValueCodeableconcept(value: Codeableconcept)
  ExtensionValueCodeablereference(value: Codeablereference)
  ExtensionValueCoding(value: Coding)
  ExtensionValueContactpoint(value: Contactpoint)
  ExtensionValueCount(value: Count)
  ExtensionValueDistance(value: Distance)
  ExtensionValueDuration(value: Duration)
  ExtensionValueHumanname(value: Humanname)
  ExtensionValueIdentifier(value: Identifier)
  ExtensionValueMoney(value: Money)
  ExtensionValuePeriod(value: Period)
  ExtensionValueQuantity(value: Quantity)
  ExtensionValueRange(value: Range)
  ExtensionValueRatio(value: Ratio)
  ExtensionValueRatiorange(value: Ratiorange)
  ExtensionValueReference(value: Reference)
  ExtensionValueSampleddata(value: Sampleddata)
  ExtensionValueSignature(value: Signature)
  ExtensionValueTiming(value: Timing)
  ExtensionValueContactdetail(value: Contactdetail)
  ExtensionValueDatarequirement(value: Datarequirement)
  ExtensionValueExpression(value: Expression)
  ExtensionValueParameterdefinition(value: Parameterdefinition)
  ExtensionValueRelatedartifact(value: Relatedartifact)
  ExtensionValueTriggerdefinition(value: Triggerdefinition)
  ExtensionValueUsagecontext(value: Usagecontext)
  ExtensionValueAvailability(value: Availability)
  ExtensionValueExtendedcontactdetail(value: Extendedcontactdetail)
  ExtensionValueDosage(value: Dosage)
  ExtensionValueMeta(value: Meta)
}

pub fn extension_value_to_json(elt: ExtensionValue) -> Json {
  case elt {
    ExtensionValueBase64binary(v) -> json.string(v)
    ExtensionValueBoolean(v) -> json.bool(v)
    ExtensionValueCanonical(v) -> json.string(v)
    ExtensionValueCode(v) -> json.string(v)
    ExtensionValueDate(v) -> json.string(v)
    ExtensionValueDatetime(v) -> json.string(v)
    ExtensionValueDecimal(v) -> json.float(v)
    ExtensionValueId(v) -> json.string(v)
    ExtensionValueInstant(v) -> json.string(v)
    ExtensionValueInteger(v) -> json.int(v)
    ExtensionValueInteger64(v) -> json.int(v)
    ExtensionValueMarkdown(v) -> json.string(v)
    ExtensionValueOid(v) -> json.string(v)
    ExtensionValuePositiveint(v) -> json.int(v)
    ExtensionValueString(v) -> json.string(v)
    ExtensionValueTime(v) -> json.string(v)
    ExtensionValueUnsignedint(v) -> json.int(v)
    ExtensionValueUri(v) -> json.string(v)
    ExtensionValueUrl(v) -> json.string(v)
    ExtensionValueUuid(v) -> json.string(v)
    ExtensionValueAddress(v) -> address_to_json(v)
    ExtensionValueAge(v) -> age_to_json(v)
    ExtensionValueAnnotation(v) -> annotation_to_json(v)
    ExtensionValueAttachment(v) -> attachment_to_json(v)
    ExtensionValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ExtensionValueCodeablereference(v) -> codeablereference_to_json(v)
    ExtensionValueCoding(v) -> coding_to_json(v)
    ExtensionValueContactpoint(v) -> contactpoint_to_json(v)
    ExtensionValueCount(v) -> count_to_json(v)
    ExtensionValueDistance(v) -> distance_to_json(v)
    ExtensionValueDuration(v) -> duration_to_json(v)
    ExtensionValueHumanname(v) -> humanname_to_json(v)
    ExtensionValueIdentifier(v) -> identifier_to_json(v)
    ExtensionValueMoney(v) -> money_to_json(v)
    ExtensionValuePeriod(v) -> period_to_json(v)
    ExtensionValueQuantity(v) -> quantity_to_json(v)
    ExtensionValueRange(v) -> range_to_json(v)
    ExtensionValueRatio(v) -> ratio_to_json(v)
    ExtensionValueRatiorange(v) -> ratiorange_to_json(v)
    ExtensionValueReference(v) -> reference_to_json(v)
    ExtensionValueSampleddata(v) -> sampleddata_to_json(v)
    ExtensionValueSignature(v) -> signature_to_json(v)
    ExtensionValueTiming(v) -> timing_to_json(v)
    ExtensionValueContactdetail(v) -> contactdetail_to_json(v)
    ExtensionValueDatarequirement(v) -> datarequirement_to_json(v)
    ExtensionValueExpression(v) -> expression_to_json(v)
    ExtensionValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    ExtensionValueRelatedartifact(v) -> relatedartifact_to_json(v)
    ExtensionValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ExtensionValueUsagecontext(v) -> usagecontext_to_json(v)
    ExtensionValueAvailability(v) -> availability_to_json(v)
    ExtensionValueExtendedcontactdetail(v) -> extendedcontactdetail_to_json(v)
    ExtensionValueDosage(v) -> dosage_to_json(v)
    ExtensionValueMeta(v) -> meta_to_json(v)
  }
}

pub fn extension_value_decoder() -> Decoder(ExtensionValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ExtensionValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ExtensionValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ExtensionValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ExtensionValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ExtensionValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ExtensionValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ExtensionValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ExtensionValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ExtensionValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ExtensionValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(ExtensionValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ExtensionValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ExtensionValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ExtensionValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ExtensionValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ExtensionValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ExtensionValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ExtensionValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ExtensionValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ExtensionValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ExtensionValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ExtensionValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ExtensionValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ExtensionValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ExtensionValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ExtensionValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ExtensionValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ExtensionValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ExtensionValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ExtensionValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ExtensionValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ExtensionValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ExtensionValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ExtensionValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ExtensionValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ExtensionValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ExtensionValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ExtensionValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ExtensionValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ExtensionValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ExtensionValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ExtensionValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ExtensionValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(ExtensionValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ExtensionValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ExtensionValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(ExtensionValueMeta),
    ],
  )
}

pub fn extension_new(url url: String) -> Extension {
  Extension(value: None, url:, extension: [], id: None)
}

pub fn extension_to_json(extension: Extension) -> Json {
  let Extension(value:, url:, extension:, id:) = extension
  let fields = [
    #("url", json.string(url)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ExtensionValueBase64binary(_) -> "Base64binary"
          ExtensionValueBoolean(_) -> "Boolean"
          ExtensionValueCanonical(_) -> "Canonical"
          ExtensionValueCode(_) -> "Code"
          ExtensionValueDate(_) -> "Date"
          ExtensionValueDatetime(_) -> "Datetime"
          ExtensionValueDecimal(_) -> "Decimal"
          ExtensionValueId(_) -> "Id"
          ExtensionValueInstant(_) -> "Instant"
          ExtensionValueInteger(_) -> "Integer"
          ExtensionValueInteger64(_) -> "Integer64"
          ExtensionValueMarkdown(_) -> "Markdown"
          ExtensionValueOid(_) -> "Oid"
          ExtensionValuePositiveint(_) -> "Positiveint"
          ExtensionValueString(_) -> "String"
          ExtensionValueTime(_) -> "Time"
          ExtensionValueUnsignedint(_) -> "Unsignedint"
          ExtensionValueUri(_) -> "Uri"
          ExtensionValueUrl(_) -> "Url"
          ExtensionValueUuid(_) -> "Uuid"
          ExtensionValueAddress(_) -> "Address"
          ExtensionValueAge(_) -> "Age"
          ExtensionValueAnnotation(_) -> "Annotation"
          ExtensionValueAttachment(_) -> "Attachment"
          ExtensionValueCodeableconcept(_) -> "Codeableconcept"
          ExtensionValueCodeablereference(_) -> "Codeablereference"
          ExtensionValueCoding(_) -> "Coding"
          ExtensionValueContactpoint(_) -> "Contactpoint"
          ExtensionValueCount(_) -> "Count"
          ExtensionValueDistance(_) -> "Distance"
          ExtensionValueDuration(_) -> "Duration"
          ExtensionValueHumanname(_) -> "Humanname"
          ExtensionValueIdentifier(_) -> "Identifier"
          ExtensionValueMoney(_) -> "Money"
          ExtensionValuePeriod(_) -> "Period"
          ExtensionValueQuantity(_) -> "Quantity"
          ExtensionValueRange(_) -> "Range"
          ExtensionValueRatio(_) -> "Ratio"
          ExtensionValueRatiorange(_) -> "Ratiorange"
          ExtensionValueReference(_) -> "Reference"
          ExtensionValueSampleddata(_) -> "Sampleddata"
          ExtensionValueSignature(_) -> "Signature"
          ExtensionValueTiming(_) -> "Timing"
          ExtensionValueContactdetail(_) -> "Contactdetail"
          ExtensionValueDatarequirement(_) -> "Datarequirement"
          ExtensionValueExpression(_) -> "Expression"
          ExtensionValueParameterdefinition(_) -> "Parameterdefinition"
          ExtensionValueRelatedartifact(_) -> "Relatedartifact"
          ExtensionValueTriggerdefinition(_) -> "Triggerdefinition"
          ExtensionValueUsagecontext(_) -> "Usagecontext"
          ExtensionValueAvailability(_) -> "Availability"
          ExtensionValueExtendedcontactdetail(_) -> "Extendedcontactdetail"
          ExtensionValueDosage(_) -> "Dosage"
          ExtensionValueMeta(_) -> "Meta"
        },
        extension_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn extension_decoder() -> Decoder(Extension) {
  use value <- decode.then(none_if_omitted(extension_value_decoder()))
  use url <- decode.field("url", decode.string)
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Extension(value:, url:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/HumanName#resource
pub type Humanname {
  Humanname(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r5valuesets.Nameuse),
    text: Option(String),
    family: Option(String),
    given: List(String),
    prefix: List(String),
    suffix: List(String),
    period: Option(Period),
  )
}

pub fn humanname_new() -> Humanname {
  Humanname(
    period: None,
    suffix: [],
    prefix: [],
    given: [],
    family: None,
    text: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn humanname_to_json(humanname: Humanname) -> Json {
  let Humanname(
    period:,
    suffix:,
    prefix:,
    given:,
    family:,
    text:,
    use_:,
    extension:,
    id:,
  ) = humanname
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case suffix {
    [] -> fields
    _ -> [#("suffix", json.array(suffix, json.string)), ..fields]
  }
  let fields = case prefix {
    [] -> fields
    _ -> [#("prefix", json.array(prefix, json.string)), ..fields]
  }
  let fields = case given {
    [] -> fields
    _ -> [#("given", json.array(given, json.string)), ..fields]
  }
  let fields = case family {
    Some(v) -> [#("family", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r5valuesets.nameuse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn humanname_decoder() -> Decoder(Humanname) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use suffix <- decode.optional_field("suffix", [], decode.list(decode.string))
  use prefix <- decode.optional_field("prefix", [], decode.list(decode.string))
  use given <- decode.optional_field("given", [], decode.list(decode.string))
  use family <- decode.optional_field(
    "family",
    None,
    decode.optional(decode.string),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r5valuesets.nameuse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Humanname(
    period:,
    suffix:,
    prefix:,
    given:,
    family:,
    text:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Identifier#resource
pub type Identifier {
  Identifier(
    id: Option(String),
    extension: List(Extension),
    use_: Option(r5valuesets.Identifieruse),
    type_: Option(Codeableconcept),
    system: Option(String),
    value: Option(String),
    period: Option(Period),
    assigner: Option(Reference),
  )
}

pub fn identifier_new() -> Identifier {
  Identifier(
    assigner: None,
    period: None,
    value: None,
    system: None,
    type_: None,
    use_: None,
    extension: [],
    id: None,
  )
}

pub fn identifier_to_json(identifier: Identifier) -> Json {
  let Identifier(
    assigner:,
    period:,
    value:,
    system:,
    type_:,
    use_:,
    extension:,
    id:,
  ) = identifier
  let fields = []
  let fields = case assigner {
    Some(v) -> [#("assigner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case use_ {
    Some(v) -> [#("use", r5valuesets.identifieruse_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn identifier_decoder() -> Decoder(Identifier) {
  use assigner <- decode.optional_field(
    "assigner",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(r5valuesets.identifieruse_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Identifier(
    assigner:,
    period:,
    value:,
    system:,
    type_:,
    use_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MarketingStatus#resource
pub type Marketingstatus {
  Marketingstatus(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    country: Option(Codeableconcept),
    jurisdiction: Option(Codeableconcept),
    status: Codeableconcept,
    date_range: Option(Period),
    restore_date: Option(String),
  )
}

pub fn marketingstatus_new(status status: Codeableconcept) -> Marketingstatus {
  Marketingstatus(
    restore_date: None,
    date_range: None,
    status:,
    jurisdiction: None,
    country: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn marketingstatus_to_json(marketingstatus: Marketingstatus) -> Json {
  let Marketingstatus(
    restore_date:,
    date_range:,
    status:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ) = marketingstatus
  let fields = [
    #("status", codeableconcept_to_json(status)),
  ]
  let fields = case restore_date {
    Some(v) -> [#("restoreDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date_range {
    Some(v) -> [#("dateRange", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case country {
    Some(v) -> [#("country", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn marketingstatus_decoder() -> Decoder(Marketingstatus) {
  use restore_date <- decode.optional_field(
    "restoreDate",
    None,
    decode.optional(decode.string),
  )
  use date_range <- decode.optional_field(
    "dateRange",
    None,
    decode.optional(period_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Marketingstatus(
    restore_date:,
    date_range:,
    status:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Meta#resource
pub type Meta {
  Meta(
    id: Option(String),
    extension: List(Extension),
    version_id: Option(String),
    last_updated: Option(String),
    source: Option(String),
    profile: List(String),
    security: List(Coding),
    tag: List(Coding),
  )
}

pub fn meta_new() -> Meta {
  Meta(
    tag: [],
    security: [],
    profile: [],
    source: None,
    last_updated: None,
    version_id: None,
    extension: [],
    id: None,
  )
}

pub fn meta_to_json(meta: Meta) -> Json {
  let Meta(
    tag:,
    security:,
    profile:,
    source:,
    last_updated:,
    version_id:,
    extension:,
    id:,
  ) = meta
  let fields = []
  let fields = case tag {
    [] -> fields
    _ -> [#("tag", json.array(tag, coding_to_json)), ..fields]
  }
  let fields = case security {
    [] -> fields
    _ -> [#("security", json.array(security, coding_to_json)), ..fields]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_updated {
    Some(v) -> [#("lastUpdated", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_id {
    Some(v) -> [#("versionId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn meta_decoder() -> Decoder(Meta) {
  use tag <- decode.optional_field("tag", [], decode.list(coding_decoder()))
  use security <- decode.optional_field(
    "security",
    [],
    decode.list(coding_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use last_updated <- decode.optional_field(
    "lastUpdated",
    None,
    decode.optional(decode.string),
  )
  use version_id <- decode.optional_field(
    "versionId",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Meta(
    tag:,
    security:,
    profile:,
    source:,
    last_updated:,
    version_id:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MonetaryComponent#resource
pub type Monetarycomponent {
  Monetarycomponent(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Pricecomponenttype,
    code: Option(Codeableconcept),
    factor: Option(Float),
    amount: Option(Money),
  )
}

pub fn monetarycomponent_new(
  type_ type_: r5valuesets.Pricecomponenttype,
) -> Monetarycomponent {
  Monetarycomponent(
    amount: None,
    factor: None,
    code: None,
    type_:,
    extension: [],
    id: None,
  )
}

pub fn monetarycomponent_to_json(monetarycomponent: Monetarycomponent) -> Json {
  let Monetarycomponent(amount:, factor:, code:, type_:, extension:, id:) =
    monetarycomponent
  let fields = [
    #("type", r5valuesets.pricecomponenttype_to_json(type_)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn monetarycomponent_decoder() -> Decoder(Monetarycomponent) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", r5valuesets.pricecomponenttype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Monetarycomponent(
    amount:,
    factor:,
    code:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Money#resource
pub type Money {
  Money(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    currency: Option(String),
  )
}

pub fn money_new() -> Money {
  Money(currency: None, value: None, extension: [], id: None)
}

pub fn money_to_json(money: Money) -> Json {
  let Money(currency:, value:, extension:, id:) = money
  let fields = []
  let fields = case currency {
    Some(v) -> [#("currency", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn money_decoder() -> Decoder(Money) {
  use currency <- decode.optional_field(
    "currency",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Money(currency:, value:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Narrative#resource
pub type Narrative {
  Narrative(
    id: Option(String),
    extension: List(Extension),
    status: r5valuesets.Narrativestatus,
    div: String,
  )
}

pub fn narrative_new(
  div div: String,
  status status: r5valuesets.Narrativestatus,
) -> Narrative {
  Narrative(div:, status:, extension: [], id: None)
}

pub fn narrative_to_json(narrative: Narrative) -> Json {
  let Narrative(div:, status:, extension:, id:) = narrative
  let fields = [
    #("div", json.string(div)),
    #("status", r5valuesets.narrativestatus_to_json(status)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn narrative_decoder() -> Decoder(Narrative) {
  use div <- decode.field("div", decode.string)
  use status <- decode.field("status", r5valuesets.narrativestatus_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Narrative(div:, status:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/ParameterDefinition#resource
pub type Parameterdefinition {
  Parameterdefinition(
    id: Option(String),
    extension: List(Extension),
    name: Option(String),
    use_: r5valuesets.Operationparameteruse,
    min: Option(Int),
    max: Option(String),
    documentation: Option(String),
    type_: r5valuesets.Fhirtypes,
    profile: Option(String),
  )
}

pub fn parameterdefinition_new(
  type_ type_: r5valuesets.Fhirtypes,
  use_ use_: r5valuesets.Operationparameteruse,
) -> Parameterdefinition {
  Parameterdefinition(
    profile: None,
    type_:,
    documentation: None,
    max: None,
    min: None,
    use_:,
    name: None,
    extension: [],
    id: None,
  )
}

pub fn parameterdefinition_to_json(
  parameterdefinition: Parameterdefinition,
) -> Json {
  let Parameterdefinition(
    profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    extension:,
    id:,
  ) = parameterdefinition
  let fields = [
    #("type", r5valuesets.fhirtypes_to_json(type_)),
    #("use", r5valuesets.operationparameteruse_to_json(use_)),
  ]
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn parameterdefinition_decoder() -> Decoder(Parameterdefinition) {
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.fhirtypes_decoder())
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use use_ <- decode.field("use", r5valuesets.operationparameteruse_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Parameterdefinition(
    profile:,
    type_:,
    documentation:,
    max:,
    min:,
    use_:,
    name:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Period#resource
pub type Period {
  Period(
    id: Option(String),
    extension: List(Extension),
    start: Option(String),
    end: Option(String),
  )
}

pub fn period_new() -> Period {
  Period(end: None, start: None, extension: [], id: None)
}

pub fn period_to_json(period: Period) -> Json {
  let Period(end:, start:, extension:, id:) = period
  let fields = []
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn period_decoder() -> Decoder(Period) {
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Period(end:, start:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/PrimitiveType#resource
pub type Primitivetype {
  Primitivetype(id: Option(String), extension: List(Extension))
}

pub fn primitivetype_new() -> Primitivetype {
  Primitivetype(extension: [], id: None)
}

pub fn primitivetype_to_json(primitivetype: Primitivetype) -> Json {
  let Primitivetype(extension:, id:) = primitivetype
  let fields = []
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn primitivetype_decoder() -> Decoder(Primitivetype) {
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Primitivetype(extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/ProductShelfLife#resource
pub type Productshelflife {
  Productshelflife(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    period: Option(ProductshelflifePeriod),
    special_precautions_for_storage: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ProductShelfLife#resource
pub type ProductshelflifePeriod {
  ProductshelflifePeriodDuration(period: Duration)
  ProductshelflifePeriodString(period: String)
}

pub fn productshelflife_period_to_json(elt: ProductshelflifePeriod) -> Json {
  case elt {
    ProductshelflifePeriodDuration(v) -> duration_to_json(v)
    ProductshelflifePeriodString(v) -> json.string(v)
  }
}

pub fn productshelflife_period_decoder() -> Decoder(ProductshelflifePeriod) {
  decode.one_of(
    decode.field("periodDuration", duration_decoder(), decode.success)
      |> decode.map(ProductshelflifePeriodDuration),
    [
      decode.field("periodString", decode.string, decode.success)
      |> decode.map(ProductshelflifePeriodString),
    ],
  )
}

pub fn productshelflife_new() -> Productshelflife {
  Productshelflife(
    special_precautions_for_storage: [],
    period: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn productshelflife_to_json(productshelflife: Productshelflife) -> Json {
  let Productshelflife(
    special_precautions_for_storage:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = productshelflife
  let fields = []
  let fields = case special_precautions_for_storage {
    [] -> fields
    _ -> [
      #(
        "specialPrecautionsForStorage",
        json.array(special_precautions_for_storage, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [
      #(
        "period"
          <> case v {
          ProductshelflifePeriodDuration(_) -> "Duration"
          ProductshelflifePeriodString(_) -> "String"
        },
        productshelflife_period_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn productshelflife_decoder() -> Decoder(Productshelflife) {
  use special_precautions_for_storage <- decode.optional_field(
    "specialPrecautionsForStorage",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use period <- decode.then(none_if_omitted(productshelflife_period_decoder()))
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Productshelflife(
    special_precautions_for_storage:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Quantity#resource
pub type Quantity {
  Quantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn quantity_new() -> Quantity {
  Quantity(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn quantity_to_json(quantity: Quantity) -> Json {
  let Quantity(code:, system:, unit:, comparator:, value:, extension:, id:) =
    quantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn quantity_decoder() -> Decoder(Quantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Quantity(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Range#resource
pub type Range {
  Range(
    id: Option(String),
    extension: List(Extension),
    low: Option(Quantity),
    high: Option(Quantity),
  )
}

pub fn range_new() -> Range {
  Range(high: None, low: None, extension: [], id: None)
}

pub fn range_to_json(range: Range) -> Json {
  let Range(high:, low:, extension:, id:) = range
  let fields = []
  let fields = case high {
    Some(v) -> [#("high", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low {
    Some(v) -> [#("low", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn range_decoder() -> Decoder(Range) {
  use high <- decode.optional_field(
    "high",
    None,
    decode.optional(quantity_decoder()),
  )
  use low <- decode.optional_field(
    "low",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Range(high:, low:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Ratio#resource
pub type Ratio {
  Ratio(
    id: Option(String),
    extension: List(Extension),
    numerator: Option(Quantity),
    denominator: Option(Quantity),
  )
}

pub fn ratio_new() -> Ratio {
  Ratio(denominator: None, numerator: None, extension: [], id: None)
}

pub fn ratio_to_json(ratio: Ratio) -> Json {
  let Ratio(denominator:, numerator:, extension:, id:) = ratio
  let fields = []
  let fields = case denominator {
    Some(v) -> [#("denominator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case numerator {
    Some(v) -> [#("numerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ratio_decoder() -> Decoder(Ratio) {
  use denominator <- decode.optional_field(
    "denominator",
    None,
    decode.optional(quantity_decoder()),
  )
  use numerator <- decode.optional_field(
    "numerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Ratio(denominator:, numerator:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/RatioRange#resource
pub type Ratiorange {
  Ratiorange(
    id: Option(String),
    extension: List(Extension),
    low_numerator: Option(Quantity),
    high_numerator: Option(Quantity),
    denominator: Option(Quantity),
  )
}

pub fn ratiorange_new() -> Ratiorange {
  Ratiorange(
    denominator: None,
    high_numerator: None,
    low_numerator: None,
    extension: [],
    id: None,
  )
}

pub fn ratiorange_to_json(ratiorange: Ratiorange) -> Json {
  let Ratiorange(denominator:, high_numerator:, low_numerator:, extension:, id:) =
    ratiorange
  let fields = []
  let fields = case denominator {
    Some(v) -> [#("denominator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case high_numerator {
    Some(v) -> [#("highNumerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low_numerator {
    Some(v) -> [#("lowNumerator", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ratiorange_decoder() -> Decoder(Ratiorange) {
  use denominator <- decode.optional_field(
    "denominator",
    None,
    decode.optional(quantity_decoder()),
  )
  use high_numerator <- decode.optional_field(
    "highNumerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use low_numerator <- decode.optional_field(
    "lowNumerator",
    None,
    decode.optional(quantity_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Ratiorange(
    denominator:,
    high_numerator:,
    low_numerator:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Reference#resource
pub type Reference {
  Reference(
    id: Option(String),
    extension: List(Extension),
    reference: Option(String),
    type_: Option(String),
    identifier: Option(Identifier),
    display: Option(String),
  )
}

pub fn reference_new() -> Reference {
  Reference(
    display: None,
    identifier: None,
    type_: None,
    reference: None,
    extension: [],
    id: None,
  )
}

pub fn reference_to_json(reference: Reference) -> Json {
  let Reference(display:, identifier:, type_:, reference:, extension:, id:) =
    reference
  let fields = []
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn reference_decoder() -> Decoder(Reference) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Reference(
    display:,
    identifier:,
    type_:,
    reference:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/RelatedArtifact#resource
pub type Relatedartifact {
  Relatedartifact(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Relatedartifacttype,
    classifier: List(Codeableconcept),
    label: Option(String),
    display: Option(String),
    citation: Option(String),
    document: Option(Attachment),
    resource: Option(String),
    resource_reference: Option(Reference),
    publication_status: Option(r5valuesets.Publicationstatus),
    publication_date: Option(String),
  )
}

pub fn relatedartifact_new(
  type_ type_: r5valuesets.Relatedartifacttype,
) -> Relatedartifact {
  Relatedartifact(
    publication_date: None,
    publication_status: None,
    resource_reference: None,
    resource: None,
    document: None,
    citation: None,
    display: None,
    label: None,
    classifier: [],
    type_:,
    extension: [],
    id: None,
  )
}

pub fn relatedartifact_to_json(relatedartifact: Relatedartifact) -> Json {
  let Relatedartifact(
    publication_date:,
    publication_status:,
    resource_reference:,
    resource:,
    document:,
    citation:,
    display:,
    label:,
    classifier:,
    type_:,
    extension:,
    id:,
  ) = relatedartifact
  let fields = [
    #("type", r5valuesets.relatedartifacttype_to_json(type_)),
  ]
  let fields = case publication_date {
    Some(v) -> [#("publicationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_status {
    Some(v) -> [
      #("publicationStatus", r5valuesets.publicationstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource_reference {
    Some(v) -> [#("resourceReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case document {
    Some(v) -> [#("document", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case citation {
    Some(v) -> [#("citation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn relatedartifact_decoder() -> Decoder(Relatedartifact) {
  use publication_date <- decode.optional_field(
    "publicationDate",
    None,
    decode.optional(decode.string),
  )
  use publication_status <- decode.optional_field(
    "publicationStatus",
    None,
    decode.optional(r5valuesets.publicationstatus_decoder()),
  )
  use resource_reference <- decode.optional_field(
    "resourceReference",
    None,
    decode.optional(reference_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use document <- decode.optional_field(
    "document",
    None,
    decode.optional(attachment_decoder()),
  )
  use citation <- decode.optional_field(
    "citation",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", r5valuesets.relatedartifacttype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Relatedartifact(
    publication_date:,
    publication_status:,
    resource_reference:,
    resource:,
    document:,
    citation:,
    display:,
    label:,
    classifier:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SampledData#resource
pub type Sampleddata {
  Sampleddata(
    id: Option(String),
    extension: List(Extension),
    origin: Quantity,
    interval: Option(Float),
    interval_unit: String,
    factor: Option(Float),
    lower_limit: Option(Float),
    upper_limit: Option(Float),
    dimensions: Int,
    code_map: Option(String),
    offsets: Option(String),
    data: Option(String),
  )
}

pub fn sampleddata_new(
  dimensions dimensions: Int,
  interval_unit interval_unit: String,
  origin origin: Quantity,
) -> Sampleddata {
  Sampleddata(
    data: None,
    offsets: None,
    code_map: None,
    dimensions:,
    upper_limit: None,
    lower_limit: None,
    factor: None,
    interval_unit:,
    interval: None,
    origin:,
    extension: [],
    id: None,
  )
}

pub fn sampleddata_to_json(sampleddata: Sampleddata) -> Json {
  let Sampleddata(
    data:,
    offsets:,
    code_map:,
    dimensions:,
    upper_limit:,
    lower_limit:,
    factor:,
    interval_unit:,
    interval:,
    origin:,
    extension:,
    id:,
  ) = sampleddata
  let fields = [
    #("dimensions", json.int(dimensions)),
    #("intervalUnit", json.string(interval_unit)),
    #("origin", quantity_to_json(origin)),
  ]
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case offsets {
    Some(v) -> [#("offsets", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code_map {
    Some(v) -> [#("codeMap", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case upper_limit {
    Some(v) -> [#("upperLimit", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case lower_limit {
    Some(v) -> [#("lowerLimit", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case interval {
    Some(v) -> [#("interval", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn sampleddata_decoder() -> Decoder(Sampleddata) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use offsets <- decode.optional_field(
    "offsets",
    None,
    decode.optional(decode.string),
  )
  use code_map <- decode.optional_field(
    "codeMap",
    None,
    decode.optional(decode.string),
  )
  use dimensions <- decode.field("dimensions", decode.int)
  use upper_limit <- decode.optional_field(
    "upperLimit",
    None,
    decode.optional(decode.float),
  )
  use lower_limit <- decode.optional_field(
    "lowerLimit",
    None,
    decode.optional(decode.float),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use interval_unit <- decode.field("intervalUnit", decode.string)
  use interval <- decode.optional_field(
    "interval",
    None,
    decode.optional(decode.float),
  )
  use origin <- decode.field("origin", quantity_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Sampleddata(
    data:,
    offsets:,
    code_map:,
    dimensions:,
    upper_limit:,
    lower_limit:,
    factor:,
    interval_unit:,
    interval:,
    origin:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Signature#resource
pub type Signature {
  Signature(
    id: Option(String),
    extension: List(Extension),
    type_: List(Coding),
    when: Option(String),
    who: Option(Reference),
    on_behalf_of: Option(Reference),
    target_format: Option(String),
    sig_format: Option(String),
    data: Option(String),
  )
}

pub fn signature_new() -> Signature {
  Signature(
    data: None,
    sig_format: None,
    target_format: None,
    on_behalf_of: None,
    who: None,
    when: None,
    type_: [],
    extension: [],
    id: None,
  )
}

pub fn signature_to_json(signature: Signature) -> Json {
  let Signature(
    data:,
    sig_format:,
    target_format:,
    on_behalf_of:,
    who:,
    when:,
    type_:,
    extension:,
    id:,
  ) = signature
  let fields = []
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sig_format {
    Some(v) -> [#("sigFormat", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target_format {
    Some(v) -> [#("targetFormat", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case when {
    Some(v) -> [#("when", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, coding_to_json)), ..fields]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn signature_decoder() -> Decoder(Signature) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use sig_format <- decode.optional_field(
    "sigFormat",
    None,
    decode.optional(decode.string),
  )
  use target_format <- decode.optional_field(
    "targetFormat",
    None,
    decode.optional(decode.string),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use when <- decode.optional_field(
    "when",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field("type", [], decode.list(coding_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Signature(
    data:,
    sig_format:,
    target_format:,
    on_behalf_of:,
    who:,
    when:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Timing#resource
pub type Timing {
  Timing(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event: List(String),
    repeat: Option(TimingRepeat),
    code: Option(Codeableconcept),
  )
}

pub fn timing_new() -> Timing {
  Timing(
    code: None,
    repeat: None,
    event: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Timing#resource
pub type TimingRepeat {
  TimingRepeat(
    id: Option(String),
    extension: List(Extension),
    bounds: Option(TimingRepeatBounds),
    count: Option(Int),
    count_max: Option(Int),
    duration: Option(Float),
    duration_max: Option(Float),
    duration_unit: Option(r5valuesets.Unitsoftime),
    frequency: Option(Int),
    frequency_max: Option(Int),
    period: Option(Float),
    period_max: Option(Float),
    period_unit: Option(r5valuesets.Unitsoftime),
    day_of_week: List(r5valuesets.Daysofweek),
    time_of_day: List(String),
    when: List(r5valuesets.Eventtiming),
    offset: Option(Int),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Timing#resource
pub type TimingRepeatBounds {
  TimingRepeatBoundsDuration(bounds: Duration)
  TimingRepeatBoundsRange(bounds: Range)
  TimingRepeatBoundsPeriod(bounds: Period)
}

pub fn timing_repeat_bounds_to_json(elt: TimingRepeatBounds) -> Json {
  case elt {
    TimingRepeatBoundsDuration(v) -> duration_to_json(v)
    TimingRepeatBoundsRange(v) -> range_to_json(v)
    TimingRepeatBoundsPeriod(v) -> period_to_json(v)
  }
}

pub fn timing_repeat_bounds_decoder() -> Decoder(TimingRepeatBounds) {
  decode.one_of(
    decode.field("boundsDuration", duration_decoder(), decode.success)
      |> decode.map(TimingRepeatBoundsDuration),
    [
      decode.field("boundsRange", range_decoder(), decode.success)
        |> decode.map(TimingRepeatBoundsRange),
      decode.field("boundsPeriod", period_decoder(), decode.success)
        |> decode.map(TimingRepeatBoundsPeriod),
    ],
  )
}

pub fn timing_repeat_new() -> TimingRepeat {
  TimingRepeat(
    offset: None,
    when: [],
    time_of_day: [],
    day_of_week: [],
    period_unit: None,
    period_max: None,
    period: None,
    frequency_max: None,
    frequency: None,
    duration_unit: None,
    duration_max: None,
    duration: None,
    count_max: None,
    count: None,
    bounds: None,
    extension: [],
    id: None,
  )
}

pub fn timing_repeat_to_json(timing_repeat: TimingRepeat) -> Json {
  let TimingRepeat(
    offset:,
    when:,
    time_of_day:,
    day_of_week:,
    period_unit:,
    period_max:,
    period:,
    frequency_max:,
    frequency:,
    duration_unit:,
    duration_max:,
    duration:,
    count_max:,
    count:,
    bounds:,
    extension:,
    id:,
  ) = timing_repeat
  let fields = []
  let fields = case offset {
    Some(v) -> [#("offset", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case when {
    [] -> fields
    _ -> [
      #("when", json.array(when, r5valuesets.eventtiming_to_json)),
      ..fields
    ]
  }
  let fields = case time_of_day {
    [] -> fields
    _ -> [#("timeOfDay", json.array(time_of_day, json.string)), ..fields]
  }
  let fields = case day_of_week {
    [] -> fields
    _ -> [
      #("dayOfWeek", json.array(day_of_week, r5valuesets.daysofweek_to_json)),
      ..fields
    ]
  }
  let fields = case period_unit {
    Some(v) -> [#("periodUnit", r5valuesets.unitsoftime_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period_max {
    Some(v) -> [#("periodMax", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case frequency_max {
    Some(v) -> [#("frequencyMax", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case frequency {
    Some(v) -> [#("frequency", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case duration_unit {
    Some(v) -> [#("durationUnit", r5valuesets.unitsoftime_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case duration_max {
    Some(v) -> [#("durationMax", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case count_max {
    Some(v) -> [#("countMax", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case bounds {
    Some(v) -> [
      #(
        "bounds"
          <> case v {
          TimingRepeatBoundsDuration(_) -> "Duration"
          TimingRepeatBoundsRange(_) -> "Range"
          TimingRepeatBoundsPeriod(_) -> "Period"
        },
        timing_repeat_bounds_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn timing_repeat_decoder() -> Decoder(TimingRepeat) {
  use offset <- decode.optional_field(
    "offset",
    None,
    decode.optional(decode.int),
  )
  use when <- decode.optional_field(
    "when",
    [],
    decode.list(r5valuesets.eventtiming_decoder()),
  )
  use time_of_day <- decode.optional_field(
    "timeOfDay",
    [],
    decode.list(decode.string),
  )
  use day_of_week <- decode.optional_field(
    "dayOfWeek",
    [],
    decode.list(r5valuesets.daysofweek_decoder()),
  )
  use period_unit <- decode.optional_field(
    "periodUnit",
    None,
    decode.optional(r5valuesets.unitsoftime_decoder()),
  )
  use period_max <- decode.optional_field(
    "periodMax",
    None,
    decode.optional(decode.float),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(decode.float),
  )
  use frequency_max <- decode.optional_field(
    "frequencyMax",
    None,
    decode.optional(decode.int),
  )
  use frequency <- decode.optional_field(
    "frequency",
    None,
    decode.optional(decode.int),
  )
  use duration_unit <- decode.optional_field(
    "durationUnit",
    None,
    decode.optional(r5valuesets.unitsoftime_decoder()),
  )
  use duration_max <- decode.optional_field(
    "durationMax",
    None,
    decode.optional(decode.float),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(decode.float),
  )
  use count_max <- decode.optional_field(
    "countMax",
    None,
    decode.optional(decode.int),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use bounds <- decode.then(none_if_omitted(timing_repeat_bounds_decoder()))
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TimingRepeat(
    offset:,
    when:,
    time_of_day:,
    day_of_week:,
    period_unit:,
    period_max:,
    period:,
    frequency_max:,
    frequency:,
    duration_unit:,
    duration_max:,
    duration:,
    count_max:,
    count:,
    bounds:,
    extension:,
    id:,
  ))
}

pub fn timing_to_json(timing: Timing) -> Json {
  let Timing(code:, repeat:, event:, modifier_extension:, extension:, id:) =
    timing
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case repeat {
    Some(v) -> [#("repeat", timing_repeat_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn timing_decoder() -> Decoder(Timing) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use repeat <- decode.optional_field(
    "repeat",
    None,
    decode.optional(timing_repeat_decoder()),
  )
  use event <- decode.optional_field("event", [], decode.list(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Timing(
    code:,
    repeat:,
    event:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/TriggerDefinition#resource
pub type Triggerdefinition {
  Triggerdefinition(
    id: Option(String),
    extension: List(Extension),
    type_: r5valuesets.Triggertype,
    name: Option(String),
    code: Option(Codeableconcept),
    subscription_topic: Option(String),
    timing: Option(TriggerdefinitionTiming),
    data: List(Datarequirement),
    condition: Option(Expression),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TriggerDefinition#resource
pub type TriggerdefinitionTiming {
  TriggerdefinitionTimingTiming(timing: Timing)
  TriggerdefinitionTimingReference(timing: Reference)
  TriggerdefinitionTimingDate(timing: String)
  TriggerdefinitionTimingDatetime(timing: String)
}

pub fn triggerdefinition_timing_to_json(elt: TriggerdefinitionTiming) -> Json {
  case elt {
    TriggerdefinitionTimingTiming(v) -> timing_to_json(v)
    TriggerdefinitionTimingReference(v) -> reference_to_json(v)
    TriggerdefinitionTimingDate(v) -> json.string(v)
    TriggerdefinitionTimingDatetime(v) -> json.string(v)
  }
}

pub fn triggerdefinition_timing_decoder() -> Decoder(TriggerdefinitionTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(TriggerdefinitionTimingTiming),
    [
      decode.field("timingReference", reference_decoder(), decode.success)
        |> decode.map(TriggerdefinitionTimingReference),
      decode.field("timingDate", decode.string, decode.success)
        |> decode.map(TriggerdefinitionTimingDate),
      decode.field("timingDateTime", decode.string, decode.success)
        |> decode.map(TriggerdefinitionTimingDatetime),
    ],
  )
}

pub fn triggerdefinition_new(
  type_ type_: r5valuesets.Triggertype,
) -> Triggerdefinition {
  Triggerdefinition(
    condition: None,
    data: [],
    timing: None,
    subscription_topic: None,
    code: None,
    name: None,
    type_:,
    extension: [],
    id: None,
  )
}

pub fn triggerdefinition_to_json(triggerdefinition: Triggerdefinition) -> Json {
  let Triggerdefinition(
    condition:,
    data:,
    timing:,
    subscription_topic:,
    code:,
    name:,
    type_:,
    extension:,
    id:,
  ) = triggerdefinition
  let fields = [
    #("type", r5valuesets.triggertype_to_json(type_)),
  ]
  let fields = case condition {
    Some(v) -> [#("condition", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case data {
    [] -> fields
    _ -> [#("data", json.array(data, datarequirement_to_json)), ..fields]
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          TriggerdefinitionTimingTiming(_) -> "Timing"
          TriggerdefinitionTimingReference(_) -> "Reference"
          TriggerdefinitionTimingDate(_) -> "Date"
          TriggerdefinitionTimingDatetime(_) -> "Datetime"
        },
        triggerdefinition_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case subscription_topic {
    Some(v) -> [#("subscriptionTopic", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn triggerdefinition_decoder() -> Decoder(Triggerdefinition) {
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(expression_decoder()),
  )
  use data <- decode.optional_field(
    "data",
    [],
    decode.list(datarequirement_decoder()),
  )
  use timing <- decode.then(none_if_omitted(triggerdefinition_timing_decoder()))
  use subscription_topic <- decode.optional_field(
    "subscriptionTopic",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.triggertype_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Triggerdefinition(
    condition:,
    data:,
    timing:,
    subscription_topic:,
    code:,
    name:,
    type_:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/UsageContext#resource
pub type Usagecontext {
  Usagecontext(
    id: Option(String),
    extension: List(Extension),
    code: Coding,
    value: UsagecontextValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/UsageContext#resource
pub type UsagecontextValue {
  UsagecontextValueCodeableconcept(value: Codeableconcept)
  UsagecontextValueQuantity(value: Quantity)
  UsagecontextValueRange(value: Range)
  UsagecontextValueReference(value: Reference)
}

pub fn usagecontext_value_to_json(elt: UsagecontextValue) -> Json {
  case elt {
    UsagecontextValueCodeableconcept(v) -> codeableconcept_to_json(v)
    UsagecontextValueQuantity(v) -> quantity_to_json(v)
    UsagecontextValueRange(v) -> range_to_json(v)
    UsagecontextValueReference(v) -> reference_to_json(v)
  }
}

pub fn usagecontext_value_decoder() -> Decoder(UsagecontextValue) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(UsagecontextValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(UsagecontextValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(UsagecontextValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(UsagecontextValueReference),
    ],
  )
}

pub fn usagecontext_new(
  value value: UsagecontextValue,
  code code: Coding,
) -> Usagecontext {
  Usagecontext(value:, code:, extension: [], id: None)
}

pub fn usagecontext_to_json(usagecontext: Usagecontext) -> Json {
  let Usagecontext(value:, code:, extension:, id:) = usagecontext
  let fields = [
    #("value", usagecontext_value_to_json(value)),
    #("code", coding_to_json(code)),
  ]
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn usagecontext_decoder() -> Decoder(Usagecontext) {
  use value <- decode.then(usagecontext_value_decoder())
  use code <- decode.field("code", coding_decoder())
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Usagecontext(value:, code:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/VirtualServiceDetail#resource
pub type Virtualservicedetail {
  Virtualservicedetail(
    id: Option(String),
    extension: List(Extension),
    channel_type: Option(Coding),
    address: Option(VirtualservicedetailAddress),
    additional_info: List(String),
    max_participants: Option(Int),
    session_key: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VirtualServiceDetail#resource
pub type VirtualservicedetailAddress {
  VirtualservicedetailAddressUrl(address: String)
  VirtualservicedetailAddressString(address: String)
  VirtualservicedetailAddressContactpoint(address: Contactpoint)
  VirtualservicedetailAddressExtendedcontactdetail(
    address: Extendedcontactdetail,
  )
}

pub fn virtualservicedetail_address_to_json(
  elt: VirtualservicedetailAddress,
) -> Json {
  case elt {
    VirtualservicedetailAddressUrl(v) -> json.string(v)
    VirtualservicedetailAddressString(v) -> json.string(v)
    VirtualservicedetailAddressContactpoint(v) -> contactpoint_to_json(v)
    VirtualservicedetailAddressExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
  }
}

pub fn virtualservicedetail_address_decoder() -> Decoder(
  VirtualservicedetailAddress,
) {
  decode.one_of(
    decode.field("addressUrl", decode.string, decode.success)
      |> decode.map(VirtualservicedetailAddressUrl),
    [
      decode.field("addressString", decode.string, decode.success)
        |> decode.map(VirtualservicedetailAddressString),
      decode.field(
        "addressContactPoint",
        contactpoint_decoder(),
        decode.success,
      )
        |> decode.map(VirtualservicedetailAddressContactpoint),
      decode.field(
        "addressExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(VirtualservicedetailAddressExtendedcontactdetail),
    ],
  )
}

pub fn virtualservicedetail_new() -> Virtualservicedetail {
  Virtualservicedetail(
    session_key: None,
    max_participants: None,
    additional_info: [],
    address: None,
    channel_type: None,
    extension: [],
    id: None,
  )
}

pub fn virtualservicedetail_to_json(
  virtualservicedetail: Virtualservicedetail,
) -> Json {
  let Virtualservicedetail(
    session_key:,
    max_participants:,
    additional_info:,
    address:,
    channel_type:,
    extension:,
    id:,
  ) = virtualservicedetail
  let fields = []
  let fields = case session_key {
    Some(v) -> [#("sessionKey", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_participants {
    Some(v) -> [#("maxParticipants", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case additional_info {
    [] -> fields
    _ -> [
      #("additionalInfo", json.array(additional_info, json.string)),
      ..fields
    ]
  }
  let fields = case address {
    Some(v) -> [
      #(
        "address"
          <> case v {
          VirtualservicedetailAddressUrl(_) -> "Url"
          VirtualservicedetailAddressString(_) -> "String"
          VirtualservicedetailAddressContactpoint(_) -> "Contactpoint"
          VirtualservicedetailAddressExtendedcontactdetail(_) ->
            "Extendedcontactdetail"
        },
        virtualservicedetail_address_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case channel_type {
    Some(v) -> [#("channelType", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn virtualservicedetail_decoder() -> Decoder(Virtualservicedetail) {
  use session_key <- decode.optional_field(
    "sessionKey",
    None,
    decode.optional(decode.string),
  )
  use max_participants <- decode.optional_field(
    "maxParticipants",
    None,
    decode.optional(decode.int),
  )
  use additional_info <- decode.optional_field(
    "additionalInfo",
    [],
    decode.list(decode.string),
  )
  use address <- decode.then(
    none_if_omitted(virtualservicedetail_address_decoder()),
  )
  use channel_type <- decode.optional_field(
    "channelType",
    None,
    decode.optional(coding_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Virtualservicedetail(
    session_key:,
    max_participants:,
    additional_info:,
    address:,
    channel_type:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MoneyQuantity#resource
pub type Moneyquantity {
  Moneyquantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    comparator: Option(r5valuesets.Quantitycomparator),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn moneyquantity_new() -> Moneyquantity {
  Moneyquantity(
    code: None,
    system: None,
    unit: None,
    comparator: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn moneyquantity_to_json(moneyquantity: Moneyquantity) -> Json {
  let Moneyquantity(code:, system:, unit:, comparator:, value:, extension:, id:) =
    moneyquantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.quantitycomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn moneyquantity_decoder() -> Decoder(Moneyquantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.quantitycomparator_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Moneyquantity(
    code:,
    system:,
    unit:,
    comparator:,
    value:,
    extension:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SimpleQuantity#resource
pub type Simplequantity {
  Simplequantity(
    id: Option(String),
    extension: List(Extension),
    value: Option(Float),
    unit: Option(String),
    system: Option(String),
    code: Option(String),
  )
}

pub fn simplequantity_new() -> Simplequantity {
  Simplequantity(
    code: None,
    system: None,
    unit: None,
    value: None,
    extension: [],
    id: None,
  )
}

pub fn simplequantity_to_json(simplequantity: Simplequantity) -> Json {
  let Simplequantity(code:, system:, unit:, value:, extension:, id:) =
    simplequantity
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn simplequantity_decoder() -> Decoder(Simplequantity) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.float),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(Simplequantity(code:, system:, unit:, value:, extension:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type Account {
  Account(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Accountstatus,
    billing_status: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    name: Option(String),
    subject: List(Reference),
    service_period: Option(Period),
    coverage: List(AccountCoverage),
    owner: Option(Reference),
    description: Option(String),
    guarantor: List(AccountGuarantor),
    diagnosis: List(AccountDiagnosis),
    procedure: List(AccountProcedure),
    related_account: List(AccountRelatedaccount),
    currency: Option(Codeableconcept),
    balance: List(AccountBalance),
    calculated_at: Option(String),
  )
}

pub fn account_new(status status: r5valuesets.Accountstatus) -> Account {
  Account(
    calculated_at: None,
    balance: [],
    currency: None,
    related_account: [],
    procedure: [],
    diagnosis: [],
    guarantor: [],
    description: None,
    owner: None,
    coverage: [],
    service_period: None,
    subject: [],
    name: None,
    type_: None,
    billing_status: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountCoverage {
  AccountCoverage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    coverage: Reference,
    priority: Option(Int),
  )
}

pub fn account_coverage_new(coverage coverage: Reference) -> AccountCoverage {
  AccountCoverage(
    priority: None,
    coverage:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountGuarantor {
  AccountGuarantor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    party: Reference,
    on_hold: Option(Bool),
    period: Option(Period),
  )
}

pub fn account_guarantor_new(party party: Reference) -> AccountGuarantor {
  AccountGuarantor(
    period: None,
    on_hold: None,
    party:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountDiagnosis {
  AccountDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    condition: Codeablereference,
    date_of_diagnosis: Option(String),
    type_: List(Codeableconcept),
    on_admission: Option(Bool),
    package_code: List(Codeableconcept),
  )
}

pub fn account_diagnosis_new(
  condition condition: Codeablereference,
) -> AccountDiagnosis {
  AccountDiagnosis(
    package_code: [],
    on_admission: None,
    type_: [],
    date_of_diagnosis: None,
    condition:,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountProcedure {
  AccountProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    code: Codeablereference,
    date_of_service: Option(String),
    type_: List(Codeableconcept),
    package_code: List(Codeableconcept),
    device: List(Reference),
  )
}

pub fn account_procedure_new(code code: Codeablereference) -> AccountProcedure {
  AccountProcedure(
    device: [],
    package_code: [],
    type_: [],
    date_of_service: None,
    code:,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountRelatedaccount {
  AccountRelatedaccount(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship: Option(Codeableconcept),
    account: Reference,
  )
}

pub fn account_relatedaccount_new(
  account account: Reference,
) -> AccountRelatedaccount {
  AccountRelatedaccount(
    account:,
    relationship: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Account#resource
pub type AccountBalance {
  AccountBalance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    aggregate: Option(Codeableconcept),
    term: Option(Codeableconcept),
    estimate: Option(Bool),
    amount: Money,
  )
}

pub fn account_balance_new(amount amount: Money) -> AccountBalance {
  AccountBalance(
    amount:,
    estimate: None,
    term: None,
    aggregate: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn account_balance_to_json(account_balance: AccountBalance) -> Json {
  let AccountBalance(
    amount:,
    estimate:,
    term:,
    aggregate:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_balance
  let fields = [
    #("amount", money_to_json(amount)),
  ]
  let fields = case estimate {
    Some(v) -> [#("estimate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case aggregate {
    Some(v) -> [#("aggregate", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_balance_decoder() -> Decoder(AccountBalance) {
  use amount <- decode.field("amount", money_decoder())
  use estimate <- decode.optional_field(
    "estimate",
    None,
    decode.optional(decode.bool),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use aggregate <- decode.optional_field(
    "aggregate",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountBalance(
    amount:,
    estimate:,
    term:,
    aggregate:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_relatedaccount_to_json(
  account_relatedaccount: AccountRelatedaccount,
) -> Json {
  let AccountRelatedaccount(
    account:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_relatedaccount
  let fields = [
    #("account", reference_to_json(account)),
  ]
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_relatedaccount_decoder() -> Decoder(AccountRelatedaccount) {
  use account <- decode.field("account", reference_decoder())
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountRelatedaccount(
    account:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_procedure_to_json(account_procedure: AccountProcedure) -> Json {
  let AccountProcedure(
    device:,
    package_code:,
    type_:,
    date_of_service:,
    code:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_procedure
  let fields = [
    #("code", codeablereference_to_json(code)),
  ]
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, reference_to_json)), ..fields]
  }
  let fields = case package_code {
    [] -> fields
    _ -> [
      #("packageCode", json.array(package_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case date_of_service {
    Some(v) -> [#("dateOfService", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_procedure_decoder() -> Decoder(AccountProcedure) {
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(reference_decoder()),
  )
  use package_code <- decode.optional_field(
    "packageCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use date_of_service <- decode.optional_field(
    "dateOfService",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", codeablereference_decoder())
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountProcedure(
    device:,
    package_code:,
    type_:,
    date_of_service:,
    code:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_diagnosis_to_json(account_diagnosis: AccountDiagnosis) -> Json {
  let AccountDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    date_of_diagnosis:,
    condition:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_diagnosis
  let fields = [
    #("condition", codeablereference_to_json(condition)),
  ]
  let fields = case package_code {
    [] -> fields
    _ -> [
      #("packageCode", json.array(package_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case on_admission {
    Some(v) -> [#("onAdmission", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case date_of_diagnosis {
    Some(v) -> [#("dateOfDiagnosis", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_diagnosis_decoder() -> Decoder(AccountDiagnosis) {
  use package_code <- decode.optional_field(
    "packageCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use on_admission <- decode.optional_field(
    "onAdmission",
    None,
    decode.optional(decode.bool),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use date_of_diagnosis <- decode.optional_field(
    "dateOfDiagnosis",
    None,
    decode.optional(decode.string),
  )
  use condition <- decode.field("condition", codeablereference_decoder())
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountDiagnosis(
    package_code:,
    on_admission:,
    type_:,
    date_of_diagnosis:,
    condition:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_guarantor_to_json(account_guarantor: AccountGuarantor) -> Json {
  let AccountGuarantor(
    period:,
    on_hold:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_guarantor
  let fields = [
    #("party", reference_to_json(party)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_hold {
    Some(v) -> [#("onHold", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_guarantor_decoder() -> Decoder(AccountGuarantor) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use on_hold <- decode.optional_field(
    "onHold",
    None,
    decode.optional(decode.bool),
  )
  use party <- decode.field("party", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountGuarantor(
    period:,
    on_hold:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_coverage_to_json(account_coverage: AccountCoverage) -> Json {
  let AccountCoverage(
    priority:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ) = account_coverage
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case priority {
    Some(v) -> [#("priority", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn account_coverage_decoder() -> Decoder(AccountCoverage) {
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(decode.int),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AccountCoverage(
    priority:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn account_to_json(account: Account) -> Json {
  let Account(
    calculated_at:,
    balance:,
    currency:,
    related_account:,
    procedure:,
    diagnosis:,
    guarantor:,
    description:,
    owner:,
    coverage:,
    service_period:,
    subject:,
    name:,
    type_:,
    billing_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = account
  let fields = [
    #("status", r5valuesets.accountstatus_to_json(status)),
  ]
  let fields = case calculated_at {
    Some(v) -> [#("calculatedAt", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case balance {
    [] -> fields
    _ -> [#("balance", json.array(balance, account_balance_to_json)), ..fields]
  }
  let fields = case currency {
    Some(v) -> [#("currency", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related_account {
    [] -> fields
    _ -> [
      #(
        "relatedAccount",
        json.array(related_account, account_relatedaccount_to_json),
      ),
      ..fields
    ]
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #("procedure", json.array(procedure, account_procedure_to_json)),
      ..fields
    ]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, account_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case guarantor {
    [] -> fields
    _ -> [
      #("guarantor", json.array(guarantor, account_guarantor_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case coverage {
    [] -> fields
    _ -> [
      #("coverage", json.array(coverage, account_coverage_to_json)),
      ..fields
    ]
  }
  let fields = case service_period {
    Some(v) -> [#("servicePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case billing_status {
    Some(v) -> [#("billingStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Account")), ..fields]
  json.object(fields)
}

pub fn account_decoder() -> Decoder(Account) {
  use calculated_at <- decode.optional_field(
    "calculatedAt",
    None,
    decode.optional(decode.string),
  )
  use balance <- decode.optional_field(
    "balance",
    [],
    decode.list(account_balance_decoder()),
  )
  use currency <- decode.optional_field(
    "currency",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use related_account <- decode.optional_field(
    "relatedAccount",
    [],
    decode.list(account_relatedaccount_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(account_procedure_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(account_diagnosis_decoder()),
  )
  use guarantor <- decode.optional_field(
    "guarantor",
    [],
    decode.list(account_guarantor_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use coverage <- decode.optional_field(
    "coverage",
    [],
    decode.list(account_coverage_decoder()),
  )
  use service_period <- decode.optional_field(
    "servicePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use billing_status <- decode.optional_field(
    "billingStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.accountstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Account",
    decode.failure(account_new(status:), "resourceType"),
  )
  decode.success(Account(
    calculated_at:,
    balance:,
    currency:,
    related_account:,
    procedure:,
    diagnosis:,
    guarantor:,
    description:,
    owner:,
    coverage:,
    service_period:,
    subject:,
    name:,
    type_:,
    billing_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type Activitydefinition {
  Activitydefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ActivitydefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(ActivitydefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    kind: Option(r5valuesets.Requestresourcetypes),
    profile: Option(String),
    code: Option(Codeableconcept),
    intent: Option(r5valuesets.Requestintent),
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    timing: Option(ActivitydefinitionTiming),
    as_needed: Option(ActivitydefinitionAsneeded),
    location: Option(Codeablereference),
    participant: List(ActivitydefinitionParticipant),
    product: Option(ActivitydefinitionProduct),
    quantity: Option(Quantity),
    dosage: List(Dosage),
    body_site: List(Codeableconcept),
    specimen_requirement: List(String),
    observation_requirement: List(String),
    observation_result_requirement: List(String),
    transform: Option(String),
    dynamic_value: List(ActivitydefinitionDynamicvalue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionVersionalgorithm {
  ActivitydefinitionVersionalgorithmString(version_algorithm: String)
  ActivitydefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn activitydefinition_versionalgorithm_to_json(
  elt: ActivitydefinitionVersionalgorithm,
) -> Json {
  case elt {
    ActivitydefinitionVersionalgorithmString(v) -> json.string(v)
    ActivitydefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn activitydefinition_versionalgorithm_decoder() -> Decoder(
  ActivitydefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ActivitydefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ActivitydefinitionVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionSubject {
  ActivitydefinitionSubjectCodeableconcept(subject: Codeableconcept)
  ActivitydefinitionSubjectReference(subject: Reference)
  ActivitydefinitionSubjectCanonical(subject: String)
}

pub fn activitydefinition_subject_to_json(
  elt: ActivitydefinitionSubject,
) -> Json {
  case elt {
    ActivitydefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    ActivitydefinitionSubjectReference(v) -> reference_to_json(v)
    ActivitydefinitionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn activitydefinition_subject_decoder() -> Decoder(
  ActivitydefinitionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ActivitydefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(ActivitydefinitionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(ActivitydefinitionSubjectCanonical),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionTiming {
  ActivitydefinitionTimingTiming(timing: Timing)
  ActivitydefinitionTimingAge(timing: Age)
  ActivitydefinitionTimingRange(timing: Range)
  ActivitydefinitionTimingDuration(timing: Duration)
}

pub fn activitydefinition_timing_to_json(elt: ActivitydefinitionTiming) -> Json {
  case elt {
    ActivitydefinitionTimingTiming(v) -> timing_to_json(v)
    ActivitydefinitionTimingAge(v) -> age_to_json(v)
    ActivitydefinitionTimingRange(v) -> range_to_json(v)
    ActivitydefinitionTimingDuration(v) -> duration_to_json(v)
  }
}

pub fn activitydefinition_timing_decoder() -> Decoder(ActivitydefinitionTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(ActivitydefinitionTimingTiming),
    [
      decode.field("timingAge", age_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingAge),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingRange),
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(ActivitydefinitionTimingDuration),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionAsneeded {
  ActivitydefinitionAsneededBoolean(as_needed: Bool)
  ActivitydefinitionAsneededCodeableconcept(as_needed: Codeableconcept)
}

pub fn activitydefinition_asneeded_to_json(
  elt: ActivitydefinitionAsneeded,
) -> Json {
  case elt {
    ActivitydefinitionAsneededBoolean(v) -> json.bool(v)
    ActivitydefinitionAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn activitydefinition_asneeded_decoder() -> Decoder(
  ActivitydefinitionAsneeded,
) {
  decode.one_of(
    decode.field("asNeededBoolean", decode.bool, decode.success)
      |> decode.map(ActivitydefinitionAsneededBoolean),
    [
      decode.field(
        "asNeededCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ActivitydefinitionAsneededCodeableconcept),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionProduct {
  ActivitydefinitionProductReference(product: Reference)
  ActivitydefinitionProductCodeableconcept(product: Codeableconcept)
}

pub fn activitydefinition_product_to_json(
  elt: ActivitydefinitionProduct,
) -> Json {
  case elt {
    ActivitydefinitionProductReference(v) -> reference_to_json(v)
    ActivitydefinitionProductCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn activitydefinition_product_decoder() -> Decoder(
  ActivitydefinitionProduct,
) {
  decode.one_of(
    decode.field("productReference", reference_decoder(), decode.success)
      |> decode.map(ActivitydefinitionProductReference),
    [
      decode.field(
        "productCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ActivitydefinitionProductCodeableconcept),
    ],
  )
}

pub fn activitydefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Activitydefinition {
  Activitydefinition(
    dynamic_value: [],
    transform: None,
    observation_result_requirement: [],
    observation_requirement: [],
    specimen_requirement: [],
    body_site: [],
    dosage: [],
    quantity: None,
    product: None,
    participant: [],
    location: None,
    as_needed: None,
    timing: None,
    do_not_perform: None,
    priority: None,
    intent: None,
    code: None,
    profile: None,
    kind: None,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionParticipant {
  ActivitydefinitionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Actionparticipanttype),
    type_canonical: Option(String),
    type_reference: Option(Reference),
    role: Option(Codeableconcept),
    function: Option(Codeableconcept),
  )
}

pub fn activitydefinition_participant_new() -> ActivitydefinitionParticipant {
  ActivitydefinitionParticipant(
    function: None,
    role: None,
    type_reference: None,
    type_canonical: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActivityDefinition#resource
pub type ActivitydefinitionDynamicvalue {
  ActivitydefinitionDynamicvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: String,
    expression: Expression,
  )
}

pub fn activitydefinition_dynamicvalue_new(
  expression expression: Expression,
  path path: String,
) -> ActivitydefinitionDynamicvalue {
  ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn activitydefinition_dynamicvalue_to_json(
  activitydefinition_dynamicvalue: ActivitydefinitionDynamicvalue,
) -> Json {
  let ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = activitydefinition_dynamicvalue
  let fields = [
    #("expression", expression_to_json(expression)),
    #("path", json.string(path)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn activitydefinition_dynamicvalue_decoder() -> Decoder(
  ActivitydefinitionDynamicvalue,
) {
  use expression <- decode.field("expression", expression_decoder())
  use path <- decode.field("path", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ActivitydefinitionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn activitydefinition_participant_to_json(
  activitydefinition_participant: ActivitydefinitionParticipant,
) -> Json {
  let ActivitydefinitionParticipant(
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = activitydefinition_participant
  let fields = []
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_reference {
    Some(v) -> [#("typeReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_canonical {
    Some(v) -> [#("typeCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.actionparticipanttype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn activitydefinition_participant_decoder() -> Decoder(
  ActivitydefinitionParticipant,
) {
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    None,
    decode.optional(reference_decoder()),
  )
  use type_canonical <- decode.optional_field(
    "typeCanonical",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.actionparticipanttype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ActivitydefinitionParticipant(
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn activitydefinition_to_json(
  activitydefinition: Activitydefinition,
) -> Json {
  let Activitydefinition(
    dynamic_value:,
    transform:,
    observation_result_requirement:,
    observation_requirement:,
    specimen_requirement:,
    body_site:,
    dosage:,
    quantity:,
    product:,
    participant:,
    location:,
    as_needed:,
    timing:,
    do_not_perform:,
    priority:,
    intent:,
    code:,
    profile:,
    kind:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = activitydefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case dynamic_value {
    [] -> fields
    _ -> [
      #(
        "dynamicValue",
        json.array(dynamic_value, activitydefinition_dynamicvalue_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case observation_result_requirement {
    [] -> fields
    _ -> [
      #(
        "observationResultRequirement",
        json.array(observation_result_requirement, json.string),
      ),
      ..fields
    ]
  }
  let fields = case observation_requirement {
    [] -> fields
    _ -> [
      #(
        "observationRequirement",
        json.array(observation_requirement, json.string),
      ),
      ..fields
    ]
  }
  let fields = case specimen_requirement {
    [] -> fields
    _ -> [
      #("specimenRequirement", json.array(specimen_requirement, json.string)),
      ..fields
    ]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product {
    Some(v) -> [
      #(
        "product"
          <> case v {
          ActivitydefinitionProductReference(_) -> "Reference"
          ActivitydefinitionProductCodeableconcept(_) -> "Codeableconcept"
        },
        activitydefinition_product_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, activitydefinition_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [
      #(
        "asNeeded"
          <> case v {
          ActivitydefinitionAsneededBoolean(_) -> "Boolean"
          ActivitydefinitionAsneededCodeableconcept(_) -> "Codeableconcept"
        },
        activitydefinition_asneeded_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ActivitydefinitionTimingTiming(_) -> "Timing"
          ActivitydefinitionTimingAge(_) -> "Age"
          ActivitydefinitionTimingRange(_) -> "Range"
          ActivitydefinitionTimingDuration(_) -> "Duration"
        },
        activitydefinition_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case intent {
    Some(v) -> [#("intent", r5valuesets.requestintent_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case kind {
    Some(v) -> [
      #("kind", r5valuesets.requestresourcetypes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          ActivitydefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          ActivitydefinitionSubjectReference(_) -> "Reference"
          ActivitydefinitionSubjectCanonical(_) -> "Canonical"
        },
        activitydefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ActivitydefinitionVersionalgorithmString(_) -> "String"
          ActivitydefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        activitydefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Activitydefinition")), ..fields]
  json.object(fields)
}

pub fn activitydefinition_decoder() -> Decoder(Activitydefinition) {
  use dynamic_value <- decode.optional_field(
    "dynamicValue",
    [],
    decode.list(activitydefinition_dynamicvalue_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(decode.string),
  )
  use observation_result_requirement <- decode.optional_field(
    "observationResultRequirement",
    [],
    decode.list(decode.string),
  )
  use observation_requirement <- decode.optional_field(
    "observationRequirement",
    [],
    decode.list(decode.string),
  )
  use specimen_requirement <- decode.optional_field(
    "specimenRequirement",
    [],
    decode.list(decode.string),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use product <- decode.then(
    none_if_omitted(activitydefinition_product_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(activitydefinition_participant_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use as_needed <- decode.then(
    none_if_omitted(activitydefinition_asneeded_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(activitydefinition_timing_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.optional_field(
    "intent",
    None,
    decode.optional(r5valuesets.requestintent_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use kind <- decode.optional_field(
    "kind",
    None,
    decode.optional(r5valuesets.requestresourcetypes_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(
    none_if_omitted(activitydefinition_subject_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(activitydefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Activitydefinition",
    decode.failure(activitydefinition_new(status:), "resourceType"),
  )
  decode.success(Activitydefinition(
    dynamic_value:,
    transform:,
    observation_result_requirement:,
    observation_requirement:,
    specimen_requirement:,
    body_site:,
    dosage:,
    quantity:,
    product:,
    participant:,
    location:,
    as_needed:,
    timing:,
    do_not_perform:,
    priority:,
    intent:,
    code:,
    profile:,
    kind:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ActorDefinition#resource
pub type Actordefinition {
  Actordefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ActordefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    type_: r5valuesets.Examplescenarioactortype,
    documentation: Option(String),
    reference: List(String),
    capabilities: Option(String),
    derived_from: List(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ActorDefinition#resource
pub type ActordefinitionVersionalgorithm {
  ActordefinitionVersionalgorithmString(version_algorithm: String)
  ActordefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn actordefinition_versionalgorithm_to_json(
  elt: ActordefinitionVersionalgorithm,
) -> Json {
  case elt {
    ActordefinitionVersionalgorithmString(v) -> json.string(v)
    ActordefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn actordefinition_versionalgorithm_decoder() -> Decoder(
  ActordefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ActordefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ActordefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn actordefinition_new(
  type_ type_: r5valuesets.Examplescenarioactortype,
  status status: r5valuesets.Publicationstatus,
) -> Actordefinition {
  Actordefinition(
    derived_from: [],
    capabilities: None,
    reference: [],
    documentation: None,
    type_:,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn actordefinition_to_json(actordefinition: Actordefinition) -> Json {
  let Actordefinition(
    derived_from:,
    capabilities:,
    reference:,
    documentation:,
    type_:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = actordefinition
  let fields = [
    #("type", r5valuesets.examplescenarioactortype_to_json(type_)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case capabilities {
    Some(v) -> [#("capabilities", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, json.string)), ..fields]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ActordefinitionVersionalgorithmString(_) -> "String"
          ActordefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        actordefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Actordefinition")), ..fields]
  json.object(fields)
}

pub fn actordefinition_decoder() -> Decoder(Actordefinition) {
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use capabilities <- decode.optional_field(
    "capabilities",
    None,
    decode.optional(decode.string),
  )
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(decode.string),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.examplescenarioactortype_decoder(),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(actordefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Actordefinition",
    decode.failure(actordefinition_new(type_:, status:), "resourceType"),
  )
  decode.success(Actordefinition(
    derived_from:,
    capabilities:,
    reference:,
    documentation:,
    type_:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type Administrableproductdefinition {
  Administrableproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Publicationstatus,
    form_of: List(Reference),
    administrable_dose_form: Option(Codeableconcept),
    unit_of_presentation: Option(Codeableconcept),
    produced_from: List(Reference),
    ingredient: List(Codeableconcept),
    device: Option(Reference),
    description: Option(String),
    property: List(AdministrableproductdefinitionProperty),
    route_of_administration: List(
      AdministrableproductdefinitionRouteofadministration,
    ),
  )
}

pub fn administrableproductdefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Administrableproductdefinition {
  Administrableproductdefinition(
    route_of_administration: [],
    property: [],
    description: None,
    device: None,
    ingredient: [],
    produced_from: [],
    unit_of_presentation: None,
    administrable_dose_form: None,
    form_of: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionProperty {
  AdministrableproductdefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(AdministrableproductdefinitionPropertyValue),
    status: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionPropertyValue {
  AdministrableproductdefinitionPropertyValueCodeableconcept(
    value: Codeableconcept,
  )
  AdministrableproductdefinitionPropertyValueQuantity(value: Quantity)
  AdministrableproductdefinitionPropertyValueDate(value: String)
  AdministrableproductdefinitionPropertyValueBoolean(value: Bool)
  AdministrableproductdefinitionPropertyValueMarkdown(value: String)
  AdministrableproductdefinitionPropertyValueAttachment(value: Attachment)
  AdministrableproductdefinitionPropertyValueReference(value: Reference)
}

pub fn administrableproductdefinition_property_value_to_json(
  elt: AdministrableproductdefinitionPropertyValue,
) -> Json {
  case elt {
    AdministrableproductdefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    AdministrableproductdefinitionPropertyValueQuantity(v) ->
      quantity_to_json(v)
    AdministrableproductdefinitionPropertyValueDate(v) -> json.string(v)
    AdministrableproductdefinitionPropertyValueBoolean(v) -> json.bool(v)
    AdministrableproductdefinitionPropertyValueMarkdown(v) -> json.string(v)
    AdministrableproductdefinitionPropertyValueAttachment(v) ->
      attachment_to_json(v)
    AdministrableproductdefinitionPropertyValueReference(v) ->
      reference_to_json(v)
  }
}

pub fn administrableproductdefinition_property_value_decoder() -> Decoder(
  AdministrableproductdefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(AdministrableproductdefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueBoolean),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueMarkdown),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(AdministrableproductdefinitionPropertyValueReference),
    ],
  )
}

pub fn administrableproductdefinition_property_new(
  type_ type_: Codeableconcept,
) -> AdministrableproductdefinitionProperty {
  AdministrableproductdefinitionProperty(
    status: None,
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministration {
  AdministrableproductdefinitionRouteofadministration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    first_dose: Option(Quantity),
    max_single_dose: Option(Quantity),
    max_dose_per_day: Option(Quantity),
    max_dose_per_treatment_period: Option(Ratio),
    max_treatment_period: Option(Duration),
    target_species: List(
      AdministrableproductdefinitionRouteofadministrationTargetspecies,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_new(
  code code: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministration {
  AdministrableproductdefinitionRouteofadministration(
    target_species: [],
    max_treatment_period: None,
    max_dose_per_treatment_period: None,
    max_dose_per_day: None,
    max_single_dose: None,
    first_dose: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministrationTargetspecies {
  AdministrableproductdefinitionRouteofadministrationTargetspecies(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    withdrawal_period: List(
      AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_new(
  code code: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministrationTargetspecies {
  AdministrableproductdefinitionRouteofadministrationTargetspecies(
    withdrawal_period: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdministrableProductDefinition#resource
pub type AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod {
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    tissue: Codeableconcept,
    value: Quantity,
    supporting_information: Option(String),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_new(
  value value: Quantity,
  tissue tissue: Codeableconcept,
) -> AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod {
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    supporting_information: None,
    value:,
    tissue:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_to_json(
  administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod: AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
) -> Json {
  let AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
    supporting_information:,
    value:,
    tissue:,
    modifier_extension:,
    extension:,
    id:,
  ) =
    administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod
  let fields = [
    #("value", quantity_to_json(value)),
    #("tissue", codeableconcept_to_json(tissue)),
  ]
  let fields = case supporting_information {
    Some(v) -> [#("supportingInformation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod,
) {
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.field("value", quantity_decoder())
  use tissue <- decode.field("tissue", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    AdministrableproductdefinitionRouteofadministrationTargetspeciesWithdrawalperiod(
      supporting_information:,
      value:,
      tissue:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_to_json(
  administrableproductdefinition_routeofadministration_targetspecies: AdministrableproductdefinitionRouteofadministrationTargetspecies,
) -> Json {
  let AdministrableproductdefinitionRouteofadministrationTargetspecies(
    withdrawal_period:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_routeofadministration_targetspecies
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case withdrawal_period {
    [] -> fields
    _ -> [
      #(
        "withdrawalPeriod",
        json.array(
          withdrawal_period,
          administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_targetspecies_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministrationTargetspecies,
) {
  use withdrawal_period <- decode.optional_field(
    "withdrawalPeriod",
    [],
    decode.list(
      administrableproductdefinition_routeofadministration_targetspecies_withdrawalperiod_decoder(),
    ),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    AdministrableproductdefinitionRouteofadministrationTargetspecies(
      withdrawal_period:,
      code:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn administrableproductdefinition_routeofadministration_to_json(
  administrableproductdefinition_routeofadministration: AdministrableproductdefinitionRouteofadministration,
) -> Json {
  let AdministrableproductdefinitionRouteofadministration(
    target_species:,
    max_treatment_period:,
    max_dose_per_treatment_period:,
    max_dose_per_day:,
    max_single_dose:,
    first_dose:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_routeofadministration
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case target_species {
    [] -> fields
    _ -> [
      #(
        "targetSpecies",
        json.array(
          target_species,
          administrableproductdefinition_routeofadministration_targetspecies_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case max_treatment_period {
    Some(v) -> [#("maxTreatmentPeriod", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_treatment_period {
    Some(v) -> [#("maxDosePerTreatmentPeriod", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_dose_per_day {
    Some(v) -> [#("maxDosePerDay", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case max_single_dose {
    Some(v) -> [#("maxSingleDose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case first_dose {
    Some(v) -> [#("firstDose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_routeofadministration_decoder() -> Decoder(
  AdministrableproductdefinitionRouteofadministration,
) {
  use target_species <- decode.optional_field(
    "targetSpecies",
    [],
    decode.list(
      administrableproductdefinition_routeofadministration_targetspecies_decoder(),
    ),
  )
  use max_treatment_period <- decode.optional_field(
    "maxTreatmentPeriod",
    None,
    decode.optional(duration_decoder()),
  )
  use max_dose_per_treatment_period <- decode.optional_field(
    "maxDosePerTreatmentPeriod",
    None,
    decode.optional(ratio_decoder()),
  )
  use max_dose_per_day <- decode.optional_field(
    "maxDosePerDay",
    None,
    decode.optional(quantity_decoder()),
  )
  use max_single_dose <- decode.optional_field(
    "maxSingleDose",
    None,
    decode.optional(quantity_decoder()),
  )
  use first_dose <- decode.optional_field(
    "firstDose",
    None,
    decode.optional(quantity_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdministrableproductdefinitionRouteofadministration(
    target_species:,
    max_treatment_period:,
    max_dose_per_treatment_period:,
    max_dose_per_day:,
    max_single_dose:,
    first_dose:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn administrableproductdefinition_property_to_json(
  administrableproductdefinition_property: AdministrableproductdefinitionProperty,
) -> Json {
  let AdministrableproductdefinitionProperty(
    status:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = administrableproductdefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          AdministrableproductdefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          AdministrableproductdefinitionPropertyValueQuantity(_) -> "Quantity"
          AdministrableproductdefinitionPropertyValueDate(_) -> "Date"
          AdministrableproductdefinitionPropertyValueBoolean(_) -> "Boolean"
          AdministrableproductdefinitionPropertyValueMarkdown(_) -> "Markdown"
          AdministrableproductdefinitionPropertyValueAttachment(_) ->
            "Attachment"
          AdministrableproductdefinitionPropertyValueReference(_) -> "Reference"
        },
        administrableproductdefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn administrableproductdefinition_property_decoder() -> Decoder(
  AdministrableproductdefinitionProperty,
) {
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(administrableproductdefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdministrableproductdefinitionProperty(
    status:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn administrableproductdefinition_to_json(
  administrableproductdefinition: Administrableproductdefinition,
) -> Json {
  let Administrableproductdefinition(
    route_of_administration:,
    property:,
    description:,
    device:,
    ingredient:,
    produced_from:,
    unit_of_presentation:,
    administrable_dose_form:,
    form_of:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = administrableproductdefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case route_of_administration {
    [] -> fields
    _ -> [
      #(
        "routeOfAdministration",
        json.array(
          route_of_administration,
          administrableproductdefinition_routeofadministration_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, administrableproductdefinition_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case produced_from {
    [] -> fields
    _ -> [
      #("producedFrom", json.array(produced_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case unit_of_presentation {
    Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case administrable_dose_form {
    Some(v) -> [
      #("administrableDoseForm", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case form_of {
    [] -> fields
    _ -> [#("formOf", json.array(form_of, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Administrableproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn administrableproductdefinition_decoder() -> Decoder(
  Administrableproductdefinition,
) {
  use route_of_administration <- decode.optional_field(
    "routeOfAdministration",
    [],
    decode.list(administrableproductdefinition_routeofadministration_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(administrableproductdefinition_property_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use produced_from <- decode.optional_field(
    "producedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use unit_of_presentation <- decode.optional_field(
    "unitOfPresentation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use administrable_dose_form <- decode.optional_field(
    "administrableDoseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use form_of <- decode.optional_field(
    "formOf",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Administrableproductdefinition",
    decode.failure(administrableproductdefinition_new(status:), "resourceType"),
  )
  decode.success(Administrableproductdefinition(
    route_of_administration:,
    property:,
    description:,
    device:,
    ingredient:,
    produced_from:,
    unit_of_presentation:,
    administrable_dose_form:,
    form_of:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type Adverseevent {
  Adverseevent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Adverseeventstatus,
    actuality: r5valuesets.Adverseeventactuality,
    category: List(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(AdverseeventOccurrence),
    detected: Option(String),
    recorded_date: Option(String),
    resulting_effect: List(Reference),
    location: Option(Reference),
    seriousness: Option(Codeableconcept),
    outcome: List(Codeableconcept),
    recorder: Option(Reference),
    participant: List(AdverseeventParticipant),
    study: List(Reference),
    expected_in_research_study: Option(Bool),
    suspect_entity: List(AdverseeventSuspectentity),
    contributing_factor: List(AdverseeventContributingfactor),
    preventive_action: List(AdverseeventPreventiveaction),
    mitigating_action: List(AdverseeventMitigatingaction),
    supporting_info: List(AdverseeventSupportinginfo),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventOccurrence {
  AdverseeventOccurrenceDatetime(occurrence: String)
  AdverseeventOccurrencePeriod(occurrence: Period)
  AdverseeventOccurrenceTiming(occurrence: Timing)
}

pub fn adverseevent_occurrence_to_json(elt: AdverseeventOccurrence) -> Json {
  case elt {
    AdverseeventOccurrenceDatetime(v) -> json.string(v)
    AdverseeventOccurrencePeriod(v) -> period_to_json(v)
    AdverseeventOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn adverseevent_occurrence_decoder() -> Decoder(AdverseeventOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(AdverseeventOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(AdverseeventOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(AdverseeventOccurrenceTiming),
    ],
  )
}

pub fn adverseevent_new(
  subject subject: Reference,
  actuality actuality: r5valuesets.Adverseeventactuality,
  status status: r5valuesets.Adverseeventstatus,
) -> Adverseevent {
  Adverseevent(
    note: [],
    supporting_info: [],
    mitigating_action: [],
    preventive_action: [],
    contributing_factor: [],
    suspect_entity: [],
    expected_in_research_study: None,
    study: [],
    participant: [],
    recorder: None,
    outcome: [],
    seriousness: None,
    location: None,
    resulting_effect: [],
    recorded_date: None,
    detected: None,
    occurrence: None,
    encounter: None,
    subject:,
    code: None,
    category: [],
    actuality:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventParticipant {
  AdverseeventParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn adverseevent_participant_new(
  actor actor: Reference,
) -> AdverseeventParticipant {
  AdverseeventParticipant(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentity {
  AdverseeventSuspectentity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    instance: AdverseeventSuspectentityInstance,
    causality: Option(AdverseeventSuspectentityCausality),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentityInstance {
  AdverseeventSuspectentityInstanceCodeableconcept(instance: Codeableconcept)
  AdverseeventSuspectentityInstanceReference(instance: Reference)
}

pub fn adverseevent_suspectentity_instance_to_json(
  elt: AdverseeventSuspectentityInstance,
) -> Json {
  case elt {
    AdverseeventSuspectentityInstanceCodeableconcept(v) ->
      codeableconcept_to_json(v)
    AdverseeventSuspectentityInstanceReference(v) -> reference_to_json(v)
  }
}

pub fn adverseevent_suspectentity_instance_decoder() -> Decoder(
  AdverseeventSuspectentityInstance,
) {
  decode.one_of(
    decode.field(
      "instanceCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(AdverseeventSuspectentityInstanceCodeableconcept),
    [
      decode.field("instanceReference", reference_decoder(), decode.success)
      |> decode.map(AdverseeventSuspectentityInstanceReference),
    ],
  )
}

pub fn adverseevent_suspectentity_new(
  instance instance: AdverseeventSuspectentityInstance,
) -> AdverseeventSuspectentity {
  AdverseeventSuspectentity(
    causality: None,
    instance:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSuspectentityCausality {
  AdverseeventSuspectentityCausality(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    assessment_method: Option(Codeableconcept),
    entity_relatedness: Option(Codeableconcept),
    author: Option(Reference),
  )
}

pub fn adverseevent_suspectentity_causality_new() -> AdverseeventSuspectentityCausality {
  AdverseeventSuspectentityCausality(
    author: None,
    entity_relatedness: None,
    assessment_method: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventContributingfactor {
  AdverseeventContributingfactor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: AdverseeventContributingfactorItem,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventContributingfactorItem {
  AdverseeventContributingfactorItemReference(item: Reference)
  AdverseeventContributingfactorItemCodeableconcept(item: Codeableconcept)
}

pub fn adverseevent_contributingfactor_item_to_json(
  elt: AdverseeventContributingfactorItem,
) -> Json {
  case elt {
    AdverseeventContributingfactorItemReference(v) -> reference_to_json(v)
    AdverseeventContributingfactorItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn adverseevent_contributingfactor_item_decoder() -> Decoder(
  AdverseeventContributingfactorItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(AdverseeventContributingfactorItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(AdverseeventContributingfactorItemCodeableconcept),
    ],
  )
}

pub fn adverseevent_contributingfactor_new(
  item item: AdverseeventContributingfactorItem,
) -> AdverseeventContributingfactor {
  AdverseeventContributingfactor(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventPreventiveaction {
  AdverseeventPreventiveaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: AdverseeventPreventiveactionItem,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventPreventiveactionItem {
  AdverseeventPreventiveactionItemReference(item: Reference)
  AdverseeventPreventiveactionItemCodeableconcept(item: Codeableconcept)
}

pub fn adverseevent_preventiveaction_item_to_json(
  elt: AdverseeventPreventiveactionItem,
) -> Json {
  case elt {
    AdverseeventPreventiveactionItemReference(v) -> reference_to_json(v)
    AdverseeventPreventiveactionItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn adverseevent_preventiveaction_item_decoder() -> Decoder(
  AdverseeventPreventiveactionItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(AdverseeventPreventiveactionItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(AdverseeventPreventiveactionItemCodeableconcept),
    ],
  )
}

pub fn adverseevent_preventiveaction_new(
  item item: AdverseeventPreventiveactionItem,
) -> AdverseeventPreventiveaction {
  AdverseeventPreventiveaction(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventMitigatingaction {
  AdverseeventMitigatingaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: AdverseeventMitigatingactionItem,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventMitigatingactionItem {
  AdverseeventMitigatingactionItemReference(item: Reference)
  AdverseeventMitigatingactionItemCodeableconcept(item: Codeableconcept)
}

pub fn adverseevent_mitigatingaction_item_to_json(
  elt: AdverseeventMitigatingactionItem,
) -> Json {
  case elt {
    AdverseeventMitigatingactionItemReference(v) -> reference_to_json(v)
    AdverseeventMitigatingactionItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn adverseevent_mitigatingaction_item_decoder() -> Decoder(
  AdverseeventMitigatingactionItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(AdverseeventMitigatingactionItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(AdverseeventMitigatingactionItemCodeableconcept),
    ],
  )
}

pub fn adverseevent_mitigatingaction_new(
  item item: AdverseeventMitigatingactionItem,
) -> AdverseeventMitigatingaction {
  AdverseeventMitigatingaction(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSupportinginfo {
  AdverseeventSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: AdverseeventSupportinginfoItem,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AdverseEvent#resource
pub type AdverseeventSupportinginfoItem {
  AdverseeventSupportinginfoItemReference(item: Reference)
  AdverseeventSupportinginfoItemCodeableconcept(item: Codeableconcept)
}

pub fn adverseevent_supportinginfo_item_to_json(
  elt: AdverseeventSupportinginfoItem,
) -> Json {
  case elt {
    AdverseeventSupportinginfoItemReference(v) -> reference_to_json(v)
    AdverseeventSupportinginfoItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn adverseevent_supportinginfo_item_decoder() -> Decoder(
  AdverseeventSupportinginfoItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(AdverseeventSupportinginfoItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(AdverseeventSupportinginfoItemCodeableconcept),
    ],
  )
}

pub fn adverseevent_supportinginfo_new(
  item item: AdverseeventSupportinginfoItem,
) -> AdverseeventSupportinginfo {
  AdverseeventSupportinginfo(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn adverseevent_supportinginfo_to_json(
  adverseevent_supportinginfo: AdverseeventSupportinginfo,
) -> Json {
  let AdverseeventSupportinginfo(item:, modifier_extension:, extension:, id:) =
    adverseevent_supportinginfo
  let fields = [
    #("item", adverseevent_supportinginfo_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_supportinginfo_decoder() -> Decoder(
  AdverseeventSupportinginfo,
) {
  use item <- decode.then(adverseevent_supportinginfo_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventSupportinginfo(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_mitigatingaction_to_json(
  adverseevent_mitigatingaction: AdverseeventMitigatingaction,
) -> Json {
  let AdverseeventMitigatingaction(item:, modifier_extension:, extension:, id:) =
    adverseevent_mitigatingaction
  let fields = [
    #("item", adverseevent_mitigatingaction_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_mitigatingaction_decoder() -> Decoder(
  AdverseeventMitigatingaction,
) {
  use item <- decode.then(adverseevent_mitigatingaction_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventMitigatingaction(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_preventiveaction_to_json(
  adverseevent_preventiveaction: AdverseeventPreventiveaction,
) -> Json {
  let AdverseeventPreventiveaction(item:, modifier_extension:, extension:, id:) =
    adverseevent_preventiveaction
  let fields = [
    #("item", adverseevent_preventiveaction_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_preventiveaction_decoder() -> Decoder(
  AdverseeventPreventiveaction,
) {
  use item <- decode.then(adverseevent_preventiveaction_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventPreventiveaction(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_contributingfactor_to_json(
  adverseevent_contributingfactor: AdverseeventContributingfactor,
) -> Json {
  let AdverseeventContributingfactor(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_contributingfactor
  let fields = [
    #("item", adverseevent_contributingfactor_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_contributingfactor_decoder() -> Decoder(
  AdverseeventContributingfactor,
) {
  use item <- decode.then(adverseevent_contributingfactor_item_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventContributingfactor(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_suspectentity_causality_to_json(
  adverseevent_suspectentity_causality: AdverseeventSuspectentityCausality,
) -> Json {
  let AdverseeventSuspectentityCausality(
    author:,
    entity_relatedness:,
    assessment_method:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_suspectentity_causality
  let fields = []
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entity_relatedness {
    Some(v) -> [#("entityRelatedness", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case assessment_method {
    Some(v) -> [#("assessmentMethod", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_suspectentity_causality_decoder() -> Decoder(
  AdverseeventSuspectentityCausality,
) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use entity_relatedness <- decode.optional_field(
    "entityRelatedness",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use assessment_method <- decode.optional_field(
    "assessmentMethod",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventSuspectentityCausality(
    author:,
    entity_relatedness:,
    assessment_method:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_suspectentity_to_json(
  adverseevent_suspectentity: AdverseeventSuspectentity,
) -> Json {
  let AdverseeventSuspectentity(
    causality:,
    instance:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_suspectentity
  let fields = [
    #("instance", adverseevent_suspectentity_instance_to_json(instance)),
  ]
  let fields = case causality {
    Some(v) -> [
      #("causality", adverseevent_suspectentity_causality_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_suspectentity_decoder() -> Decoder(
  AdverseeventSuspectentity,
) {
  use causality <- decode.optional_field(
    "causality",
    None,
    decode.optional(adverseevent_suspectentity_causality_decoder()),
  )
  use instance <- decode.then(adverseevent_suspectentity_instance_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventSuspectentity(
    causality:,
    instance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_participant_to_json(
  adverseevent_participant: AdverseeventParticipant,
) -> Json {
  let AdverseeventParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = adverseevent_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn adverseevent_participant_decoder() -> Decoder(AdverseeventParticipant) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AdverseeventParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn adverseevent_to_json(adverseevent: Adverseevent) -> Json {
  let Adverseevent(
    note:,
    supporting_info:,
    mitigating_action:,
    preventive_action:,
    contributing_factor:,
    suspect_entity:,
    expected_in_research_study:,
    study:,
    participant:,
    recorder:,
    outcome:,
    seriousness:,
    location:,
    resulting_effect:,
    recorded_date:,
    detected:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    category:,
    actuality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = adverseevent
  let fields = [
    #("subject", reference_to_json(subject)),
    #("actuality", r5valuesets.adverseeventactuality_to_json(actuality)),
    #("status", r5valuesets.adverseeventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, adverseevent_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case mitigating_action {
    [] -> fields
    _ -> [
      #(
        "mitigatingAction",
        json.array(mitigating_action, adverseevent_mitigatingaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case preventive_action {
    [] -> fields
    _ -> [
      #(
        "preventiveAction",
        json.array(preventive_action, adverseevent_preventiveaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contributing_factor {
    [] -> fields
    _ -> [
      #(
        "contributingFactor",
        json.array(contributing_factor, adverseevent_contributingfactor_to_json),
      ),
      ..fields
    ]
  }
  let fields = case suspect_entity {
    [] -> fields
    _ -> [
      #(
        "suspectEntity",
        json.array(suspect_entity, adverseevent_suspectentity_to_json),
      ),
      ..fields
    ]
  }
  let fields = case expected_in_research_study {
    Some(v) -> [#("expectedInResearchStudy", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case study {
    [] -> fields
    _ -> [#("study", json.array(study, reference_to_json)), ..fields]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, adverseevent_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    [] -> fields
    _ -> [#("outcome", json.array(outcome, codeableconcept_to_json)), ..fields]
  }
  let fields = case seriousness {
    Some(v) -> [#("seriousness", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resulting_effect {
    [] -> fields
    _ -> [
      #("resultingEffect", json.array(resulting_effect, reference_to_json)),
      ..fields
    ]
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case detected {
    Some(v) -> [#("detected", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          AdverseeventOccurrenceDatetime(_) -> "Datetime"
          AdverseeventOccurrencePeriod(_) -> "Period"
          AdverseeventOccurrenceTiming(_) -> "Timing"
        },
        adverseevent_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Adverseevent")), ..fields]
  json.object(fields)
}

pub fn adverseevent_decoder() -> Decoder(Adverseevent) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(adverseevent_supportinginfo_decoder()),
  )
  use mitigating_action <- decode.optional_field(
    "mitigatingAction",
    [],
    decode.list(adverseevent_mitigatingaction_decoder()),
  )
  use preventive_action <- decode.optional_field(
    "preventiveAction",
    [],
    decode.list(adverseevent_preventiveaction_decoder()),
  )
  use contributing_factor <- decode.optional_field(
    "contributingFactor",
    [],
    decode.list(adverseevent_contributingfactor_decoder()),
  )
  use suspect_entity <- decode.optional_field(
    "suspectEntity",
    [],
    decode.list(adverseevent_suspectentity_decoder()),
  )
  use expected_in_research_study <- decode.optional_field(
    "expectedInResearchStudy",
    None,
    decode.optional(decode.bool),
  )
  use study <- decode.optional_field(
    "study",
    [],
    decode.list(reference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(adverseevent_participant_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use seriousness <- decode.optional_field(
    "seriousness",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use resulting_effect <- decode.optional_field(
    "resultingEffect",
    [],
    decode.list(reference_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use detected <- decode.optional_field(
    "detected",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(adverseevent_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use actuality <- decode.field(
    "actuality",
    r5valuesets.adverseeventactuality_decoder(),
  )
  use status <- decode.field("status", r5valuesets.adverseeventstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Adverseevent",
    decode.failure(
      adverseevent_new(subject:, actuality:, status:),
      "resourceType",
    ),
  )
  decode.success(Adverseevent(
    note:,
    supporting_info:,
    mitigating_action:,
    preventive_action:,
    contributing_factor:,
    suspect_entity:,
    expected_in_research_study:,
    study:,
    participant:,
    recorder:,
    outcome:,
    seriousness:,
    location:,
    resulting_effect:,
    recorded_date:,
    detected:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    category:,
    actuality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/AllergyIntolerance#resource
pub type Allergyintolerance {
  Allergyintolerance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    clinical_status: Option(Codeableconcept),
    verification_status: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    category: List(r5valuesets.Allergyintolerancecategory),
    criticality: Option(r5valuesets.Allergyintolerancecriticality),
    code: Option(Codeableconcept),
    patient: Reference,
    encounter: Option(Reference),
    onset: Option(AllergyintoleranceOnset),
    recorded_date: Option(String),
    participant: List(AllergyintoleranceParticipant),
    last_occurrence: Option(String),
    note: List(Annotation),
    reaction: List(AllergyintoleranceReaction),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceOnset {
  AllergyintoleranceOnsetDatetime(onset: String)
  AllergyintoleranceOnsetAge(onset: Age)
  AllergyintoleranceOnsetPeriod(onset: Period)
  AllergyintoleranceOnsetRange(onset: Range)
  AllergyintoleranceOnsetString(onset: String)
}

pub fn allergyintolerance_onset_to_json(elt: AllergyintoleranceOnset) -> Json {
  case elt {
    AllergyintoleranceOnsetDatetime(v) -> json.string(v)
    AllergyintoleranceOnsetAge(v) -> age_to_json(v)
    AllergyintoleranceOnsetPeriod(v) -> period_to_json(v)
    AllergyintoleranceOnsetRange(v) -> range_to_json(v)
    AllergyintoleranceOnsetString(v) -> json.string(v)
  }
}

pub fn allergyintolerance_onset_decoder() -> Decoder(AllergyintoleranceOnset) {
  decode.one_of(
    decode.field("onsetDateTime", decode.string, decode.success)
      |> decode.map(AllergyintoleranceOnsetDatetime),
    [
      decode.field("onsetAge", age_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetAge),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetPeriod),
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(AllergyintoleranceOnsetRange),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(AllergyintoleranceOnsetString),
    ],
  )
}

pub fn allergyintolerance_new(patient patient: Reference) -> Allergyintolerance {
  Allergyintolerance(
    reaction: [],
    note: [],
    last_occurrence: None,
    participant: [],
    recorded_date: None,
    onset: None,
    encounter: None,
    patient:,
    code: None,
    criticality: None,
    category: [],
    type_: None,
    verification_status: None,
    clinical_status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceParticipant {
  AllergyintoleranceParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn allergyintolerance_participant_new(
  actor actor: Reference,
) -> AllergyintoleranceParticipant {
  AllergyintoleranceParticipant(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AllergyIntolerance#resource
pub type AllergyintoleranceReaction {
  AllergyintoleranceReaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Option(Codeableconcept),
    manifestation: List(Codeablereference),
    description: Option(String),
    onset: Option(String),
    severity: Option(r5valuesets.Reactioneventseverity),
    exposure_route: Option(Codeableconcept),
    note: List(Annotation),
  )
}

pub fn allergyintolerance_reaction_new() -> AllergyintoleranceReaction {
  AllergyintoleranceReaction(
    note: [],
    exposure_route: None,
    severity: None,
    onset: None,
    description: None,
    manifestation: [],
    substance: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn allergyintolerance_reaction_to_json(
  allergyintolerance_reaction: AllergyintoleranceReaction,
) -> Json {
  let AllergyintoleranceReaction(
    note:,
    exposure_route:,
    severity:,
    onset:,
    description:,
    manifestation:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = allergyintolerance_reaction
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case exposure_route {
    Some(v) -> [#("exposureRoute", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [
      #("severity", r5valuesets.reactioneventseverity_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [#("onset", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manifestation {
    [] -> fields
    _ -> [
      #("manifestation", json.array(manifestation, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case substance {
    Some(v) -> [#("substance", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn allergyintolerance_reaction_decoder() -> Decoder(
  AllergyintoleranceReaction,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use exposure_route <- decode.optional_field(
    "exposureRoute",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(r5valuesets.reactioneventseverity_decoder()),
  )
  use onset <- decode.optional_field(
    "onset",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use manifestation <- decode.optional_field(
    "manifestation",
    [],
    decode.list(codeablereference_decoder()),
  )
  use substance <- decode.optional_field(
    "substance",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AllergyintoleranceReaction(
    note:,
    exposure_route:,
    severity:,
    onset:,
    description:,
    manifestation:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn allergyintolerance_participant_to_json(
  allergyintolerance_participant: AllergyintoleranceParticipant,
) -> Json {
  let AllergyintoleranceParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = allergyintolerance_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn allergyintolerance_participant_decoder() -> Decoder(
  AllergyintoleranceParticipant,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AllergyintoleranceParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn allergyintolerance_to_json(
  allergyintolerance: Allergyintolerance,
) -> Json {
  let Allergyintolerance(
    reaction:,
    note:,
    last_occurrence:,
    participant:,
    recorded_date:,
    onset:,
    encounter:,
    patient:,
    code:,
    criticality:,
    category:,
    type_:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = allergyintolerance
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case reaction {
    [] -> fields
    _ -> [
      #("reaction", json.array(reaction, allergyintolerance_reaction_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case last_occurrence {
    Some(v) -> [#("lastOccurrence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, allergyintolerance_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          AllergyintoleranceOnsetDatetime(_) -> "Datetime"
          AllergyintoleranceOnsetAge(_) -> "Age"
          AllergyintoleranceOnsetPeriod(_) -> "Period"
          AllergyintoleranceOnsetRange(_) -> "Range"
          AllergyintoleranceOnsetString(_) -> "String"
        },
        allergyintolerance_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case criticality {
    Some(v) -> [
      #("criticality", r5valuesets.allergyintolerancecriticality_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #(
        "category",
        json.array(category, r5valuesets.allergyintolerancecategory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case verification_status {
    Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case clinical_status {
    Some(v) -> [#("clinicalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Allergyintolerance")), ..fields]
  json.object(fields)
}

pub fn allergyintolerance_decoder() -> Decoder(Allergyintolerance) {
  use reaction <- decode.optional_field(
    "reaction",
    [],
    decode.list(allergyintolerance_reaction_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use last_occurrence <- decode.optional_field(
    "lastOccurrence",
    None,
    decode.optional(decode.string),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(allergyintolerance_participant_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use onset <- decode.then(none_if_omitted(allergyintolerance_onset_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use criticality <- decode.optional_field(
    "criticality",
    None,
    decode.optional(r5valuesets.allergyintolerancecriticality_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(r5valuesets.allergyintolerancecategory_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use verification_status <- decode.optional_field(
    "verificationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_status <- decode.optional_field(
    "clinicalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Allergyintolerance",
    decode.failure(allergyintolerance_new(patient:), "resourceType"),
  )
  decode.success(Allergyintolerance(
    reaction:,
    note:,
    last_occurrence:,
    participant:,
    recorded_date:,
    onset:,
    encounter:,
    patient:,
    code:,
    criticality:,
    category:,
    type_:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type Appointment {
  Appointment(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Appointmentstatus,
    cancellation_reason: Option(Codeableconcept),
    class: List(Codeableconcept),
    service_category: List(Codeableconcept),
    service_type: List(Codeablereference),
    specialty: List(Codeableconcept),
    appointment_type: Option(Codeableconcept),
    reason: List(Codeablereference),
    priority: Option(Codeableconcept),
    description: Option(String),
    replaces: List(Reference),
    virtual_service: List(Virtualservicedetail),
    supporting_information: List(Reference),
    previous_appointment: Option(Reference),
    originating_appointment: Option(Reference),
    start: Option(String),
    end: Option(String),
    minutes_duration: Option(Int),
    requested_period: List(Period),
    slot: List(Reference),
    account: List(Reference),
    created: Option(String),
    cancellation_date: Option(String),
    note: List(Annotation),
    patient_instruction: List(Codeablereference),
    based_on: List(Reference),
    subject: Option(Reference),
    participant: List(AppointmentParticipant),
    recurrence_id: Option(Int),
    occurrence_changed: Option(Bool),
    recurrence_template: List(AppointmentRecurrencetemplate),
  )
}

pub fn appointment_new(
  status status: r5valuesets.Appointmentstatus,
) -> Appointment {
  Appointment(
    recurrence_template: [],
    occurrence_changed: None,
    recurrence_id: None,
    participant: [],
    subject: None,
    based_on: [],
    patient_instruction: [],
    note: [],
    cancellation_date: None,
    created: None,
    account: [],
    slot: [],
    requested_period: [],
    minutes_duration: None,
    end: None,
    start: None,
    originating_appointment: None,
    previous_appointment: None,
    supporting_information: [],
    virtual_service: [],
    replaces: [],
    description: None,
    priority: None,
    reason: [],
    appointment_type: None,
    specialty: [],
    service_type: [],
    service_category: [],
    class: [],
    cancellation_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type AppointmentParticipant {
  AppointmentParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    period: Option(Period),
    actor: Option(Reference),
    required: Option(Bool),
    status: r5valuesets.Participationstatus,
  )
}

pub fn appointment_participant_new(
  status status: r5valuesets.Participationstatus,
) -> AppointmentParticipant {
  AppointmentParticipant(
    status:,
    required: None,
    actor: None,
    period: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type AppointmentRecurrencetemplate {
  AppointmentRecurrencetemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    timezone: Option(Codeableconcept),
    recurrence_type: Codeableconcept,
    last_occurrence_date: Option(String),
    occurrence_count: Option(Int),
    occurrence_date: List(String),
    weekly_template: Option(AppointmentRecurrencetemplateWeeklytemplate),
    monthly_template: Option(AppointmentRecurrencetemplateMonthlytemplate),
    yearly_template: Option(AppointmentRecurrencetemplateYearlytemplate),
    excluding_date: List(String),
    excluding_recurrence_id: List(Int),
  )
}

pub fn appointment_recurrencetemplate_new(
  recurrence_type recurrence_type: Codeableconcept,
) -> AppointmentRecurrencetemplate {
  AppointmentRecurrencetemplate(
    excluding_recurrence_id: [],
    excluding_date: [],
    yearly_template: None,
    monthly_template: None,
    weekly_template: None,
    occurrence_date: [],
    occurrence_count: None,
    last_occurrence_date: None,
    recurrence_type:,
    timezone: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type AppointmentRecurrencetemplateWeeklytemplate {
  AppointmentRecurrencetemplateWeeklytemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    monday: Option(Bool),
    tuesday: Option(Bool),
    wednesday: Option(Bool),
    thursday: Option(Bool),
    friday: Option(Bool),
    saturday: Option(Bool),
    sunday: Option(Bool),
    week_interval: Option(Int),
  )
}

pub fn appointment_recurrencetemplate_weeklytemplate_new() -> AppointmentRecurrencetemplateWeeklytemplate {
  AppointmentRecurrencetemplateWeeklytemplate(
    week_interval: None,
    sunday: None,
    saturday: None,
    friday: None,
    thursday: None,
    wednesday: None,
    tuesday: None,
    monday: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type AppointmentRecurrencetemplateMonthlytemplate {
  AppointmentRecurrencetemplateMonthlytemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    day_of_month: Option(Int),
    nth_week_of_month: Option(Coding),
    day_of_week: Option(Coding),
    month_interval: Int,
  )
}

pub fn appointment_recurrencetemplate_monthlytemplate_new(
  month_interval month_interval: Int,
) -> AppointmentRecurrencetemplateMonthlytemplate {
  AppointmentRecurrencetemplateMonthlytemplate(
    month_interval:,
    day_of_week: None,
    nth_week_of_month: None,
    day_of_month: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Appointment#resource
pub type AppointmentRecurrencetemplateYearlytemplate {
  AppointmentRecurrencetemplateYearlytemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    year_interval: Int,
  )
}

pub fn appointment_recurrencetemplate_yearlytemplate_new(
  year_interval year_interval: Int,
) -> AppointmentRecurrencetemplateYearlytemplate {
  AppointmentRecurrencetemplateYearlytemplate(
    year_interval:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn appointment_recurrencetemplate_yearlytemplate_to_json(
  appointment_recurrencetemplate_yearlytemplate: AppointmentRecurrencetemplateYearlytemplate,
) -> Json {
  let AppointmentRecurrencetemplateYearlytemplate(
    year_interval:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_recurrencetemplate_yearlytemplate
  let fields = [
    #("yearInterval", json.int(year_interval)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_recurrencetemplate_yearlytemplate_decoder() -> Decoder(
  AppointmentRecurrencetemplateYearlytemplate,
) {
  use year_interval <- decode.field("yearInterval", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentRecurrencetemplateYearlytemplate(
    year_interval:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_recurrencetemplate_monthlytemplate_to_json(
  appointment_recurrencetemplate_monthlytemplate: AppointmentRecurrencetemplateMonthlytemplate,
) -> Json {
  let AppointmentRecurrencetemplateMonthlytemplate(
    month_interval:,
    day_of_week:,
    nth_week_of_month:,
    day_of_month:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_recurrencetemplate_monthlytemplate
  let fields = [
    #("monthInterval", json.int(month_interval)),
  ]
  let fields = case day_of_week {
    Some(v) -> [#("dayOfWeek", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case nth_week_of_month {
    Some(v) -> [#("nthWeekOfMonth", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case day_of_month {
    Some(v) -> [#("dayOfMonth", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_recurrencetemplate_monthlytemplate_decoder() -> Decoder(
  AppointmentRecurrencetemplateMonthlytemplate,
) {
  use month_interval <- decode.field("monthInterval", decode.int)
  use day_of_week <- decode.optional_field(
    "dayOfWeek",
    None,
    decode.optional(coding_decoder()),
  )
  use nth_week_of_month <- decode.optional_field(
    "nthWeekOfMonth",
    None,
    decode.optional(coding_decoder()),
  )
  use day_of_month <- decode.optional_field(
    "dayOfMonth",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentRecurrencetemplateMonthlytemplate(
    month_interval:,
    day_of_week:,
    nth_week_of_month:,
    day_of_month:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_recurrencetemplate_weeklytemplate_to_json(
  appointment_recurrencetemplate_weeklytemplate: AppointmentRecurrencetemplateWeeklytemplate,
) -> Json {
  let AppointmentRecurrencetemplateWeeklytemplate(
    week_interval:,
    sunday:,
    saturday:,
    friday:,
    thursday:,
    wednesday:,
    tuesday:,
    monday:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_recurrencetemplate_weeklytemplate
  let fields = []
  let fields = case week_interval {
    Some(v) -> [#("weekInterval", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sunday {
    Some(v) -> [#("sunday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case saturday {
    Some(v) -> [#("saturday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case friday {
    Some(v) -> [#("friday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case thursday {
    Some(v) -> [#("thursday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case wednesday {
    Some(v) -> [#("wednesday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case tuesday {
    Some(v) -> [#("tuesday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case monday {
    Some(v) -> [#("monday", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_recurrencetemplate_weeklytemplate_decoder() -> Decoder(
  AppointmentRecurrencetemplateWeeklytemplate,
) {
  use week_interval <- decode.optional_field(
    "weekInterval",
    None,
    decode.optional(decode.int),
  )
  use sunday <- decode.optional_field(
    "sunday",
    None,
    decode.optional(decode.bool),
  )
  use saturday <- decode.optional_field(
    "saturday",
    None,
    decode.optional(decode.bool),
  )
  use friday <- decode.optional_field(
    "friday",
    None,
    decode.optional(decode.bool),
  )
  use thursday <- decode.optional_field(
    "thursday",
    None,
    decode.optional(decode.bool),
  )
  use wednesday <- decode.optional_field(
    "wednesday",
    None,
    decode.optional(decode.bool),
  )
  use tuesday <- decode.optional_field(
    "tuesday",
    None,
    decode.optional(decode.bool),
  )
  use monday <- decode.optional_field(
    "monday",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentRecurrencetemplateWeeklytemplate(
    week_interval:,
    sunday:,
    saturday:,
    friday:,
    thursday:,
    wednesday:,
    tuesday:,
    monday:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_recurrencetemplate_to_json(
  appointment_recurrencetemplate: AppointmentRecurrencetemplate,
) -> Json {
  let AppointmentRecurrencetemplate(
    excluding_recurrence_id:,
    excluding_date:,
    yearly_template:,
    monthly_template:,
    weekly_template:,
    occurrence_date:,
    occurrence_count:,
    last_occurrence_date:,
    recurrence_type:,
    timezone:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_recurrencetemplate
  let fields = [
    #("recurrenceType", codeableconcept_to_json(recurrence_type)),
  ]
  let fields = case excluding_recurrence_id {
    [] -> fields
    _ -> [
      #("excludingRecurrenceId", json.array(excluding_recurrence_id, json.int)),
      ..fields
    ]
  }
  let fields = case excluding_date {
    [] -> fields
    _ -> [#("excludingDate", json.array(excluding_date, json.string)), ..fields]
  }
  let fields = case yearly_template {
    Some(v) -> [
      #(
        "yearlyTemplate",
        appointment_recurrencetemplate_yearlytemplate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case monthly_template {
    Some(v) -> [
      #(
        "monthlyTemplate",
        appointment_recurrencetemplate_monthlytemplate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case weekly_template {
    Some(v) -> [
      #(
        "weeklyTemplate",
        appointment_recurrencetemplate_weeklytemplate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case occurrence_date {
    [] -> fields
    _ -> [
      #("occurrenceDate", json.array(occurrence_date, json.string)),
      ..fields
    ]
  }
  let fields = case occurrence_count {
    Some(v) -> [#("occurrenceCount", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case last_occurrence_date {
    Some(v) -> [#("lastOccurrenceDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case timezone {
    Some(v) -> [#("timezone", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_recurrencetemplate_decoder() -> Decoder(
  AppointmentRecurrencetemplate,
) {
  use excluding_recurrence_id <- decode.optional_field(
    "excludingRecurrenceId",
    [],
    decode.list(decode.int),
  )
  use excluding_date <- decode.optional_field(
    "excludingDate",
    [],
    decode.list(decode.string),
  )
  use yearly_template <- decode.optional_field(
    "yearlyTemplate",
    None,
    decode.optional(appointment_recurrencetemplate_yearlytemplate_decoder()),
  )
  use monthly_template <- decode.optional_field(
    "monthlyTemplate",
    None,
    decode.optional(appointment_recurrencetemplate_monthlytemplate_decoder()),
  )
  use weekly_template <- decode.optional_field(
    "weeklyTemplate",
    None,
    decode.optional(appointment_recurrencetemplate_weeklytemplate_decoder()),
  )
  use occurrence_date <- decode.optional_field(
    "occurrenceDate",
    [],
    decode.list(decode.string),
  )
  use occurrence_count <- decode.optional_field(
    "occurrenceCount",
    None,
    decode.optional(decode.int),
  )
  use last_occurrence_date <- decode.optional_field(
    "lastOccurrenceDate",
    None,
    decode.optional(decode.string),
  )
  use recurrence_type <- decode.field(
    "recurrenceType",
    codeableconcept_decoder(),
  )
  use timezone <- decode.optional_field(
    "timezone",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentRecurrencetemplate(
    excluding_recurrence_id:,
    excluding_date:,
    yearly_template:,
    monthly_template:,
    weekly_template:,
    occurrence_date:,
    occurrence_count:,
    last_occurrence_date:,
    recurrence_type:,
    timezone:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_participant_to_json(
  appointment_participant: AppointmentParticipant,
) -> Json {
  let AppointmentParticipant(
    status:,
    required:,
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = appointment_participant
  let fields = [
    #("status", r5valuesets.participationstatus_to_json(status)),
  ]
  let fields = case required {
    Some(v) -> [#("required", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn appointment_participant_decoder() -> Decoder(AppointmentParticipant) {
  use status <- decode.field(
    "status",
    r5valuesets.participationstatus_decoder(),
  )
  use required <- decode.optional_field(
    "required",
    None,
    decode.optional(decode.bool),
  )
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AppointmentParticipant(
    status:,
    required:,
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn appointment_to_json(appointment: Appointment) -> Json {
  let Appointment(
    recurrence_template:,
    occurrence_changed:,
    recurrence_id:,
    participant:,
    subject:,
    based_on:,
    patient_instruction:,
    note:,
    cancellation_date:,
    created:,
    account:,
    slot:,
    requested_period:,
    minutes_duration:,
    end:,
    start:,
    originating_appointment:,
    previous_appointment:,
    supporting_information:,
    virtual_service:,
    replaces:,
    description:,
    priority:,
    reason:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    class:,
    cancellation_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = appointment
  let fields = [
    #("status", r5valuesets.appointmentstatus_to_json(status)),
  ]
  let fields = case recurrence_template {
    [] -> fields
    _ -> [
      #(
        "recurrenceTemplate",
        json.array(recurrence_template, appointment_recurrencetemplate_to_json),
      ),
      ..fields
    ]
  }
  let fields = case occurrence_changed {
    Some(v) -> [#("occurrenceChanged", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case recurrence_id {
    Some(v) -> [#("recurrenceId", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, appointment_participant_to_json)),
      ..fields
    ]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case patient_instruction {
    [] -> fields
    _ -> [
      #(
        "patientInstruction",
        json.array(patient_instruction, codeablereference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case cancellation_date {
    Some(v) -> [#("cancellationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case slot {
    [] -> fields
    _ -> [#("slot", json.array(slot, reference_to_json)), ..fields]
  }
  let fields = case requested_period {
    [] -> fields
    _ -> [
      #("requestedPeriod", json.array(requested_period, period_to_json)),
      ..fields
    ]
  }
  let fields = case minutes_duration {
    Some(v) -> [#("minutesDuration", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case originating_appointment {
    Some(v) -> [#("originatingAppointment", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case previous_appointment {
    Some(v) -> [#("previousAppointment", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case virtual_service {
    [] -> fields
    _ -> [
      #(
        "virtualService",
        json.array(virtual_service, virtualservicedetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case appointment_type {
    Some(v) -> [#("appointmentType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case class {
    [] -> fields
    _ -> [#("class", json.array(class, codeableconcept_to_json)), ..fields]
  }
  let fields = case cancellation_reason {
    Some(v) -> [#("cancellationReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Appointment")), ..fields]
  json.object(fields)
}

pub fn appointment_decoder() -> Decoder(Appointment) {
  use recurrence_template <- decode.optional_field(
    "recurrenceTemplate",
    [],
    decode.list(appointment_recurrencetemplate_decoder()),
  )
  use occurrence_changed <- decode.optional_field(
    "occurrenceChanged",
    None,
    decode.optional(decode.bool),
  )
  use recurrence_id <- decode.optional_field(
    "recurrenceId",
    None,
    decode.optional(decode.int),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(appointment_participant_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    [],
    decode.list(codeablereference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use cancellation_date <- decode.optional_field(
    "cancellationDate",
    None,
    decode.optional(decode.string),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use slot <- decode.optional_field(
    "slot",
    [],
    decode.list(reference_decoder()),
  )
  use requested_period <- decode.optional_field(
    "requestedPeriod",
    [],
    decode.list(period_decoder()),
  )
  use minutes_duration <- decode.optional_field(
    "minutesDuration",
    None,
    decode.optional(decode.int),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use originating_appointment <- decode.optional_field(
    "originatingAppointment",
    None,
    decode.optional(reference_decoder()),
  )
  use previous_appointment <- decode.optional_field(
    "previousAppointment",
    None,
    decode.optional(reference_decoder()),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use virtual_service <- decode.optional_field(
    "virtualService",
    [],
    decode.list(virtualservicedetail_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use appointment_type <- decode.optional_field(
    "appointmentType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeablereference_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use class <- decode.optional_field(
    "class",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use cancellation_reason <- decode.optional_field(
    "cancellationReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.appointmentstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Appointment",
    decode.failure(appointment_new(status:), "resourceType"),
  )
  decode.success(Appointment(
    recurrence_template:,
    occurrence_changed:,
    recurrence_id:,
    participant:,
    subject:,
    based_on:,
    patient_instruction:,
    note:,
    cancellation_date:,
    created:,
    account:,
    slot:,
    requested_period:,
    minutes_duration:,
    end:,
    start:,
    originating_appointment:,
    previous_appointment:,
    supporting_information:,
    virtual_service:,
    replaces:,
    description:,
    priority:,
    reason:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    class:,
    cancellation_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/AppointmentResponse#resource
pub type Appointmentresponse {
  Appointmentresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    appointment: Reference,
    proposed_new_time: Option(Bool),
    start: Option(String),
    end: Option(String),
    participant_type: List(Codeableconcept),
    actor: Option(Reference),
    participant_status: r5valuesets.Appointmentresponsestatus,
    comment: Option(String),
    recurring: Option(Bool),
    occurrence_date: Option(String),
    recurrence_id: Option(Int),
  )
}

pub fn appointmentresponse_new(
  participant_status participant_status: r5valuesets.Appointmentresponsestatus,
  appointment appointment: Reference,
) -> Appointmentresponse {
  Appointmentresponse(
    recurrence_id: None,
    occurrence_date: None,
    recurring: None,
    comment: None,
    participant_status:,
    actor: None,
    participant_type: [],
    end: None,
    start: None,
    proposed_new_time: None,
    appointment:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn appointmentresponse_to_json(
  appointmentresponse: Appointmentresponse,
) -> Json {
  let Appointmentresponse(
    recurrence_id:,
    occurrence_date:,
    recurring:,
    comment:,
    participant_status:,
    actor:,
    participant_type:,
    end:,
    start:,
    proposed_new_time:,
    appointment:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = appointmentresponse
  let fields = [
    #(
      "participantStatus",
      r5valuesets.appointmentresponsestatus_to_json(participant_status),
    ),
    #("appointment", reference_to_json(appointment)),
  ]
  let fields = case recurrence_id {
    Some(v) -> [#("recurrenceId", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence_date {
    Some(v) -> [#("occurrenceDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case recurring {
    Some(v) -> [#("recurring", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant_type {
    [] -> fields
    _ -> [
      #(
        "participantType",
        json.array(participant_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case proposed_new_time {
    Some(v) -> [#("proposedNewTime", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Appointmentresponse")), ..fields]
  json.object(fields)
}

pub fn appointmentresponse_decoder() -> Decoder(Appointmentresponse) {
  use recurrence_id <- decode.optional_field(
    "recurrenceId",
    None,
    decode.optional(decode.int),
  )
  use occurrence_date <- decode.optional_field(
    "occurrenceDate",
    None,
    decode.optional(decode.string),
  )
  use recurring <- decode.optional_field(
    "recurring",
    None,
    decode.optional(decode.bool),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use participant_status <- decode.field(
    "participantStatus",
    r5valuesets.appointmentresponsestatus_decoder(),
  )
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use participant_type <- decode.optional_field(
    "participantType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use proposed_new_time <- decode.optional_field(
    "proposedNewTime",
    None,
    decode.optional(decode.bool),
  )
  use appointment <- decode.field("appointment", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Appointmentresponse",
    decode.failure(
      appointmentresponse_new(participant_status:, appointment:),
      "resourceType",
    ),
  )
  decode.success(Appointmentresponse(
    recurrence_id:,
    occurrence_date:,
    recurring:,
    comment:,
    participant_status:,
    actor:,
    participant_type:,
    end:,
    start:,
    proposed_new_time:,
    appointment:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ArtifactAssessment#resource
pub type Artifactassessment {
  Artifactassessment(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    title: Option(String),
    cite_as: Option(ArtifactassessmentCiteas),
    date: Option(String),
    copyright: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    artifact: ArtifactassessmentArtifact,
    content: List(ArtifactassessmentContent),
    workflow_status: Option(r5valuesets.Artifactassessmentworkflowstatus),
    disposition: Option(r5valuesets.Artifactassessmentdisposition),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ArtifactAssessment#resource
pub type ArtifactassessmentCiteas {
  ArtifactassessmentCiteasReference(cite_as: Reference)
  ArtifactassessmentCiteasMarkdown(cite_as: String)
}

pub fn artifactassessment_citeas_to_json(elt: ArtifactassessmentCiteas) -> Json {
  case elt {
    ArtifactassessmentCiteasReference(v) -> reference_to_json(v)
    ArtifactassessmentCiteasMarkdown(v) -> json.string(v)
  }
}

pub fn artifactassessment_citeas_decoder() -> Decoder(ArtifactassessmentCiteas) {
  decode.one_of(
    decode.field("citeAsReference", reference_decoder(), decode.success)
      |> decode.map(ArtifactassessmentCiteasReference),
    [
      decode.field("citeAsMarkdown", decode.string, decode.success)
      |> decode.map(ArtifactassessmentCiteasMarkdown),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ArtifactAssessment#resource
pub type ArtifactassessmentArtifact {
  ArtifactassessmentArtifactReference(artifact: Reference)
  ArtifactassessmentArtifactCanonical(artifact: String)
  ArtifactassessmentArtifactUri(artifact: String)
}

pub fn artifactassessment_artifact_to_json(
  elt: ArtifactassessmentArtifact,
) -> Json {
  case elt {
    ArtifactassessmentArtifactReference(v) -> reference_to_json(v)
    ArtifactassessmentArtifactCanonical(v) -> json.string(v)
    ArtifactassessmentArtifactUri(v) -> json.string(v)
  }
}

pub fn artifactassessment_artifact_decoder() -> Decoder(
  ArtifactassessmentArtifact,
) {
  decode.one_of(
    decode.field("artifactReference", reference_decoder(), decode.success)
      |> decode.map(ArtifactassessmentArtifactReference),
    [
      decode.field("artifactCanonical", decode.string, decode.success)
        |> decode.map(ArtifactassessmentArtifactCanonical),
      decode.field("artifactUri", decode.string, decode.success)
        |> decode.map(ArtifactassessmentArtifactUri),
    ],
  )
}

pub fn artifactassessment_new(
  artifact artifact: ArtifactassessmentArtifact,
) -> Artifactassessment {
  Artifactassessment(
    disposition: None,
    workflow_status: None,
    content: [],
    artifact:,
    last_review_date: None,
    approval_date: None,
    copyright: None,
    date: None,
    cite_as: None,
    title: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ArtifactAssessment#resource
pub type ArtifactassessmentContent {
  ArtifactassessmentContent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    information_type: Option(r5valuesets.Artifactassessmentinformationtype),
    summary: Option(String),
    type_: Option(Codeableconcept),
    classifier: List(Codeableconcept),
    quantity: Option(Quantity),
    author: Option(Reference),
    path: List(String),
    related_artifact: List(Relatedartifact),
    free_to_share: Option(Bool),
  )
}

pub fn artifactassessment_content_new() -> ArtifactassessmentContent {
  ArtifactassessmentContent(
    free_to_share: None,
    related_artifact: [],
    path: [],
    author: None,
    quantity: None,
    classifier: [],
    type_: None,
    summary: None,
    information_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn artifactassessment_content_to_json(
  artifactassessment_content: ArtifactassessmentContent,
) -> Json {
  let ArtifactassessmentContent(
    free_to_share:,
    related_artifact:,
    path:,
    author:,
    quantity:,
    classifier:,
    type_:,
    summary:,
    information_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = artifactassessment_content
  let fields = []
  let fields = case free_to_share {
    Some(v) -> [#("freeToShare", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case path {
    [] -> fields
    _ -> [#("path", json.array(path, json.string)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case summary {
    Some(v) -> [#("summary", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case information_type {
    Some(v) -> [
      #(
        "informationType",
        r5valuesets.artifactassessmentinformationtype_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn artifactassessment_content_decoder() -> Decoder(
  ArtifactassessmentContent,
) {
  use free_to_share <- decode.optional_field(
    "freeToShare",
    None,
    decode.optional(decode.bool),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use path <- decode.optional_field("path", [], decode.list(decode.string))
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    None,
    decode.optional(decode.string),
  )
  use information_type <- decode.optional_field(
    "informationType",
    None,
    decode.optional(r5valuesets.artifactassessmentinformationtype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ArtifactassessmentContent(
    free_to_share:,
    related_artifact:,
    path:,
    author:,
    quantity:,
    classifier:,
    type_:,
    summary:,
    information_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn artifactassessment_to_json(
  artifactassessment: Artifactassessment,
) -> Json {
  let Artifactassessment(
    disposition:,
    workflow_status:,
    content:,
    artifact:,
    last_review_date:,
    approval_date:,
    copyright:,
    date:,
    cite_as:,
    title:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = artifactassessment
  let fields = [
    #("artifact", artifactassessment_artifact_to_json(artifact)),
  ]
  let fields = case disposition {
    Some(v) -> [
      #("disposition", r5valuesets.artifactassessmentdisposition_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case workflow_status {
    Some(v) -> [
      #(
        "workflowStatus",
        r5valuesets.artifactassessmentworkflowstatus_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case content {
    [] -> fields
    _ -> [
      #("content", json.array(content, artifactassessment_content_to_json)),
      ..fields
    ]
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cite_as {
    Some(v) -> [
      #(
        "citeAs"
          <> case v {
          ArtifactassessmentCiteasReference(_) -> "Reference"
          ArtifactassessmentCiteasMarkdown(_) -> "Markdown"
        },
        artifactassessment_citeas_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Artifactassessment")), ..fields]
  json.object(fields)
}

pub fn artifactassessment_decoder() -> Decoder(Artifactassessment) {
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(r5valuesets.artifactassessmentdisposition_decoder()),
  )
  use workflow_status <- decode.optional_field(
    "workflowStatus",
    None,
    decode.optional(r5valuesets.artifactassessmentworkflowstatus_decoder()),
  )
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(artifactassessment_content_decoder()),
  )
  use artifact <- decode.then(artifactassessment_artifact_decoder())
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use cite_as <- decode.then(
    none_if_omitted(artifactassessment_citeas_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Artifactassessment",
    decode.failure(artifactassessment_new(artifact:), "resourceType"),
  )
  decode.success(Artifactassessment(
    disposition:,
    workflow_status:,
    content:,
    artifact:,
    last_review_date:,
    approval_date:,
    copyright:,
    date:,
    cite_as:,
    title:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type Auditevent {
  Auditevent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: List(Codeableconcept),
    code: Codeableconcept,
    action: Option(r5valuesets.Auditeventaction),
    severity: Option(r5valuesets.Auditeventseverity),
    occurred: Option(AuditeventOccurred),
    recorded: String,
    outcome: Option(AuditeventOutcome),
    authorization: List(Codeableconcept),
    based_on: List(Reference),
    patient: Option(Reference),
    encounter: Option(Reference),
    agent: List(AuditeventAgent),
    source: AuditeventSource,
    entity: List(AuditeventEntity),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventOccurred {
  AuditeventOccurredPeriod(occurred: Period)
  AuditeventOccurredDatetime(occurred: String)
}

pub fn auditevent_occurred_to_json(elt: AuditeventOccurred) -> Json {
  case elt {
    AuditeventOccurredPeriod(v) -> period_to_json(v)
    AuditeventOccurredDatetime(v) -> json.string(v)
  }
}

pub fn auditevent_occurred_decoder() -> Decoder(AuditeventOccurred) {
  decode.one_of(
    decode.field("occurredPeriod", period_decoder(), decode.success)
      |> decode.map(AuditeventOccurredPeriod),
    [
      decode.field("occurredDateTime", decode.string, decode.success)
      |> decode.map(AuditeventOccurredDatetime),
    ],
  )
}

pub fn auditevent_new(
  source source: AuditeventSource,
  recorded recorded: String,
  code code: Codeableconcept,
) -> Auditevent {
  Auditevent(
    entity: [],
    source:,
    agent: [],
    encounter: None,
    patient: None,
    based_on: [],
    authorization: [],
    outcome: None,
    recorded:,
    occurred: None,
    severity: None,
    action: None,
    code:,
    category: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventOutcome {
  AuditeventOutcome(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Coding,
    detail: List(Codeableconcept),
  )
}

pub fn auditevent_outcome_new(code code: Coding) -> AuditeventOutcome {
  AuditeventOutcome(
    detail: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventAgent {
  AuditeventAgent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    role: List(Codeableconcept),
    who: Reference,
    requestor: Option(Bool),
    location: Option(Reference),
    policy: List(String),
    network: Option(AuditeventAgentNetwork),
    authorization: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventAgentNetwork {
  AuditeventAgentNetworkReference(network: Reference)
  AuditeventAgentNetworkUri(network: String)
  AuditeventAgentNetworkString(network: String)
}

pub fn auditevent_agent_network_to_json(elt: AuditeventAgentNetwork) -> Json {
  case elt {
    AuditeventAgentNetworkReference(v) -> reference_to_json(v)
    AuditeventAgentNetworkUri(v) -> json.string(v)
    AuditeventAgentNetworkString(v) -> json.string(v)
  }
}

pub fn auditevent_agent_network_decoder() -> Decoder(AuditeventAgentNetwork) {
  decode.one_of(
    decode.field("networkReference", reference_decoder(), decode.success)
      |> decode.map(AuditeventAgentNetworkReference),
    [
      decode.field("networkUri", decode.string, decode.success)
        |> decode.map(AuditeventAgentNetworkUri),
      decode.field("networkString", decode.string, decode.success)
        |> decode.map(AuditeventAgentNetworkString),
    ],
  )
}

pub fn auditevent_agent_new(who who: Reference) -> AuditeventAgent {
  AuditeventAgent(
    authorization: [],
    network: None,
    policy: [],
    location: None,
    requestor: None,
    who:,
    role: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventSource {
  AuditeventSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: Option(Reference),
    observer: Reference,
    type_: List(Codeableconcept),
  )
}

pub fn auditevent_source_new(observer observer: Reference) -> AuditeventSource {
  AuditeventSource(
    type_: [],
    observer:,
    site: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventEntity {
  AuditeventEntity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    what: Option(Reference),
    role: Option(Codeableconcept),
    security_label: List(Codeableconcept),
    query: Option(String),
    detail: List(AuditeventEntityDetail),
  )
}

pub fn auditevent_entity_new() -> AuditeventEntity {
  AuditeventEntity(
    detail: [],
    query: None,
    security_label: [],
    role: None,
    what: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetail {
  AuditeventEntityDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: AuditeventEntityDetailValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/AuditEvent#resource
pub type AuditeventEntityDetailValue {
  AuditeventEntityDetailValueQuantity(value: Quantity)
  AuditeventEntityDetailValueCodeableconcept(value: Codeableconcept)
  AuditeventEntityDetailValueString(value: String)
  AuditeventEntityDetailValueBoolean(value: Bool)
  AuditeventEntityDetailValueInteger(value: Int)
  AuditeventEntityDetailValueRange(value: Range)
  AuditeventEntityDetailValueRatio(value: Ratio)
  AuditeventEntityDetailValueTime(value: String)
  AuditeventEntityDetailValueDatetime(value: String)
  AuditeventEntityDetailValuePeriod(value: Period)
  AuditeventEntityDetailValueBase64binary(value: String)
}

pub fn auditevent_entity_detail_value_to_json(
  elt: AuditeventEntityDetailValue,
) -> Json {
  case elt {
    AuditeventEntityDetailValueQuantity(v) -> quantity_to_json(v)
    AuditeventEntityDetailValueCodeableconcept(v) -> codeableconcept_to_json(v)
    AuditeventEntityDetailValueString(v) -> json.string(v)
    AuditeventEntityDetailValueBoolean(v) -> json.bool(v)
    AuditeventEntityDetailValueInteger(v) -> json.int(v)
    AuditeventEntityDetailValueRange(v) -> range_to_json(v)
    AuditeventEntityDetailValueRatio(v) -> ratio_to_json(v)
    AuditeventEntityDetailValueTime(v) -> json.string(v)
    AuditeventEntityDetailValueDatetime(v) -> json.string(v)
    AuditeventEntityDetailValuePeriod(v) -> period_to_json(v)
    AuditeventEntityDetailValueBase64binary(v) -> json.string(v)
  }
}

pub fn auditevent_entity_detail_value_decoder() -> Decoder(
  AuditeventEntityDetailValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(AuditeventEntityDetailValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(AuditeventEntityDetailValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(AuditeventEntityDetailValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(AuditeventEntityDetailValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(AuditeventEntityDetailValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(AuditeventEntityDetailValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(AuditeventEntityDetailValueRatio),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(AuditeventEntityDetailValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(AuditeventEntityDetailValueDatetime),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(AuditeventEntityDetailValuePeriod),
      decode.field("valueBase64Binary", decode.string, decode.success)
        |> decode.map(AuditeventEntityDetailValueBase64binary),
    ],
  )
}

pub fn auditevent_entity_detail_new(
  value value: AuditeventEntityDetailValue,
  type_ type_: Codeableconcept,
) -> AuditeventEntityDetail {
  AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn auditevent_entity_detail_to_json(
  auditevent_entity_detail: AuditeventEntityDetail,
) -> Json {
  let AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_entity_detail
  let fields = [
    #("value", auditevent_entity_detail_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_entity_detail_decoder() -> Decoder(AuditeventEntityDetail) {
  use value <- decode.then(auditevent_entity_detail_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventEntityDetail(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_entity_to_json(auditevent_entity: AuditeventEntity) -> Json {
  let AuditeventEntity(
    detail:,
    query:,
    security_label:,
    role:,
    what:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_entity
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, auditevent_entity_detail_to_json)),
      ..fields
    ]
  }
  let fields = case query {
    Some(v) -> [#("query", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case what {
    Some(v) -> [#("what", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_entity_decoder() -> Decoder(AuditeventEntity) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(auditevent_entity_detail_decoder()),
  )
  use query <- decode.optional_field(
    "query",
    None,
    decode.optional(decode.string),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use what <- decode.optional_field(
    "what",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventEntity(
    detail:,
    query:,
    security_label:,
    role:,
    what:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_source_to_json(auditevent_source: AuditeventSource) -> Json {
  let AuditeventSource(
    type_:,
    observer:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_source
  let fields = [
    #("observer", reference_to_json(observer)),
  ]
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case site {
    Some(v) -> [#("site", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_source_decoder() -> Decoder(AuditeventSource) {
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use observer <- decode.field("observer", reference_decoder())
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventSource(
    type_:,
    observer:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_agent_to_json(auditevent_agent: AuditeventAgent) -> Json {
  let AuditeventAgent(
    authorization:,
    network:,
    policy:,
    location:,
    requestor:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = auditevent_agent
  let fields = [
    #("who", reference_to_json(who)),
  ]
  let fields = case authorization {
    [] -> fields
    _ -> [
      #("authorization", json.array(authorization, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    Some(v) -> [
      #(
        "network"
          <> case v {
          AuditeventAgentNetworkReference(_) -> "Reference"
          AuditeventAgentNetworkUri(_) -> "Uri"
          AuditeventAgentNetworkString(_) -> "String"
        },
        auditevent_agent_network_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case policy {
    [] -> fields
    _ -> [#("policy", json.array(policy, json.string)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_agent_decoder() -> Decoder(AuditeventAgent) {
  use authorization <- decode.optional_field(
    "authorization",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use network <- decode.then(
    none_if_omitted(auditevent_agent_network_decoder()),
  )
  use policy <- decode.optional_field("policy", [], decode.list(decode.string))
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(decode.bool),
  )
  use who <- decode.field("who", reference_decoder())
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventAgent(
    authorization:,
    network:,
    policy:,
    location:,
    requestor:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_outcome_to_json(auditevent_outcome: AuditeventOutcome) -> Json {
  let AuditeventOutcome(detail:, code:, modifier_extension:, extension:, id:) =
    auditevent_outcome
  let fields = [
    #("code", coding_to_json(code)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn auditevent_outcome_decoder() -> Decoder(AuditeventOutcome) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.field("code", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(AuditeventOutcome(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn auditevent_to_json(auditevent: Auditevent) -> Json {
  let Auditevent(
    entity:,
    source:,
    agent:,
    encounter:,
    patient:,
    based_on:,
    authorization:,
    outcome:,
    recorded:,
    occurred:,
    severity:,
    action:,
    code:,
    category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = auditevent
  let fields = [
    #("source", auditevent_source_to_json(source)),
    #("recorded", json.string(recorded)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case entity {
    [] -> fields
    _ -> [#("entity", json.array(entity, auditevent_entity_to_json)), ..fields]
  }
  let fields = case agent {
    [] -> fields
    _ -> [#("agent", json.array(agent, auditevent_agent_to_json)), ..fields]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case authorization {
    [] -> fields
    _ -> [
      #("authorization", json.array(authorization, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", auditevent_outcome_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurred {
    Some(v) -> [
      #(
        "occurred"
          <> case v {
          AuditeventOccurredPeriod(_) -> "Period"
          AuditeventOccurredDatetime(_) -> "Datetime"
        },
        auditevent_occurred_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [
      #("severity", r5valuesets.auditeventseverity_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case action {
    Some(v) -> [#("action", r5valuesets.auditeventaction_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Auditevent")), ..fields]
  json.object(fields)
}

pub fn auditevent_decoder() -> Decoder(Auditevent) {
  use entity <- decode.optional_field(
    "entity",
    [],
    decode.list(auditevent_entity_decoder()),
  )
  use source <- decode.field("source", auditevent_source_decoder())
  use agent <- decode.optional_field(
    "agent",
    [],
    decode.list(auditevent_agent_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use authorization <- decode.optional_field(
    "authorization",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(auditevent_outcome_decoder()),
  )
  use recorded <- decode.field("recorded", decode.string)
  use occurred <- decode.then(none_if_omitted(auditevent_occurred_decoder()))
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(r5valuesets.auditeventseverity_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    None,
    decode.optional(r5valuesets.auditeventaction_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Auditevent",
    decode.failure(auditevent_new(source:, recorded:, code:), "resourceType"),
  )
  decode.success(Auditevent(
    entity:,
    source:,
    agent:,
    encounter:,
    patient:,
    based_on:,
    authorization:,
    outcome:,
    recorded:,
    occurred:,
    severity:,
    action:,
    code:,
    category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Basic#resource
pub type Basic {
  Basic(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Codeableconcept,
    subject: Option(Reference),
    created: Option(String),
    author: Option(Reference),
  )
}

pub fn basic_new(code code: Codeableconcept) -> Basic {
  Basic(
    author: None,
    created: None,
    subject: None,
    code:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn basic_to_json(basic: Basic) -> Json {
  let Basic(
    author:,
    created:,
    subject:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = basic
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Basic")), ..fields]
  json.object(fields)
}

pub fn basic_decoder() -> Decoder(Basic) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Basic",
    decode.failure(basic_new(code:), "resourceType"),
  )
  decode.success(Basic(
    author:,
    created:,
    subject:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Binary#resource
pub type Binary {
  Binary(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    content_type: String,
    security_context: Option(Reference),
    data: Option(String),
  )
}

pub fn binary_new(content_type content_type: String) -> Binary {
  Binary(
    data: None,
    security_context: None,
    content_type:,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn binary_to_json(binary: Binary) -> Json {
  let Binary(
    data:,
    security_context:,
    content_type:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = binary
  let fields = [
    #("contentType", json.string(content_type)),
  ]
  let fields = case data {
    Some(v) -> [#("data", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case security_context {
    Some(v) -> [#("securityContext", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Binary")), ..fields]
  json.object(fields)
}

pub fn binary_decoder() -> Decoder(Binary) {
  use data <- decode.optional_field(
    "data",
    None,
    decode.optional(decode.string),
  )
  use security_context <- decode.optional_field(
    "securityContext",
    None,
    decode.optional(reference_decoder()),
  )
  use content_type <- decode.field("contentType", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Binary",
    decode.failure(binary_new(content_type:), "resourceType"),
  )
  decode.success(Binary(
    data:,
    security_context:,
    content_type:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProduct#resource
pub type Biologicallyderivedproduct {
  Biologicallyderivedproduct(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_category: Option(Coding),
    product_code: Option(Codeableconcept),
    parent: List(Reference),
    request: List(Reference),
    identifier: List(Identifier),
    biological_source_event: Option(Identifier),
    processing_facility: List(Reference),
    division: Option(String),
    product_status: Option(Coding),
    expiration_date: Option(String),
    collection: Option(BiologicallyderivedproductCollection),
    storage_temp_requirements: Option(Range),
    property: List(BiologicallyderivedproductProperty),
  )
}

pub fn biologicallyderivedproduct_new() -> Biologicallyderivedproduct {
  Biologicallyderivedproduct(
    property: [],
    storage_temp_requirements: None,
    collection: None,
    expiration_date: None,
    product_status: None,
    division: None,
    processing_facility: [],
    biological_source_event: None,
    identifier: [],
    request: [],
    parent: [],
    product_code: None,
    product_category: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollection {
  BiologicallyderivedproductCollection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    collector: Option(Reference),
    source: Option(Reference),
    collected: Option(BiologicallyderivedproductCollectionCollected),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductCollectionCollected {
  BiologicallyderivedproductCollectionCollectedDatetime(collected: String)
  BiologicallyderivedproductCollectionCollectedPeriod(collected: Period)
}

pub fn biologicallyderivedproduct_collection_collected_to_json(
  elt: BiologicallyderivedproductCollectionCollected,
) -> Json {
  case elt {
    BiologicallyderivedproductCollectionCollectedDatetime(v) -> json.string(v)
    BiologicallyderivedproductCollectionCollectedPeriod(v) -> period_to_json(v)
  }
}

pub fn biologicallyderivedproduct_collection_collected_decoder() -> Decoder(
  BiologicallyderivedproductCollectionCollected,
) {
  decode.one_of(
    decode.field("collectedDateTime", decode.string, decode.success)
      |> decode.map(BiologicallyderivedproductCollectionCollectedDatetime),
    [
      decode.field("collectedPeriod", period_decoder(), decode.success)
      |> decode.map(BiologicallyderivedproductCollectionCollectedPeriod),
    ],
  )
}

pub fn biologicallyderivedproduct_collection_new() -> BiologicallyderivedproductCollection {
  BiologicallyderivedproductCollection(
    collected: None,
    source: None,
    collector: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductProperty {
  BiologicallyderivedproductProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: BiologicallyderivedproductPropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProduct#resource
pub type BiologicallyderivedproductPropertyValue {
  BiologicallyderivedproductPropertyValueBoolean(value: Bool)
  BiologicallyderivedproductPropertyValueInteger(value: Int)
  BiologicallyderivedproductPropertyValueCodeableconcept(value: Codeableconcept)
  BiologicallyderivedproductPropertyValuePeriod(value: Period)
  BiologicallyderivedproductPropertyValueQuantity(value: Quantity)
  BiologicallyderivedproductPropertyValueRange(value: Range)
  BiologicallyderivedproductPropertyValueRatio(value: Ratio)
  BiologicallyderivedproductPropertyValueString(value: String)
  BiologicallyderivedproductPropertyValueAttachment(value: Attachment)
}

pub fn biologicallyderivedproduct_property_value_to_json(
  elt: BiologicallyderivedproductPropertyValue,
) -> Json {
  case elt {
    BiologicallyderivedproductPropertyValueBoolean(v) -> json.bool(v)
    BiologicallyderivedproductPropertyValueInteger(v) -> json.int(v)
    BiologicallyderivedproductPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    BiologicallyderivedproductPropertyValuePeriod(v) -> period_to_json(v)
    BiologicallyderivedproductPropertyValueQuantity(v) -> quantity_to_json(v)
    BiologicallyderivedproductPropertyValueRange(v) -> range_to_json(v)
    BiologicallyderivedproductPropertyValueRatio(v) -> ratio_to_json(v)
    BiologicallyderivedproductPropertyValueString(v) -> json.string(v)
    BiologicallyderivedproductPropertyValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn biologicallyderivedproduct_property_value_decoder() -> Decoder(
  BiologicallyderivedproductPropertyValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(BiologicallyderivedproductPropertyValueBoolean),
    [
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueInteger),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(BiologicallyderivedproductPropertyValueCodeableconcept),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueRatio),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueString),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(BiologicallyderivedproductPropertyValueAttachment),
    ],
  )
}

pub fn biologicallyderivedproduct_property_new(
  value value: BiologicallyderivedproductPropertyValue,
  type_ type_: Codeableconcept,
) -> BiologicallyderivedproductProperty {
  BiologicallyderivedproductProperty(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn biologicallyderivedproduct_property_to_json(
  biologicallyderivedproduct_property: BiologicallyderivedproductProperty,
) -> Json {
  let BiologicallyderivedproductProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_property
  let fields = [
    #("value", biologicallyderivedproduct_property_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_property_decoder() -> Decoder(
  BiologicallyderivedproductProperty,
) {
  use value <- decode.then(biologicallyderivedproduct_property_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_collection_to_json(
  biologicallyderivedproduct_collection: BiologicallyderivedproductCollection,
) -> Json {
  let BiologicallyderivedproductCollection(
    collected:,
    source:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproduct_collection
  let fields = []
  let fields = case collected {
    Some(v) -> [
      #(
        "collected"
          <> case v {
          BiologicallyderivedproductCollectionCollectedDatetime(_) -> "Datetime"
          BiologicallyderivedproductCollectionCollectedPeriod(_) -> "Period"
        },
        biologicallyderivedproduct_collection_collected_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case collector {
    Some(v) -> [#("collector", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproduct_collection_decoder() -> Decoder(
  BiologicallyderivedproductCollection,
) {
  use collected <- decode.then(
    none_if_omitted(biologicallyderivedproduct_collection_collected_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use collector <- decode.optional_field(
    "collector",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductCollection(
    collected:,
    source:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproduct_to_json(
  biologicallyderivedproduct: Biologicallyderivedproduct,
) -> Json {
  let Biologicallyderivedproduct(
    property:,
    storage_temp_requirements:,
    collection:,
    expiration_date:,
    product_status:,
    division:,
    processing_facility:,
    biological_source_event:,
    identifier:,
    request:,
    parent:,
    product_code:,
    product_category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = biologicallyderivedproduct
  let fields = []
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, biologicallyderivedproduct_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case storage_temp_requirements {
    Some(v) -> [#("storageTempRequirements", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case collection {
    Some(v) -> [
      #("collection", biologicallyderivedproduct_collection_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case product_status {
    Some(v) -> [#("productStatus", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case division {
    Some(v) -> [#("division", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case processing_facility {
    [] -> fields
    _ -> [
      #(
        "processingFacility",
        json.array(processing_facility, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case biological_source_event {
    Some(v) -> [#("biologicalSourceEvent", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, reference_to_json)), ..fields]
  }
  let fields = case product_code {
    Some(v) -> [#("productCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_category {
    Some(v) -> [#("productCategory", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Biologicallyderivedproduct")),
    ..fields
  ]
  json.object(fields)
}

pub fn biologicallyderivedproduct_decoder() -> Decoder(
  Biologicallyderivedproduct,
) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(biologicallyderivedproduct_property_decoder()),
  )
  use storage_temp_requirements <- decode.optional_field(
    "storageTempRequirements",
    None,
    decode.optional(range_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    None,
    decode.optional(biologicallyderivedproduct_collection_decoder()),
  )
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use product_status <- decode.optional_field(
    "productStatus",
    None,
    decode.optional(coding_decoder()),
  )
  use division <- decode.optional_field(
    "division",
    None,
    decode.optional(decode.string),
  )
  use processing_facility <- decode.optional_field(
    "processingFacility",
    [],
    decode.list(reference_decoder()),
  )
  use biological_source_event <- decode.optional_field(
    "biologicalSourceEvent",
    None,
    decode.optional(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use parent <- decode.optional_field(
    "parent",
    [],
    decode.list(reference_decoder()),
  )
  use product_code <- decode.optional_field(
    "productCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_category <- decode.optional_field(
    "productCategory",
    None,
    decode.optional(coding_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Biologicallyderivedproduct",
    decode.failure(biologicallyderivedproduct_new(), "resourceType"),
  )
  decode.success(Biologicallyderivedproduct(
    property:,
    storage_temp_requirements:,
    collection:,
    expiration_date:,
    product_status:,
    division:,
    processing_facility:,
    biological_source_event:,
    identifier:,
    request:,
    parent:,
    product_code:,
    product_category:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProductDispense#resource
pub type Biologicallyderivedproductdispense {
  Biologicallyderivedproductdispense(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Biologicallyderivedproductdispensestatus,
    origin_relationship_type: Option(Codeableconcept),
    product: Reference,
    patient: Reference,
    match_status: Option(Codeableconcept),
    performer: List(BiologicallyderivedproductdispensePerformer),
    location: Option(Reference),
    quantity: Option(Quantity),
    prepared_date: Option(String),
    when_handed_over: Option(String),
    destination: Option(Reference),
    note: List(Annotation),
    usage_instruction: Option(String),
  )
}

pub fn biologicallyderivedproductdispense_new(
  patient patient: Reference,
  product product: Reference,
  status status: r5valuesets.Biologicallyderivedproductdispensestatus,
) -> Biologicallyderivedproductdispense {
  Biologicallyderivedproductdispense(
    usage_instruction: None,
    note: [],
    destination: None,
    when_handed_over: None,
    prepared_date: None,
    quantity: None,
    location: None,
    performer: [],
    match_status: None,
    patient:,
    product:,
    origin_relationship_type: None,
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BiologicallyDerivedProductDispense#resource
pub type BiologicallyderivedproductdispensePerformer {
  BiologicallyderivedproductdispensePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn biologicallyderivedproductdispense_performer_new(
  actor actor: Reference,
) -> BiologicallyderivedproductdispensePerformer {
  BiologicallyderivedproductdispensePerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn biologicallyderivedproductdispense_performer_to_json(
  biologicallyderivedproductdispense_performer: BiologicallyderivedproductdispensePerformer,
) -> Json {
  let BiologicallyderivedproductdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = biologicallyderivedproductdispense_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn biologicallyderivedproductdispense_performer_decoder() -> Decoder(
  BiologicallyderivedproductdispensePerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BiologicallyderivedproductdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn biologicallyderivedproductdispense_to_json(
  biologicallyderivedproductdispense: Biologicallyderivedproductdispense,
) -> Json {
  let Biologicallyderivedproductdispense(
    usage_instruction:,
    note:,
    destination:,
    when_handed_over:,
    prepared_date:,
    quantity:,
    location:,
    performer:,
    match_status:,
    patient:,
    product:,
    origin_relationship_type:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = biologicallyderivedproductdispense
  let fields = [
    #("patient", reference_to_json(patient)),
    #("product", reference_to_json(product)),
    #(
      "status",
      r5valuesets.biologicallyderivedproductdispensestatus_to_json(status),
    ),
  ]
  let fields = case usage_instruction {
    Some(v) -> [#("usageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case when_handed_over {
    Some(v) -> [#("whenHandedOver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prepared_date {
    Some(v) -> [#("preparedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(
          performer,
          biologicallyderivedproductdispense_performer_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case match_status {
    Some(v) -> [#("matchStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case origin_relationship_type {
    Some(v) -> [
      #("originRelationshipType", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Biologicallyderivedproductdispense")),
    ..fields
  ]
  json.object(fields)
}

pub fn biologicallyderivedproductdispense_decoder() -> Decoder(
  Biologicallyderivedproductdispense,
) {
  use usage_instruction <- decode.optional_field(
    "usageInstruction",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use when_handed_over <- decode.optional_field(
    "whenHandedOver",
    None,
    decode.optional(decode.string),
  )
  use prepared_date <- decode.optional_field(
    "preparedDate",
    None,
    decode.optional(decode.string),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(biologicallyderivedproductdispense_performer_decoder()),
  )
  use match_status <- decode.optional_field(
    "matchStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use product <- decode.field("product", reference_decoder())
  use origin_relationship_type <- decode.optional_field(
    "originRelationshipType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.biologicallyderivedproductdispensestatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Biologicallyderivedproductdispense",
    decode.failure(
      biologicallyderivedproductdispense_new(patient:, product:, status:),
      "resourceType",
    ),
  )
  decode.success(Biologicallyderivedproductdispense(
    usage_instruction:,
    note:,
    destination:,
    when_handed_over:,
    prepared_date:,
    quantity:,
    location:,
    performer:,
    match_status:,
    patient:,
    product:,
    origin_relationship_type:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/BodyStructure#resource
pub type Bodystructure {
  Bodystructure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    morphology: Option(Codeableconcept),
    included_structure: List(BodystructureIncludedstructure),
    description: Option(String),
    image: List(Attachment),
    patient: Reference,
  )
}

pub fn bodystructure_new(patient patient: Reference) -> Bodystructure {
  Bodystructure(
    patient:,
    image: [],
    description: None,
    included_structure: [],
    morphology: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BodyStructure#resource
pub type BodystructureIncludedstructure {
  BodystructureIncludedstructure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    structure: Codeableconcept,
    laterality: Option(Codeableconcept),
    body_landmark_orientation: List(
      BodystructureIncludedstructureBodylandmarkorientation,
    ),
    spatial_reference: List(Reference),
    qualifier: List(Codeableconcept),
  )
}

pub fn bodystructure_includedstructure_new(
  structure structure: Codeableconcept,
) -> BodystructureIncludedstructure {
  BodystructureIncludedstructure(
    qualifier: [],
    spatial_reference: [],
    body_landmark_orientation: [],
    laterality: None,
    structure:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BodyStructure#resource
pub type BodystructureIncludedstructureBodylandmarkorientation {
  BodystructureIncludedstructureBodylandmarkorientation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    landmark_description: List(Codeableconcept),
    clock_face_position: List(Codeableconcept),
    distance_from_landmark: List(
      BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark,
    ),
    surface_orientation: List(Codeableconcept),
  )
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_new() -> BodystructureIncludedstructureBodylandmarkorientation {
  BodystructureIncludedstructureBodylandmarkorientation(
    surface_orientation: [],
    distance_from_landmark: [],
    clock_face_position: [],
    landmark_description: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/BodyStructure#resource
pub type BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark {
  BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device: List(Codeablereference),
    value: List(Quantity),
  )
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark_new() -> BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark {
  BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark(
    value: [],
    device: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark_to_json(
  bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark: BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark,
) -> Json {
  let BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark(
    value:,
    device:,
    modifier_extension:,
    extension:,
    id:,
  ) =
    bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark
  let fields = []
  let fields = case value {
    [] -> fields
    _ -> [#("value", json.array(value, quantity_to_json)), ..fields]
  }
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, codeablereference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark_decoder() -> Decoder(
  BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark,
) {
  use value <- decode.optional_field(
    "value",
    [],
    decode.list(quantity_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    BodystructureIncludedstructureBodylandmarkorientationDistancefromlandmark(
      value:,
      device:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_to_json(
  bodystructure_includedstructure_bodylandmarkorientation: BodystructureIncludedstructureBodylandmarkorientation,
) -> Json {
  let BodystructureIncludedstructureBodylandmarkorientation(
    surface_orientation:,
    distance_from_landmark:,
    clock_face_position:,
    landmark_description:,
    modifier_extension:,
    extension:,
    id:,
  ) = bodystructure_includedstructure_bodylandmarkorientation
  let fields = []
  let fields = case surface_orientation {
    [] -> fields
    _ -> [
      #(
        "surfaceOrientation",
        json.array(surface_orientation, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case distance_from_landmark {
    [] -> fields
    _ -> [
      #(
        "distanceFromLandmark",
        json.array(
          distance_from_landmark,
          bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case clock_face_position {
    [] -> fields
    _ -> [
      #(
        "clockFacePosition",
        json.array(clock_face_position, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case landmark_description {
    [] -> fields
    _ -> [
      #(
        "landmarkDescription",
        json.array(landmark_description, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bodystructure_includedstructure_bodylandmarkorientation_decoder() -> Decoder(
  BodystructureIncludedstructureBodylandmarkorientation,
) {
  use surface_orientation <- decode.optional_field(
    "surfaceOrientation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use distance_from_landmark <- decode.optional_field(
    "distanceFromLandmark",
    [],
    decode.list(
      bodystructure_includedstructure_bodylandmarkorientation_distancefromlandmark_decoder(),
    ),
  )
  use clock_face_position <- decode.optional_field(
    "clockFacePosition",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use landmark_description <- decode.optional_field(
    "landmarkDescription",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BodystructureIncludedstructureBodylandmarkorientation(
    surface_orientation:,
    distance_from_landmark:,
    clock_face_position:,
    landmark_description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bodystructure_includedstructure_to_json(
  bodystructure_includedstructure: BodystructureIncludedstructure,
) -> Json {
  let BodystructureIncludedstructure(
    qualifier:,
    spatial_reference:,
    body_landmark_orientation:,
    laterality:,
    structure:,
    modifier_extension:,
    extension:,
    id:,
  ) = bodystructure_includedstructure
  let fields = [
    #("structure", codeableconcept_to_json(structure)),
  ]
  let fields = case qualifier {
    [] -> fields
    _ -> [
      #("qualifier", json.array(qualifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case spatial_reference {
    [] -> fields
    _ -> [
      #("spatialReference", json.array(spatial_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case body_landmark_orientation {
    [] -> fields
    _ -> [
      #(
        "bodyLandmarkOrientation",
        json.array(
          body_landmark_orientation,
          bodystructure_includedstructure_bodylandmarkorientation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case laterality {
    Some(v) -> [#("laterality", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bodystructure_includedstructure_decoder() -> Decoder(
  BodystructureIncludedstructure,
) {
  use qualifier <- decode.optional_field(
    "qualifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use spatial_reference <- decode.optional_field(
    "spatialReference",
    [],
    decode.list(reference_decoder()),
  )
  use body_landmark_orientation <- decode.optional_field(
    "bodyLandmarkOrientation",
    [],
    decode.list(
      bodystructure_includedstructure_bodylandmarkorientation_decoder(),
    ),
  )
  use laterality <- decode.optional_field(
    "laterality",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use structure <- decode.field("structure", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BodystructureIncludedstructure(
    qualifier:,
    spatial_reference:,
    body_landmark_orientation:,
    laterality:,
    structure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bodystructure_to_json(bodystructure: Bodystructure) -> Json {
  let Bodystructure(
    patient:,
    image:,
    description:,
    included_structure:,
    morphology:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = bodystructure
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case image {
    [] -> fields
    _ -> [#("image", json.array(image, attachment_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case included_structure {
    [] -> fields
    _ -> [
      #(
        "includedStructure",
        json.array(included_structure, bodystructure_includedstructure_to_json),
      ),
      ..fields
    ]
  }
  let fields = case morphology {
    Some(v) -> [#("morphology", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Bodystructure")), ..fields]
  json.object(fields)
}

pub fn bodystructure_decoder() -> Decoder(Bodystructure) {
  use patient <- decode.field("patient", reference_decoder())
  use image <- decode.optional_field(
    "image",
    [],
    decode.list(attachment_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use included_structure <- decode.optional_field(
    "includedStructure",
    [],
    decode.list(bodystructure_includedstructure_decoder()),
  )
  use morphology <- decode.optional_field(
    "morphology",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Bodystructure",
    decode.failure(bodystructure_new(patient:), "resourceType"),
  )
  decode.success(Bodystructure(
    patient:,
    image:,
    description:,
    included_structure:,
    morphology:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type Bundle {
  Bundle(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    identifier: Option(Identifier),
    type_: r5valuesets.Bundletype,
    timestamp: Option(String),
    total: Option(Int),
    link: List(BundleLink),
    entry: List(BundleEntry),
    signature: Option(Signature),
    issues: Option(Resource),
  )
}

pub fn bundle_new(type_ type_: r5valuesets.Bundletype) -> Bundle {
  Bundle(
    issues: None,
    signature: None,
    entry: [],
    link: [],
    total: None,
    timestamp: None,
    type_:,
    identifier: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type BundleLink {
  BundleLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relation: r5valuesets.Ianalinkrelations,
    url: String,
  )
}

pub fn bundle_link_new(
  url url: String,
  relation relation: r5valuesets.Ianalinkrelations,
) -> BundleLink {
  BundleLink(url:, relation:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type BundleEntry {
  BundleEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    full_url: Option(String),
    resource: Option(Resource),
    search: Option(BundleEntrySearch),
    request: Option(BundleEntryRequest),
    response: Option(BundleEntryResponse),
  )
}

pub fn bundle_entry_new() -> BundleEntry {
  BundleEntry(
    response: None,
    request: None,
    search: None,
    resource: None,
    full_url: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type BundleEntrySearch {
  BundleEntrySearch(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: Option(r5valuesets.Searchentrymode),
    score: Option(Float),
  )
}

pub fn bundle_entry_search_new() -> BundleEntrySearch {
  BundleEntrySearch(
    score: None,
    mode: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type BundleEntryRequest {
  BundleEntryRequest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    method: r5valuesets.Httpverb,
    url: String,
    if_none_match: Option(String),
    if_modified_since: Option(String),
    if_match: Option(String),
    if_none_exist: Option(String),
  )
}

pub fn bundle_entry_request_new(
  url url: String,
  method method: r5valuesets.Httpverb,
) -> BundleEntryRequest {
  BundleEntryRequest(
    if_none_exist: None,
    if_match: None,
    if_modified_since: None,
    if_none_match: None,
    url:,
    method:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Bundle#resource
pub type BundleEntryResponse {
  BundleEntryResponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: String,
    location: Option(String),
    etag: Option(String),
    last_modified: Option(String),
    outcome: Option(Resource),
  )
}

pub fn bundle_entry_response_new(status status: String) -> BundleEntryResponse {
  BundleEntryResponse(
    outcome: None,
    last_modified: None,
    etag: None,
    location: None,
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn bundle_entry_response_to_json(
  bundle_entry_response: BundleEntryResponse,
) -> Json {
  let BundleEntryResponse(
    outcome:,
    last_modified:,
    etag:,
    location:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry_response
  let fields = [
    #("status", json.string(status)),
  ]
  let fields = case outcome {
    Some(v) -> [#("outcome", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_modified {
    Some(v) -> [#("lastModified", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case etag {
    Some(v) -> [#("etag", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_response_decoder() -> Decoder(BundleEntryResponse) {
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(resource_decoder()),
  )
  use last_modified <- decode.optional_field(
    "lastModified",
    None,
    decode.optional(decode.string),
  )
  use etag <- decode.optional_field(
    "etag",
    None,
    decode.optional(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntryResponse(
    outcome:,
    last_modified:,
    etag:,
    location:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_request_to_json(
  bundle_entry_request: BundleEntryRequest,
) -> Json {
  let BundleEntryRequest(
    if_none_exist:,
    if_match:,
    if_modified_since:,
    if_none_match:,
    url:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry_request
  let fields = [
    #("url", json.string(url)),
    #("method", r5valuesets.httpverb_to_json(method)),
  ]
  let fields = case if_none_exist {
    Some(v) -> [#("ifNoneExist", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_match {
    Some(v) -> [#("ifMatch", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_modified_since {
    Some(v) -> [#("ifModifiedSince", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case if_none_match {
    Some(v) -> [#("ifNoneMatch", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_request_decoder() -> Decoder(BundleEntryRequest) {
  use if_none_exist <- decode.optional_field(
    "ifNoneExist",
    None,
    decode.optional(decode.string),
  )
  use if_match <- decode.optional_field(
    "ifMatch",
    None,
    decode.optional(decode.string),
  )
  use if_modified_since <- decode.optional_field(
    "ifModifiedSince",
    None,
    decode.optional(decode.string),
  )
  use if_none_match <- decode.optional_field(
    "ifNoneMatch",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use method <- decode.field("method", r5valuesets.httpverb_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntryRequest(
    if_none_exist:,
    if_match:,
    if_modified_since:,
    if_none_match:,
    url:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_search_to_json(
  bundle_entry_search: BundleEntrySearch,
) -> Json {
  let BundleEntrySearch(score:, mode:, modifier_extension:, extension:, id:) =
    bundle_entry_search
  let fields = []
  let fields = case score {
    Some(v) -> [#("score", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", r5valuesets.searchentrymode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_search_decoder() -> Decoder(BundleEntrySearch) {
  use score <- decode.optional_field(
    "score",
    None,
    decode.optional(decode.float),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r5valuesets.searchentrymode_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntrySearch(
    score:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_entry_to_json(bundle_entry: BundleEntry) -> Json {
  let BundleEntry(
    response:,
    request:,
    search:,
    resource:,
    full_url:,
    modifier_extension:,
    extension:,
    id:,
  ) = bundle_entry
  let fields = []
  let fields = case response {
    Some(v) -> [#("response", bundle_entry_response_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", bundle_entry_request_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case search {
    Some(v) -> [#("search", bundle_entry_search_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case full_url {
    Some(v) -> [#("fullUrl", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_entry_decoder() -> Decoder(BundleEntry) {
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(bundle_entry_response_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(bundle_entry_request_decoder()),
  )
  use search <- decode.optional_field(
    "search",
    None,
    decode.optional(bundle_entry_search_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(resource_decoder()),
  )
  use full_url <- decode.optional_field(
    "fullUrl",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleEntry(
    response:,
    request:,
    search:,
    resource:,
    full_url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_link_to_json(bundle_link: BundleLink) -> Json {
  let BundleLink(url:, relation:, modifier_extension:, extension:, id:) =
    bundle_link
  let fields = [
    #("url", json.string(url)),
    #("relation", r5valuesets.ianalinkrelations_to_json(relation)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn bundle_link_decoder() -> Decoder(BundleLink) {
  use url <- decode.field("url", decode.string)
  use relation <- decode.field(
    "relation",
    r5valuesets.ianalinkrelations_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(BundleLink(
    url:,
    relation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn bundle_to_json(bundle: Bundle) -> Json {
  let Bundle(
    issues:,
    signature:,
    entry:,
    link:,
    total:,
    timestamp:,
    type_:,
    identifier:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = bundle
  let fields = [
    #("type", r5valuesets.bundletype_to_json(type_)),
  ]
  let fields = case issues {
    Some(v) -> [#("issues", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case signature {
    Some(v) -> [#("signature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, bundle_entry_to_json)), ..fields]
  }
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, bundle_link_to_json)), ..fields]
  }
  let fields = case total {
    Some(v) -> [#("total", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case timestamp {
    Some(v) -> [#("timestamp", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Bundle")), ..fields]
  json.object(fields)
}

pub fn bundle_decoder() -> Decoder(Bundle) {
  use issues <- decode.optional_field(
    "issues",
    None,
    decode.optional(resource_decoder()),
  )
  use signature <- decode.optional_field(
    "signature",
    None,
    decode.optional(signature_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(bundle_entry_decoder()),
  )
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(bundle_link_decoder()),
  )
  use total <- decode.optional_field("total", None, decode.optional(decode.int))
  use timestamp <- decode.optional_field(
    "timestamp",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.bundletype_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Bundle",
    decode.failure(bundle_new(type_:), "resourceType"),
  )
  decode.success(Bundle(
    issues:,
    signature:,
    entry:,
    link:,
    total:,
    timestamp:,
    type_:,
    identifier:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CanonicalResource#resource
pub type Canonicalresource {
  Canonicalresource(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(CanonicalresourceVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CanonicalResource#resource
pub type CanonicalresourceVersionalgorithm {
  CanonicalresourceVersionalgorithmString(version_algorithm: String)
  CanonicalresourceVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn canonicalresource_versionalgorithm_to_json(
  elt: CanonicalresourceVersionalgorithm,
) -> Json {
  case elt {
    CanonicalresourceVersionalgorithmString(v) -> json.string(v)
    CanonicalresourceVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn canonicalresource_versionalgorithm_decoder() -> Decoder(
  CanonicalresourceVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(CanonicalresourceVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(CanonicalresourceVersionalgorithmCoding),
    ],
  )
}

pub fn canonicalresource_new(
  status status: r5valuesets.Publicationstatus,
) -> Canonicalresource {
  Canonicalresource(
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn canonicalresource_to_json(canonicalresource: Canonicalresource) -> Json {
  let Canonicalresource(
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = canonicalresource
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          CanonicalresourceVersionalgorithmString(_) -> "String"
          CanonicalresourceVersionalgorithmCoding(_) -> "Coding"
        },
        canonicalresource_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Canonicalresource")), ..fields]
  json.object(fields)
}

pub fn canonicalresource_decoder() -> Decoder(Canonicalresource) {
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(canonicalresource_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Canonicalresource",
    decode.failure(canonicalresource_new(status:), "resourceType"),
  )
  decode.success(Canonicalresource(
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type Capabilitystatement {
  Capabilitystatement(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(CapabilitystatementVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    kind: r5valuesets.Capabilitystatementkind,
    instantiates: List(String),
    imports: List(String),
    software: Option(CapabilitystatementSoftware),
    implementation: Option(CapabilitystatementImplementation),
    fhir_version: r5valuesets.Fhirversion,
    format: List(String),
    patch_format: List(String),
    accept_language: List(String),
    implementation_guide: List(String),
    rest: List(CapabilitystatementRest),
    messaging: List(CapabilitystatementMessaging),
    document: List(CapabilitystatementDocument),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementVersionalgorithm {
  CapabilitystatementVersionalgorithmString(version_algorithm: String)
  CapabilitystatementVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn capabilitystatement_versionalgorithm_to_json(
  elt: CapabilitystatementVersionalgorithm,
) -> Json {
  case elt {
    CapabilitystatementVersionalgorithmString(v) -> json.string(v)
    CapabilitystatementVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn capabilitystatement_versionalgorithm_decoder() -> Decoder(
  CapabilitystatementVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(CapabilitystatementVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(CapabilitystatementVersionalgorithmCoding),
    ],
  )
}

pub fn capabilitystatement_new(
  fhir_version fhir_version: r5valuesets.Fhirversion,
  kind kind: r5valuesets.Capabilitystatementkind,
  date date: String,
  status status: r5valuesets.Publicationstatus,
) -> Capabilitystatement {
  Capabilitystatement(
    document: [],
    messaging: [],
    rest: [],
    implementation_guide: [],
    accept_language: [],
    patch_format: [],
    format: [],
    fhir_version:,
    implementation: None,
    software: None,
    imports: [],
    instantiates: [],
    kind:,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementSoftware {
  CapabilitystatementSoftware(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    version: Option(String),
    release_date: Option(String),
  )
}

pub fn capabilitystatement_software_new(
  name name: String,
) -> CapabilitystatementSoftware {
  CapabilitystatementSoftware(
    release_date: None,
    version: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementImplementation {
  CapabilitystatementImplementation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    url: Option(String),
    custodian: Option(Reference),
  )
}

pub fn capabilitystatement_implementation_new(
  description description: String,
) -> CapabilitystatementImplementation {
  CapabilitystatementImplementation(
    custodian: None,
    url: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRest {
  CapabilitystatementRest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r5valuesets.Restfulcapabilitymode,
    documentation: Option(String),
    security: Option(CapabilitystatementRestSecurity),
    resource: List(CapabilitystatementRestResource),
    interaction: List(CapabilitystatementRestInteraction),
    compartment: List(String),
  )
}

pub fn capabilitystatement_rest_new(
  mode mode: r5valuesets.Restfulcapabilitymode,
) -> CapabilitystatementRest {
  CapabilitystatementRest(
    compartment: [],
    interaction: [],
    resource: [],
    security: None,
    documentation: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestSecurity {
  CapabilitystatementRestSecurity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    cors: Option(Bool),
    service: List(Codeableconcept),
    description: Option(String),
  )
}

pub fn capabilitystatement_rest_security_new() -> CapabilitystatementRestSecurity {
  CapabilitystatementRestSecurity(
    description: None,
    service: [],
    cors: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResource {
  CapabilitystatementRestResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Resourcetypes,
    profile: Option(String),
    supported_profile: List(String),
    documentation: Option(String),
    interaction: List(CapabilitystatementRestResourceInteraction),
    versioning: Option(r5valuesets.Versioningpolicy),
    read_history: Option(Bool),
    update_create: Option(Bool),
    conditional_create: Option(Bool),
    conditional_read: Option(r5valuesets.Conditionalreadstatus),
    conditional_update: Option(Bool),
    conditional_patch: Option(Bool),
    conditional_delete: Option(r5valuesets.Conditionaldeletestatus),
    reference_policy: List(r5valuesets.Referencehandlingpolicy),
    search_include: List(String),
    search_rev_include: List(String),
    search_param: List(CapabilitystatementRestResourceSearchparam),
    operation: List(CapabilitystatementRestResourceOperation),
  )
}

pub fn capabilitystatement_rest_resource_new(
  type_ type_: r5valuesets.Resourcetypes,
) -> CapabilitystatementRestResource {
  CapabilitystatementRestResource(
    operation: [],
    search_param: [],
    search_rev_include: [],
    search_include: [],
    reference_policy: [],
    conditional_delete: None,
    conditional_patch: None,
    conditional_update: None,
    conditional_read: None,
    conditional_create: None,
    update_create: None,
    read_history: None,
    versioning: None,
    interaction: [],
    documentation: None,
    supported_profile: [],
    profile: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceInteraction {
  CapabilitystatementRestResourceInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Typerestfulinteraction,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_interaction_new(
  code code: r5valuesets.Typerestfulinteraction,
) -> CapabilitystatementRestResourceInteraction {
  CapabilitystatementRestResourceInteraction(
    documentation: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceSearchparam {
  CapabilitystatementRestResourceSearchparam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    definition: Option(String),
    type_: r5valuesets.Searchparamtype,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_searchparam_new(
  type_ type_: r5valuesets.Searchparamtype,
  name name: String,
) -> CapabilitystatementRestResourceSearchparam {
  CapabilitystatementRestResourceSearchparam(
    documentation: None,
    type_:,
    definition: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestResourceOperation {
  CapabilitystatementRestResourceOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    definition: String,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_resource_operation_new(
  definition definition: String,
  name name: String,
) -> CapabilitystatementRestResourceOperation {
  CapabilitystatementRestResourceOperation(
    documentation: None,
    definition:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementRestInteraction {
  CapabilitystatementRestInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Systemrestfulinteraction,
    documentation: Option(String),
  )
}

pub fn capabilitystatement_rest_interaction_new(
  code code: r5valuesets.Systemrestfulinteraction,
) -> CapabilitystatementRestInteraction {
  CapabilitystatementRestInteraction(
    documentation: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessaging {
  CapabilitystatementMessaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    endpoint: List(CapabilitystatementMessagingEndpoint),
    reliable_cache: Option(Int),
    documentation: Option(String),
    supported_message: List(CapabilitystatementMessagingSupportedmessage),
  )
}

pub fn capabilitystatement_messaging_new() -> CapabilitystatementMessaging {
  CapabilitystatementMessaging(
    supported_message: [],
    documentation: None,
    reliable_cache: None,
    endpoint: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingEndpoint {
  CapabilitystatementMessagingEndpoint(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    protocol: Coding,
    address: String,
  )
}

pub fn capabilitystatement_messaging_endpoint_new(
  address address: String,
  protocol protocol: Coding,
) -> CapabilitystatementMessagingEndpoint {
  CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementMessagingSupportedmessage {
  CapabilitystatementMessagingSupportedmessage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r5valuesets.Eventcapabilitymode,
    definition: String,
  )
}

pub fn capabilitystatement_messaging_supportedmessage_new(
  definition definition: String,
  mode mode: r5valuesets.Eventcapabilitymode,
) -> CapabilitystatementMessagingSupportedmessage {
  CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CapabilityStatement#resource
pub type CapabilitystatementDocument {
  CapabilitystatementDocument(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r5valuesets.Documentmode,
    documentation: Option(String),
    profile: String,
  )
}

pub fn capabilitystatement_document_new(
  profile profile: String,
  mode mode: r5valuesets.Documentmode,
) -> CapabilitystatementDocument {
  CapabilitystatementDocument(
    profile:,
    documentation: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn capabilitystatement_document_to_json(
  capabilitystatement_document: CapabilitystatementDocument,
) -> Json {
  let CapabilitystatementDocument(
    profile:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_document
  let fields = [
    #("profile", json.string(profile)),
    #("mode", r5valuesets.documentmode_to_json(mode)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_document_decoder() -> Decoder(
  CapabilitystatementDocument,
) {
  use profile <- decode.field("profile", decode.string)
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.documentmode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementDocument(
    profile:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_supportedmessage_to_json(
  capabilitystatement_messaging_supportedmessage: CapabilitystatementMessagingSupportedmessage,
) -> Json {
  let CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging_supportedmessage
  let fields = [
    #("definition", json.string(definition)),
    #("mode", r5valuesets.eventcapabilitymode_to_json(mode)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_supportedmessage_decoder() -> Decoder(
  CapabilitystatementMessagingSupportedmessage,
) {
  use definition <- decode.field("definition", decode.string)
  use mode <- decode.field("mode", r5valuesets.eventcapabilitymode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessagingSupportedmessage(
    definition:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_endpoint_to_json(
  capabilitystatement_messaging_endpoint: CapabilitystatementMessagingEndpoint,
) -> Json {
  let CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging_endpoint
  let fields = [
    #("address", json.string(address)),
    #("protocol", coding_to_json(protocol)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_endpoint_decoder() -> Decoder(
  CapabilitystatementMessagingEndpoint,
) {
  use address <- decode.field("address", decode.string)
  use protocol <- decode.field("protocol", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessagingEndpoint(
    address:,
    protocol:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_messaging_to_json(
  capabilitystatement_messaging: CapabilitystatementMessaging,
) -> Json {
  let CapabilitystatementMessaging(
    supported_message:,
    documentation:,
    reliable_cache:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_messaging
  let fields = []
  let fields = case supported_message {
    [] -> fields
    _ -> [
      #(
        "supportedMessage",
        json.array(
          supported_message,
          capabilitystatement_messaging_supportedmessage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reliable_cache {
    Some(v) -> [#("reliableCache", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [
      #(
        "endpoint",
        json.array(endpoint, capabilitystatement_messaging_endpoint_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_messaging_decoder() -> Decoder(
  CapabilitystatementMessaging,
) {
  use supported_message <- decode.optional_field(
    "supportedMessage",
    [],
    decode.list(capabilitystatement_messaging_supportedmessage_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use reliable_cache <- decode.optional_field(
    "reliableCache",
    None,
    decode.optional(decode.int),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(capabilitystatement_messaging_endpoint_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementMessaging(
    supported_message:,
    documentation:,
    reliable_cache:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_interaction_to_json(
  capabilitystatement_rest_interaction: CapabilitystatementRestInteraction,
) -> Json {
  let CapabilitystatementRestInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_interaction
  let fields = [
    #("code", r5valuesets.systemrestfulinteraction_to_json(code)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_interaction_decoder() -> Decoder(
  CapabilitystatementRestInteraction,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field(
    "code",
    r5valuesets.systemrestfulinteraction_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_operation_to_json(
  capabilitystatement_rest_resource_operation: CapabilitystatementRestResourceOperation,
) -> Json {
  let CapabilitystatementRestResourceOperation(
    documentation:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_operation
  let fields = [
    #("definition", json.string(definition)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_operation_decoder() -> Decoder(
  CapabilitystatementRestResourceOperation,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.field("definition", decode.string)
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceOperation(
    documentation:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_searchparam_to_json(
  capabilitystatement_rest_resource_searchparam: CapabilitystatementRestResourceSearchparam,
) -> Json {
  let CapabilitystatementRestResourceSearchparam(
    documentation:,
    type_:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_searchparam
  let fields = [
    #("type", r5valuesets.searchparamtype_to_json(type_)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_searchparam_decoder() -> Decoder(
  CapabilitystatementRestResourceSearchparam,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.searchparamtype_decoder())
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceSearchparam(
    documentation:,
    type_:,
    definition:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_interaction_to_json(
  capabilitystatement_rest_resource_interaction: CapabilitystatementRestResourceInteraction,
) -> Json {
  let CapabilitystatementRestResourceInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource_interaction
  let fields = [
    #("code", r5valuesets.typerestfulinteraction_to_json(code)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_interaction_decoder() -> Decoder(
  CapabilitystatementRestResourceInteraction,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", r5valuesets.typerestfulinteraction_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResourceInteraction(
    documentation:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_resource_to_json(
  capabilitystatement_rest_resource: CapabilitystatementRestResource,
) -> Json {
  let CapabilitystatementRestResource(
    operation:,
    search_param:,
    search_rev_include:,
    search_include:,
    reference_policy:,
    conditional_delete:,
    conditional_patch:,
    conditional_update:,
    conditional_read:,
    conditional_create:,
    update_create:,
    read_history:,
    versioning:,
    interaction:,
    documentation:,
    supported_profile:,
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_resource
  let fields = [
    #("type", r5valuesets.resourcetypes_to_json(type_)),
  ]
  let fields = case operation {
    [] -> fields
    _ -> [
      #(
        "operation",
        json.array(
          operation,
          capabilitystatement_rest_resource_operation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case search_param {
    [] -> fields
    _ -> [
      #(
        "searchParam",
        json.array(
          search_param,
          capabilitystatement_rest_resource_searchparam_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case search_rev_include {
    [] -> fields
    _ -> [
      #("searchRevInclude", json.array(search_rev_include, json.string)),
      ..fields
    ]
  }
  let fields = case search_include {
    [] -> fields
    _ -> [#("searchInclude", json.array(search_include, json.string)), ..fields]
  }
  let fields = case reference_policy {
    [] -> fields
    _ -> [
      #(
        "referencePolicy",
        json.array(
          reference_policy,
          r5valuesets.referencehandlingpolicy_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case conditional_delete {
    Some(v) -> [
      #("conditionalDelete", r5valuesets.conditionaldeletestatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case conditional_patch {
    Some(v) -> [#("conditionalPatch", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case conditional_update {
    Some(v) -> [#("conditionalUpdate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case conditional_read {
    Some(v) -> [
      #("conditionalRead", r5valuesets.conditionalreadstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case conditional_create {
    Some(v) -> [#("conditionalCreate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case update_create {
    Some(v) -> [#("updateCreate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case read_history {
    Some(v) -> [#("readHistory", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case versioning {
    Some(v) -> [
      #("versioning", r5valuesets.versioningpolicy_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case interaction {
    [] -> fields
    _ -> [
      #(
        "interaction",
        json.array(
          interaction,
          capabilitystatement_rest_resource_interaction_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supported_profile {
    [] -> fields
    _ -> [
      #("supportedProfile", json.array(supported_profile, json.string)),
      ..fields
    ]
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_resource_decoder() -> Decoder(
  CapabilitystatementRestResource,
) {
  use operation <- decode.optional_field(
    "operation",
    [],
    decode.list(capabilitystatement_rest_resource_operation_decoder()),
  )
  use search_param <- decode.optional_field(
    "searchParam",
    [],
    decode.list(capabilitystatement_rest_resource_searchparam_decoder()),
  )
  use search_rev_include <- decode.optional_field(
    "searchRevInclude",
    [],
    decode.list(decode.string),
  )
  use search_include <- decode.optional_field(
    "searchInclude",
    [],
    decode.list(decode.string),
  )
  use reference_policy <- decode.optional_field(
    "referencePolicy",
    [],
    decode.list(r5valuesets.referencehandlingpolicy_decoder()),
  )
  use conditional_delete <- decode.optional_field(
    "conditionalDelete",
    None,
    decode.optional(r5valuesets.conditionaldeletestatus_decoder()),
  )
  use conditional_patch <- decode.optional_field(
    "conditionalPatch",
    None,
    decode.optional(decode.bool),
  )
  use conditional_update <- decode.optional_field(
    "conditionalUpdate",
    None,
    decode.optional(decode.bool),
  )
  use conditional_read <- decode.optional_field(
    "conditionalRead",
    None,
    decode.optional(r5valuesets.conditionalreadstatus_decoder()),
  )
  use conditional_create <- decode.optional_field(
    "conditionalCreate",
    None,
    decode.optional(decode.bool),
  )
  use update_create <- decode.optional_field(
    "updateCreate",
    None,
    decode.optional(decode.bool),
  )
  use read_history <- decode.optional_field(
    "readHistory",
    None,
    decode.optional(decode.bool),
  )
  use versioning <- decode.optional_field(
    "versioning",
    None,
    decode.optional(r5valuesets.versioningpolicy_decoder()),
  )
  use interaction <- decode.optional_field(
    "interaction",
    [],
    decode.list(capabilitystatement_rest_resource_interaction_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use supported_profile <- decode.optional_field(
    "supportedProfile",
    [],
    decode.list(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestResource(
    operation:,
    search_param:,
    search_rev_include:,
    search_include:,
    reference_policy:,
    conditional_delete:,
    conditional_patch:,
    conditional_update:,
    conditional_read:,
    conditional_create:,
    update_create:,
    read_history:,
    versioning:,
    interaction:,
    documentation:,
    supported_profile:,
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_security_to_json(
  capabilitystatement_rest_security: CapabilitystatementRestSecurity,
) -> Json {
  let CapabilitystatementRestSecurity(
    description:,
    service:,
    cors:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest_security
  let fields = []
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case service {
    [] -> fields
    _ -> [#("service", json.array(service, codeableconcept_to_json)), ..fields]
  }
  let fields = case cors {
    Some(v) -> [#("cors", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_security_decoder() -> Decoder(
  CapabilitystatementRestSecurity,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use service <- decode.optional_field(
    "service",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use cors <- decode.optional_field("cors", None, decode.optional(decode.bool))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRestSecurity(
    description:,
    service:,
    cors:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_rest_to_json(
  capabilitystatement_rest: CapabilitystatementRest,
) -> Json {
  let CapabilitystatementRest(
    compartment:,
    interaction:,
    resource:,
    security:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_rest
  let fields = [
    #("mode", r5valuesets.restfulcapabilitymode_to_json(mode)),
  ]
  let fields = case compartment {
    [] -> fields
    _ -> [#("compartment", json.array(compartment, json.string)), ..fields]
  }
  let fields = case interaction {
    [] -> fields
    _ -> [
      #(
        "interaction",
        json.array(interaction, capabilitystatement_rest_interaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, capabilitystatement_rest_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case security {
    Some(v) -> [
      #("security", capabilitystatement_rest_security_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_rest_decoder() -> Decoder(CapabilitystatementRest) {
  use compartment <- decode.optional_field(
    "compartment",
    [],
    decode.list(decode.string),
  )
  use interaction <- decode.optional_field(
    "interaction",
    [],
    decode.list(capabilitystatement_rest_interaction_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(capabilitystatement_rest_resource_decoder()),
  )
  use security <- decode.optional_field(
    "security",
    None,
    decode.optional(capabilitystatement_rest_security_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.restfulcapabilitymode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementRest(
    compartment:,
    interaction:,
    resource:,
    security:,
    documentation:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_implementation_to_json(
  capabilitystatement_implementation: CapabilitystatementImplementation,
) -> Json {
  let CapabilitystatementImplementation(
    custodian:,
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_implementation
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_implementation_decoder() -> Decoder(
  CapabilitystatementImplementation,
) {
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementImplementation(
    custodian:,
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_software_to_json(
  capabilitystatement_software: CapabilitystatementSoftware,
) -> Json {
  let CapabilitystatementSoftware(
    release_date:,
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = capabilitystatement_software
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case release_date {
    Some(v) -> [#("releaseDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn capabilitystatement_software_decoder() -> Decoder(
  CapabilitystatementSoftware,
) {
  use release_date <- decode.optional_field(
    "releaseDate",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CapabilitystatementSoftware(
    release_date:,
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn capabilitystatement_to_json(
  capabilitystatement: Capabilitystatement,
) -> Json {
  let Capabilitystatement(
    document:,
    messaging:,
    rest:,
    implementation_guide:,
    accept_language:,
    patch_format:,
    format:,
    fhir_version:,
    implementation:,
    software:,
    imports:,
    instantiates:,
    kind:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = capabilitystatement
  let fields = [
    #("fhirVersion", r5valuesets.fhirversion_to_json(fhir_version)),
    #("kind", r5valuesets.capabilitystatementkind_to_json(kind)),
    #("date", json.string(date)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case document {
    [] -> fields
    _ -> [
      #("document", json.array(document, capabilitystatement_document_to_json)),
      ..fields
    ]
  }
  let fields = case messaging {
    [] -> fields
    _ -> [
      #(
        "messaging",
        json.array(messaging, capabilitystatement_messaging_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rest {
    [] -> fields
    _ -> [
      #("rest", json.array(rest, capabilitystatement_rest_to_json)),
      ..fields
    ]
  }
  let fields = case implementation_guide {
    [] -> fields
    _ -> [
      #("implementationGuide", json.array(implementation_guide, json.string)),
      ..fields
    ]
  }
  let fields = case accept_language {
    [] -> fields
    _ -> [
      #("acceptLanguage", json.array(accept_language, json.string)),
      ..fields
    ]
  }
  let fields = case patch_format {
    [] -> fields
    _ -> [#("patchFormat", json.array(patch_format, json.string)), ..fields]
  }
  let fields = case format {
    [] -> fields
    _ -> [#("format", json.array(format, json.string)), ..fields]
  }
  let fields = case implementation {
    Some(v) -> [
      #("implementation", capabilitystatement_implementation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [
      #("software", capabilitystatement_software_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case imports {
    [] -> fields
    _ -> [#("imports", json.array(imports, json.string)), ..fields]
  }
  let fields = case instantiates {
    [] -> fields
    _ -> [#("instantiates", json.array(instantiates, json.string)), ..fields]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          CapabilitystatementVersionalgorithmString(_) -> "String"
          CapabilitystatementVersionalgorithmCoding(_) -> "Coding"
        },
        capabilitystatement_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Capabilitystatement")), ..fields]
  json.object(fields)
}

pub fn capabilitystatement_decoder() -> Decoder(Capabilitystatement) {
  use document <- decode.optional_field(
    "document",
    [],
    decode.list(capabilitystatement_document_decoder()),
  )
  use messaging <- decode.optional_field(
    "messaging",
    [],
    decode.list(capabilitystatement_messaging_decoder()),
  )
  use rest <- decode.optional_field(
    "rest",
    [],
    decode.list(capabilitystatement_rest_decoder()),
  )
  use implementation_guide <- decode.optional_field(
    "implementationGuide",
    [],
    decode.list(decode.string),
  )
  use accept_language <- decode.optional_field(
    "acceptLanguage",
    [],
    decode.list(decode.string),
  )
  use patch_format <- decode.optional_field(
    "patchFormat",
    [],
    decode.list(decode.string),
  )
  use format <- decode.optional_field("format", [], decode.list(decode.string))
  use fhir_version <- decode.field(
    "fhirVersion",
    r5valuesets.fhirversion_decoder(),
  )
  use implementation <- decode.optional_field(
    "implementation",
    None,
    decode.optional(capabilitystatement_implementation_decoder()),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(capabilitystatement_software_decoder()),
  )
  use imports <- decode.optional_field(
    "imports",
    [],
    decode.list(decode.string),
  )
  use instantiates <- decode.optional_field(
    "instantiates",
    [],
    decode.list(decode.string),
  )
  use kind <- decode.field(
    "kind",
    r5valuesets.capabilitystatementkind_decoder(),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(capabilitystatement_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Capabilitystatement",
    decode.failure(
      capabilitystatement_new(fhir_version:, kind:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Capabilitystatement(
    document:,
    messaging:,
    rest:,
    implementation_guide:,
    accept_language:,
    patch_format:,
    format:,
    fhir_version:,
    implementation:,
    software:,
    imports:,
    instantiates:,
    kind:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CarePlan#resource
pub type Careplan {
  Careplan(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Requeststatus,
    intent: r5valuesets.Careplanintent,
    category: List(Codeableconcept),
    title: Option(String),
    description: Option(String),
    subject: Reference,
    encounter: Option(Reference),
    period: Option(Period),
    created: Option(String),
    custodian: Option(Reference),
    contributor: List(Reference),
    care_team: List(Reference),
    addresses: List(Codeablereference),
    supporting_info: List(Reference),
    goal: List(Reference),
    activity: List(CareplanActivity),
    note: List(Annotation),
  )
}

pub fn careplan_new(
  subject subject: Reference,
  intent intent: r5valuesets.Careplanintent,
  status status: r5valuesets.Requeststatus,
) -> Careplan {
  Careplan(
    note: [],
    activity: [],
    goal: [],
    supporting_info: [],
    addresses: [],
    care_team: [],
    contributor: [],
    custodian: None,
    created: None,
    period: None,
    encounter: None,
    subject:,
    description: None,
    title: None,
    category: [],
    intent:,
    status:,
    part_of: [],
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CarePlan#resource
pub type CareplanActivity {
  CareplanActivity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    performed_activity: List(Codeablereference),
    progress: List(Annotation),
    planned_activity_reference: Option(Reference),
  )
}

pub fn careplan_activity_new() -> CareplanActivity {
  CareplanActivity(
    planned_activity_reference: None,
    progress: [],
    performed_activity: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn careplan_activity_to_json(careplan_activity: CareplanActivity) -> Json {
  let CareplanActivity(
    planned_activity_reference:,
    progress:,
    performed_activity:,
    modifier_extension:,
    extension:,
    id:,
  ) = careplan_activity
  let fields = []
  let fields = case planned_activity_reference {
    Some(v) -> [#("plannedActivityReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case progress {
    [] -> fields
    _ -> [#("progress", json.array(progress, annotation_to_json)), ..fields]
  }
  let fields = case performed_activity {
    [] -> fields
    _ -> [
      #(
        "performedActivity",
        json.array(performed_activity, codeablereference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn careplan_activity_decoder() -> Decoder(CareplanActivity) {
  use planned_activity_reference <- decode.optional_field(
    "plannedActivityReference",
    None,
    decode.optional(reference_decoder()),
  )
  use progress <- decode.optional_field(
    "progress",
    [],
    decode.list(annotation_decoder()),
  )
  use performed_activity <- decode.optional_field(
    "performedActivity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CareplanActivity(
    planned_activity_reference:,
    progress:,
    performed_activity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn careplan_to_json(careplan: Careplan) -> Json {
  let Careplan(
    note:,
    activity:,
    goal:,
    supporting_info:,
    addresses:,
    care_team:,
    contributor:,
    custodian:,
    created:,
    period:,
    encounter:,
    subject:,
    description:,
    title:,
    category:,
    intent:,
    status:,
    part_of:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = careplan
  let fields = [
    #("subject", reference_to_json(subject)),
    #("intent", r5valuesets.careplanintent_to_json(intent)),
    #("status", r5valuesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case activity {
    [] -> fields
    _ -> [
      #("activity", json.array(activity, careplan_activity_to_json)),
      ..fields
    ]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, reference_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [
      #("addresses", json.array(addresses, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [#("careTeam", json.array(care_team, reference_to_json)), ..fields]
  }
  let fields = case contributor {
    [] -> fields
    _ -> [
      #("contributor", json.array(contributor, reference_to_json)),
      ..fields
    ]
  }
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Careplan")), ..fields]
  json.object(fields)
}

pub fn careplan_decoder() -> Decoder(Careplan) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use activity <- decode.optional_field(
    "activity",
    [],
    decode.list(careplan_activity_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(codeablereference_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(reference_decoder()),
  )
  use contributor <- decode.optional_field(
    "contributor",
    [],
    decode.list(reference_decoder()),
  )
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.careplanintent_decoder())
  use status <- decode.field("status", r5valuesets.requeststatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Careplan",
    decode.failure(careplan_new(subject:, intent:, status:), "resourceType"),
  )
  decode.success(Careplan(
    note:,
    activity:,
    goal:,
    supporting_info:,
    addresses:,
    care_team:,
    contributor:,
    custodian:,
    created:,
    period:,
    encounter:,
    subject:,
    description:,
    title:,
    category:,
    intent:,
    status:,
    part_of:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CareTeam#resource
pub type Careteam {
  Careteam(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Careteamstatus),
    category: List(Codeableconcept),
    name: Option(String),
    subject: Option(Reference),
    period: Option(Period),
    participant: List(CareteamParticipant),
    reason: List(Codeablereference),
    managing_organization: List(Reference),
    telecom: List(Contactpoint),
    note: List(Annotation),
  )
}

pub fn careteam_new() -> Careteam {
  Careteam(
    note: [],
    telecom: [],
    managing_organization: [],
    reason: [],
    participant: [],
    period: None,
    subject: None,
    name: None,
    category: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CareTeam#resource
pub type CareteamParticipant {
  CareteamParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    member: Option(Reference),
    on_behalf_of: Option(Reference),
    coverage: Option(CareteamParticipantCoverage),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CareTeam#resource
pub type CareteamParticipantCoverage {
  CareteamParticipantCoveragePeriod(coverage: Period)
  CareteamParticipantCoverageTiming(coverage: Timing)
}

pub fn careteam_participant_coverage_to_json(
  elt: CareteamParticipantCoverage,
) -> Json {
  case elt {
    CareteamParticipantCoveragePeriod(v) -> period_to_json(v)
    CareteamParticipantCoverageTiming(v) -> timing_to_json(v)
  }
}

pub fn careteam_participant_coverage_decoder() -> Decoder(
  CareteamParticipantCoverage,
) {
  decode.one_of(
    decode.field("coveragePeriod", period_decoder(), decode.success)
      |> decode.map(CareteamParticipantCoveragePeriod),
    [
      decode.field("coverageTiming", timing_decoder(), decode.success)
      |> decode.map(CareteamParticipantCoverageTiming),
    ],
  )
}

pub fn careteam_participant_new() -> CareteamParticipant {
  CareteamParticipant(
    coverage: None,
    on_behalf_of: None,
    member: None,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn careteam_participant_to_json(
  careteam_participant: CareteamParticipant,
) -> Json {
  let CareteamParticipant(
    coverage:,
    on_behalf_of:,
    member:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = careteam_participant
  let fields = []
  let fields = case coverage {
    Some(v) -> [
      #(
        "coverage"
          <> case v {
          CareteamParticipantCoveragePeriod(_) -> "Period"
          CareteamParticipantCoverageTiming(_) -> "Timing"
        },
        careteam_participant_coverage_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case member {
    Some(v) -> [#("member", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn careteam_participant_decoder() -> Decoder(CareteamParticipant) {
  use coverage <- decode.then(
    none_if_omitted(careteam_participant_coverage_decoder()),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use member <- decode.optional_field(
    "member",
    None,
    decode.optional(reference_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CareteamParticipant(
    coverage:,
    on_behalf_of:,
    member:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn careteam_to_json(careteam: Careteam) -> Json {
  let Careteam(
    note:,
    telecom:,
    managing_organization:,
    reason:,
    participant:,
    period:,
    subject:,
    name:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = careteam
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case managing_organization {
    [] -> fields
    _ -> [
      #(
        "managingOrganization",
        json.array(managing_organization, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, careteam_participant_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.careteamstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Careteam")), ..fields]
  json.object(fields)
}

pub fn careteam_decoder() -> Decoder(Careteam) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(careteam_participant_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.careteamstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Careteam",
    decode.failure(careteam_new(), "resourceType"),
  )
  decode.success(Careteam(
    note:,
    telecom:,
    managing_organization:,
    reason:,
    participant:,
    period:,
    subject:,
    name:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItem#resource
pub type Chargeitem {
  Chargeitem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    definition_uri: List(String),
    definition_canonical: List(String),
    status: r5valuesets.Chargeitemstatus,
    part_of: List(Reference),
    code: Codeableconcept,
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(ChargeitemOccurrence),
    performer: List(ChargeitemPerformer),
    performing_organization: Option(Reference),
    requesting_organization: Option(Reference),
    cost_center: Option(Reference),
    quantity: Option(Quantity),
    bodysite: List(Codeableconcept),
    unit_price_component: Option(Monetarycomponent),
    total_price_component: Option(Monetarycomponent),
    override_reason: Option(Codeableconcept),
    enterer: Option(Reference),
    entered_date: Option(String),
    reason: List(Codeableconcept),
    service: List(Codeablereference),
    product: List(Codeablereference),
    account: List(Reference),
    note: List(Annotation),
    supporting_information: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItem#resource
pub type ChargeitemOccurrence {
  ChargeitemOccurrenceDatetime(occurrence: String)
  ChargeitemOccurrencePeriod(occurrence: Period)
  ChargeitemOccurrenceTiming(occurrence: Timing)
}

pub fn chargeitem_occurrence_to_json(elt: ChargeitemOccurrence) -> Json {
  case elt {
    ChargeitemOccurrenceDatetime(v) -> json.string(v)
    ChargeitemOccurrencePeriod(v) -> period_to_json(v)
    ChargeitemOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn chargeitem_occurrence_decoder() -> Decoder(ChargeitemOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ChargeitemOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ChargeitemOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ChargeitemOccurrenceTiming),
    ],
  )
}

pub fn chargeitem_new(
  subject subject: Reference,
  code code: Codeableconcept,
  status status: r5valuesets.Chargeitemstatus,
) -> Chargeitem {
  Chargeitem(
    supporting_information: [],
    note: [],
    account: [],
    product: [],
    service: [],
    reason: [],
    entered_date: None,
    enterer: None,
    override_reason: None,
    total_price_component: None,
    unit_price_component: None,
    bodysite: [],
    quantity: None,
    cost_center: None,
    requesting_organization: None,
    performing_organization: None,
    performer: [],
    occurrence: None,
    encounter: None,
    subject:,
    code:,
    part_of: [],
    status:,
    definition_canonical: [],
    definition_uri: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItem#resource
pub type ChargeitemPerformer {
  ChargeitemPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn chargeitem_performer_new(actor actor: Reference) -> ChargeitemPerformer {
  ChargeitemPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn chargeitem_performer_to_json(
  chargeitem_performer: ChargeitemPerformer,
) -> Json {
  let ChargeitemPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitem_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitem_performer_decoder() -> Decoder(ChargeitemPerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitem_to_json(chargeitem: Chargeitem) -> Json {
  let Chargeitem(
    supporting_information:,
    note:,
    account:,
    product:,
    service:,
    reason:,
    entered_date:,
    enterer:,
    override_reason:,
    total_price_component:,
    unit_price_component:,
    bodysite:,
    quantity:,
    cost_center:,
    requesting_organization:,
    performing_organization:,
    performer:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    part_of:,
    status:,
    definition_canonical:,
    definition_uri:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = chargeitem
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.chargeitemstatus_to_json(status)),
  ]
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case product {
    [] -> fields
    _ -> [
      #("product", json.array(product, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case service {
    [] -> fields
    _ -> [
      #("service", json.array(service, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case entered_date {
    Some(v) -> [#("enteredDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case override_reason {
    Some(v) -> [#("overrideReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total_price_component {
    Some(v) -> [
      #("totalPriceComponent", monetarycomponent_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case unit_price_component {
    Some(v) -> [#("unitPriceComponent", monetarycomponent_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case bodysite {
    [] -> fields
    _ -> [
      #("bodysite", json.array(bodysite, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cost_center {
    Some(v) -> [#("costCenter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requesting_organization {
    Some(v) -> [#("requestingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performing_organization {
    Some(v) -> [#("performingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, chargeitem_performer_to_json)),
      ..fields
    ]
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ChargeitemOccurrenceDatetime(_) -> "Datetime"
          ChargeitemOccurrencePeriod(_) -> "Period"
          ChargeitemOccurrenceTiming(_) -> "Timing"
        },
        chargeitem_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case definition_canonical {
    [] -> fields
    _ -> [
      #("definitionCanonical", json.array(definition_canonical, json.string)),
      ..fields
    ]
  }
  let fields = case definition_uri {
    [] -> fields
    _ -> [#("definitionUri", json.array(definition_uri, json.string)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Chargeitem")), ..fields]
  json.object(fields)
}

pub fn chargeitem_decoder() -> Decoder(Chargeitem) {
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use product <- decode.optional_field(
    "product",
    [],
    decode.list(codeablereference_decoder()),
  )
  use service <- decode.optional_field(
    "service",
    [],
    decode.list(codeablereference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use entered_date <- decode.optional_field(
    "enteredDate",
    None,
    decode.optional(decode.string),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use override_reason <- decode.optional_field(
    "overrideReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use total_price_component <- decode.optional_field(
    "totalPriceComponent",
    None,
    decode.optional(monetarycomponent_decoder()),
  )
  use unit_price_component <- decode.optional_field(
    "unitPriceComponent",
    None,
    decode.optional(monetarycomponent_decoder()),
  )
  use bodysite <- decode.optional_field(
    "bodysite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use cost_center <- decode.optional_field(
    "costCenter",
    None,
    decode.optional(reference_decoder()),
  )
  use requesting_organization <- decode.optional_field(
    "requestingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use performing_organization <- decode.optional_field(
    "performingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(chargeitem_performer_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(chargeitem_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.field("status", r5valuesets.chargeitemstatus_decoder())
  use definition_canonical <- decode.optional_field(
    "definitionCanonical",
    [],
    decode.list(decode.string),
  )
  use definition_uri <- decode.optional_field(
    "definitionUri",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Chargeitem",
    decode.failure(chargeitem_new(subject:, code:, status:), "resourceType"),
  )
  decode.success(Chargeitem(
    supporting_information:,
    note:,
    account:,
    product:,
    service:,
    reason:,
    entered_date:,
    enterer:,
    override_reason:,
    total_price_component:,
    unit_price_component:,
    bodysite:,
    quantity:,
    cost_center:,
    requesting_organization:,
    performing_organization:,
    performer:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    part_of:,
    status:,
    definition_canonical:,
    definition_uri:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItemDefinition#resource
pub type Chargeitemdefinition {
  Chargeitemdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ChargeitemdefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    derived_from_uri: List(String),
    part_of: List(String),
    replaces: List(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    code: Option(Codeableconcept),
    instance: List(Reference),
    applicability: List(ChargeitemdefinitionApplicability),
    property_group: List(ChargeitemdefinitionPropertygroup),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionVersionalgorithm {
  ChargeitemdefinitionVersionalgorithmString(version_algorithm: String)
  ChargeitemdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn chargeitemdefinition_versionalgorithm_to_json(
  elt: ChargeitemdefinitionVersionalgorithm,
) -> Json {
  case elt {
    ChargeitemdefinitionVersionalgorithmString(v) -> json.string(v)
    ChargeitemdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn chargeitemdefinition_versionalgorithm_decoder() -> Decoder(
  ChargeitemdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ChargeitemdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ChargeitemdefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn chargeitemdefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Chargeitemdefinition {
  Chargeitemdefinition(
    property_group: [],
    applicability: [],
    instance: [],
    code: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    replaces: [],
    part_of: [],
    derived_from_uri: [],
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionApplicability {
  ChargeitemdefinitionApplicability(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    condition: Option(Expression),
    effective_period: Option(Period),
    related_artifact: Option(Relatedartifact),
  )
}

pub fn chargeitemdefinition_applicability_new() -> ChargeitemdefinitionApplicability {
  ChargeitemdefinitionApplicability(
    related_artifact: None,
    effective_period: None,
    condition: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ChargeItemDefinition#resource
pub type ChargeitemdefinitionPropertygroup {
  ChargeitemdefinitionPropertygroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    price_component: List(Monetarycomponent),
  )
}

pub fn chargeitemdefinition_propertygroup_new() -> ChargeitemdefinitionPropertygroup {
  ChargeitemdefinitionPropertygroup(
    price_component: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn chargeitemdefinition_propertygroup_to_json(
  chargeitemdefinition_propertygroup: ChargeitemdefinitionPropertygroup,
) -> Json {
  let ChargeitemdefinitionPropertygroup(
    price_component:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitemdefinition_propertygroup
  let fields = []
  let fields = case price_component {
    [] -> fields
    _ -> [
      #(
        "priceComponent",
        json.array(price_component, monetarycomponent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitemdefinition_propertygroup_decoder() -> Decoder(
  ChargeitemdefinitionPropertygroup,
) {
  use price_component <- decode.optional_field(
    "priceComponent",
    [],
    decode.list(monetarycomponent_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemdefinitionPropertygroup(
    price_component:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitemdefinition_applicability_to_json(
  chargeitemdefinition_applicability: ChargeitemdefinitionApplicability,
) -> Json {
  let ChargeitemdefinitionApplicability(
    related_artifact:,
    effective_period:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ) = chargeitemdefinition_applicability
  let fields = []
  let fields = case related_artifact {
    Some(v) -> [#("relatedArtifact", relatedartifact_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn chargeitemdefinition_applicability_decoder() -> Decoder(
  ChargeitemdefinitionApplicability,
) {
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    None,
    decode.optional(relatedartifact_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(expression_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ChargeitemdefinitionApplicability(
    related_artifact:,
    effective_period:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn chargeitemdefinition_to_json(
  chargeitemdefinition: Chargeitemdefinition,
) -> Json {
  let Chargeitemdefinition(
    property_group:,
    applicability:,
    instance:,
    code:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    part_of:,
    derived_from_uri:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = chargeitemdefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case property_group {
    [] -> fields
    _ -> [
      #(
        "propertyGroup",
        json.array(property_group, chargeitemdefinition_propertygroup_to_json),
      ),
      ..fields
    ]
  }
  let fields = case applicability {
    [] -> fields
    _ -> [
      #(
        "applicability",
        json.array(applicability, chargeitemdefinition_applicability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case instance {
    [] -> fields
    _ -> [#("instance", json.array(instance, reference_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, json.string)), ..fields]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, json.string)), ..fields]
  }
  let fields = case derived_from_uri {
    [] -> fields
    _ -> [
      #("derivedFromUri", json.array(derived_from_uri, json.string)),
      ..fields
    ]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ChargeitemdefinitionVersionalgorithmString(_) -> "String"
          ChargeitemdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        chargeitemdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Chargeitemdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn chargeitemdefinition_decoder() -> Decoder(Chargeitemdefinition) {
  use property_group <- decode.optional_field(
    "propertyGroup",
    [],
    decode.list(chargeitemdefinition_propertygroup_decoder()),
  )
  use applicability <- decode.optional_field(
    "applicability",
    [],
    decode.list(chargeitemdefinition_applicability_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(decode.string),
  )
  use part_of <- decode.optional_field("partOf", [], decode.list(decode.string))
  use derived_from_uri <- decode.optional_field(
    "derivedFromUri",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(chargeitemdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Chargeitemdefinition",
    decode.failure(chargeitemdefinition_new(status:), "resourceType"),
  )
  decode.success(Chargeitemdefinition(
    property_group:,
    applicability:,
    instance:,
    code:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    part_of:,
    derived_from_uri:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type Citation {
  Citation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(CitationVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    summary: List(CitationSummary),
    classification: List(CitationClassification),
    note: List(Annotation),
    current_state: List(Codeableconcept),
    status_date: List(CitationStatusdate),
    related_artifact: List(Relatedartifact),
    cited_artifact: Option(CitationCitedartifact),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationVersionalgorithm {
  CitationVersionalgorithmString(version_algorithm: String)
  CitationVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn citation_versionalgorithm_to_json(elt: CitationVersionalgorithm) -> Json {
  case elt {
    CitationVersionalgorithmString(v) -> json.string(v)
    CitationVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn citation_versionalgorithm_decoder() -> Decoder(CitationVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(CitationVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(CitationVersionalgorithmCoding),
    ],
  )
}

pub fn citation_new(status status: r5valuesets.Publicationstatus) -> Citation {
  Citation(
    cited_artifact: None,
    related_artifact: [],
    status_date: [],
    current_state: [],
    note: [],
    classification: [],
    summary: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationSummary {
  CitationSummary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    style: Option(Codeableconcept),
    text: String,
  )
}

pub fn citation_summary_new(text text: String) -> CitationSummary {
  CitationSummary(
    text:,
    style: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationClassification {
  CitationClassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    classifier: List(Codeableconcept),
  )
}

pub fn citation_classification_new() -> CitationClassification {
  CitationClassification(
    classifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationStatusdate {
  CitationStatusdate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    activity: Codeableconcept,
    actual: Option(Bool),
    period: Period,
  )
}

pub fn citation_statusdate_new(
  period period: Period,
  activity activity: Codeableconcept,
) -> CitationStatusdate {
  CitationStatusdate(
    period:,
    actual: None,
    activity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifact {
  CitationCitedartifact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    related_identifier: List(Identifier),
    date_accessed: Option(String),
    version: Option(CitationCitedartifactVersion),
    current_state: List(Codeableconcept),
    status_date: List(CitationCitedartifactStatusdate),
    title: List(CitationCitedartifactTitle),
    abstract: List(CitationCitedartifactAbstract),
    part: Option(CitationCitedartifactPart),
    relates_to: List(CitationCitedartifactRelatesto),
    publication_form: List(CitationCitedartifactPublicationform),
    web_location: List(CitationCitedartifactWeblocation),
    classification: List(CitationCitedartifactClassification),
    contributorship: Option(CitationCitedartifactContributorship),
    note: List(Annotation),
  )
}

pub fn citation_citedartifact_new() -> CitationCitedartifact {
  CitationCitedartifact(
    note: [],
    contributorship: None,
    classification: [],
    web_location: [],
    publication_form: [],
    relates_to: [],
    part: None,
    abstract: [],
    title: [],
    status_date: [],
    current_state: [],
    version: None,
    date_accessed: None,
    related_identifier: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactVersion {
  CitationCitedartifactVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: String,
    base_citation: Option(Reference),
  )
}

pub fn citation_citedartifact_version_new(
  value value: String,
) -> CitationCitedartifactVersion {
  CitationCitedartifactVersion(
    base_citation: None,
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactStatusdate {
  CitationCitedartifactStatusdate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    activity: Codeableconcept,
    actual: Option(Bool),
    period: Period,
  )
}

pub fn citation_citedartifact_statusdate_new(
  period period: Period,
  activity activity: Codeableconcept,
) -> CitationCitedartifactStatusdate {
  CitationCitedartifactStatusdate(
    period:,
    actual: None,
    activity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactTitle {
  CitationCitedartifactTitle(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    language: Option(Codeableconcept),
    text: String,
  )
}

pub fn citation_citedartifact_title_new(
  text text: String,
) -> CitationCitedartifactTitle {
  CitationCitedartifactTitle(
    text:,
    language: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactAbstract {
  CitationCitedartifactAbstract(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    language: Option(Codeableconcept),
    text: String,
    copyright: Option(String),
  )
}

pub fn citation_citedartifact_abstract_new(
  text text: String,
) -> CitationCitedartifactAbstract {
  CitationCitedartifactAbstract(
    copyright: None,
    text:,
    language: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactPart {
  CitationCitedartifactPart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: Option(String),
    base_citation: Option(Reference),
  )
}

pub fn citation_citedartifact_part_new() -> CitationCitedartifactPart {
  CitationCitedartifactPart(
    base_citation: None,
    value: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactRelatesto {
  CitationCitedartifactRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Relatedartifacttypeall,
    classifier: List(Codeableconcept),
    label: Option(String),
    display: Option(String),
    citation: Option(String),
    document: Option(Attachment),
    resource: Option(String),
    resource_reference: Option(Reference),
  )
}

pub fn citation_citedartifact_relatesto_new(
  type_ type_: r5valuesets.Relatedartifacttypeall,
) -> CitationCitedartifactRelatesto {
  CitationCitedartifactRelatesto(
    resource_reference: None,
    resource: None,
    document: None,
    citation: None,
    display: None,
    label: None,
    classifier: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationform {
  CitationCitedartifactPublicationform(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    published_in: Option(CitationCitedartifactPublicationformPublishedin),
    cited_medium: Option(Codeableconcept),
    volume: Option(String),
    issue: Option(String),
    article_date: Option(String),
    publication_date_text: Option(String),
    publication_date_season: Option(String),
    last_revision_date: Option(String),
    language: List(Codeableconcept),
    accession_number: Option(String),
    page_string: Option(String),
    first_page: Option(String),
    last_page: Option(String),
    page_count: Option(String),
    copyright: Option(String),
  )
}

pub fn citation_citedartifact_publicationform_new() -> CitationCitedartifactPublicationform {
  CitationCitedartifactPublicationform(
    copyright: None,
    page_count: None,
    last_page: None,
    first_page: None,
    page_string: None,
    accession_number: None,
    language: [],
    last_revision_date: None,
    publication_date_season: None,
    publication_date_text: None,
    article_date: None,
    issue: None,
    volume: None,
    cited_medium: None,
    published_in: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactPublicationformPublishedin {
  CitationCitedartifactPublicationformPublishedin(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    identifier: List(Identifier),
    title: Option(String),
    publisher: Option(Reference),
    publisher_location: Option(String),
  )
}

pub fn citation_citedartifact_publicationform_publishedin_new() -> CitationCitedartifactPublicationformPublishedin {
  CitationCitedartifactPublicationformPublishedin(
    publisher_location: None,
    publisher: None,
    title: None,
    identifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactWeblocation {
  CitationCitedartifactWeblocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    classifier: List(Codeableconcept),
    url: Option(String),
  )
}

pub fn citation_citedartifact_weblocation_new() -> CitationCitedartifactWeblocation {
  CitationCitedartifactWeblocation(
    url: None,
    classifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactClassification {
  CitationCitedartifactClassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    classifier: List(Codeableconcept),
    artifact_assessment: List(Reference),
  )
}

pub fn citation_citedartifact_classification_new() -> CitationCitedartifactClassification {
  CitationCitedartifactClassification(
    artifact_assessment: [],
    classifier: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorship {
  CitationCitedartifactContributorship(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    complete: Option(Bool),
    entry: List(CitationCitedartifactContributorshipEntry),
    summary: List(CitationCitedartifactContributorshipSummary),
  )
}

pub fn citation_citedartifact_contributorship_new() -> CitationCitedartifactContributorship {
  CitationCitedartifactContributorship(
    summary: [],
    entry: [],
    complete: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipEntry {
  CitationCitedartifactContributorshipEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    contributor: Reference,
    forename_initials: Option(String),
    affiliation: List(Reference),
    contribution_type: List(Codeableconcept),
    role: Option(Codeableconcept),
    contribution_instance: List(
      CitationCitedartifactContributorshipEntryContributioninstance,
    ),
    corresponding_contact: Option(Bool),
    ranking_order: Option(Int),
  )
}

pub fn citation_citedartifact_contributorship_entry_new(
  contributor contributor: Reference,
) -> CitationCitedartifactContributorshipEntry {
  CitationCitedartifactContributorshipEntry(
    ranking_order: None,
    corresponding_contact: None,
    contribution_instance: [],
    role: None,
    contribution_type: [],
    affiliation: [],
    forename_initials: None,
    contributor:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipEntryContributioninstance {
  CitationCitedartifactContributorshipEntryContributioninstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    time: Option(String),
  )
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_new(
  type_ type_: Codeableconcept,
) -> CitationCitedartifactContributorshipEntryContributioninstance {
  CitationCitedartifactContributorshipEntryContributioninstance(
    time: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Citation#resource
pub type CitationCitedartifactContributorshipSummary {
  CitationCitedartifactContributorshipSummary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    style: Option(Codeableconcept),
    source: Option(Codeableconcept),
    value: String,
  )
}

pub fn citation_citedartifact_contributorship_summary_new(
  value value: String,
) -> CitationCitedartifactContributorshipSummary {
  CitationCitedartifactContributorshipSummary(
    value:,
    source: None,
    style: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn citation_citedartifact_contributorship_summary_to_json(
  citation_citedartifact_contributorship_summary: CitationCitedartifactContributorshipSummary,
) -> Json {
  let CitationCitedartifactContributorshipSummary(
    value:,
    source:,
    style:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_summary
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case source {
    Some(v) -> [#("source", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case style {
    Some(v) -> [#("style", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_summary_decoder() -> Decoder(
  CitationCitedartifactContributorshipSummary,
) {
  use value <- decode.field("value", decode.string)
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use style <- decode.optional_field(
    "style",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipSummary(
    value:,
    source:,
    style:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_to_json(
  citation_citedartifact_contributorship_entry_contributioninstance: CitationCitedartifactContributorshipEntryContributioninstance,
) -> Json {
  let CitationCitedartifactContributorshipEntryContributioninstance(
    time:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_entry_contributioninstance
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_entry_contributioninstance_decoder() -> Decoder(
  CitationCitedartifactContributorshipEntryContributioninstance,
) {
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipEntryContributioninstance(
    time:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_entry_to_json(
  citation_citedartifact_contributorship_entry: CitationCitedartifactContributorshipEntry,
) -> Json {
  let CitationCitedartifactContributorshipEntry(
    ranking_order:,
    corresponding_contact:,
    contribution_instance:,
    role:,
    contribution_type:,
    affiliation:,
    forename_initials:,
    contributor:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship_entry
  let fields = [
    #("contributor", reference_to_json(contributor)),
  ]
  let fields = case ranking_order {
    Some(v) -> [#("rankingOrder", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case corresponding_contact {
    Some(v) -> [#("correspondingContact", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case contribution_instance {
    [] -> fields
    _ -> [
      #(
        "contributionInstance",
        json.array(
          contribution_instance,
          citation_citedartifact_contributorship_entry_contributioninstance_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contribution_type {
    [] -> fields
    _ -> [
      #(
        "contributionType",
        json.array(contribution_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case affiliation {
    [] -> fields
    _ -> [
      #("affiliation", json.array(affiliation, reference_to_json)),
      ..fields
    ]
  }
  let fields = case forename_initials {
    Some(v) -> [#("forenameInitials", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_entry_decoder() -> Decoder(
  CitationCitedartifactContributorshipEntry,
) {
  use ranking_order <- decode.optional_field(
    "rankingOrder",
    None,
    decode.optional(decode.int),
  )
  use corresponding_contact <- decode.optional_field(
    "correspondingContact",
    None,
    decode.optional(decode.bool),
  )
  use contribution_instance <- decode.optional_field(
    "contributionInstance",
    [],
    decode.list(
      citation_citedartifact_contributorship_entry_contributioninstance_decoder(),
    ),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use contribution_type <- decode.optional_field(
    "contributionType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use affiliation <- decode.optional_field(
    "affiliation",
    [],
    decode.list(reference_decoder()),
  )
  use forename_initials <- decode.optional_field(
    "forenameInitials",
    None,
    decode.optional(decode.string),
  )
  use contributor <- decode.field("contributor", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorshipEntry(
    ranking_order:,
    corresponding_contact:,
    contribution_instance:,
    role:,
    contribution_type:,
    affiliation:,
    forename_initials:,
    contributor:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_contributorship_to_json(
  citation_citedartifact_contributorship: CitationCitedartifactContributorship,
) -> Json {
  let CitationCitedartifactContributorship(
    summary:,
    entry:,
    complete:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_contributorship
  let fields = []
  let fields = case summary {
    [] -> fields
    _ -> [
      #(
        "summary",
        json.array(
          summary,
          citation_citedartifact_contributorship_summary_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case entry {
    [] -> fields
    _ -> [
      #(
        "entry",
        json.array(entry, citation_citedartifact_contributorship_entry_to_json),
      ),
      ..fields
    ]
  }
  let fields = case complete {
    Some(v) -> [#("complete", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_contributorship_decoder() -> Decoder(
  CitationCitedartifactContributorship,
) {
  use summary <- decode.optional_field(
    "summary",
    [],
    decode.list(citation_citedartifact_contributorship_summary_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(citation_citedartifact_contributorship_entry_decoder()),
  )
  use complete <- decode.optional_field(
    "complete",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactContributorship(
    summary:,
    entry:,
    complete:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_classification_to_json(
  citation_citedartifact_classification: CitationCitedartifactClassification,
) -> Json {
  let CitationCitedartifactClassification(
    artifact_assessment:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_classification
  let fields = []
  let fields = case artifact_assessment {
    [] -> fields
    _ -> [
      #(
        "artifactAssessment",
        json.array(artifact_assessment, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_classification_decoder() -> Decoder(
  CitationCitedartifactClassification,
) {
  use artifact_assessment <- decode.optional_field(
    "artifactAssessment",
    [],
    decode.list(reference_decoder()),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactClassification(
    artifact_assessment:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_weblocation_to_json(
  citation_citedartifact_weblocation: CitationCitedartifactWeblocation,
) -> Json {
  let CitationCitedartifactWeblocation(
    url:,
    classifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_weblocation
  let fields = []
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_weblocation_decoder() -> Decoder(
  CitationCitedartifactWeblocation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactWeblocation(
    url:,
    classifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_publicationform_publishedin_to_json(
  citation_citedartifact_publicationform_publishedin: CitationCitedartifactPublicationformPublishedin,
) -> Json {
  let CitationCitedartifactPublicationformPublishedin(
    publisher_location:,
    publisher:,
    title:,
    identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform_publishedin
  let fields = []
  let fields = case publisher_location {
    Some(v) -> [#("publisherLocation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_publishedin_decoder() -> Decoder(
  CitationCitedartifactPublicationformPublishedin,
) {
  use publisher_location <- decode.optional_field(
    "publisherLocation",
    None,
    decode.optional(decode.string),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(reference_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPublicationformPublishedin(
    publisher_location:,
    publisher:,
    title:,
    identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_publicationform_to_json(
  citation_citedartifact_publicationform: CitationCitedartifactPublicationform,
) -> Json {
  let CitationCitedartifactPublicationform(
    copyright:,
    page_count:,
    last_page:,
    first_page:,
    page_string:,
    accession_number:,
    language:,
    last_revision_date:,
    publication_date_season:,
    publication_date_text:,
    article_date:,
    issue:,
    volume:,
    cited_medium:,
    published_in:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_publicationform
  let fields = []
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case page_count {
    Some(v) -> [#("pageCount", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_page {
    Some(v) -> [#("lastPage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case first_page {
    Some(v) -> [#("firstPage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case page_string {
    Some(v) -> [#("pageString", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case accession_number {
    Some(v) -> [#("accessionNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    [] -> fields
    _ -> [
      #("language", json.array(language, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case last_revision_date {
    Some(v) -> [#("lastRevisionDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_date_season {
    Some(v) -> [#("publicationDateSeason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_date_text {
    Some(v) -> [#("publicationDateText", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case article_date {
    Some(v) -> [#("articleDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case issue {
    Some(v) -> [#("issue", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case volume {
    Some(v) -> [#("volume", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cited_medium {
    Some(v) -> [#("citedMedium", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case published_in {
    Some(v) -> [
      #(
        "publishedIn",
        citation_citedartifact_publicationform_publishedin_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_publicationform_decoder() -> Decoder(
  CitationCitedartifactPublicationform,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use page_count <- decode.optional_field(
    "pageCount",
    None,
    decode.optional(decode.string),
  )
  use last_page <- decode.optional_field(
    "lastPage",
    None,
    decode.optional(decode.string),
  )
  use first_page <- decode.optional_field(
    "firstPage",
    None,
    decode.optional(decode.string),
  )
  use page_string <- decode.optional_field(
    "pageString",
    None,
    decode.optional(decode.string),
  )
  use accession_number <- decode.optional_field(
    "accessionNumber",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use last_revision_date <- decode.optional_field(
    "lastRevisionDate",
    None,
    decode.optional(decode.string),
  )
  use publication_date_season <- decode.optional_field(
    "publicationDateSeason",
    None,
    decode.optional(decode.string),
  )
  use publication_date_text <- decode.optional_field(
    "publicationDateText",
    None,
    decode.optional(decode.string),
  )
  use article_date <- decode.optional_field(
    "articleDate",
    None,
    decode.optional(decode.string),
  )
  use issue <- decode.optional_field(
    "issue",
    None,
    decode.optional(decode.string),
  )
  use volume <- decode.optional_field(
    "volume",
    None,
    decode.optional(decode.string),
  )
  use cited_medium <- decode.optional_field(
    "citedMedium",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use published_in <- decode.optional_field(
    "publishedIn",
    None,
    decode.optional(
      citation_citedartifact_publicationform_publishedin_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPublicationform(
    copyright:,
    page_count:,
    last_page:,
    first_page:,
    page_string:,
    accession_number:,
    language:,
    last_revision_date:,
    publication_date_season:,
    publication_date_text:,
    article_date:,
    issue:,
    volume:,
    cited_medium:,
    published_in:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_relatesto_to_json(
  citation_citedartifact_relatesto: CitationCitedartifactRelatesto,
) -> Json {
  let CitationCitedartifactRelatesto(
    resource_reference:,
    resource:,
    document:,
    citation:,
    display:,
    label:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_relatesto
  let fields = [
    #("type", r5valuesets.relatedartifacttypeall_to_json(type_)),
  ]
  let fields = case resource_reference {
    Some(v) -> [#("resourceReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case document {
    Some(v) -> [#("document", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case citation {
    Some(v) -> [#("citation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_relatesto_decoder() -> Decoder(
  CitationCitedartifactRelatesto,
) {
  use resource_reference <- decode.optional_field(
    "resourceReference",
    None,
    decode.optional(reference_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use document <- decode.optional_field(
    "document",
    None,
    decode.optional(attachment_decoder()),
  )
  use citation <- decode.optional_field(
    "citation",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.relatedartifacttypeall_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactRelatesto(
    resource_reference:,
    resource:,
    document:,
    citation:,
    display:,
    label:,
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_part_to_json(
  citation_citedartifact_part: CitationCitedartifactPart,
) -> Json {
  let CitationCitedartifactPart(
    base_citation:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_part
  let fields = []
  let fields = case base_citation {
    Some(v) -> [#("baseCitation", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_part_decoder() -> Decoder(
  CitationCitedartifactPart,
) {
  use base_citation <- decode.optional_field(
    "baseCitation",
    None,
    decode.optional(reference_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactPart(
    base_citation:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_abstract_to_json(
  citation_citedartifact_abstract: CitationCitedartifactAbstract,
) -> Json {
  let CitationCitedartifactAbstract(
    copyright:,
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_abstract
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_abstract_decoder() -> Decoder(
  CitationCitedartifactAbstract,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use text <- decode.field("text", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactAbstract(
    copyright:,
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_title_to_json(
  citation_citedartifact_title: CitationCitedartifactTitle,
) -> Json {
  let CitationCitedartifactTitle(
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_title
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_title_decoder() -> Decoder(
  CitationCitedartifactTitle,
) {
  use text <- decode.field("text", decode.string)
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactTitle(
    text:,
    language:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_statusdate_to_json(
  citation_citedartifact_statusdate: CitationCitedartifactStatusdate,
) -> Json {
  let CitationCitedartifactStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_statusdate
  let fields = [
    #("period", period_to_json(period)),
    #("activity", codeableconcept_to_json(activity)),
  ]
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_statusdate_decoder() -> Decoder(
  CitationCitedartifactStatusdate,
) {
  use period <- decode.field("period", period_decoder())
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use activity <- decode.field("activity", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_version_to_json(
  citation_citedartifact_version: CitationCitedartifactVersion,
) -> Json {
  let CitationCitedartifactVersion(
    base_citation:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact_version
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case base_citation {
    Some(v) -> [#("baseCitation", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_version_decoder() -> Decoder(
  CitationCitedartifactVersion,
) {
  use base_citation <- decode.optional_field(
    "baseCitation",
    None,
    decode.optional(reference_decoder()),
  )
  use value <- decode.field("value", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifactVersion(
    base_citation:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_citedartifact_to_json(
  citation_citedartifact: CitationCitedartifact,
) -> Json {
  let CitationCitedartifact(
    note:,
    contributorship:,
    classification:,
    web_location:,
    publication_form:,
    relates_to:,
    part:,
    abstract:,
    title:,
    status_date:,
    current_state:,
    version:,
    date_accessed:,
    related_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_citedartifact
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case contributorship {
    Some(v) -> [
      #("contributorship", citation_citedartifact_contributorship_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #(
        "classification",
        json.array(
          classification,
          citation_citedartifact_classification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case web_location {
    [] -> fields
    _ -> [
      #(
        "webLocation",
        json.array(web_location, citation_citedartifact_weblocation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case publication_form {
    [] -> fields
    _ -> [
      #(
        "publicationForm",
        json.array(
          publication_form,
          citation_citedartifact_publicationform_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #(
        "relatesTo",
        json.array(relates_to, citation_citedartifact_relatesto_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part {
    Some(v) -> [#("part", citation_citedartifact_part_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case abstract {
    [] -> fields
    _ -> [
      #(
        "abstract",
        json.array(abstract, citation_citedartifact_abstract_to_json),
      ),
      ..fields
    ]
  }
  let fields = case title {
    [] -> fields
    _ -> [
      #("title", json.array(title, citation_citedartifact_title_to_json)),
      ..fields
    ]
  }
  let fields = case status_date {
    [] -> fields
    _ -> [
      #(
        "statusDate",
        json.array(status_date, citation_citedartifact_statusdate_to_json),
      ),
      ..fields
    ]
  }
  let fields = case current_state {
    [] -> fields
    _ -> [
      #("currentState", json.array(current_state, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case version {
    Some(v) -> [
      #("version", citation_citedartifact_version_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case date_accessed {
    Some(v) -> [#("dateAccessed", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_identifier {
    [] -> fields
    _ -> [
      #("relatedIdentifier", json.array(related_identifier, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_citedartifact_decoder() -> Decoder(CitationCitedartifact) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use contributorship <- decode.optional_field(
    "contributorship",
    None,
    decode.optional(citation_citedartifact_contributorship_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(citation_citedartifact_classification_decoder()),
  )
  use web_location <- decode.optional_field(
    "webLocation",
    [],
    decode.list(citation_citedartifact_weblocation_decoder()),
  )
  use publication_form <- decode.optional_field(
    "publicationForm",
    [],
    decode.list(citation_citedartifact_publicationform_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(citation_citedartifact_relatesto_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    None,
    decode.optional(citation_citedartifact_part_decoder()),
  )
  use abstract <- decode.optional_field(
    "abstract",
    [],
    decode.list(citation_citedartifact_abstract_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    [],
    decode.list(citation_citedartifact_title_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    [],
    decode.list(citation_citedartifact_statusdate_decoder()),
  )
  use current_state <- decode.optional_field(
    "currentState",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(citation_citedartifact_version_decoder()),
  )
  use date_accessed <- decode.optional_field(
    "dateAccessed",
    None,
    decode.optional(decode.string),
  )
  use related_identifier <- decode.optional_field(
    "relatedIdentifier",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationCitedartifact(
    note:,
    contributorship:,
    classification:,
    web_location:,
    publication_form:,
    relates_to:,
    part:,
    abstract:,
    title:,
    status_date:,
    current_state:,
    version:,
    date_accessed:,
    related_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_statusdate_to_json(
  citation_statusdate: CitationStatusdate,
) -> Json {
  let CitationStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_statusdate
  let fields = [
    #("period", period_to_json(period)),
    #("activity", codeableconcept_to_json(activity)),
  ]
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_statusdate_decoder() -> Decoder(CitationStatusdate) {
  use period <- decode.field("period", period_decoder())
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use activity <- decode.field("activity", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationStatusdate(
    period:,
    actual:,
    activity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_classification_to_json(
  citation_classification: CitationClassification,
) -> Json {
  let CitationClassification(
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = citation_classification
  let fields = []
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_classification_decoder() -> Decoder(CitationClassification) {
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationClassification(
    classifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_summary_to_json(citation_summary: CitationSummary) -> Json {
  let CitationSummary(text:, style:, modifier_extension:, extension:, id:) =
    citation_summary
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case style {
    Some(v) -> [#("style", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn citation_summary_decoder() -> Decoder(CitationSummary) {
  use text <- decode.field("text", decode.string)
  use style <- decode.optional_field(
    "style",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CitationSummary(
    text:,
    style:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn citation_to_json(citation: Citation) -> Json {
  let Citation(
    cited_artifact:,
    related_artifact:,
    status_date:,
    current_state:,
    note:,
    classification:,
    summary:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = citation
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case cited_artifact {
    Some(v) -> [#("citedArtifact", citation_citedartifact_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case status_date {
    [] -> fields
    _ -> [
      #("statusDate", json.array(status_date, citation_statusdate_to_json)),
      ..fields
    ]
  }
  let fields = case current_state {
    [] -> fields
    _ -> [
      #("currentState", json.array(current_state, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #(
        "classification",
        json.array(classification, citation_classification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case summary {
    [] -> fields
    _ -> [#("summary", json.array(summary, citation_summary_to_json)), ..fields]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          CitationVersionalgorithmString(_) -> "String"
          CitationVersionalgorithmCoding(_) -> "Coding"
        },
        citation_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Citation")), ..fields]
  json.object(fields)
}

pub fn citation_decoder() -> Decoder(Citation) {
  use cited_artifact <- decode.optional_field(
    "citedArtifact",
    None,
    decode.optional(citation_citedartifact_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    [],
    decode.list(citation_statusdate_decoder()),
  )
  use current_state <- decode.optional_field(
    "currentState",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(citation_classification_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    [],
    decode.list(citation_summary_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(citation_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Citation",
    decode.failure(citation_new(status:), "resourceType"),
  )
  decode.success(Citation(
    cited_artifact:,
    related_artifact:,
    status_date:,
    current_state:,
    note:,
    classification:,
    summary:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type Claim {
  Claim(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    trace_number: List(Identifier),
    status: r5valuesets.Fmstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r5valuesets.Claimuse,
    patient: Reference,
    billable_period: Option(Period),
    created: String,
    enterer: Option(Reference),
    insurer: Option(Reference),
    provider: Option(Reference),
    priority: Option(Codeableconcept),
    funds_reserve: Option(Codeableconcept),
    related: List(ClaimRelated),
    prescription: Option(Reference),
    original_prescription: Option(Reference),
    payee: Option(ClaimPayee),
    referral: Option(Reference),
    encounter: List(Reference),
    facility: Option(Reference),
    diagnosis_related_group: Option(Codeableconcept),
    event: List(ClaimEvent),
    care_team: List(ClaimCareteam),
    supporting_info: List(ClaimSupportinginfo),
    diagnosis: List(ClaimDiagnosis),
    procedure: List(ClaimProcedure),
    insurance: List(ClaimInsurance),
    accident: Option(ClaimAccident),
    patient_paid: Option(Money),
    item: List(ClaimItem),
    total: Option(Money),
  )
}

pub fn claim_new(
  created created: String,
  patient patient: Reference,
  use_ use_: r5valuesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r5valuesets.Fmstatus,
) -> Claim {
  Claim(
    total: None,
    item: [],
    patient_paid: None,
    accident: None,
    insurance: [],
    procedure: [],
    diagnosis: [],
    supporting_info: [],
    care_team: [],
    event: [],
    diagnosis_related_group: None,
    facility: None,
    encounter: [],
    referral: None,
    payee: None,
    original_prescription: None,
    prescription: None,
    related: [],
    funds_reserve: None,
    priority: None,
    provider: None,
    insurer: None,
    enterer: None,
    created:,
    billable_period: None,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    trace_number: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimRelated {
  ClaimRelated(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    claim: Option(Reference),
    relationship: Option(Codeableconcept),
    reference: Option(Identifier),
  )
}

pub fn claim_related_new() -> ClaimRelated {
  ClaimRelated(
    reference: None,
    relationship: None,
    claim: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimPayee {
  ClaimPayee(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    party: Option(Reference),
  )
}

pub fn claim_payee_new(type_ type_: Codeableconcept) -> ClaimPayee {
  ClaimPayee(
    party: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimEvent {
  ClaimEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    when: ClaimEventWhen,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimEventWhen {
  ClaimEventWhenDatetime(when: String)
  ClaimEventWhenPeriod(when: Period)
}

pub fn claim_event_when_to_json(elt: ClaimEventWhen) -> Json {
  case elt {
    ClaimEventWhenDatetime(v) -> json.string(v)
    ClaimEventWhenPeriod(v) -> period_to_json(v)
  }
}

pub fn claim_event_when_decoder() -> Decoder(ClaimEventWhen) {
  decode.one_of(
    decode.field("whenDateTime", decode.string, decode.success)
      |> decode.map(ClaimEventWhenDatetime),
    [
      decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimEventWhenPeriod),
    ],
  )
}

pub fn claim_event_new(
  when when: ClaimEventWhen,
  type_ type_: Codeableconcept,
) -> ClaimEvent {
  ClaimEvent(when:, type_:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimCareteam {
  ClaimCareteam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    provider: Reference,
    responsible: Option(Bool),
    role: Option(Codeableconcept),
    specialty: Option(Codeableconcept),
  )
}

pub fn claim_careteam_new(
  provider provider: Reference,
  sequence sequence: Int,
) -> ClaimCareteam {
  ClaimCareteam(
    specialty: None,
    role: None,
    responsible: None,
    provider:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimSupportinginfo {
  ClaimSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    category: Codeableconcept,
    code: Option(Codeableconcept),
    timing: Option(ClaimSupportinginfoTiming),
    value: Option(ClaimSupportinginfoValue),
    reason: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoTiming {
  ClaimSupportinginfoTimingDate(timing: String)
  ClaimSupportinginfoTimingPeriod(timing: Period)
}

pub fn claim_supportinginfo_timing_to_json(
  elt: ClaimSupportinginfoTiming,
) -> Json {
  case elt {
    ClaimSupportinginfoTimingDate(v) -> json.string(v)
    ClaimSupportinginfoTimingPeriod(v) -> period_to_json(v)
  }
}

pub fn claim_supportinginfo_timing_decoder() -> Decoder(
  ClaimSupportinginfoTiming,
) {
  decode.one_of(
    decode.field("timingDate", decode.string, decode.success)
      |> decode.map(ClaimSupportinginfoTimingDate),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimSupportinginfoTimingPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimSupportinginfoValue {
  ClaimSupportinginfoValueBoolean(value: Bool)
  ClaimSupportinginfoValueString(value: String)
  ClaimSupportinginfoValueQuantity(value: Quantity)
  ClaimSupportinginfoValueAttachment(value: Attachment)
  ClaimSupportinginfoValueReference(value: Reference)
  ClaimSupportinginfoValueIdentifier(value: Identifier)
}

pub fn claim_supportinginfo_value_to_json(elt: ClaimSupportinginfoValue) -> Json {
  case elt {
    ClaimSupportinginfoValueBoolean(v) -> json.bool(v)
    ClaimSupportinginfoValueString(v) -> json.string(v)
    ClaimSupportinginfoValueQuantity(v) -> quantity_to_json(v)
    ClaimSupportinginfoValueAttachment(v) -> attachment_to_json(v)
    ClaimSupportinginfoValueReference(v) -> reference_to_json(v)
    ClaimSupportinginfoValueIdentifier(v) -> identifier_to_json(v)
  }
}

pub fn claim_supportinginfo_value_decoder() -> Decoder(ClaimSupportinginfoValue) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ClaimSupportinginfoValueBoolean),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ClaimSupportinginfoValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueQuantity),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueReference),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ClaimSupportinginfoValueIdentifier),
    ],
  )
}

pub fn claim_supportinginfo_new(
  category category: Codeableconcept,
  sequence sequence: Int,
) -> ClaimSupportinginfo {
  ClaimSupportinginfo(
    reason: None,
    value: None,
    timing: None,
    code: None,
    category:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimDiagnosis {
  ClaimDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    diagnosis: ClaimDiagnosisDiagnosis,
    type_: List(Codeableconcept),
    on_admission: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimDiagnosisDiagnosis {
  ClaimDiagnosisDiagnosisCodeableconcept(diagnosis: Codeableconcept)
  ClaimDiagnosisDiagnosisReference(diagnosis: Reference)
}

pub fn claim_diagnosis_diagnosis_to_json(elt: ClaimDiagnosisDiagnosis) -> Json {
  case elt {
    ClaimDiagnosisDiagnosisCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimDiagnosisDiagnosisReference(v) -> reference_to_json(v)
  }
}

pub fn claim_diagnosis_diagnosis_decoder() -> Decoder(ClaimDiagnosisDiagnosis) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimDiagnosisDiagnosisCodeableconcept),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(ClaimDiagnosisDiagnosisReference),
    ],
  )
}

pub fn claim_diagnosis_new(
  diagnosis diagnosis: ClaimDiagnosisDiagnosis,
  sequence sequence: Int,
) -> ClaimDiagnosis {
  ClaimDiagnosis(
    on_admission: None,
    type_: [],
    diagnosis:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimProcedure {
  ClaimProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    type_: List(Codeableconcept),
    date: Option(String),
    procedure: ClaimProcedureProcedure,
    udi: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimProcedureProcedure {
  ClaimProcedureProcedureCodeableconcept(procedure: Codeableconcept)
  ClaimProcedureProcedureReference(procedure: Reference)
}

pub fn claim_procedure_procedure_to_json(elt: ClaimProcedureProcedure) -> Json {
  case elt {
    ClaimProcedureProcedureCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimProcedureProcedureReference(v) -> reference_to_json(v)
  }
}

pub fn claim_procedure_procedure_decoder() -> Decoder(ClaimProcedureProcedure) {
  decode.one_of(
    decode.field(
      "procedureCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimProcedureProcedureCodeableconcept),
    [
      decode.field("procedureReference", reference_decoder(), decode.success)
      |> decode.map(ClaimProcedureProcedureReference),
    ],
  )
}

pub fn claim_procedure_new(
  procedure procedure: ClaimProcedureProcedure,
  sequence sequence: Int,
) -> ClaimProcedure {
  ClaimProcedure(
    udi: [],
    procedure:,
    date: None,
    type_: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimInsurance {
  ClaimInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    focal: Bool,
    identifier: Option(Identifier),
    coverage: Reference,
    business_arrangement: Option(String),
    pre_auth_ref: List(String),
    claim_response: Option(Reference),
  )
}

pub fn claim_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
  sequence sequence: Int,
) -> ClaimInsurance {
  ClaimInsurance(
    claim_response: None,
    pre_auth_ref: [],
    business_arrangement: None,
    coverage:,
    identifier: None,
    focal:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimAccident {
  ClaimAccident(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: String,
    type_: Option(Codeableconcept),
    location: Option(ClaimAccidentLocation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimAccidentLocation {
  ClaimAccidentLocationAddress(location: Address)
  ClaimAccidentLocationReference(location: Reference)
}

pub fn claim_accident_location_to_json(elt: ClaimAccidentLocation) -> Json {
  case elt {
    ClaimAccidentLocationAddress(v) -> address_to_json(v)
    ClaimAccidentLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claim_accident_location_decoder() -> Decoder(ClaimAccidentLocation) {
  decode.one_of(
    decode.field("locationAddress", address_decoder(), decode.success)
      |> decode.map(ClaimAccidentLocationAddress),
    [
      decode.field("locationReference", reference_decoder(), decode.success)
      |> decode.map(ClaimAccidentLocationReference),
    ],
  )
}

pub fn claim_accident_new(date date: String) -> ClaimAccident {
  ClaimAccident(
    location: None,
    type_: None,
    date:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItem {
  ClaimItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    trace_number: List(Identifier),
    care_team_sequence: List(Int),
    diagnosis_sequence: List(Int),
    procedure_sequence: List(Int),
    information_sequence: List(Int),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    request: List(Reference),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ClaimItemServiced),
    location: Option(ClaimItemLocation),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
    body_site: List(ClaimItemBodysite),
    encounter: List(Reference),
    detail: List(ClaimItemDetail),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItemServiced {
  ClaimItemServicedDate(serviced: String)
  ClaimItemServicedPeriod(serviced: Period)
}

pub fn claim_item_serviced_to_json(elt: ClaimItemServiced) -> Json {
  case elt {
    ClaimItemServicedDate(v) -> json.string(v)
    ClaimItemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn claim_item_serviced_decoder() -> Decoder(ClaimItemServiced) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ClaimItemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimItemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItemLocation {
  ClaimItemLocationCodeableconcept(location: Codeableconcept)
  ClaimItemLocationAddress(location: Address)
  ClaimItemLocationReference(location: Reference)
}

pub fn claim_item_location_to_json(elt: ClaimItemLocation) -> Json {
  case elt {
    ClaimItemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimItemLocationAddress(v) -> address_to_json(v)
    ClaimItemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claim_item_location_decoder() -> Decoder(ClaimItemLocation) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimItemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ClaimItemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ClaimItemLocationReference),
    ],
  )
}

pub fn claim_item_new(sequence sequence: Int) -> ClaimItem {
  ClaimItem(
    detail: [],
    encounter: [],
    body_site: [],
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    request: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    information_sequence: [],
    procedure_sequence: [],
    diagnosis_sequence: [],
    care_team_sequence: [],
    trace_number: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItemBodysite {
  ClaimItemBodysite(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: List(Codeablereference),
    sub_site: List(Codeableconcept),
  )
}

pub fn claim_item_bodysite_new() -> ClaimItemBodysite {
  ClaimItemBodysite(
    sub_site: [],
    site: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItemDetail {
  ClaimItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
    sub_detail: List(ClaimItemDetailSubdetail),
  )
}

pub fn claim_item_detail_new(sequence sequence: Int) -> ClaimItemDetail {
  ClaimItemDetail(
    sub_detail: [],
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    program_code: [],
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    trace_number: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Claim#resource
pub type ClaimItemDetailSubdetail {
  ClaimItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
  )
}

pub fn claim_item_detail_subdetail_new(
  sequence sequence: Int,
) -> ClaimItemDetailSubdetail {
  ClaimItemDetailSubdetail(
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    program_code: [],
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    trace_number: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn claim_item_detail_subdetail_to_json(
  claim_item_detail_subdetail: ClaimItemDetailSubdetail,
) -> Json {
  let ClaimItemDetailSubdetail(
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item_detail_subdetail
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_detail_subdetail_decoder() -> Decoder(
  ClaimItemDetailSubdetail,
) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItemDetailSubdetail(
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_item_detail_to_json(claim_item_detail: ClaimItemDetail) -> Json {
  let ClaimItemDetail(
    sub_detail:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item_detail
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claim_item_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_detail_decoder() -> Decoder(ClaimItemDetail) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claim_item_detail_subdetail_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItemDetail(
    sub_detail:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_item_bodysite_to_json(
  claim_item_bodysite: ClaimItemBodysite,
) -> Json {
  let ClaimItemBodysite(sub_site:, site:, modifier_extension:, extension:, id:) =
    claim_item_bodysite
  let fields = []
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, codeablereference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_bodysite_decoder() -> Decoder(ClaimItemBodysite) {
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_item_to_json(claim_item: ClaimItem) -> Json {
  let ClaimItem(
    detail:,
    encounter:,
    body_site:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_item
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, claim_item_detail_to_json)), ..fields]
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, claim_item_bodysite_to_json)),
      ..fields
    ]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimItemLocationCodeableconcept(_) -> "Codeableconcept"
          ClaimItemLocationAddress(_) -> "Address"
          ClaimItemLocationReference(_) -> "Reference"
        },
        claim_item_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ClaimItemServicedDate(_) -> "Date"
          ClaimItemServicedPeriod(_) -> "Period"
        },
        claim_item_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case information_sequence {
    [] -> fields
    _ -> [
      #("informationSequence", json.array(information_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case procedure_sequence {
    [] -> fields
    _ -> [
      #("procedureSequence", json.array(procedure_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case diagnosis_sequence {
    [] -> fields
    _ -> [
      #("diagnosisSequence", json.array(diagnosis_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case care_team_sequence {
    [] -> fields
    _ -> [
      #("careTeamSequence", json.array(care_team_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_item_decoder() -> Decoder(ClaimItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claim_item_detail_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(claim_item_bodysite_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use location <- decode.then(none_if_omitted(claim_item_location_decoder()))
  use serviced <- decode.then(none_if_omitted(claim_item_serviced_decoder()))
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use information_sequence <- decode.optional_field(
    "informationSequence",
    [],
    decode.list(decode.int),
  )
  use procedure_sequence <- decode.optional_field(
    "procedureSequence",
    [],
    decode.list(decode.int),
  )
  use diagnosis_sequence <- decode.optional_field(
    "diagnosisSequence",
    [],
    decode.list(decode.int),
  )
  use care_team_sequence <- decode.optional_field(
    "careTeamSequence",
    [],
    decode.list(decode.int),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimItem(
    detail:,
    encounter:,
    body_site:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_accident_to_json(claim_accident: ClaimAccident) -> Json {
  let ClaimAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_accident
  let fields = [
    #("date", json.string(date)),
  ]
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimAccidentLocationAddress(_) -> "Address"
          ClaimAccidentLocationReference(_) -> "Reference"
        },
        claim_accident_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_accident_decoder() -> Decoder(ClaimAccident) {
  use location <- decode.then(
    none_if_omitted(claim_accident_location_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_insurance_to_json(claim_insurance: ClaimInsurance) -> Json {
  let ClaimInsurance(
    claim_response:,
    pre_auth_ref:,
    business_arrangement:,
    coverage:,
    identifier:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_insurance_decoder() -> Decoder(ClaimInsurance) {
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use focal <- decode.field("focal", decode.bool)
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimInsurance(
    claim_response:,
    pre_auth_ref:,
    business_arrangement:,
    coverage:,
    identifier:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_procedure_to_json(claim_procedure: ClaimProcedure) -> Json {
  let ClaimProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_procedure
  let fields = [
    #("procedure", claim_procedure_procedure_to_json(procedure)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_procedure_decoder() -> Decoder(ClaimProcedure) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use procedure <- decode.then(claim_procedure_procedure_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_diagnosis_to_json(claim_diagnosis: ClaimDiagnosis) -> Json {
  let ClaimDiagnosis(
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_diagnosis
  let fields = [
    #("diagnosis", claim_diagnosis_diagnosis_to_json(diagnosis)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case on_admission {
    Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_diagnosis_decoder() -> Decoder(ClaimDiagnosis) {
  use on_admission <- decode.optional_field(
    "onAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diagnosis <- decode.then(claim_diagnosis_diagnosis_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimDiagnosis(
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_supportinginfo_to_json(
  claim_supportinginfo: ClaimSupportinginfo,
) -> Json {
  let ClaimSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_supportinginfo
  let fields = [
    #("category", codeableconcept_to_json(category)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ClaimSupportinginfoValueBoolean(_) -> "Boolean"
          ClaimSupportinginfoValueString(_) -> "String"
          ClaimSupportinginfoValueQuantity(_) -> "Quantity"
          ClaimSupportinginfoValueAttachment(_) -> "Attachment"
          ClaimSupportinginfoValueReference(_) -> "Reference"
          ClaimSupportinginfoValueIdentifier(_) -> "Identifier"
        },
        claim_supportinginfo_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ClaimSupportinginfoTimingDate(_) -> "Date"
          ClaimSupportinginfoTimingPeriod(_) -> "Period"
        },
        claim_supportinginfo_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_supportinginfo_decoder() -> Decoder(ClaimSupportinginfo) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(claim_supportinginfo_value_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(claim_supportinginfo_timing_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_careteam_to_json(claim_careteam: ClaimCareteam) -> Json {
  let ClaimCareteam(
    specialty:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_careteam
  let fields = [
    #("provider", reference_to_json(provider)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case specialty {
    Some(v) -> [#("specialty", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_careteam_decoder() -> Decoder(ClaimCareteam) {
  use specialty <- decode.optional_field(
    "specialty",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.field("provider", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimCareteam(
    specialty:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_event_to_json(claim_event: ClaimEvent) -> Json {
  let ClaimEvent(when:, type_:, modifier_extension:, extension:, id:) =
    claim_event
  let fields = [
    #("when", claim_event_when_to_json(when)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_event_decoder() -> Decoder(ClaimEvent) {
  use when <- decode.then(claim_event_when_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimEvent(when:, type_:, modifier_extension:, extension:, id:))
}

pub fn claim_payee_to_json(claim_payee: ClaimPayee) -> Json {
  let ClaimPayee(party:, type_:, modifier_extension:, extension:, id:) =
    claim_payee
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_payee_decoder() -> Decoder(ClaimPayee) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_related_to_json(claim_related: ClaimRelated) -> Json {
  let ClaimRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ) = claim_related
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claim_related_decoder() -> Decoder(ClaimRelated) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(identifier_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claim_to_json(claim: Claim) -> Json {
  let Claim(
    total:,
    item:,
    patient_paid:,
    accident:,
    insurance:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    event:,
    diagnosis_related_group:,
    facility:,
    encounter:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = claim
  let fields = [
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r5valuesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case total {
    Some(v) -> [#("total", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, claim_item_to_json)), ..fields]
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case accident {
    Some(v) -> [#("accident", claim_accident_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #("insurance", json.array(insurance, claim_insurance_to_json)),
      ..fields
    ]
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #("procedure", json.array(procedure, claim_procedure_to_json)),
      ..fields
    ]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, claim_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, claim_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [
      #("careTeam", json.array(care_team, claim_careteam_to_json)),
      ..fields
    ]
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, claim_event_to_json)), ..fields]
  }
  let fields = case diagnosis_related_group {
    Some(v) -> [
      #("diagnosisRelatedGroup", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case referral {
    Some(v) -> [#("referral", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", claim_payee_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case original_prescription {
    Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prescription {
    Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related {
    [] -> fields
    _ -> [#("related", json.array(related, claim_related_to_json)), ..fields]
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case billable_period {
    Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Claim")), ..fields]
  json.object(fields)
}

pub fn claim_decoder() -> Decoder(Claim) {
  use total <- decode.optional_field(
    "total",
    None,
    decode.optional(money_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(claim_item_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use accident <- decode.optional_field(
    "accident",
    None,
    decode.optional(claim_accident_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(claim_insurance_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(claim_procedure_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(claim_diagnosis_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(claim_supportinginfo_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(claim_careteam_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(claim_event_decoder()),
  )
  use diagnosis_related_group <- decode.optional_field(
    "diagnosisRelatedGroup",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use referral <- decode.optional_field(
    "referral",
    None,
    decode.optional(reference_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(claim_payee_decoder()),
  )
  use original_prescription <- decode.optional_field(
    "originalPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use prescription <- decode.optional_field(
    "prescription",
    None,
    decode.optional(reference_decoder()),
  )
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(claim_related_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use billable_period <- decode.optional_field(
    "billablePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r5valuesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Claim",
    decode.failure(
      claim_new(created:, patient:, use_:, type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Claim(
    total:,
    item:,
    patient_paid:,
    accident:,
    insurance:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    event:,
    diagnosis_related_group:,
    facility:,
    encounter:,
    referral:,
    payee:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type Claimresponse {
  Claimresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    trace_number: List(Identifier),
    status: r5valuesets.Fmstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r5valuesets.Claimuse,
    patient: Reference,
    created: String,
    insurer: Option(Reference),
    requestor: Option(Reference),
    request: Option(Reference),
    outcome: r5valuesets.Claimoutcome,
    decision: Option(Codeableconcept),
    disposition: Option(String),
    pre_auth_ref: Option(String),
    pre_auth_period: Option(Period),
    event: List(ClaimresponseEvent),
    payee_type: Option(Codeableconcept),
    encounter: List(Reference),
    diagnosis_related_group: Option(Codeableconcept),
    item: List(ClaimresponseItem),
    add_item: List(ClaimresponseAdditem),
    total: List(ClaimresponseTotal),
    payment: Option(ClaimresponsePayment),
    funds_reserve: Option(Codeableconcept),
    form_code: Option(Codeableconcept),
    form: Option(Attachment),
    process_note: List(ClaimresponseProcessnote),
    communication_request: List(Reference),
    insurance: List(ClaimresponseInsurance),
    error: List(ClaimresponseError),
  )
}

pub fn claimresponse_new(
  outcome outcome: r5valuesets.Claimoutcome,
  created created: String,
  patient patient: Reference,
  use_ use_: r5valuesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r5valuesets.Fmstatus,
) -> Claimresponse {
  Claimresponse(
    error: [],
    insurance: [],
    communication_request: [],
    process_note: [],
    form: None,
    form_code: None,
    funds_reserve: None,
    payment: None,
    total: [],
    add_item: [],
    item: [],
    diagnosis_related_group: None,
    encounter: [],
    payee_type: None,
    event: [],
    pre_auth_period: None,
    pre_auth_ref: None,
    disposition: None,
    decision: None,
    outcome:,
    request: None,
    requestor: None,
    insurer: None,
    created:,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    trace_number: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseEvent {
  ClaimresponseEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    when: ClaimresponseEventWhen,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseEventWhen {
  ClaimresponseEventWhenDatetime(when: String)
  ClaimresponseEventWhenPeriod(when: Period)
}

pub fn claimresponse_event_when_to_json(elt: ClaimresponseEventWhen) -> Json {
  case elt {
    ClaimresponseEventWhenDatetime(v) -> json.string(v)
    ClaimresponseEventWhenPeriod(v) -> period_to_json(v)
  }
}

pub fn claimresponse_event_when_decoder() -> Decoder(ClaimresponseEventWhen) {
  decode.one_of(
    decode.field("whenDateTime", decode.string, decode.success)
      |> decode.map(ClaimresponseEventWhenDatetime),
    [
      decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimresponseEventWhenPeriod),
    ],
  )
}

pub fn claimresponse_event_new(
  when when: ClaimresponseEventWhen,
  type_ type_: Codeableconcept,
) -> ClaimresponseEvent {
  ClaimresponseEvent(
    when:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItem {
  ClaimresponseItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: Int,
    trace_number: List(Identifier),
    note_number: List(Int),
    review_outcome: Option(ClaimresponseItemReviewoutcome),
    adjudication: List(ClaimresponseItemAdjudication),
    detail: List(ClaimresponseItemDetail),
  )
}

pub fn claimresponse_item_new(
  item_sequence item_sequence: Int,
) -> ClaimresponseItem {
  ClaimresponseItem(
    detail: [],
    adjudication: [],
    review_outcome: None,
    note_number: [],
    trace_number: [],
    item_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemReviewoutcome {
  ClaimresponseItemReviewoutcome(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    decision: Option(Codeableconcept),
    reason: List(Codeableconcept),
    pre_auth_ref: Option(String),
    pre_auth_period: Option(Period),
  )
}

pub fn claimresponse_item_reviewoutcome_new() -> ClaimresponseItemReviewoutcome {
  ClaimresponseItemReviewoutcome(
    pre_auth_period: None,
    pre_auth_ref: None,
    reason: [],
    decision: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemAdjudication {
  ClaimresponseItemAdjudication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    reason: Option(Codeableconcept),
    amount: Option(Money),
    quantity: Option(Quantity),
  )
}

pub fn claimresponse_item_adjudication_new(
  category category: Codeableconcept,
) -> ClaimresponseItemAdjudication {
  ClaimresponseItemAdjudication(
    quantity: None,
    amount: None,
    reason: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetail {
  ClaimresponseItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    detail_sequence: Int,
    trace_number: List(Identifier),
    note_number: List(Int),
    sub_detail: List(ClaimresponseItemDetailSubdetail),
  )
}

pub fn claimresponse_item_detail_new(
  detail_sequence detail_sequence: Int,
) -> ClaimresponseItemDetail {
  ClaimresponseItemDetail(
    sub_detail: [],
    note_number: [],
    trace_number: [],
    detail_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseItemDetailSubdetail {
  ClaimresponseItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sub_detail_sequence: Int,
    trace_number: List(Identifier),
    note_number: List(Int),
  )
}

pub fn claimresponse_item_detail_subdetail_new(
  sub_detail_sequence sub_detail_sequence: Int,
) -> ClaimresponseItemDetailSubdetail {
  ClaimresponseItemDetailSubdetail(
    note_number: [],
    trace_number: [],
    sub_detail_sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditem {
  ClaimresponseAdditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: List(Int),
    detail_sequence: List(Int),
    subdetail_sequence: List(Int),
    trace_number: List(Identifier),
    provider: List(Reference),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    request: List(Reference),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ClaimresponseAdditemServiced),
    location: Option(ClaimresponseAdditemLocation),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    body_site: List(ClaimresponseAdditemBodysite),
    note_number: List(Int),
    detail: List(ClaimresponseAdditemDetail),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemServiced {
  ClaimresponseAdditemServicedDate(serviced: String)
  ClaimresponseAdditemServicedPeriod(serviced: Period)
}

pub fn claimresponse_additem_serviced_to_json(
  elt: ClaimresponseAdditemServiced,
) -> Json {
  case elt {
    ClaimresponseAdditemServicedDate(v) -> json.string(v)
    ClaimresponseAdditemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn claimresponse_additem_serviced_decoder() -> Decoder(
  ClaimresponseAdditemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ClaimresponseAdditemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ClaimresponseAdditemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemLocation {
  ClaimresponseAdditemLocationCodeableconcept(location: Codeableconcept)
  ClaimresponseAdditemLocationAddress(location: Address)
  ClaimresponseAdditemLocationReference(location: Reference)
}

pub fn claimresponse_additem_location_to_json(
  elt: ClaimresponseAdditemLocation,
) -> Json {
  case elt {
    ClaimresponseAdditemLocationCodeableconcept(v) -> codeableconcept_to_json(v)
    ClaimresponseAdditemLocationAddress(v) -> address_to_json(v)
    ClaimresponseAdditemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn claimresponse_additem_location_decoder() -> Decoder(
  ClaimresponseAdditemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ClaimresponseAdditemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ClaimresponseAdditemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ClaimresponseAdditemLocationReference),
    ],
  )
}

pub fn claimresponse_additem_new() -> ClaimresponseAdditem {
  ClaimresponseAdditem(
    detail: [],
    note_number: [],
    body_site: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    request: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    provider: [],
    trace_number: [],
    subdetail_sequence: [],
    detail_sequence: [],
    item_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemBodysite {
  ClaimresponseAdditemBodysite(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: List(Codeablereference),
    sub_site: List(Codeableconcept),
  )
}

pub fn claimresponse_additem_bodysite_new() -> ClaimresponseAdditemBodysite {
  ClaimresponseAdditemBodysite(
    sub_site: [],
    site: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetail {
  ClaimresponseAdditemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    note_number: List(Int),
    sub_detail: List(ClaimresponseAdditemDetailSubdetail),
  )
}

pub fn claimresponse_additem_detail_new() -> ClaimresponseAdditemDetail {
  ClaimresponseAdditemDetail(
    sub_detail: [],
    note_number: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    trace_number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseAdditemDetailSubdetail {
  ClaimresponseAdditemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    note_number: List(Int),
  )
}

pub fn claimresponse_additem_detail_subdetail_new() -> ClaimresponseAdditemDetailSubdetail {
  ClaimresponseAdditemDetailSubdetail(
    note_number: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    trace_number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseTotal {
  ClaimresponseTotal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    amount: Money,
  )
}

pub fn claimresponse_total_new(
  amount amount: Money,
  category category: Codeableconcept,
) -> ClaimresponseTotal {
  ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponsePayment {
  ClaimresponsePayment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    adjustment: Option(Money),
    adjustment_reason: Option(Codeableconcept),
    date: Option(String),
    amount: Money,
    identifier: Option(Identifier),
  )
}

pub fn claimresponse_payment_new(
  amount amount: Money,
  type_ type_: Codeableconcept,
) -> ClaimresponsePayment {
  ClaimresponsePayment(
    identifier: None,
    amount:,
    date: None,
    adjustment_reason: None,
    adjustment: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseProcessnote {
  ClaimresponseProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: Option(Int),
    type_: Option(Codeableconcept),
    text: String,
    language: Option(Codeableconcept),
  )
}

pub fn claimresponse_processnote_new(
  text text: String,
) -> ClaimresponseProcessnote {
  ClaimresponseProcessnote(
    language: None,
    text:,
    type_: None,
    number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseInsurance {
  ClaimresponseInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    focal: Bool,
    coverage: Reference,
    business_arrangement: Option(String),
    claim_response: Option(Reference),
  )
}

pub fn claimresponse_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
  sequence sequence: Int,
) -> ClaimresponseInsurance {
  ClaimresponseInsurance(
    claim_response: None,
    business_arrangement: None,
    coverage:,
    focal:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClaimResponse#resource
pub type ClaimresponseError {
  ClaimresponseError(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: Option(Int),
    detail_sequence: Option(Int),
    sub_detail_sequence: Option(Int),
    code: Codeableconcept,
    expression: List(String),
  )
}

pub fn claimresponse_error_new(code code: Codeableconcept) -> ClaimresponseError {
  ClaimresponseError(
    expression: [],
    code:,
    sub_detail_sequence: None,
    detail_sequence: None,
    item_sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn claimresponse_error_to_json(
  claimresponse_error: ClaimresponseError,
) -> Json {
  let ClaimresponseError(
    expression:,
    code:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_error
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case expression {
    [] -> fields
    _ -> [#("expression", json.array(expression, json.string)), ..fields]
  }
  let fields = case sub_detail_sequence {
    Some(v) -> [#("subDetailSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case detail_sequence {
    Some(v) -> [#("detailSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case item_sequence {
    Some(v) -> [#("itemSequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_error_decoder() -> Decoder(ClaimresponseError) {
  use expression <- decode.optional_field(
    "expression",
    [],
    decode.list(decode.string),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use sub_detail_sequence <- decode.optional_field(
    "subDetailSequence",
    None,
    decode.optional(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    None,
    decode.optional(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseError(
    expression:,
    code:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_insurance_to_json(
  claimresponse_insurance: ClaimresponseInsurance,
) -> Json {
  let ClaimresponseInsurance(
    claim_response:,
    business_arrangement:,
    coverage:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_insurance_decoder() -> Decoder(ClaimresponseInsurance) {
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.field("focal", decode.bool)
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseInsurance(
    claim_response:,
    business_arrangement:,
    coverage:,
    focal:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_processnote_to_json(
  claimresponse_processnote: ClaimresponseProcessnote,
) -> Json {
  let ClaimresponseProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_processnote
  let fields = [
    #("text", json.string(text)),
  ]
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_processnote_decoder() -> Decoder(ClaimresponseProcessnote) {
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.field("text", decode.string)
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_payment_to_json(
  claimresponse_payment: ClaimresponsePayment,
) -> Json {
  let ClaimresponsePayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_payment
  let fields = [
    #("amount", money_to_json(amount)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment_reason {
    Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment {
    Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_payment_decoder() -> Decoder(ClaimresponsePayment) {
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use amount <- decode.field("amount", money_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use adjustment_reason <- decode.optional_field(
    "adjustmentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use adjustment <- decode.optional_field(
    "adjustment",
    None,
    decode.optional(money_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponsePayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_total_to_json(
  claimresponse_total: ClaimresponseTotal,
) -> Json {
  let ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_total
  let fields = [
    #("amount", money_to_json(amount)),
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_total_decoder() -> Decoder(ClaimresponseTotal) {
  use amount <- decode.field("amount", money_decoder())
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_detail_subdetail_to_json(
  claimresponse_additem_detail_subdetail: ClaimresponseAdditemDetailSubdetail,
) -> Json {
  let ClaimresponseAdditemDetailSubdetail(
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem_detail_subdetail
  let fields = []
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_detail_subdetail_decoder() -> Decoder(
  ClaimresponseAdditemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditemDetailSubdetail(
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_detail_to_json(
  claimresponse_additem_detail: ClaimresponseAdditemDetail,
) -> Json {
  let ClaimresponseAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem_detail
  let fields = []
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claimresponse_additem_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_detail_decoder() -> Decoder(
  ClaimresponseAdditemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claimresponse_additem_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_bodysite_to_json(
  claimresponse_additem_bodysite: ClaimresponseAdditemBodysite,
) -> Json {
  let ClaimresponseAdditemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem_bodysite
  let fields = []
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, codeablereference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_bodysite_decoder() -> Decoder(
  ClaimresponseAdditemBodysite,
) {
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_additem_to_json(
  claimresponse_additem: ClaimresponseAdditem,
) -> Json {
  let ClaimresponseAdditem(
    detail:,
    note_number:,
    body_site:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    provider:,
    trace_number:,
    subdetail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_additem
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, claimresponse_additem_detail_to_json)),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #(
        "bodySite",
        json.array(body_site, claimresponse_additem_bodysite_to_json),
      ),
      ..fields
    ]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ClaimresponseAdditemLocationCodeableconcept(_) -> "Codeableconcept"
          ClaimresponseAdditemLocationAddress(_) -> "Address"
          ClaimresponseAdditemLocationReference(_) -> "Reference"
        },
        claimresponse_additem_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ClaimresponseAdditemServicedDate(_) -> "Date"
          ClaimresponseAdditemServicedPeriod(_) -> "Period"
        },
        claimresponse_additem_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    [] -> fields
    _ -> [#("provider", json.array(provider, reference_to_json)), ..fields]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case subdetail_sequence {
    [] -> fields
    _ -> [
      #("subdetailSequence", json.array(subdetail_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case detail_sequence {
    [] -> fields
    _ -> [#("detailSequence", json.array(detail_sequence, json.int)), ..fields]
  }
  let fields = case item_sequence {
    [] -> fields
    _ -> [#("itemSequence", json.array(item_sequence, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_additem_decoder() -> Decoder(ClaimresponseAdditem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claimresponse_additem_detail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(claimresponse_additem_bodysite_decoder()),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(claimresponse_additem_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(claimresponse_additem_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    [],
    decode.list(reference_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use subdetail_sequence <- decode.optional_field(
    "subdetailSequence",
    [],
    decode.list(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    [],
    decode.list(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseAdditem(
    detail:,
    note_number:,
    body_site:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    provider:,
    trace_number:,
    subdetail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_detail_subdetail_to_json(
  claimresponse_item_detail_subdetail: ClaimresponseItemDetailSubdetail,
) -> Json {
  let ClaimresponseItemDetailSubdetail(
    note_number:,
    trace_number:,
    sub_detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_detail_subdetail
  let fields = [
    #("subDetailSequence", json.int(sub_detail_sequence)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_detail_subdetail_decoder() -> Decoder(
  ClaimresponseItemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sub_detail_sequence <- decode.field("subDetailSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemDetailSubdetail(
    note_number:,
    trace_number:,
    sub_detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_detail_to_json(
  claimresponse_item_detail: ClaimresponseItemDetail,
) -> Json {
  let ClaimresponseItemDetail(
    sub_detail:,
    note_number:,
    trace_number:,
    detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_detail
  let fields = [
    #("detailSequence", json.int(detail_sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(sub_detail, claimresponse_item_detail_subdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_detail_decoder() -> Decoder(ClaimresponseItemDetail) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(claimresponse_item_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use detail_sequence <- decode.field("detailSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemDetail(
    sub_detail:,
    note_number:,
    trace_number:,
    detail_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_adjudication_to_json(
  claimresponse_item_adjudication: ClaimresponseItemAdjudication,
) -> Json {
  let ClaimresponseItemAdjudication(
    quantity:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_adjudication
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_adjudication_decoder() -> Decoder(
  ClaimresponseItemAdjudication,
) {
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemAdjudication(
    quantity:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_reviewoutcome_to_json(
  claimresponse_item_reviewoutcome: ClaimresponseItemReviewoutcome,
) -> Json {
  let ClaimresponseItemReviewoutcome(
    pre_auth_period:,
    pre_auth_ref:,
    reason:,
    decision:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item_reviewoutcome
  let fields = []
  let fields = case pre_auth_period {
    Some(v) -> [#("preAuthPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_reviewoutcome_decoder() -> Decoder(
  ClaimresponseItemReviewoutcome,
) {
  use pre_auth_period <- decode.optional_field(
    "preAuthPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItemReviewoutcome(
    pre_auth_period:,
    pre_auth_ref:,
    reason:,
    decision:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_item_to_json(claimresponse_item: ClaimresponseItem) -> Json {
  let ClaimresponseItem(
    detail:,
    adjudication:,
    review_outcome:,
    note_number:,
    trace_number:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = claimresponse_item
  let fields = [
    #("itemSequence", json.int(item_sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, claimresponse_item_detail_to_json)),
      ..fields
    ]
  }
  let fields = case adjudication {
    [] -> fields
    _ -> [
      #(
        "adjudication",
        json.array(adjudication, claimresponse_item_adjudication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case review_outcome {
    Some(v) -> [
      #("reviewOutcome", claimresponse_item_reviewoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_item_decoder() -> Decoder(ClaimresponseItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(claimresponse_item_detail_decoder()),
  )
  use adjudication <- decode.optional_field(
    "adjudication",
    [],
    decode.list(claimresponse_item_adjudication_decoder()),
  )
  use review_outcome <- decode.optional_field(
    "reviewOutcome",
    None,
    decode.optional(claimresponse_item_reviewoutcome_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use item_sequence <- decode.field("itemSequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseItem(
    detail:,
    adjudication:,
    review_outcome:,
    note_number:,
    trace_number:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_event_to_json(
  claimresponse_event: ClaimresponseEvent,
) -> Json {
  let ClaimresponseEvent(when:, type_:, modifier_extension:, extension:, id:) =
    claimresponse_event
  let fields = [
    #("when", claimresponse_event_when_to_json(when)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn claimresponse_event_decoder() -> Decoder(ClaimresponseEvent) {
  use when <- decode.then(claimresponse_event_when_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClaimresponseEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn claimresponse_to_json(claimresponse: Claimresponse) -> Json {
  let Claimresponse(
    error:,
    insurance:,
    communication_request:,
    process_note:,
    form:,
    form_code:,
    funds_reserve:,
    payment:,
    total:,
    add_item:,
    item:,
    diagnosis_related_group:,
    encounter:,
    payee_type:,
    event:,
    pre_auth_period:,
    pre_auth_ref:,
    disposition:,
    decision:,
    outcome:,
    request:,
    requestor:,
    insurer:,
    created:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = claimresponse
  let fields = [
    #("outcome", r5valuesets.claimoutcome_to_json(outcome)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r5valuesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [#("error", json.array(error, claimresponse_error_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #("insurance", json.array(insurance, claimresponse_insurance_to_json)),
      ..fields
    ]
  }
  let fields = case communication_request {
    [] -> fields
    _ -> [
      #(
        "communicationRequest",
        json.array(communication_request, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, claimresponse_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", claimresponse_payment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    [] -> fields
    _ -> [#("total", json.array(total, claimresponse_total_to_json)), ..fields]
  }
  let fields = case add_item {
    [] -> fields
    _ -> [
      #("addItem", json.array(add_item, claimresponse_additem_to_json)),
      ..fields
    ]
  }
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, claimresponse_item_to_json)), ..fields]
  }
  let fields = case diagnosis_related_group {
    Some(v) -> [
      #("diagnosisRelatedGroup", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case payee_type {
    Some(v) -> [#("payeeType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, claimresponse_event_to_json)), ..fields]
  }
  let fields = case pre_auth_period {
    Some(v) -> [#("preAuthPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Claimresponse")), ..fields]
  json.object(fields)
}

pub fn claimresponse_decoder() -> Decoder(Claimresponse) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(claimresponse_error_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(claimresponse_insurance_decoder()),
  )
  use communication_request <- decode.optional_field(
    "communicationRequest",
    [],
    decode.list(reference_decoder()),
  )
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(claimresponse_processnote_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(attachment_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(claimresponse_payment_decoder()),
  )
  use total <- decode.optional_field(
    "total",
    [],
    decode.list(claimresponse_total_decoder()),
  )
  use add_item <- decode.optional_field(
    "addItem",
    [],
    decode.list(claimresponse_additem_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(claimresponse_item_decoder()),
  )
  use diagnosis_related_group <- decode.optional_field(
    "diagnosisRelatedGroup",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use payee_type <- decode.optional_field(
    "payeeType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(claimresponse_event_decoder()),
  )
  use pre_auth_period <- decode.optional_field(
    "preAuthPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use outcome <- decode.field("outcome", r5valuesets.claimoutcome_decoder())
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r5valuesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Claimresponse",
    decode.failure(
      claimresponse_new(outcome:, created:, patient:, use_:, type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Claimresponse(
    error:,
    insurance:,
    communication_request:,
    process_note:,
    form:,
    form_code:,
    funds_reserve:,
    payment:,
    total:,
    add_item:,
    item:,
    diagnosis_related_group:,
    encounter:,
    payee_type:,
    event:,
    pre_auth_period:,
    pre_auth_ref:,
    disposition:,
    decision:,
    outcome:,
    request:,
    requestor:,
    insurer:,
    created:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalImpression#resource
pub type Clinicalimpression {
  Clinicalimpression(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Eventstatus,
    status_reason: Option(Codeableconcept),
    description: Option(String),
    subject: Reference,
    encounter: Option(Reference),
    effective: Option(ClinicalimpressionEffective),
    date: Option(String),
    performer: Option(Reference),
    previous: Option(Reference),
    problem: List(Reference),
    change_pattern: Option(Codeableconcept),
    protocol: List(String),
    summary: Option(String),
    finding: List(ClinicalimpressionFinding),
    prognosis_codeable_concept: List(Codeableconcept),
    prognosis_reference: List(Reference),
    supporting_info: List(Reference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionEffective {
  ClinicalimpressionEffectiveDatetime(effective: String)
  ClinicalimpressionEffectivePeriod(effective: Period)
}

pub fn clinicalimpression_effective_to_json(
  elt: ClinicalimpressionEffective,
) -> Json {
  case elt {
    ClinicalimpressionEffectiveDatetime(v) -> json.string(v)
    ClinicalimpressionEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn clinicalimpression_effective_decoder() -> Decoder(
  ClinicalimpressionEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(ClinicalimpressionEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(ClinicalimpressionEffectivePeriod),
    ],
  )
}

pub fn clinicalimpression_new(
  subject subject: Reference,
  status status: r5valuesets.Eventstatus,
) -> Clinicalimpression {
  Clinicalimpression(
    note: [],
    supporting_info: [],
    prognosis_reference: [],
    prognosis_codeable_concept: [],
    finding: [],
    summary: None,
    protocol: [],
    change_pattern: None,
    problem: [],
    previous: None,
    performer: None,
    date: None,
    effective: None,
    encounter: None,
    subject:,
    description: None,
    status_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalImpression#resource
pub type ClinicalimpressionFinding {
  ClinicalimpressionFinding(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Option(Codeablereference),
    basis: Option(String),
  )
}

pub fn clinicalimpression_finding_new() -> ClinicalimpressionFinding {
  ClinicalimpressionFinding(
    basis: None,
    item: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn clinicalimpression_finding_to_json(
  clinicalimpression_finding: ClinicalimpressionFinding,
) -> Json {
  let ClinicalimpressionFinding(
    basis:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalimpression_finding
  let fields = []
  let fields = case basis {
    Some(v) -> [#("basis", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case item {
    Some(v) -> [#("item", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalimpression_finding_decoder() -> Decoder(
  ClinicalimpressionFinding,
) {
  use basis <- decode.optional_field(
    "basis",
    None,
    decode.optional(decode.string),
  )
  use item <- decode.optional_field(
    "item",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalimpressionFinding(
    basis:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalimpression_to_json(
  clinicalimpression: Clinicalimpression,
) -> Json {
  let Clinicalimpression(
    note:,
    supporting_info:,
    prognosis_reference:,
    prognosis_codeable_concept:,
    finding:,
    summary:,
    protocol:,
    change_pattern:,
    problem:,
    previous:,
    performer:,
    date:,
    effective:,
    encounter:,
    subject:,
    description:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = clinicalimpression
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.eventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case prognosis_reference {
    [] -> fields
    _ -> [
      #(
        "prognosisReference",
        json.array(prognosis_reference, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case prognosis_codeable_concept {
    [] -> fields
    _ -> [
      #(
        "prognosisCodeableConcept",
        json.array(prognosis_codeable_concept, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case finding {
    [] -> fields
    _ -> [
      #("finding", json.array(finding, clinicalimpression_finding_to_json)),
      ..fields
    ]
  }
  let fields = case summary {
    Some(v) -> [#("summary", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case protocol {
    [] -> fields
    _ -> [#("protocol", json.array(protocol, json.string)), ..fields]
  }
  let fields = case change_pattern {
    Some(v) -> [#("changePattern", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case problem {
    [] -> fields
    _ -> [#("problem", json.array(problem, reference_to_json)), ..fields]
  }
  let fields = case previous {
    Some(v) -> [#("previous", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          ClinicalimpressionEffectiveDatetime(_) -> "Datetime"
          ClinicalimpressionEffectivePeriod(_) -> "Period"
        },
        clinicalimpression_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Clinicalimpression")), ..fields]
  json.object(fields)
}

pub fn clinicalimpression_decoder() -> Decoder(Clinicalimpression) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use prognosis_reference <- decode.optional_field(
    "prognosisReference",
    [],
    decode.list(reference_decoder()),
  )
  use prognosis_codeable_concept <- decode.optional_field(
    "prognosisCodeableConcept",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use finding <- decode.optional_field(
    "finding",
    [],
    decode.list(clinicalimpression_finding_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    None,
    decode.optional(decode.string),
  )
  use protocol <- decode.optional_field(
    "protocol",
    [],
    decode.list(decode.string),
  )
  use change_pattern <- decode.optional_field(
    "changePattern",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use problem <- decode.optional_field(
    "problem",
    [],
    decode.list(reference_decoder()),
  )
  use previous <- decode.optional_field(
    "previous",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(clinicalimpression_effective_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.eventstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Clinicalimpression",
    decode.failure(clinicalimpression_new(subject:, status:), "resourceType"),
  )
  decode.success(Clinicalimpression(
    note:,
    supporting_info:,
    prognosis_reference:,
    prognosis_codeable_concept:,
    finding:,
    summary:,
    protocol:,
    change_pattern:,
    problem:,
    previous:,
    performer:,
    date:,
    effective:,
    encounter:,
    subject:,
    description:,
    status_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type Clinicalusedefinition {
  Clinicalusedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: r5valuesets.Clinicalusedefinitiontype,
    category: List(Codeableconcept),
    subject: List(Reference),
    status: Option(Codeableconcept),
    contraindication: Option(ClinicalusedefinitionContraindication),
    indication: Option(ClinicalusedefinitionIndication),
    interaction: Option(ClinicalusedefinitionInteraction),
    population: List(Reference),
    library: List(String),
    undesirable_effect: Option(ClinicalusedefinitionUndesirableeffect),
    warning: Option(ClinicalusedefinitionWarning),
  )
}

pub fn clinicalusedefinition_new(
  type_ type_: r5valuesets.Clinicalusedefinitiontype,
) -> Clinicalusedefinition {
  Clinicalusedefinition(
    warning: None,
    undesirable_effect: None,
    library: [],
    population: [],
    interaction: None,
    indication: None,
    contraindication: None,
    status: None,
    subject: [],
    category: [],
    type_:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionContraindication {
  ClinicalusedefinitionContraindication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    disease_symptom_procedure: Option(Codeablereference),
    disease_status: Option(Codeablereference),
    comorbidity: List(Codeablereference),
    indication: List(Reference),
    applicability: Option(Expression),
    other_therapy: List(ClinicalusedefinitionContraindicationOthertherapy),
  )
}

pub fn clinicalusedefinition_contraindication_new() -> ClinicalusedefinitionContraindication {
  ClinicalusedefinitionContraindication(
    other_therapy: [],
    applicability: None,
    indication: [],
    comorbidity: [],
    disease_status: None,
    disease_symptom_procedure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionContraindicationOthertherapy {
  ClinicalusedefinitionContraindicationOthertherapy(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship_type: Codeableconcept,
    treatment: Codeablereference,
  )
}

pub fn clinicalusedefinition_contraindication_othertherapy_new(
  treatment treatment: Codeablereference,
  relationship_type relationship_type: Codeableconcept,
) -> ClinicalusedefinitionContraindicationOthertherapy {
  ClinicalusedefinitionContraindicationOthertherapy(
    treatment:,
    relationship_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionIndication {
  ClinicalusedefinitionIndication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    disease_symptom_procedure: Option(Codeablereference),
    disease_status: Option(Codeablereference),
    comorbidity: List(Codeablereference),
    intended_effect: Option(Codeablereference),
    duration: Option(ClinicalusedefinitionIndicationDuration),
    undesirable_effect: List(Reference),
    applicability: Option(Expression),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionIndicationDuration {
  ClinicalusedefinitionIndicationDurationRange(duration: Range)
  ClinicalusedefinitionIndicationDurationString(duration: String)
}

pub fn clinicalusedefinition_indication_duration_to_json(
  elt: ClinicalusedefinitionIndicationDuration,
) -> Json {
  case elt {
    ClinicalusedefinitionIndicationDurationRange(v) -> range_to_json(v)
    ClinicalusedefinitionIndicationDurationString(v) -> json.string(v)
  }
}

pub fn clinicalusedefinition_indication_duration_decoder() -> Decoder(
  ClinicalusedefinitionIndicationDuration,
) {
  decode.one_of(
    decode.field("durationRange", range_decoder(), decode.success)
      |> decode.map(ClinicalusedefinitionIndicationDurationRange),
    [
      decode.field("durationString", decode.string, decode.success)
      |> decode.map(ClinicalusedefinitionIndicationDurationString),
    ],
  )
}

pub fn clinicalusedefinition_indication_new() -> ClinicalusedefinitionIndication {
  ClinicalusedefinitionIndication(
    applicability: None,
    undesirable_effect: [],
    duration: None,
    intended_effect: None,
    comorbidity: [],
    disease_status: None,
    disease_symptom_procedure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteraction {
  ClinicalusedefinitionInteraction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    interactant: List(ClinicalusedefinitionInteractionInteractant),
    type_: Option(Codeableconcept),
    effect: Option(Codeablereference),
    incidence: Option(Codeableconcept),
    management: List(Codeableconcept),
  )
}

pub fn clinicalusedefinition_interaction_new() -> ClinicalusedefinitionInteraction {
  ClinicalusedefinitionInteraction(
    management: [],
    incidence: None,
    effect: None,
    type_: None,
    interactant: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteractionInteractant {
  ClinicalusedefinitionInteractionInteractant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: ClinicalusedefinitionInteractionInteractantItem,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionInteractionInteractantItem {
  ClinicalusedefinitionInteractionInteractantItemReference(item: Reference)
  ClinicalusedefinitionInteractionInteractantItemCodeableconcept(
    item: Codeableconcept,
  )
}

pub fn clinicalusedefinition_interaction_interactant_item_to_json(
  elt: ClinicalusedefinitionInteractionInteractantItem,
) -> Json {
  case elt {
    ClinicalusedefinitionInteractionInteractantItemReference(v) ->
      reference_to_json(v)
    ClinicalusedefinitionInteractionInteractantItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn clinicalusedefinition_interaction_interactant_item_decoder() -> Decoder(
  ClinicalusedefinitionInteractionInteractantItem,
) {
  decode.one_of(
    decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(ClinicalusedefinitionInteractionInteractantItemReference),
    [
      decode.field(
        "itemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(
        ClinicalusedefinitionInteractionInteractantItemCodeableconcept,
      ),
    ],
  )
}

pub fn clinicalusedefinition_interaction_interactant_new(
  item item: ClinicalusedefinitionInteractionInteractantItem,
) -> ClinicalusedefinitionInteractionInteractant {
  ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionUndesirableeffect {
  ClinicalusedefinitionUndesirableeffect(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    symptom_condition_effect: Option(Codeablereference),
    classification: Option(Codeableconcept),
    frequency_of_occurrence: Option(Codeableconcept),
  )
}

pub fn clinicalusedefinition_undesirableeffect_new() -> ClinicalusedefinitionUndesirableeffect {
  ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence: None,
    classification: None,
    symptom_condition_effect: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ClinicalUseDefinition#resource
pub type ClinicalusedefinitionWarning {
  ClinicalusedefinitionWarning(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    code: Option(Codeableconcept),
  )
}

pub fn clinicalusedefinition_warning_new() -> ClinicalusedefinitionWarning {
  ClinicalusedefinitionWarning(
    code: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn clinicalusedefinition_warning_to_json(
  clinicalusedefinition_warning: ClinicalusedefinitionWarning,
) -> Json {
  let ClinicalusedefinitionWarning(
    code:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_warning
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_warning_decoder() -> Decoder(
  ClinicalusedefinitionWarning,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionWarning(
    code:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_undesirableeffect_to_json(
  clinicalusedefinition_undesirableeffect: ClinicalusedefinitionUndesirableeffect,
) -> Json {
  let ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence:,
    classification:,
    symptom_condition_effect:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_undesirableeffect
  let fields = []
  let fields = case frequency_of_occurrence {
    Some(v) -> [
      #("frequencyOfOccurrence", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case classification {
    Some(v) -> [#("classification", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case symptom_condition_effect {
    Some(v) -> [
      #("symptomConditionEffect", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_undesirableeffect_decoder() -> Decoder(
  ClinicalusedefinitionUndesirableeffect,
) {
  use frequency_of_occurrence <- decode.optional_field(
    "frequencyOfOccurrence",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use symptom_condition_effect <- decode.optional_field(
    "symptomConditionEffect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionUndesirableeffect(
    frequency_of_occurrence:,
    classification:,
    symptom_condition_effect:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_interaction_interactant_to_json(
  clinicalusedefinition_interaction_interactant: ClinicalusedefinitionInteractionInteractant,
) -> Json {
  let ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_interaction_interactant
  let fields = [
    #("item", clinicalusedefinition_interaction_interactant_item_to_json(item)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_interaction_interactant_decoder() -> Decoder(
  ClinicalusedefinitionInteractionInteractant,
) {
  use item <- decode.then(
    clinicalusedefinition_interaction_interactant_item_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionInteractionInteractant(
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_interaction_to_json(
  clinicalusedefinition_interaction: ClinicalusedefinitionInteraction,
) -> Json {
  let ClinicalusedefinitionInteraction(
    management:,
    incidence:,
    effect:,
    type_:,
    interactant:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_interaction
  let fields = []
  let fields = case management {
    [] -> fields
    _ -> [
      #("management", json.array(management, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case incidence {
    Some(v) -> [#("incidence", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effect {
    Some(v) -> [#("effect", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case interactant {
    [] -> fields
    _ -> [
      #(
        "interactant",
        json.array(
          interactant,
          clinicalusedefinition_interaction_interactant_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_interaction_decoder() -> Decoder(
  ClinicalusedefinitionInteraction,
) {
  use management <- decode.optional_field(
    "management",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use incidence <- decode.optional_field(
    "incidence",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use effect <- decode.optional_field(
    "effect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use interactant <- decode.optional_field(
    "interactant",
    [],
    decode.list(clinicalusedefinition_interaction_interactant_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionInteraction(
    management:,
    incidence:,
    effect:,
    type_:,
    interactant:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_indication_to_json(
  clinicalusedefinition_indication: ClinicalusedefinitionIndication,
) -> Json {
  let ClinicalusedefinitionIndication(
    applicability:,
    undesirable_effect:,
    duration:,
    intended_effect:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_indication
  let fields = []
  let fields = case applicability {
    Some(v) -> [#("applicability", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case undesirable_effect {
    [] -> fields
    _ -> [
      #("undesirableEffect", json.array(undesirable_effect, reference_to_json)),
      ..fields
    ]
  }
  let fields = case duration {
    Some(v) -> [
      #(
        "duration"
          <> case v {
          ClinicalusedefinitionIndicationDurationRange(_) -> "Range"
          ClinicalusedefinitionIndicationDurationString(_) -> "String"
        },
        clinicalusedefinition_indication_duration_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case intended_effect {
    Some(v) -> [#("intendedEffect", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case comorbidity {
    [] -> fields
    _ -> [
      #("comorbidity", json.array(comorbidity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case disease_status {
    Some(v) -> [#("diseaseStatus", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disease_symptom_procedure {
    Some(v) -> [
      #("diseaseSymptomProcedure", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_indication_decoder() -> Decoder(
  ClinicalusedefinitionIndication,
) {
  use applicability <- decode.optional_field(
    "applicability",
    None,
    decode.optional(expression_decoder()),
  )
  use undesirable_effect <- decode.optional_field(
    "undesirableEffect",
    [],
    decode.list(reference_decoder()),
  )
  use duration <- decode.then(
    none_if_omitted(clinicalusedefinition_indication_duration_decoder()),
  )
  use intended_effect <- decode.optional_field(
    "intendedEffect",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use comorbidity <- decode.optional_field(
    "comorbidity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use disease_status <- decode.optional_field(
    "diseaseStatus",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use disease_symptom_procedure <- decode.optional_field(
    "diseaseSymptomProcedure",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionIndication(
    applicability:,
    undesirable_effect:,
    duration:,
    intended_effect:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_contraindication_othertherapy_to_json(
  clinicalusedefinition_contraindication_othertherapy: ClinicalusedefinitionContraindicationOthertherapy,
) -> Json {
  let ClinicalusedefinitionContraindicationOthertherapy(
    treatment:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_contraindication_othertherapy
  let fields = [
    #("treatment", codeablereference_to_json(treatment)),
    #("relationshipType", codeableconcept_to_json(relationship_type)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_contraindication_othertherapy_decoder() -> Decoder(
  ClinicalusedefinitionContraindicationOthertherapy,
) {
  use treatment <- decode.field("treatment", codeablereference_decoder())
  use relationship_type <- decode.field(
    "relationshipType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionContraindicationOthertherapy(
    treatment:,
    relationship_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_contraindication_to_json(
  clinicalusedefinition_contraindication: ClinicalusedefinitionContraindication,
) -> Json {
  let ClinicalusedefinitionContraindication(
    other_therapy:,
    applicability:,
    indication:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ) = clinicalusedefinition_contraindication
  let fields = []
  let fields = case other_therapy {
    [] -> fields
    _ -> [
      #(
        "otherTherapy",
        json.array(
          other_therapy,
          clinicalusedefinition_contraindication_othertherapy_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case applicability {
    Some(v) -> [#("applicability", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case indication {
    [] -> fields
    _ -> [#("indication", json.array(indication, reference_to_json)), ..fields]
  }
  let fields = case comorbidity {
    [] -> fields
    _ -> [
      #("comorbidity", json.array(comorbidity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case disease_status {
    Some(v) -> [#("diseaseStatus", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disease_symptom_procedure {
    Some(v) -> [
      #("diseaseSymptomProcedure", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn clinicalusedefinition_contraindication_decoder() -> Decoder(
  ClinicalusedefinitionContraindication,
) {
  use other_therapy <- decode.optional_field(
    "otherTherapy",
    [],
    decode.list(clinicalusedefinition_contraindication_othertherapy_decoder()),
  )
  use applicability <- decode.optional_field(
    "applicability",
    None,
    decode.optional(expression_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    [],
    decode.list(reference_decoder()),
  )
  use comorbidity <- decode.optional_field(
    "comorbidity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use disease_status <- decode.optional_field(
    "diseaseStatus",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use disease_symptom_procedure <- decode.optional_field(
    "diseaseSymptomProcedure",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ClinicalusedefinitionContraindication(
    other_therapy:,
    applicability:,
    indication:,
    comorbidity:,
    disease_status:,
    disease_symptom_procedure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn clinicalusedefinition_to_json(
  clinicalusedefinition: Clinicalusedefinition,
) -> Json {
  let Clinicalusedefinition(
    warning:,
    undesirable_effect:,
    library:,
    population:,
    interaction:,
    indication:,
    contraindication:,
    status:,
    subject:,
    category:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = clinicalusedefinition
  let fields = [
    #("type", r5valuesets.clinicalusedefinitiontype_to_json(type_)),
  ]
  let fields = case warning {
    Some(v) -> [
      #("warning", clinicalusedefinition_warning_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case undesirable_effect {
    Some(v) -> [
      #("undesirableEffect", clinicalusedefinition_undesirableeffect_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case population {
    [] -> fields
    _ -> [#("population", json.array(population, reference_to_json)), ..fields]
  }
  let fields = case interaction {
    Some(v) -> [
      #("interaction", clinicalusedefinition_interaction_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case indication {
    Some(v) -> [
      #("indication", clinicalusedefinition_indication_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case contraindication {
    Some(v) -> [
      #("contraindication", clinicalusedefinition_contraindication_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Clinicalusedefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn clinicalusedefinition_decoder() -> Decoder(Clinicalusedefinition) {
  use warning <- decode.optional_field(
    "warning",
    None,
    decode.optional(clinicalusedefinition_warning_decoder()),
  )
  use undesirable_effect <- decode.optional_field(
    "undesirableEffect",
    None,
    decode.optional(clinicalusedefinition_undesirableeffect_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(reference_decoder()),
  )
  use interaction <- decode.optional_field(
    "interaction",
    None,
    decode.optional(clinicalusedefinition_interaction_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    None,
    decode.optional(clinicalusedefinition_indication_decoder()),
  )
  use contraindication <- decode.optional_field(
    "contraindication",
    None,
    decode.optional(clinicalusedefinition_contraindication_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.clinicalusedefinitiontype_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Clinicalusedefinition",
    decode.failure(clinicalusedefinition_new(type_:), "resourceType"),
  )
  decode.success(Clinicalusedefinition(
    warning:,
    undesirable_effect:,
    library:,
    population:,
    interaction:,
    indication:,
    contraindication:,
    status:,
    subject:,
    category:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type Codesystem {
  Codesystem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(CodesystemVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    case_sensitive: Option(Bool),
    value_set: Option(String),
    hierarchy_meaning: Option(r5valuesets.Codesystemhierarchymeaning),
    compositional: Option(Bool),
    version_needed: Option(Bool),
    content: r5valuesets.Codesystemcontentmode,
    supplements: Option(String),
    count: Option(Int),
    filter: List(CodesystemFilter),
    property: List(CodesystemProperty),
    concept: List(CodesystemConcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemVersionalgorithm {
  CodesystemVersionalgorithmString(version_algorithm: String)
  CodesystemVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn codesystem_versionalgorithm_to_json(
  elt: CodesystemVersionalgorithm,
) -> Json {
  case elt {
    CodesystemVersionalgorithmString(v) -> json.string(v)
    CodesystemVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn codesystem_versionalgorithm_decoder() -> Decoder(
  CodesystemVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(CodesystemVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(CodesystemVersionalgorithmCoding),
    ],
  )
}

pub fn codesystem_new(
  content content: r5valuesets.Codesystemcontentmode,
  status status: r5valuesets.Publicationstatus,
) -> Codesystem {
  Codesystem(
    concept: [],
    property: [],
    filter: [],
    count: None,
    supplements: None,
    content:,
    version_needed: None,
    compositional: None,
    hierarchy_meaning: None,
    value_set: None,
    case_sensitive: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemFilter {
  CodesystemFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    description: Option(String),
    operator: List(r5valuesets.Filteroperator),
    value: String,
  )
}

pub fn codesystem_filter_new(
  value value: String,
  code code: String,
) -> CodesystemFilter {
  CodesystemFilter(
    value:,
    operator: [],
    description: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemProperty {
  CodesystemProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    uri: Option(String),
    description: Option(String),
    type_: r5valuesets.Conceptpropertytype,
  )
}

pub fn codesystem_property_new(
  type_ type_: r5valuesets.Conceptpropertytype,
  code code: String,
) -> CodesystemProperty {
  CodesystemProperty(
    type_:,
    description: None,
    uri: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemConcept {
  CodesystemConcept(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    display: Option(String),
    definition: Option(String),
    designation: List(CodesystemConceptDesignation),
    property: List(CodesystemConceptProperty),
  )
}

pub fn codesystem_concept_new(code code: String) -> CodesystemConcept {
  CodesystemConcept(
    property: [],
    designation: [],
    definition: None,
    display: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptDesignation {
  CodesystemConceptDesignation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(String),
    use_: Option(Coding),
    additional_use: List(Coding),
    value: String,
  )
}

pub fn codesystem_concept_designation_new(
  value value: String,
) -> CodesystemConceptDesignation {
  CodesystemConceptDesignation(
    value:,
    additional_use: [],
    use_: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptProperty {
  CodesystemConceptProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    value: CodesystemConceptPropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CodeSystem#resource
pub type CodesystemConceptPropertyValue {
  CodesystemConceptPropertyValueCode(value: String)
  CodesystemConceptPropertyValueCoding(value: Coding)
  CodesystemConceptPropertyValueString(value: String)
  CodesystemConceptPropertyValueInteger(value: Int)
  CodesystemConceptPropertyValueBoolean(value: Bool)
  CodesystemConceptPropertyValueDatetime(value: String)
  CodesystemConceptPropertyValueDecimal(value: Float)
}

pub fn codesystem_concept_property_value_to_json(
  elt: CodesystemConceptPropertyValue,
) -> Json {
  case elt {
    CodesystemConceptPropertyValueCode(v) -> json.string(v)
    CodesystemConceptPropertyValueCoding(v) -> coding_to_json(v)
    CodesystemConceptPropertyValueString(v) -> json.string(v)
    CodesystemConceptPropertyValueInteger(v) -> json.int(v)
    CodesystemConceptPropertyValueBoolean(v) -> json.bool(v)
    CodesystemConceptPropertyValueDatetime(v) -> json.string(v)
    CodesystemConceptPropertyValueDecimal(v) -> json.float(v)
  }
}

pub fn codesystem_concept_property_value_decoder() -> Decoder(
  CodesystemConceptPropertyValue,
) {
  decode.one_of(
    decode.field("valueCode", decode.string, decode.success)
      |> decode.map(CodesystemConceptPropertyValueCode),
    [
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(CodesystemConceptPropertyValueCoding),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(CodesystemConceptPropertyValueString),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(CodesystemConceptPropertyValueInteger),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(CodesystemConceptPropertyValueBoolean),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(CodesystemConceptPropertyValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(CodesystemConceptPropertyValueDecimal),
    ],
  )
}

pub fn codesystem_concept_property_new(
  value value: CodesystemConceptPropertyValue,
  code code: String,
) -> CodesystemConceptProperty {
  CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn codesystem_concept_property_to_json(
  codesystem_concept_property: CodesystemConceptProperty,
) -> Json {
  let CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept_property
  let fields = [
    #("value", codesystem_concept_property_value_to_json(value)),
    #("code", json.string(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_property_decoder() -> Decoder(
  CodesystemConceptProperty,
) {
  use value <- decode.then(codesystem_concept_property_value_decoder())
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConceptProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_concept_designation_to_json(
  codesystem_concept_designation: CodesystemConceptDesignation,
) -> Json {
  let CodesystemConceptDesignation(
    value:,
    additional_use:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept_designation
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case additional_use {
    [] -> fields
    _ -> [
      #("additionalUse", json.array(additional_use, coding_to_json)),
      ..fields
    ]
  }
  let fields = case use_ {
    Some(v) -> [#("use", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_designation_decoder() -> Decoder(
  CodesystemConceptDesignation,
) {
  use value <- decode.field("value", decode.string)
  use additional_use <- decode.optional_field(
    "additionalUse",
    [],
    decode.list(coding_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(coding_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConceptDesignation(
    value:,
    additional_use:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_concept_to_json(codesystem_concept: CodesystemConcept) -> Json {
  let CodesystemConcept(
    property:,
    designation:,
    definition:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_concept
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, codesystem_concept_property_to_json)),
      ..fields
    ]
  }
  let fields = case designation {
    [] -> fields
    _ -> [
      #(
        "designation",
        json.array(designation, codesystem_concept_designation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_concept_decoder() -> Decoder(CodesystemConcept) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(codesystem_concept_property_decoder()),
  )
  use designation <- decode.optional_field(
    "designation",
    [],
    decode.list(codesystem_concept_designation_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemConcept(
    property:,
    designation:,
    definition:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_property_to_json(
  codesystem_property: CodesystemProperty,
) -> Json {
  let CodesystemProperty(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_property
  let fields = [
    #("type", r5valuesets.conceptpropertytype_to_json(type_)),
    #("code", json.string(code)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_property_decoder() -> Decoder(CodesystemProperty) {
  use type_ <- decode.field("type", r5valuesets.conceptpropertytype_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemProperty(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_filter_to_json(codesystem_filter: CodesystemFilter) -> Json {
  let CodesystemFilter(
    value:,
    operator:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = codesystem_filter
  let fields = [
    #("value", json.string(value)),
    #("code", json.string(code)),
  ]
  let fields = case operator {
    [] -> fields
    _ -> [
      #("operator", json.array(operator, r5valuesets.filteroperator_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn codesystem_filter_decoder() -> Decoder(CodesystemFilter) {
  use value <- decode.field("value", decode.string)
  use operator <- decode.optional_field(
    "operator",
    [],
    decode.list(r5valuesets.filteroperator_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CodesystemFilter(
    value:,
    operator:,
    description:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn codesystem_to_json(codesystem: Codesystem) -> Json {
  let Codesystem(
    concept:,
    property:,
    filter:,
    count:,
    supplements:,
    content:,
    version_needed:,
    compositional:,
    hierarchy_meaning:,
    value_set:,
    case_sensitive:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = codesystem
  let fields = [
    #("content", r5valuesets.codesystemcontentmode_to_json(content)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case concept {
    [] -> fields
    _ -> [
      #("concept", json.array(concept, codesystem_concept_to_json)),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, codesystem_property_to_json)),
      ..fields
    ]
  }
  let fields = case filter {
    [] -> fields
    _ -> [#("filter", json.array(filter, codesystem_filter_to_json)), ..fields]
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case supplements {
    Some(v) -> [#("supplements", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_needed {
    Some(v) -> [#("versionNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case compositional {
    Some(v) -> [#("compositional", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case hierarchy_meaning {
    Some(v) -> [
      #("hierarchyMeaning", r5valuesets.codesystemhierarchymeaning_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case case_sensitive {
    Some(v) -> [#("caseSensitive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          CodesystemVersionalgorithmString(_) -> "String"
          CodesystemVersionalgorithmCoding(_) -> "Coding"
        },
        codesystem_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Codesystem")), ..fields]
  json.object(fields)
}

pub fn codesystem_decoder() -> Decoder(Codesystem) {
  use concept <- decode.optional_field(
    "concept",
    [],
    decode.list(codesystem_concept_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(codesystem_property_decoder()),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(codesystem_filter_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use supplements <- decode.optional_field(
    "supplements",
    None,
    decode.optional(decode.string),
  )
  use content <- decode.field(
    "content",
    r5valuesets.codesystemcontentmode_decoder(),
  )
  use version_needed <- decode.optional_field(
    "versionNeeded",
    None,
    decode.optional(decode.bool),
  )
  use compositional <- decode.optional_field(
    "compositional",
    None,
    decode.optional(decode.bool),
  )
  use hierarchy_meaning <- decode.optional_field(
    "hierarchyMeaning",
    None,
    decode.optional(r5valuesets.codesystemhierarchymeaning_decoder()),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use case_sensitive <- decode.optional_field(
    "caseSensitive",
    None,
    decode.optional(decode.bool),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(codesystem_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Codesystem",
    decode.failure(codesystem_new(content:, status:), "resourceType"),
  )
  decode.success(Codesystem(
    concept:,
    property:,
    filter:,
    count:,
    supplements:,
    content:,
    version_needed:,
    compositional:,
    hierarchy_meaning:,
    value_set:,
    case_sensitive:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Communication#resource
pub type Communication {
  Communication(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    part_of: List(Reference),
    in_response_to: List(Reference),
    status: r5valuesets.Eventstatus,
    status_reason: Option(Codeableconcept),
    category: List(Codeableconcept),
    priority: Option(r5valuesets.Requestpriority),
    medium: List(Codeableconcept),
    subject: Option(Reference),
    topic: Option(Codeableconcept),
    about: List(Reference),
    encounter: Option(Reference),
    sent: Option(String),
    received: Option(String),
    recipient: List(Reference),
    sender: Option(Reference),
    reason: List(Codeablereference),
    payload: List(CommunicationPayload),
    note: List(Annotation),
  )
}

pub fn communication_new(
  status status: r5valuesets.Eventstatus,
) -> Communication {
  Communication(
    note: [],
    payload: [],
    reason: [],
    sender: None,
    recipient: [],
    received: None,
    sent: None,
    encounter: None,
    about: [],
    topic: None,
    subject: None,
    medium: [],
    priority: None,
    category: [],
    status_reason: None,
    status:,
    in_response_to: [],
    part_of: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Communication#resource
pub type CommunicationPayload {
  CommunicationPayload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: CommunicationPayloadContent,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Communication#resource
pub type CommunicationPayloadContent {
  CommunicationPayloadContentAttachment(content: Attachment)
  CommunicationPayloadContentReference(content: Reference)
  CommunicationPayloadContentCodeableconcept(content: Codeableconcept)
}

pub fn communication_payload_content_to_json(
  elt: CommunicationPayloadContent,
) -> Json {
  case elt {
    CommunicationPayloadContentAttachment(v) -> attachment_to_json(v)
    CommunicationPayloadContentReference(v) -> reference_to_json(v)
    CommunicationPayloadContentCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn communication_payload_content_decoder() -> Decoder(
  CommunicationPayloadContent,
) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(CommunicationPayloadContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
        |> decode.map(CommunicationPayloadContentReference),
      decode.field(
        "contentCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(CommunicationPayloadContentCodeableconcept),
    ],
  )
}

pub fn communication_payload_new(
  content content: CommunicationPayloadContent,
) -> CommunicationPayload {
  CommunicationPayload(
    content:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn communication_payload_to_json(
  communication_payload: CommunicationPayload,
) -> Json {
  let CommunicationPayload(content:, modifier_extension:, extension:, id:) =
    communication_payload
  let fields = [
    #("content", communication_payload_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn communication_payload_decoder() -> Decoder(CommunicationPayload) {
  use content <- decode.then(communication_payload_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CommunicationPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn communication_to_json(communication: Communication) -> Json {
  let Communication(
    note:,
    payload:,
    reason:,
    sender:,
    recipient:,
    received:,
    sent:,
    encounter:,
    about:,
    topic:,
    subject:,
    medium:,
    priority:,
    category:,
    status_reason:,
    status:,
    in_response_to:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = communication
  let fields = [
    #("status", r5valuesets.eventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case payload {
    [] -> fields
    _ -> [
      #("payload", json.array(payload, communication_payload_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case sender {
    Some(v) -> [#("sender", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case received {
    Some(v) -> [#("received", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sent {
    Some(v) -> [#("sent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case about {
    [] -> fields
    _ -> [#("about", json.array(about, reference_to_json)), ..fields]
  }
  let fields = case topic {
    Some(v) -> [#("topic", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case medium {
    [] -> fields
    _ -> [#("medium", json.array(medium, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case in_response_to {
    [] -> fields
    _ -> [
      #("inResponseTo", json.array(in_response_to, reference_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Communication")), ..fields]
  json.object(fields)
}

pub fn communication_decoder() -> Decoder(Communication) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use payload <- decode.optional_field(
    "payload",
    [],
    decode.list(communication_payload_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use sender <- decode.optional_field(
    "sender",
    None,
    decode.optional(reference_decoder()),
  )
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use received <- decode.optional_field(
    "received",
    None,
    decode.optional(decode.string),
  )
  use sent <- decode.optional_field(
    "sent",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use about <- decode.optional_field(
    "about",
    [],
    decode.list(reference_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use medium <- decode.optional_field(
    "medium",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.eventstatus_decoder())
  use in_response_to <- decode.optional_field(
    "inResponseTo",
    [],
    decode.list(reference_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Communication",
    decode.failure(communication_new(status:), "resourceType"),
  )
  decode.success(Communication(
    note:,
    payload:,
    reason:,
    sender:,
    recipient:,
    received:,
    sent:,
    encounter:,
    about:,
    topic:,
    subject:,
    medium:,
    priority:,
    category:,
    status_reason:,
    status:,
    in_response_to:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CommunicationRequest#resource
pub type Communicationrequest {
  Communicationrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    replaces: List(Reference),
    group_identifier: Option(Identifier),
    status: r5valuesets.Requeststatus,
    status_reason: Option(Codeableconcept),
    intent: r5valuesets.Requestintent,
    category: List(Codeableconcept),
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    medium: List(Codeableconcept),
    subject: Option(Reference),
    about: List(Reference),
    encounter: Option(Reference),
    payload: List(CommunicationrequestPayload),
    occurrence: Option(CommunicationrequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    recipient: List(Reference),
    information_provider: List(Reference),
    reason: List(Codeablereference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestOccurrence {
  CommunicationrequestOccurrenceDatetime(occurrence: String)
  CommunicationrequestOccurrencePeriod(occurrence: Period)
}

pub fn communicationrequest_occurrence_to_json(
  elt: CommunicationrequestOccurrence,
) -> Json {
  case elt {
    CommunicationrequestOccurrenceDatetime(v) -> json.string(v)
    CommunicationrequestOccurrencePeriod(v) -> period_to_json(v)
  }
}

pub fn communicationrequest_occurrence_decoder() -> Decoder(
  CommunicationrequestOccurrence,
) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(CommunicationrequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
      |> decode.map(CommunicationrequestOccurrencePeriod),
    ],
  )
}

pub fn communicationrequest_new(
  intent intent: r5valuesets.Requestintent,
  status status: r5valuesets.Requeststatus,
) -> Communicationrequest {
  Communicationrequest(
    note: [],
    reason: [],
    information_provider: [],
    recipient: [],
    requester: None,
    authored_on: None,
    occurrence: None,
    payload: [],
    encounter: None,
    about: [],
    subject: None,
    medium: [],
    do_not_perform: None,
    priority: None,
    category: [],
    intent:,
    status_reason: None,
    status:,
    group_identifier: None,
    replaces: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayload {
  CommunicationrequestPayload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: CommunicationrequestPayloadContent,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CommunicationRequest#resource
pub type CommunicationrequestPayloadContent {
  CommunicationrequestPayloadContentAttachment(content: Attachment)
  CommunicationrequestPayloadContentReference(content: Reference)
  CommunicationrequestPayloadContentCodeableconcept(content: Codeableconcept)
}

pub fn communicationrequest_payload_content_to_json(
  elt: CommunicationrequestPayloadContent,
) -> Json {
  case elt {
    CommunicationrequestPayloadContentAttachment(v) -> attachment_to_json(v)
    CommunicationrequestPayloadContentReference(v) -> reference_to_json(v)
    CommunicationrequestPayloadContentCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn communicationrequest_payload_content_decoder() -> Decoder(
  CommunicationrequestPayloadContent,
) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(CommunicationrequestPayloadContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
        |> decode.map(CommunicationrequestPayloadContentReference),
      decode.field(
        "contentCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(CommunicationrequestPayloadContentCodeableconcept),
    ],
  )
}

pub fn communicationrequest_payload_new(
  content content: CommunicationrequestPayloadContent,
) -> CommunicationrequestPayload {
  CommunicationrequestPayload(
    content:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn communicationrequest_payload_to_json(
  communicationrequest_payload: CommunicationrequestPayload,
) -> Json {
  let CommunicationrequestPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ) = communicationrequest_payload
  let fields = [
    #("content", communicationrequest_payload_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn communicationrequest_payload_decoder() -> Decoder(
  CommunicationrequestPayload,
) {
  use content <- decode.then(communicationrequest_payload_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CommunicationrequestPayload(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn communicationrequest_to_json(
  communicationrequest: Communicationrequest,
) -> Json {
  let Communicationrequest(
    note:,
    reason:,
    information_provider:,
    recipient:,
    requester:,
    authored_on:,
    occurrence:,
    payload:,
    encounter:,
    about:,
    subject:,
    medium:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_reason:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = communicationrequest
  let fields = [
    #("intent", r5valuesets.requestintent_to_json(intent)),
    #("status", r5valuesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case information_provider {
    [] -> fields
    _ -> [
      #(
        "informationProvider",
        json.array(information_provider, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          CommunicationrequestOccurrenceDatetime(_) -> "Datetime"
          CommunicationrequestOccurrencePeriod(_) -> "Period"
        },
        communicationrequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case payload {
    [] -> fields
    _ -> [
      #("payload", json.array(payload, communicationrequest_payload_to_json)),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case about {
    [] -> fields
    _ -> [#("about", json.array(about, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case medium {
    [] -> fields
    _ -> [#("medium", json.array(medium, codeableconcept_to_json)), ..fields]
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Communicationrequest")),
    ..fields
  ]
  json.object(fields)
}

pub fn communicationrequest_decoder() -> Decoder(Communicationrequest) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use information_provider <- decode.optional_field(
    "informationProvider",
    [],
    decode.list(reference_decoder()),
  )
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(communicationrequest_occurrence_decoder()),
  )
  use payload <- decode.optional_field(
    "payload",
    [],
    decode.list(communicationrequest_payload_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use about <- decode.optional_field(
    "about",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use medium <- decode.optional_field(
    "medium",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.requestintent_decoder())
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.requeststatus_decoder())
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Communicationrequest",
    decode.failure(communicationrequest_new(intent:, status:), "resourceType"),
  )
  decode.success(Communicationrequest(
    note:,
    reason:,
    information_provider:,
    recipient:,
    requester:,
    authored_on:,
    occurrence:,
    payload:,
    encounter:,
    about:,
    subject:,
    medium:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_reason:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CompartmentDefinition#resource
pub type Compartmentdefinition {
  Compartmentdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    version: Option(String),
    version_algorithm: Option(CompartmentdefinitionVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    purpose: Option(String),
    code: r5valuesets.Compartmenttype,
    search: Bool,
    resource: List(CompartmentdefinitionResource),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CompartmentDefinition#resource
pub type CompartmentdefinitionVersionalgorithm {
  CompartmentdefinitionVersionalgorithmString(version_algorithm: String)
  CompartmentdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn compartmentdefinition_versionalgorithm_to_json(
  elt: CompartmentdefinitionVersionalgorithm,
) -> Json {
  case elt {
    CompartmentdefinitionVersionalgorithmString(v) -> json.string(v)
    CompartmentdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn compartmentdefinition_versionalgorithm_decoder() -> Decoder(
  CompartmentdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(CompartmentdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(CompartmentdefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn compartmentdefinition_new(
  search search: Bool,
  code code: r5valuesets.Compartmenttype,
  status status: r5valuesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Compartmentdefinition {
  Compartmentdefinition(
    resource: [],
    search:,
    code:,
    purpose: None,
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CompartmentDefinition#resource
pub type CompartmentdefinitionResource {
  CompartmentdefinitionResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Resourcetypes,
    param: List(String),
    documentation: Option(String),
    start_param: Option(String),
    end_param: Option(String),
  )
}

pub fn compartmentdefinition_resource_new(
  code code: r5valuesets.Resourcetypes,
) -> CompartmentdefinitionResource {
  CompartmentdefinitionResource(
    end_param: None,
    start_param: None,
    documentation: None,
    param: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn compartmentdefinition_resource_to_json(
  compartmentdefinition_resource: CompartmentdefinitionResource,
) -> Json {
  let CompartmentdefinitionResource(
    end_param:,
    start_param:,
    documentation:,
    param:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = compartmentdefinition_resource
  let fields = [
    #("code", r5valuesets.resourcetypes_to_json(code)),
  ]
  let fields = case end_param {
    Some(v) -> [#("endParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start_param {
    Some(v) -> [#("startParam", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case param {
    [] -> fields
    _ -> [#("param", json.array(param, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn compartmentdefinition_resource_decoder() -> Decoder(
  CompartmentdefinitionResource,
) {
  use end_param <- decode.optional_field(
    "endParam",
    None,
    decode.optional(decode.string),
  )
  use start_param <- decode.optional_field(
    "startParam",
    None,
    decode.optional(decode.string),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use param <- decode.optional_field("param", [], decode.list(decode.string))
  use code <- decode.field("code", r5valuesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompartmentdefinitionResource(
    end_param:,
    start_param:,
    documentation:,
    param:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn compartmentdefinition_to_json(
  compartmentdefinition: Compartmentdefinition,
) -> Json {
  let Compartmentdefinition(
    resource:,
    search:,
    code:,
    purpose:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = compartmentdefinition
  let fields = [
    #("search", json.bool(search)),
    #("code", r5valuesets.compartmenttype_to_json(code)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, compartmentdefinition_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          CompartmentdefinitionVersionalgorithmString(_) -> "String"
          CompartmentdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        compartmentdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Compartmentdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn compartmentdefinition_decoder() -> Decoder(Compartmentdefinition) {
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(compartmentdefinition_resource_decoder()),
  )
  use search <- decode.field("search", decode.bool)
  use code <- decode.field("code", r5valuesets.compartmenttype_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(compartmentdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Compartmentdefinition",
    decode.failure(
      compartmentdefinition_new(search:, code:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Compartmentdefinition(
    resource:,
    search:,
    code:,
    purpose:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Composition#resource
pub type Composition {
  Composition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    status: r5valuesets.Compositionstatus,
    type_: Codeableconcept,
    category: List(Codeableconcept),
    subject: List(Reference),
    encounter: Option(Reference),
    date: String,
    use_context: List(Usagecontext),
    author: List(Reference),
    name: Option(String),
    title: String,
    note: List(Annotation),
    attester: List(CompositionAttester),
    custodian: Option(Reference),
    relates_to: List(Relatedartifact),
    event: List(CompositionEvent),
    section: List(CompositionSection),
  )
}

pub fn composition_new(
  title title: String,
  date date: String,
  type_ type_: Codeableconcept,
  status status: r5valuesets.Compositionstatus,
) -> Composition {
  Composition(
    section: [],
    event: [],
    relates_to: [],
    custodian: None,
    attester: [],
    note: [],
    title:,
    name: None,
    author: [],
    use_context: [],
    date:,
    encounter: None,
    subject: [],
    category: [],
    type_:,
    status:,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Composition#resource
pub type CompositionAttester {
  CompositionAttester(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: Codeableconcept,
    time: Option(String),
    party: Option(Reference),
  )
}

pub fn composition_attester_new(
  mode mode: Codeableconcept,
) -> CompositionAttester {
  CompositionAttester(
    party: None,
    time: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Composition#resource
pub type CompositionEvent {
  CompositionEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    period: Option(Period),
    detail: List(Codeablereference),
  )
}

pub fn composition_event_new() -> CompositionEvent {
  CompositionEvent(
    detail: [],
    period: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Composition#resource
pub type CompositionSection {
  CompositionSection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    code: Option(Codeableconcept),
    author: List(Reference),
    focus: Option(Reference),
    text: Option(Narrative),
    ordered_by: Option(Codeableconcept),
    entry: List(Reference),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn composition_section_new() -> CompositionSection {
  CompositionSection(
    empty_reason: None,
    entry: [],
    ordered_by: None,
    text: None,
    focus: None,
    author: [],
    code: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn composition_section_to_json(
  composition_section: CompositionSection,
) -> Json {
  let CompositionSection(
    empty_reason:,
    entry:,
    ordered_by:,
    text:,
    focus:,
    author:,
    code:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = composition_section
  let fields = []
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, reference_to_json)), ..fields]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_section_decoder() -> Decoder(CompositionSection) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(reference_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionSection(
    empty_reason:,
    entry:,
    ordered_by:,
    text:,
    focus:,
    author:,
    code:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_event_to_json(composition_event: CompositionEvent) -> Json {
  let CompositionEvent(detail:, period:, modifier_extension:, extension:, id:) =
    composition_event
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, codeablereference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_event_decoder() -> Decoder(CompositionEvent) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(codeablereference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionEvent(
    detail:,
    period:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_attester_to_json(
  composition_attester: CompositionAttester,
) -> Json {
  let CompositionAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = composition_attester
  let fields = [
    #("mode", codeableconcept_to_json(mode)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn composition_attester_decoder() -> Decoder(CompositionAttester) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CompositionAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn composition_to_json(composition: Composition) -> Json {
  let Composition(
    section:,
    event:,
    relates_to:,
    custodian:,
    attester:,
    note:,
    title:,
    name:,
    author:,
    use_context:,
    date:,
    encounter:,
    subject:,
    category:,
    type_:,
    status:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = composition
  let fields = [
    #("title", json.string(title)),
    #("date", json.string(date)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r5valuesets.compositionstatus_to_json(status)),
  ]
  let fields = case section {
    [] -> fields
    _ -> [
      #("section", json.array(section, composition_section_to_json)),
      ..fields
    ]
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, composition_event_to_json)), ..fields]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #("relatesTo", json.array(relates_to, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case attester {
    [] -> fields
    _ -> [
      #("attester", json.array(attester, composition_attester_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Composition")), ..fields]
  json.object(fields)
}

pub fn composition_decoder() -> Decoder(Composition) {
  use section <- decode.optional_field(
    "section",
    [],
    decode.list(composition_section_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(composition_event_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use attester <- decode.optional_field(
    "attester",
    [],
    decode.list(composition_attester_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use title <- decode.field("title", decode.string)
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field("status", r5valuesets.compositionstatus_decoder())
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Composition",
    decode.failure(
      composition_new(title:, date:, type_:, status:),
      "resourceType",
    ),
  )
  decode.success(Composition(
    section:,
    event:,
    relates_to:,
    custodian:,
    attester:,
    note:,
    title:,
    name:,
    author:,
    use_context:,
    date:,
    encounter:,
    subject:,
    category:,
    type_:,
    status:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type Conceptmap {
  Conceptmap(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ConceptmapVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    property: List(ConceptmapProperty),
    additional_attribute: List(ConceptmapAdditionalattribute),
    source_scope: Option(ConceptmapSourcescope),
    target_scope: Option(ConceptmapTargetscope),
    group: List(ConceptmapGroup),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapVersionalgorithm {
  ConceptmapVersionalgorithmString(version_algorithm: String)
  ConceptmapVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn conceptmap_versionalgorithm_to_json(
  elt: ConceptmapVersionalgorithm,
) -> Json {
  case elt {
    ConceptmapVersionalgorithmString(v) -> json.string(v)
    ConceptmapVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn conceptmap_versionalgorithm_decoder() -> Decoder(
  ConceptmapVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ConceptmapVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ConceptmapVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapSourcescope {
  ConceptmapSourcescopeUri(source_scope: String)
  ConceptmapSourcescopeCanonical(source_scope: String)
}

pub fn conceptmap_sourcescope_to_json(elt: ConceptmapSourcescope) -> Json {
  case elt {
    ConceptmapSourcescopeUri(v) -> json.string(v)
    ConceptmapSourcescopeCanonical(v) -> json.string(v)
  }
}

pub fn conceptmap_sourcescope_decoder() -> Decoder(ConceptmapSourcescope) {
  decode.one_of(
    decode.field("sourceScopeUri", decode.string, decode.success)
      |> decode.map(ConceptmapSourcescopeUri),
    [
      decode.field("sourceScopeCanonical", decode.string, decode.success)
      |> decode.map(ConceptmapSourcescopeCanonical),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapTargetscope {
  ConceptmapTargetscopeUri(target_scope: String)
  ConceptmapTargetscopeCanonical(target_scope: String)
}

pub fn conceptmap_targetscope_to_json(elt: ConceptmapTargetscope) -> Json {
  case elt {
    ConceptmapTargetscopeUri(v) -> json.string(v)
    ConceptmapTargetscopeCanonical(v) -> json.string(v)
  }
}

pub fn conceptmap_targetscope_decoder() -> Decoder(ConceptmapTargetscope) {
  decode.one_of(
    decode.field("targetScopeUri", decode.string, decode.success)
      |> decode.map(ConceptmapTargetscopeUri),
    [
      decode.field("targetScopeCanonical", decode.string, decode.success)
      |> decode.map(ConceptmapTargetscopeCanonical),
    ],
  )
}

pub fn conceptmap_new(
  status status: r5valuesets.Publicationstatus,
) -> Conceptmap {
  Conceptmap(
    group: [],
    target_scope: None,
    source_scope: None,
    additional_attribute: [],
    property: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapProperty {
  ConceptmapProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    uri: Option(String),
    description: Option(String),
    type_: r5valuesets.Conceptmappropertytype,
    system: Option(String),
  )
}

pub fn conceptmap_property_new(
  type_ type_: r5valuesets.Conceptmappropertytype,
  code code: String,
) -> ConceptmapProperty {
  ConceptmapProperty(
    system: None,
    type_:,
    description: None,
    uri: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapAdditionalattribute {
  ConceptmapAdditionalattribute(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    uri: Option(String),
    description: Option(String),
    type_: r5valuesets.Conceptmapattributetype,
  )
}

pub fn conceptmap_additionalattribute_new(
  type_ type_: r5valuesets.Conceptmapattributetype,
  code code: String,
) -> ConceptmapAdditionalattribute {
  ConceptmapAdditionalattribute(
    type_:,
    description: None,
    uri: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroup {
  ConceptmapGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source: Option(String),
    target: Option(String),
    element: List(ConceptmapGroupElement),
    unmapped: Option(ConceptmapGroupUnmapped),
  )
}

pub fn conceptmap_group_new() -> ConceptmapGroup {
  ConceptmapGroup(
    unmapped: None,
    element: [],
    target: None,
    source: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElement {
  ConceptmapGroupElement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    display: Option(String),
    value_set: Option(String),
    no_map: Option(Bool),
    target: List(ConceptmapGroupElementTarget),
  )
}

pub fn conceptmap_group_element_new() -> ConceptmapGroupElement {
  ConceptmapGroupElement(
    target: [],
    no_map: None,
    value_set: None,
    display: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTarget {
  ConceptmapGroupElementTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    display: Option(String),
    value_set: Option(String),
    relationship: r5valuesets.Conceptmaprelationship,
    comment: Option(String),
    property: List(ConceptmapGroupElementTargetProperty),
    depends_on: List(ConceptmapGroupElementTargetDependson),
  )
}

pub fn conceptmap_group_element_target_new(
  relationship relationship: r5valuesets.Conceptmaprelationship,
) -> ConceptmapGroupElementTarget {
  ConceptmapGroupElementTarget(
    depends_on: [],
    property: [],
    comment: None,
    relationship:,
    value_set: None,
    display: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetProperty {
  ConceptmapGroupElementTargetProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    value: ConceptmapGroupElementTargetPropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetPropertyValue {
  ConceptmapGroupElementTargetPropertyValueCoding(value: Coding)
  ConceptmapGroupElementTargetPropertyValueString(value: String)
  ConceptmapGroupElementTargetPropertyValueInteger(value: Int)
  ConceptmapGroupElementTargetPropertyValueBoolean(value: Bool)
  ConceptmapGroupElementTargetPropertyValueDatetime(value: String)
  ConceptmapGroupElementTargetPropertyValueDecimal(value: Float)
  ConceptmapGroupElementTargetPropertyValueCode(value: String)
}

pub fn conceptmap_group_element_target_property_value_to_json(
  elt: ConceptmapGroupElementTargetPropertyValue,
) -> Json {
  case elt {
    ConceptmapGroupElementTargetPropertyValueCoding(v) -> coding_to_json(v)
    ConceptmapGroupElementTargetPropertyValueString(v) -> json.string(v)
    ConceptmapGroupElementTargetPropertyValueInteger(v) -> json.int(v)
    ConceptmapGroupElementTargetPropertyValueBoolean(v) -> json.bool(v)
    ConceptmapGroupElementTargetPropertyValueDatetime(v) -> json.string(v)
    ConceptmapGroupElementTargetPropertyValueDecimal(v) -> json.float(v)
    ConceptmapGroupElementTargetPropertyValueCode(v) -> json.string(v)
  }
}

pub fn conceptmap_group_element_target_property_value_decoder() -> Decoder(
  ConceptmapGroupElementTargetPropertyValue,
) {
  decode.one_of(
    decode.field("valueCoding", coding_decoder(), decode.success)
      |> decode.map(ConceptmapGroupElementTargetPropertyValueCoding),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueString),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueInteger),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueBoolean),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueDecimal),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ConceptmapGroupElementTargetPropertyValueCode),
    ],
  )
}

pub fn conceptmap_group_element_target_property_new(
  value value: ConceptmapGroupElementTargetPropertyValue,
  code code: String,
) -> ConceptmapGroupElementTargetProperty {
  ConceptmapGroupElementTargetProperty(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetDependson {
  ConceptmapGroupElementTargetDependson(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    attribute: String,
    value: Option(ConceptmapGroupElementTargetDependsonValue),
    value_set: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupElementTargetDependsonValue {
  ConceptmapGroupElementTargetDependsonValueCode(value: String)
  ConceptmapGroupElementTargetDependsonValueCoding(value: Coding)
  ConceptmapGroupElementTargetDependsonValueString(value: String)
  ConceptmapGroupElementTargetDependsonValueBoolean(value: Bool)
  ConceptmapGroupElementTargetDependsonValueQuantity(value: Quantity)
}

pub fn conceptmap_group_element_target_dependson_value_to_json(
  elt: ConceptmapGroupElementTargetDependsonValue,
) -> Json {
  case elt {
    ConceptmapGroupElementTargetDependsonValueCode(v) -> json.string(v)
    ConceptmapGroupElementTargetDependsonValueCoding(v) -> coding_to_json(v)
    ConceptmapGroupElementTargetDependsonValueString(v) -> json.string(v)
    ConceptmapGroupElementTargetDependsonValueBoolean(v) -> json.bool(v)
    ConceptmapGroupElementTargetDependsonValueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn conceptmap_group_element_target_dependson_value_decoder() -> Decoder(
  ConceptmapGroupElementTargetDependsonValue,
) {
  decode.one_of(
    decode.field("valueCode", decode.string, decode.success)
      |> decode.map(ConceptmapGroupElementTargetDependsonValueCode),
    [
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ConceptmapGroupElementTargetDependsonValueCoding),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ConceptmapGroupElementTargetDependsonValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ConceptmapGroupElementTargetDependsonValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ConceptmapGroupElementTargetDependsonValueQuantity),
    ],
  )
}

pub fn conceptmap_group_element_target_dependson_new(
  attribute attribute: String,
) -> ConceptmapGroupElementTargetDependson {
  ConceptmapGroupElementTargetDependson(
    value_set: None,
    value: None,
    attribute:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConceptMap#resource
pub type ConceptmapGroupUnmapped {
  ConceptmapGroupUnmapped(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: r5valuesets.Conceptmapunmappedmode,
    code: Option(String),
    display: Option(String),
    value_set: Option(String),
    relationship: Option(r5valuesets.Conceptmaprelationship),
    other_map: Option(String),
  )
}

pub fn conceptmap_group_unmapped_new(
  mode mode: r5valuesets.Conceptmapunmappedmode,
) -> ConceptmapGroupUnmapped {
  ConceptmapGroupUnmapped(
    other_map: None,
    relationship: None,
    value_set: None,
    display: None,
    code: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn conceptmap_group_unmapped_to_json(
  conceptmap_group_unmapped: ConceptmapGroupUnmapped,
) -> Json {
  let ConceptmapGroupUnmapped(
    other_map:,
    relationship:,
    value_set:,
    display:,
    code:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_unmapped
  let fields = [
    #("mode", r5valuesets.conceptmapunmappedmode_to_json(mode)),
  ]
  let fields = case other_map {
    Some(v) -> [#("otherMap", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [
      #("relationship", r5valuesets.conceptmaprelationship_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_unmapped_decoder() -> Decoder(ConceptmapGroupUnmapped) {
  use other_map <- decode.optional_field(
    "otherMap",
    None,
    decode.optional(decode.string),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(r5valuesets.conceptmaprelationship_decoder()),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.conceptmapunmappedmode_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupUnmapped(
    other_map:,
    relationship:,
    value_set:,
    display:,
    code:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_target_dependson_to_json(
  conceptmap_group_element_target_dependson: ConceptmapGroupElementTargetDependson,
) -> Json {
  let ConceptmapGroupElementTargetDependson(
    value_set:,
    value:,
    attribute:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element_target_dependson
  let fields = [
    #("attribute", json.string(attribute)),
  ]
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ConceptmapGroupElementTargetDependsonValueCode(_) -> "Code"
          ConceptmapGroupElementTargetDependsonValueCoding(_) -> "Coding"
          ConceptmapGroupElementTargetDependsonValueString(_) -> "String"
          ConceptmapGroupElementTargetDependsonValueBoolean(_) -> "Boolean"
          ConceptmapGroupElementTargetDependsonValueQuantity(_) -> "Quantity"
        },
        conceptmap_group_element_target_dependson_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_target_dependson_decoder() -> Decoder(
  ConceptmapGroupElementTargetDependson,
) {
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.then(
    none_if_omitted(conceptmap_group_element_target_dependson_value_decoder()),
  )
  use attribute <- decode.field("attribute", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElementTargetDependson(
    value_set:,
    value:,
    attribute:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_target_property_to_json(
  conceptmap_group_element_target_property: ConceptmapGroupElementTargetProperty,
) -> Json {
  let ConceptmapGroupElementTargetProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element_target_property
  let fields = [
    #("value", conceptmap_group_element_target_property_value_to_json(value)),
    #("code", json.string(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_target_property_decoder() -> Decoder(
  ConceptmapGroupElementTargetProperty,
) {
  use value <- decode.then(
    conceptmap_group_element_target_property_value_decoder(),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElementTargetProperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_target_to_json(
  conceptmap_group_element_target: ConceptmapGroupElementTarget,
) -> Json {
  let ConceptmapGroupElementTarget(
    depends_on:,
    property:,
    comment:,
    relationship:,
    value_set:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element_target
  let fields = [
    #("relationship", r5valuesets.conceptmaprelationship_to_json(relationship)),
  ]
  let fields = case depends_on {
    [] -> fields
    _ -> [
      #(
        "dependsOn",
        json.array(
          depends_on,
          conceptmap_group_element_target_dependson_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, conceptmap_group_element_target_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_target_decoder() -> Decoder(
  ConceptmapGroupElementTarget,
) {
  use depends_on <- decode.optional_field(
    "dependsOn",
    [],
    decode.list(conceptmap_group_element_target_dependson_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(conceptmap_group_element_target_property_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use relationship <- decode.field(
    "relationship",
    r5valuesets.conceptmaprelationship_decoder(),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElementTarget(
    depends_on:,
    property:,
    comment:,
    relationship:,
    value_set:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_element_to_json(
  conceptmap_group_element: ConceptmapGroupElement,
) -> Json {
  let ConceptmapGroupElement(
    target:,
    no_map:,
    value_set:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group_element
  let fields = []
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, conceptmap_group_element_target_to_json)),
      ..fields
    ]
  }
  let fields = case no_map {
    Some(v) -> [#("noMap", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case value_set {
    Some(v) -> [#("valueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_element_decoder() -> Decoder(ConceptmapGroupElement) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(conceptmap_group_element_target_decoder()),
  )
  use no_map <- decode.optional_field(
    "noMap",
    None,
    decode.optional(decode.bool),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    None,
    decode.optional(decode.string),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroupElement(
    target:,
    no_map:,
    value_set:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_group_to_json(conceptmap_group: ConceptmapGroup) -> Json {
  let ConceptmapGroup(
    unmapped:,
    element:,
    target:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_group
  let fields = []
  let fields = case unmapped {
    Some(v) -> [#("unmapped", conceptmap_group_unmapped_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, conceptmap_group_element_to_json)),
      ..fields
    ]
  }
  let fields = case target {
    Some(v) -> [#("target", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_group_decoder() -> Decoder(ConceptmapGroup) {
  use unmapped <- decode.optional_field(
    "unmapped",
    None,
    decode.optional(conceptmap_group_unmapped_decoder()),
  )
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(conceptmap_group_element_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapGroup(
    unmapped:,
    element:,
    target:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_additionalattribute_to_json(
  conceptmap_additionalattribute: ConceptmapAdditionalattribute,
) -> Json {
  let ConceptmapAdditionalattribute(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_additionalattribute
  let fields = [
    #("type", r5valuesets.conceptmapattributetype_to_json(type_)),
    #("code", json.string(code)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_additionalattribute_decoder() -> Decoder(
  ConceptmapAdditionalattribute,
) {
  use type_ <- decode.field(
    "type",
    r5valuesets.conceptmapattributetype_decoder(),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapAdditionalattribute(
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_property_to_json(
  conceptmap_property: ConceptmapProperty,
) -> Json {
  let ConceptmapProperty(
    system:,
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = conceptmap_property
  let fields = [
    #("type", r5valuesets.conceptmappropertytype_to_json(type_)),
    #("code", json.string(code)),
  ]
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conceptmap_property_decoder() -> Decoder(ConceptmapProperty) {
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.conceptmappropertytype_decoder(),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConceptmapProperty(
    system:,
    type_:,
    description:,
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conceptmap_to_json(conceptmap: Conceptmap) -> Json {
  let Conceptmap(
    group:,
    target_scope:,
    source_scope:,
    additional_attribute:,
    property:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = conceptmap
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, conceptmap_group_to_json)), ..fields]
  }
  let fields = case target_scope {
    Some(v) -> [
      #(
        "targetScope"
          <> case v {
          ConceptmapTargetscopeUri(_) -> "Uri"
          ConceptmapTargetscopeCanonical(_) -> "Canonical"
        },
        conceptmap_targetscope_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case source_scope {
    Some(v) -> [
      #(
        "sourceScope"
          <> case v {
          ConceptmapSourcescopeUri(_) -> "Uri"
          ConceptmapSourcescopeCanonical(_) -> "Canonical"
        },
        conceptmap_sourcescope_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case additional_attribute {
    [] -> fields
    _ -> [
      #(
        "additionalAttribute",
        json.array(additional_attribute, conceptmap_additionalattribute_to_json),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, conceptmap_property_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ConceptmapVersionalgorithmString(_) -> "String"
          ConceptmapVersionalgorithmCoding(_) -> "Coding"
        },
        conceptmap_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Conceptmap")), ..fields]
  json.object(fields)
}

pub fn conceptmap_decoder() -> Decoder(Conceptmap) {
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(conceptmap_group_decoder()),
  )
  use target_scope <- decode.then(
    none_if_omitted(conceptmap_targetscope_decoder()),
  )
  use source_scope <- decode.then(
    none_if_omitted(conceptmap_sourcescope_decoder()),
  )
  use additional_attribute <- decode.optional_field(
    "additionalAttribute",
    [],
    decode.list(conceptmap_additionalattribute_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(conceptmap_property_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(conceptmap_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Conceptmap",
    decode.failure(conceptmap_new(status:), "resourceType"),
  )
  decode.success(Conceptmap(
    group:,
    target_scope:,
    source_scope:,
    additional_attribute:,
    property:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Condition#resource
pub type Condition {
  Condition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    clinical_status: Codeableconcept,
    verification_status: Option(Codeableconcept),
    category: List(Codeableconcept),
    severity: Option(Codeableconcept),
    code: Option(Codeableconcept),
    body_site: List(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    onset: Option(ConditionOnset),
    abatement: Option(ConditionAbatement),
    recorded_date: Option(String),
    participant: List(ConditionParticipant),
    stage: List(ConditionStage),
    evidence: List(Codeablereference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Condition#resource
pub type ConditionOnset {
  ConditionOnsetDatetime(onset: String)
  ConditionOnsetAge(onset: Age)
  ConditionOnsetPeriod(onset: Period)
  ConditionOnsetRange(onset: Range)
  ConditionOnsetString(onset: String)
}

pub fn condition_onset_to_json(elt: ConditionOnset) -> Json {
  case elt {
    ConditionOnsetDatetime(v) -> json.string(v)
    ConditionOnsetAge(v) -> age_to_json(v)
    ConditionOnsetPeriod(v) -> period_to_json(v)
    ConditionOnsetRange(v) -> range_to_json(v)
    ConditionOnsetString(v) -> json.string(v)
  }
}

pub fn condition_onset_decoder() -> Decoder(ConditionOnset) {
  decode.one_of(
    decode.field("onsetDateTime", decode.string, decode.success)
      |> decode.map(ConditionOnsetDatetime),
    [
      decode.field("onsetAge", age_decoder(), decode.success)
        |> decode.map(ConditionOnsetAge),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(ConditionOnsetPeriod),
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(ConditionOnsetRange),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(ConditionOnsetString),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Condition#resource
pub type ConditionAbatement {
  ConditionAbatementDatetime(abatement: String)
  ConditionAbatementAge(abatement: Age)
  ConditionAbatementPeriod(abatement: Period)
  ConditionAbatementRange(abatement: Range)
  ConditionAbatementString(abatement: String)
}

pub fn condition_abatement_to_json(elt: ConditionAbatement) -> Json {
  case elt {
    ConditionAbatementDatetime(v) -> json.string(v)
    ConditionAbatementAge(v) -> age_to_json(v)
    ConditionAbatementPeriod(v) -> period_to_json(v)
    ConditionAbatementRange(v) -> range_to_json(v)
    ConditionAbatementString(v) -> json.string(v)
  }
}

pub fn condition_abatement_decoder() -> Decoder(ConditionAbatement) {
  decode.one_of(
    decode.field("abatementDateTime", decode.string, decode.success)
      |> decode.map(ConditionAbatementDatetime),
    [
      decode.field("abatementAge", age_decoder(), decode.success)
        |> decode.map(ConditionAbatementAge),
      decode.field("abatementPeriod", period_decoder(), decode.success)
        |> decode.map(ConditionAbatementPeriod),
      decode.field("abatementRange", range_decoder(), decode.success)
        |> decode.map(ConditionAbatementRange),
      decode.field("abatementString", decode.string, decode.success)
        |> decode.map(ConditionAbatementString),
    ],
  )
}

pub fn condition_new(
  subject subject: Reference,
  clinical_status clinical_status: Codeableconcept,
) -> Condition {
  Condition(
    note: [],
    evidence: [],
    stage: [],
    participant: [],
    recorded_date: None,
    abatement: None,
    onset: None,
    encounter: None,
    subject:,
    body_site: [],
    code: None,
    severity: None,
    category: [],
    verification_status: None,
    clinical_status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Condition#resource
pub type ConditionParticipant {
  ConditionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn condition_participant_new(actor actor: Reference) -> ConditionParticipant {
  ConditionParticipant(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Condition#resource
pub type ConditionStage {
  ConditionStage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    summary: Option(Codeableconcept),
    assessment: List(Reference),
    type_: Option(Codeableconcept),
  )
}

pub fn condition_stage_new() -> ConditionStage {
  ConditionStage(
    type_: None,
    assessment: [],
    summary: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn condition_stage_to_json(condition_stage: ConditionStage) -> Json {
  let ConditionStage(
    type_:,
    assessment:,
    summary:,
    modifier_extension:,
    extension:,
    id:,
  ) = condition_stage
  let fields = []
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case assessment {
    [] -> fields
    _ -> [#("assessment", json.array(assessment, reference_to_json)), ..fields]
  }
  let fields = case summary {
    Some(v) -> [#("summary", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn condition_stage_decoder() -> Decoder(ConditionStage) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use assessment <- decode.optional_field(
    "assessment",
    [],
    decode.list(reference_decoder()),
  )
  use summary <- decode.optional_field(
    "summary",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditionStage(
    type_:,
    assessment:,
    summary:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn condition_participant_to_json(
  condition_participant: ConditionParticipant,
) -> Json {
  let ConditionParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = condition_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn condition_participant_decoder() -> Decoder(ConditionParticipant) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditionParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn condition_to_json(condition: Condition) -> Json {
  let Condition(
    note:,
    evidence:,
    stage:,
    participant:,
    recorded_date:,
    abatement:,
    onset:,
    encounter:,
    subject:,
    body_site:,
    code:,
    severity:,
    category:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = condition
  let fields = [
    #("subject", reference_to_json(subject)),
    #("clinicalStatus", codeableconcept_to_json(clinical_status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case evidence {
    [] -> fields
    _ -> [
      #("evidence", json.array(evidence, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case stage {
    [] -> fields
    _ -> [#("stage", json.array(stage, condition_stage_to_json)), ..fields]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, condition_participant_to_json)),
      ..fields
    ]
  }
  let fields = case recorded_date {
    Some(v) -> [#("recordedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case abatement {
    Some(v) -> [
      #(
        "abatement"
          <> case v {
          ConditionAbatementDatetime(_) -> "Datetime"
          ConditionAbatementAge(_) -> "Age"
          ConditionAbatementPeriod(_) -> "Period"
          ConditionAbatementRange(_) -> "Range"
          ConditionAbatementString(_) -> "String"
        },
        condition_abatement_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          ConditionOnsetDatetime(_) -> "Datetime"
          ConditionOnsetAge(_) -> "Age"
          ConditionOnsetPeriod(_) -> "Period"
          ConditionOnsetRange(_) -> "Range"
          ConditionOnsetString(_) -> "String"
        },
        condition_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case verification_status {
    Some(v) -> [#("verificationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Condition")), ..fields]
  json.object(fields)
}

pub fn condition_decoder() -> Decoder(Condition) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use evidence <- decode.optional_field(
    "evidence",
    [],
    decode.list(codeablereference_decoder()),
  )
  use stage <- decode.optional_field(
    "stage",
    [],
    decode.list(condition_stage_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(condition_participant_decoder()),
  )
  use recorded_date <- decode.optional_field(
    "recordedDate",
    None,
    decode.optional(decode.string),
  )
  use abatement <- decode.then(none_if_omitted(condition_abatement_decoder()))
  use onset <- decode.then(none_if_omitted(condition_onset_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use verification_status <- decode.optional_field(
    "verificationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_status <- decode.field(
    "clinicalStatus",
    codeableconcept_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Condition",
    decode.failure(condition_new(subject:, clinical_status:), "resourceType"),
  )
  decode.success(Condition(
    note:,
    evidence:,
    stage:,
    participant:,
    recorded_date:,
    abatement:,
    onset:,
    encounter:,
    subject:,
    body_site:,
    code:,
    severity:,
    category:,
    verification_status:,
    clinical_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type Conditiondefinition {
  Conditiondefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ConditiondefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    code: Codeableconcept,
    severity: Option(Codeableconcept),
    body_site: Option(Codeableconcept),
    stage: Option(Codeableconcept),
    has_severity: Option(Bool),
    has_body_site: Option(Bool),
    has_stage: Option(Bool),
    definition: List(String),
    observation: List(ConditiondefinitionObservation),
    medication: List(ConditiondefinitionMedication),
    precondition: List(ConditiondefinitionPrecondition),
    team: List(Reference),
    questionnaire: List(ConditiondefinitionQuestionnaire),
    plan: List(ConditiondefinitionPlan),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionVersionalgorithm {
  ConditiondefinitionVersionalgorithmString(version_algorithm: String)
  ConditiondefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn conditiondefinition_versionalgorithm_to_json(
  elt: ConditiondefinitionVersionalgorithm,
) -> Json {
  case elt {
    ConditiondefinitionVersionalgorithmString(v) -> json.string(v)
    ConditiondefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn conditiondefinition_versionalgorithm_decoder() -> Decoder(
  ConditiondefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ConditiondefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ConditiondefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn conditiondefinition_new(
  code code: Codeableconcept,
  status status: r5valuesets.Publicationstatus,
) -> Conditiondefinition {
  Conditiondefinition(
    plan: [],
    questionnaire: [],
    team: [],
    precondition: [],
    medication: [],
    observation: [],
    definition: [],
    has_stage: None,
    has_body_site: None,
    has_severity: None,
    stage: None,
    body_site: None,
    severity: None,
    code:,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionObservation {
  ConditiondefinitionObservation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    code: Option(Codeableconcept),
  )
}

pub fn conditiondefinition_observation_new() -> ConditiondefinitionObservation {
  ConditiondefinitionObservation(
    code: None,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionMedication {
  ConditiondefinitionMedication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    code: Option(Codeableconcept),
  )
}

pub fn conditiondefinition_medication_new() -> ConditiondefinitionMedication {
  ConditiondefinitionMedication(
    code: None,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionPrecondition {
  ConditiondefinitionPrecondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Conditionpreconditiontype,
    code: Codeableconcept,
    value: Option(ConditiondefinitionPreconditionValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionPreconditionValue {
  ConditiondefinitionPreconditionValueCodeableconcept(value: Codeableconcept)
  ConditiondefinitionPreconditionValueQuantity(value: Quantity)
}

pub fn conditiondefinition_precondition_value_to_json(
  elt: ConditiondefinitionPreconditionValue,
) -> Json {
  case elt {
    ConditiondefinitionPreconditionValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ConditiondefinitionPreconditionValueQuantity(v) -> quantity_to_json(v)
  }
}

pub fn conditiondefinition_precondition_value_decoder() -> Decoder(
  ConditiondefinitionPreconditionValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ConditiondefinitionPreconditionValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ConditiondefinitionPreconditionValueQuantity),
    ],
  )
}

pub fn conditiondefinition_precondition_new(
  code code: Codeableconcept,
  type_ type_: r5valuesets.Conditionpreconditiontype,
) -> ConditiondefinitionPrecondition {
  ConditiondefinitionPrecondition(
    value: None,
    code:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionQuestionnaire {
  ConditiondefinitionQuestionnaire(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    purpose: r5valuesets.Conditionquestionnairepurpose,
    reference: Reference,
  )
}

pub fn conditiondefinition_questionnaire_new(
  reference reference: Reference,
  purpose purpose: r5valuesets.Conditionquestionnairepurpose,
) -> ConditiondefinitionQuestionnaire {
  ConditiondefinitionQuestionnaire(
    reference:,
    purpose:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ConditionDefinition#resource
pub type ConditiondefinitionPlan {
  ConditiondefinitionPlan(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    reference: Reference,
  )
}

pub fn conditiondefinition_plan_new(
  reference reference: Reference,
) -> ConditiondefinitionPlan {
  ConditiondefinitionPlan(
    reference:,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn conditiondefinition_plan_to_json(
  conditiondefinition_plan: ConditiondefinitionPlan,
) -> Json {
  let ConditiondefinitionPlan(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = conditiondefinition_plan
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conditiondefinition_plan_decoder() -> Decoder(ConditiondefinitionPlan) {
  use reference <- decode.field("reference", reference_decoder())
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditiondefinitionPlan(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conditiondefinition_questionnaire_to_json(
  conditiondefinition_questionnaire: ConditiondefinitionQuestionnaire,
) -> Json {
  let ConditiondefinitionQuestionnaire(
    reference:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ) = conditiondefinition_questionnaire
  let fields = [
    #("reference", reference_to_json(reference)),
    #("purpose", r5valuesets.conditionquestionnairepurpose_to_json(purpose)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conditiondefinition_questionnaire_decoder() -> Decoder(
  ConditiondefinitionQuestionnaire,
) {
  use reference <- decode.field("reference", reference_decoder())
  use purpose <- decode.field(
    "purpose",
    r5valuesets.conditionquestionnairepurpose_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditiondefinitionQuestionnaire(
    reference:,
    purpose:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conditiondefinition_precondition_to_json(
  conditiondefinition_precondition: ConditiondefinitionPrecondition,
) -> Json {
  let ConditiondefinitionPrecondition(
    value:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = conditiondefinition_precondition
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("type", r5valuesets.conditionpreconditiontype_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ConditiondefinitionPreconditionValueCodeableconcept(_) ->
            "Codeableconcept"
          ConditiondefinitionPreconditionValueQuantity(_) -> "Quantity"
        },
        conditiondefinition_precondition_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conditiondefinition_precondition_decoder() -> Decoder(
  ConditiondefinitionPrecondition,
) {
  use value <- decode.then(
    none_if_omitted(conditiondefinition_precondition_value_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use type_ <- decode.field(
    "type",
    r5valuesets.conditionpreconditiontype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditiondefinitionPrecondition(
    value:,
    code:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conditiondefinition_medication_to_json(
  conditiondefinition_medication: ConditiondefinitionMedication,
) -> Json {
  let ConditiondefinitionMedication(
    code:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = conditiondefinition_medication
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conditiondefinition_medication_decoder() -> Decoder(
  ConditiondefinitionMedication,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditiondefinitionMedication(
    code:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conditiondefinition_observation_to_json(
  conditiondefinition_observation: ConditiondefinitionObservation,
) -> Json {
  let ConditiondefinitionObservation(
    code:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = conditiondefinition_observation
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn conditiondefinition_observation_decoder() -> Decoder(
  ConditiondefinitionObservation,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConditiondefinitionObservation(
    code:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn conditiondefinition_to_json(
  conditiondefinition: Conditiondefinition,
) -> Json {
  let Conditiondefinition(
    plan:,
    questionnaire:,
    team:,
    precondition:,
    medication:,
    observation:,
    definition:,
    has_stage:,
    has_body_site:,
    has_severity:,
    stage:,
    body_site:,
    severity:,
    code:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = conditiondefinition
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case plan {
    [] -> fields
    _ -> [
      #("plan", json.array(plan, conditiondefinition_plan_to_json)),
      ..fields
    ]
  }
  let fields = case questionnaire {
    [] -> fields
    _ -> [
      #(
        "questionnaire",
        json.array(questionnaire, conditiondefinition_questionnaire_to_json),
      ),
      ..fields
    ]
  }
  let fields = case team {
    [] -> fields
    _ -> [#("team", json.array(team, reference_to_json)), ..fields]
  }
  let fields = case precondition {
    [] -> fields
    _ -> [
      #(
        "precondition",
        json.array(precondition, conditiondefinition_precondition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case medication {
    [] -> fields
    _ -> [
      #(
        "medication",
        json.array(medication, conditiondefinition_medication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case observation {
    [] -> fields
    _ -> [
      #(
        "observation",
        json.array(observation, conditiondefinition_observation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case definition {
    [] -> fields
    _ -> [#("definition", json.array(definition, json.string)), ..fields]
  }
  let fields = case has_stage {
    Some(v) -> [#("hasStage", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case has_body_site {
    Some(v) -> [#("hasBodySite", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case has_severity {
    Some(v) -> [#("hasSeverity", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case stage {
    Some(v) -> [#("stage", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [#("severity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ConditiondefinitionVersionalgorithmString(_) -> "String"
          ConditiondefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        conditiondefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Conditiondefinition")), ..fields]
  json.object(fields)
}

pub fn conditiondefinition_decoder() -> Decoder(Conditiondefinition) {
  use plan <- decode.optional_field(
    "plan",
    [],
    decode.list(conditiondefinition_plan_decoder()),
  )
  use questionnaire <- decode.optional_field(
    "questionnaire",
    [],
    decode.list(conditiondefinition_questionnaire_decoder()),
  )
  use team <- decode.optional_field(
    "team",
    [],
    decode.list(reference_decoder()),
  )
  use precondition <- decode.optional_field(
    "precondition",
    [],
    decode.list(conditiondefinition_precondition_decoder()),
  )
  use medication <- decode.optional_field(
    "medication",
    [],
    decode.list(conditiondefinition_medication_decoder()),
  )
  use observation <- decode.optional_field(
    "observation",
    [],
    decode.list(conditiondefinition_observation_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    [],
    decode.list(decode.string),
  )
  use has_stage <- decode.optional_field(
    "hasStage",
    None,
    decode.optional(decode.bool),
  )
  use has_body_site <- decode.optional_field(
    "hasBodySite",
    None,
    decode.optional(decode.bool),
  )
  use has_severity <- decode.optional_field(
    "hasSeverity",
    None,
    decode.optional(decode.bool),
  )
  use stage <- decode.optional_field(
    "stage",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(conditiondefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Conditiondefinition",
    decode.failure(conditiondefinition_new(code:, status:), "resourceType"),
  )
  decode.success(Conditiondefinition(
    plan:,
    questionnaire:,
    team:,
    precondition:,
    medication:,
    observation:,
    definition:,
    has_stage:,
    has_body_site:,
    has_severity:,
    stage:,
    body_site:,
    severity:,
    code:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type Consent {
  Consent(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Consentstatecodes,
    category: List(Codeableconcept),
    subject: Option(Reference),
    date: Option(String),
    period: Option(Period),
    grantor: List(Reference),
    grantee: List(Reference),
    manager: List(Reference),
    controller: List(Reference),
    source_attachment: List(Attachment),
    source_reference: List(Reference),
    regulatory_basis: List(Codeableconcept),
    policy_basis: Option(ConsentPolicybasis),
    policy_text: List(Reference),
    verification: List(ConsentVerification),
    decision: Option(r5valuesets.Consentprovisiontype),
    provision: List(ConsentProvision),
  )
}

pub fn consent_new(status status: r5valuesets.Consentstatecodes) -> Consent {
  Consent(
    provision: [],
    decision: None,
    verification: [],
    policy_text: [],
    policy_basis: None,
    regulatory_basis: [],
    source_reference: [],
    source_attachment: [],
    controller: [],
    manager: [],
    grantee: [],
    grantor: [],
    period: None,
    date: None,
    subject: None,
    category: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type ConsentPolicybasis {
  ConsentPolicybasis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Option(Reference),
    url: Option(String),
  )
}

pub fn consent_policybasis_new() -> ConsentPolicybasis {
  ConsentPolicybasis(
    url: None,
    reference: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type ConsentVerification {
  ConsentVerification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    verified: Bool,
    verification_type: Option(Codeableconcept),
    verified_by: Option(Reference),
    verified_with: Option(Reference),
    verification_date: List(String),
  )
}

pub fn consent_verification_new(verified verified: Bool) -> ConsentVerification {
  ConsentVerification(
    verification_date: [],
    verified_with: None,
    verified_by: None,
    verification_type: None,
    verified:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type ConsentProvision {
  ConsentProvision(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    period: Option(Period),
    actor: List(ConsentProvisionActor),
    action: List(Codeableconcept),
    security_label: List(Coding),
    purpose: List(Coding),
    document_type: List(Coding),
    resource_type: List(Coding),
    code: List(Codeableconcept),
    data_period: Option(Period),
    data: List(ConsentProvisionData),
    expression: Option(Expression),
  )
}

pub fn consent_provision_new() -> ConsentProvision {
  ConsentProvision(
    expression: None,
    data: [],
    data_period: None,
    code: [],
    resource_type: [],
    document_type: [],
    purpose: [],
    security_label: [],
    action: [],
    actor: [],
    period: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type ConsentProvisionActor {
  ConsentProvisionActor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    reference: Option(Reference),
  )
}

pub fn consent_provision_actor_new() -> ConsentProvisionActor {
  ConsentProvisionActor(
    reference: None,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Consent#resource
pub type ConsentProvisionData {
  ConsentProvisionData(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    meaning: r5valuesets.Consentdatameaning,
    reference: Reference,
  )
}

pub fn consent_provision_data_new(
  reference reference: Reference,
  meaning meaning: r5valuesets.Consentdatameaning,
) -> ConsentProvisionData {
  ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn consent_provision_data_to_json(
  consent_provision_data: ConsentProvisionData,
) -> Json {
  let ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision_data
  let fields = [
    #("reference", reference_to_json(reference)),
    #("meaning", r5valuesets.consentdatameaning_to_json(meaning)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_data_decoder() -> Decoder(ConsentProvisionData) {
  use reference <- decode.field("reference", reference_decoder())
  use meaning <- decode.field(
    "meaning",
    r5valuesets.consentdatameaning_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvisionData(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_provision_actor_to_json(
  consent_provision_actor: ConsentProvisionActor,
) -> Json {
  let ConsentProvisionActor(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision_actor
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_actor_decoder() -> Decoder(ConsentProvisionActor) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvisionActor(
    reference:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_provision_to_json(consent_provision: ConsentProvision) -> Json {
  let ConsentProvision(
    expression:,
    data:,
    data_period:,
    code:,
    resource_type:,
    document_type:,
    purpose:,
    security_label:,
    action:,
    actor:,
    period:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_provision
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case data {
    [] -> fields
    _ -> [#("data", json.array(data, consent_provision_data_to_json)), ..fields]
  }
  let fields = case data_period {
    Some(v) -> [#("dataPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case resource_type {
    [] -> fields
    _ -> [
      #("resourceType", json.array(resource_type, coding_to_json)),
      ..fields
    ]
  }
  let fields = case document_type {
    [] -> fields
    _ -> [
      #("documentType", json.array(document_type, coding_to_json)),
      ..fields
    ]
  }
  let fields = case purpose {
    [] -> fields
    _ -> [#("purpose", json.array(purpose, coding_to_json)), ..fields]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, coding_to_json)),
      ..fields
    ]
  }
  let fields = case action {
    [] -> fields
    _ -> [#("action", json.array(action, codeableconcept_to_json)), ..fields]
  }
  let fields = case actor {
    [] -> fields
    _ -> [
      #("actor", json.array(actor, consent_provision_actor_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_provision_decoder() -> Decoder(ConsentProvision) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use data <- decode.optional_field(
    "data",
    [],
    decode.list(consent_provision_data_decoder()),
  )
  use data_period <- decode.optional_field(
    "dataPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use resource_type <- decode.optional_field(
    "resourceType",
    [],
    decode.list(coding_decoder()),
  )
  use document_type <- decode.optional_field(
    "documentType",
    [],
    decode.list(coding_decoder()),
  )
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(coding_decoder()),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(coding_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(consent_provision_actor_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentProvision(
    expression:,
    data:,
    data_period:,
    code:,
    resource_type:,
    document_type:,
    purpose:,
    security_label:,
    action:,
    actor:,
    period:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_verification_to_json(
  consent_verification: ConsentVerification,
) -> Json {
  let ConsentVerification(
    verification_date:,
    verified_with:,
    verified_by:,
    verification_type:,
    verified:,
    modifier_extension:,
    extension:,
    id:,
  ) = consent_verification
  let fields = [
    #("verified", json.bool(verified)),
  ]
  let fields = case verification_date {
    [] -> fields
    _ -> [
      #("verificationDate", json.array(verification_date, json.string)),
      ..fields
    ]
  }
  let fields = case verified_with {
    Some(v) -> [#("verifiedWith", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case verified_by {
    Some(v) -> [#("verifiedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case verification_type {
    Some(v) -> [#("verificationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_verification_decoder() -> Decoder(ConsentVerification) {
  use verification_date <- decode.optional_field(
    "verificationDate",
    [],
    decode.list(decode.string),
  )
  use verified_with <- decode.optional_field(
    "verifiedWith",
    None,
    decode.optional(reference_decoder()),
  )
  use verified_by <- decode.optional_field(
    "verifiedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use verification_type <- decode.optional_field(
    "verificationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use verified <- decode.field("verified", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentVerification(
    verification_date:,
    verified_with:,
    verified_by:,
    verification_type:,
    verified:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_policybasis_to_json(
  consent_policybasis: ConsentPolicybasis,
) -> Json {
  let ConsentPolicybasis(url:, reference:, modifier_extension:, extension:, id:) =
    consent_policybasis
  let fields = []
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn consent_policybasis_decoder() -> Decoder(ConsentPolicybasis) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ConsentPolicybasis(
    url:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn consent_to_json(consent: Consent) -> Json {
  let Consent(
    provision:,
    decision:,
    verification:,
    policy_text:,
    policy_basis:,
    regulatory_basis:,
    source_reference:,
    source_attachment:,
    controller:,
    manager:,
    grantee:,
    grantor:,
    period:,
    date:,
    subject:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = consent
  let fields = [
    #("status", r5valuesets.consentstatecodes_to_json(status)),
  ]
  let fields = case provision {
    [] -> fields
    _ -> [
      #("provision", json.array(provision, consent_provision_to_json)),
      ..fields
    ]
  }
  let fields = case decision {
    Some(v) -> [
      #("decision", r5valuesets.consentprovisiontype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case verification {
    [] -> fields
    _ -> [
      #("verification", json.array(verification, consent_verification_to_json)),
      ..fields
    ]
  }
  let fields = case policy_text {
    [] -> fields
    _ -> [#("policyText", json.array(policy_text, reference_to_json)), ..fields]
  }
  let fields = case policy_basis {
    Some(v) -> [#("policyBasis", consent_policybasis_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case regulatory_basis {
    [] -> fields
    _ -> [
      #(
        "regulatoryBasis",
        json.array(regulatory_basis, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case source_reference {
    [] -> fields
    _ -> [
      #("sourceReference", json.array(source_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case source_attachment {
    [] -> fields
    _ -> [
      #("sourceAttachment", json.array(source_attachment, attachment_to_json)),
      ..fields
    ]
  }
  let fields = case controller {
    [] -> fields
    _ -> [#("controller", json.array(controller, reference_to_json)), ..fields]
  }
  let fields = case manager {
    [] -> fields
    _ -> [#("manager", json.array(manager, reference_to_json)), ..fields]
  }
  let fields = case grantee {
    [] -> fields
    _ -> [#("grantee", json.array(grantee, reference_to_json)), ..fields]
  }
  let fields = case grantor {
    [] -> fields
    _ -> [#("grantor", json.array(grantor, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Consent")), ..fields]
  json.object(fields)
}

pub fn consent_decoder() -> Decoder(Consent) {
  use provision <- decode.optional_field(
    "provision",
    [],
    decode.list(consent_provision_decoder()),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(r5valuesets.consentprovisiontype_decoder()),
  )
  use verification <- decode.optional_field(
    "verification",
    [],
    decode.list(consent_verification_decoder()),
  )
  use policy_text <- decode.optional_field(
    "policyText",
    [],
    decode.list(reference_decoder()),
  )
  use policy_basis <- decode.optional_field(
    "policyBasis",
    None,
    decode.optional(consent_policybasis_decoder()),
  )
  use regulatory_basis <- decode.optional_field(
    "regulatoryBasis",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use source_reference <- decode.optional_field(
    "sourceReference",
    [],
    decode.list(reference_decoder()),
  )
  use source_attachment <- decode.optional_field(
    "sourceAttachment",
    [],
    decode.list(attachment_decoder()),
  )
  use controller <- decode.optional_field(
    "controller",
    [],
    decode.list(reference_decoder()),
  )
  use manager <- decode.optional_field(
    "manager",
    [],
    decode.list(reference_decoder()),
  )
  use grantee <- decode.optional_field(
    "grantee",
    [],
    decode.list(reference_decoder()),
  )
  use grantor <- decode.optional_field(
    "grantor",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.consentstatecodes_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Consent",
    decode.failure(consent_new(status:), "resourceType"),
  )
  decode.success(Consent(
    provision:,
    decision:,
    verification:,
    policy_text:,
    policy_basis:,
    regulatory_basis:,
    source_reference:,
    source_attachment:,
    controller:,
    manager:,
    grantee:,
    grantor:,
    period:,
    date:,
    subject:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type Contract {
  Contract(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    url: Option(String),
    version: Option(String),
    status: Option(r5valuesets.Contractstatus),
    legal_state: Option(Codeableconcept),
    instantiates_canonical: Option(Reference),
    instantiates_uri: Option(String),
    content_derivative: Option(Codeableconcept),
    issued: Option(String),
    applies: Option(Period),
    expiration_type: Option(Codeableconcept),
    subject: List(Reference),
    authority: List(Reference),
    domain: List(Reference),
    site: List(Reference),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    alias: List(String),
    author: Option(Reference),
    scope: Option(Codeableconcept),
    topic: Option(ContractTopic),
    type_: Option(Codeableconcept),
    sub_type: List(Codeableconcept),
    content_definition: Option(ContractContentdefinition),
    term: List(ContractTerm),
    supporting_info: List(Reference),
    relevant_history: List(Reference),
    signer: List(ContractSigner),
    friendly: List(ContractFriendly),
    legal: List(ContractLegal),
    rule: List(ContractRule),
    legally_binding: Option(ContractLegallybinding),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTopic {
  ContractTopicCodeableconcept(topic: Codeableconcept)
  ContractTopicReference(topic: Reference)
}

pub fn contract_topic_to_json(elt: ContractTopic) -> Json {
  case elt {
    ContractTopicCodeableconcept(v) -> codeableconcept_to_json(v)
    ContractTopicReference(v) -> reference_to_json(v)
  }
}

pub fn contract_topic_decoder() -> Decoder(ContractTopic) {
  decode.one_of(
    decode.field(
      "topicCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTopicCodeableconcept),
    [
      decode.field("topicReference", reference_decoder(), decode.success)
      |> decode.map(ContractTopicReference),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractLegallybinding {
  ContractLegallybindingAttachment(legally_binding: Attachment)
  ContractLegallybindingReference(legally_binding: Reference)
}

pub fn contract_legallybinding_to_json(elt: ContractLegallybinding) -> Json {
  case elt {
    ContractLegallybindingAttachment(v) -> attachment_to_json(v)
    ContractLegallybindingReference(v) -> reference_to_json(v)
  }
}

pub fn contract_legallybinding_decoder() -> Decoder(ContractLegallybinding) {
  decode.one_of(
    decode.field(
      "legallyBindingAttachment",
      attachment_decoder(),
      decode.success,
    )
      |> decode.map(ContractLegallybindingAttachment),
    [
      decode.field(
        "legallyBindingReference",
        reference_decoder(),
        decode.success,
      )
      |> decode.map(ContractLegallybindingReference),
    ],
  )
}

pub fn contract_new() -> Contract {
  Contract(
    legally_binding: None,
    rule: [],
    legal: [],
    friendly: [],
    signer: [],
    relevant_history: [],
    supporting_info: [],
    term: [],
    content_definition: None,
    sub_type: [],
    type_: None,
    topic: None,
    scope: None,
    author: None,
    alias: [],
    subtitle: None,
    title: None,
    name: None,
    site: [],
    domain: [],
    authority: [],
    subject: [],
    expiration_type: None,
    applies: None,
    issued: None,
    content_derivative: None,
    instantiates_uri: None,
    instantiates_canonical: None,
    legal_state: None,
    status: None,
    version: None,
    url: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractContentdefinition {
  ContractContentdefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    publisher: Option(Reference),
    publication_date: Option(String),
    publication_status: r5valuesets.Contractpublicationstatus,
    copyright: Option(String),
  )
}

pub fn contract_contentdefinition_new(
  publication_status publication_status: r5valuesets.Contractpublicationstatus,
  type_ type_: Codeableconcept,
) -> ContractContentdefinition {
  ContractContentdefinition(
    copyright: None,
    publication_status:,
    publication_date: None,
    publisher: None,
    sub_type: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTerm {
  ContractTerm(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    issued: Option(String),
    applies: Option(Period),
    topic: Option(ContractTermTopic),
    type_: Option(Codeableconcept),
    sub_type: Option(Codeableconcept),
    text: Option(String),
    security_label: List(ContractTermSecuritylabel),
    offer: ContractTermOffer,
    asset: List(ContractTermAsset),
    action: List(ContractTermAction),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermTopic {
  ContractTermTopicCodeableconcept(topic: Codeableconcept)
  ContractTermTopicReference(topic: Reference)
}

pub fn contract_term_topic_to_json(elt: ContractTermTopic) -> Json {
  case elt {
    ContractTermTopicCodeableconcept(v) -> codeableconcept_to_json(v)
    ContractTermTopicReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_topic_decoder() -> Decoder(ContractTermTopic) {
  decode.one_of(
    decode.field(
      "topicCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTermTopicCodeableconcept),
    [
      decode.field("topicReference", reference_decoder(), decode.success)
      |> decode.map(ContractTermTopicReference),
    ],
  )
}

pub fn contract_term_new(offer offer: ContractTermOffer) -> ContractTerm {
  ContractTerm(
    action: [],
    asset: [],
    offer:,
    security_label: [],
    text: None,
    sub_type: None,
    type_: None,
    topic: None,
    applies: None,
    issued: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermSecuritylabel {
  ContractTermSecuritylabel(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: List(Int),
    classification: Coding,
    category: List(Coding),
    control: List(Coding),
  )
}

pub fn contract_term_securitylabel_new(
  classification classification: Coding,
) -> ContractTermSecuritylabel {
  ContractTermSecuritylabel(
    control: [],
    category: [],
    classification:,
    number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermOffer {
  ContractTermOffer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    party: List(ContractTermOfferParty),
    topic: Option(Reference),
    type_: Option(Codeableconcept),
    decision: Option(Codeableconcept),
    decision_mode: List(Codeableconcept),
    answer: List(ContractTermOfferAnswer),
    text: Option(String),
    link_id: List(String),
    security_label_number: List(Int),
  )
}

pub fn contract_term_offer_new() -> ContractTermOffer {
  ContractTermOffer(
    security_label_number: [],
    link_id: [],
    text: None,
    answer: [],
    decision_mode: [],
    decision: None,
    type_: None,
    topic: None,
    party: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermOfferParty {
  ContractTermOfferParty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: List(Reference),
    role: Codeableconcept,
  )
}

pub fn contract_term_offer_party_new(
  role role: Codeableconcept,
) -> ContractTermOfferParty {
  ContractTermOfferParty(
    role:,
    reference: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswer {
  ContractTermOfferAnswer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: ContractTermOfferAnswerValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermOfferAnswerValue {
  ContractTermOfferAnswerValueBoolean(value: Bool)
  ContractTermOfferAnswerValueDecimal(value: Float)
  ContractTermOfferAnswerValueInteger(value: Int)
  ContractTermOfferAnswerValueDate(value: String)
  ContractTermOfferAnswerValueDatetime(value: String)
  ContractTermOfferAnswerValueTime(value: String)
  ContractTermOfferAnswerValueString(value: String)
  ContractTermOfferAnswerValueUri(value: String)
  ContractTermOfferAnswerValueAttachment(value: Attachment)
  ContractTermOfferAnswerValueCoding(value: Coding)
  ContractTermOfferAnswerValueQuantity(value: Quantity)
  ContractTermOfferAnswerValueReference(value: Reference)
}

pub fn contract_term_offer_answer_value_to_json(
  elt: ContractTermOfferAnswerValue,
) -> Json {
  case elt {
    ContractTermOfferAnswerValueBoolean(v) -> json.bool(v)
    ContractTermOfferAnswerValueDecimal(v) -> json.float(v)
    ContractTermOfferAnswerValueInteger(v) -> json.int(v)
    ContractTermOfferAnswerValueDate(v) -> json.string(v)
    ContractTermOfferAnswerValueDatetime(v) -> json.string(v)
    ContractTermOfferAnswerValueTime(v) -> json.string(v)
    ContractTermOfferAnswerValueString(v) -> json.string(v)
    ContractTermOfferAnswerValueUri(v) -> json.string(v)
    ContractTermOfferAnswerValueAttachment(v) -> attachment_to_json(v)
    ContractTermOfferAnswerValueCoding(v) -> coding_to_json(v)
    ContractTermOfferAnswerValueQuantity(v) -> quantity_to_json(v)
    ContractTermOfferAnswerValueReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_offer_answer_value_decoder() -> Decoder(
  ContractTermOfferAnswerValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ContractTermOfferAnswerValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ContractTermOfferAnswerValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ContractTermOfferAnswerValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ContractTermOfferAnswerValueReference),
    ],
  )
}

pub fn contract_term_offer_answer_new(
  value value: ContractTermOfferAnswerValue,
) -> ContractTermOfferAnswer {
  ContractTermOfferAnswer(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermAsset {
  ContractTermAsset(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    scope: Option(Codeableconcept),
    type_: List(Codeableconcept),
    type_reference: List(Reference),
    subtype: List(Codeableconcept),
    relationship: Option(Coding),
    context: List(ContractTermAssetContext),
    condition: Option(String),
    period_type: List(Codeableconcept),
    period: List(Period),
    use_period: List(Period),
    text: Option(String),
    link_id: List(String),
    security_label_number: List(Int),
    valued_item: List(ContractTermAssetValueditem),
  )
}

pub fn contract_term_asset_new() -> ContractTermAsset {
  ContractTermAsset(
    valued_item: [],
    security_label_number: [],
    link_id: [],
    text: None,
    use_period: [],
    period: [],
    period_type: [],
    condition: None,
    context: [],
    relationship: None,
    subtype: [],
    type_reference: [],
    type_: [],
    scope: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermAssetContext {
  ContractTermAssetContext(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Option(Reference),
    code: List(Codeableconcept),
    text: Option(String),
  )
}

pub fn contract_term_asset_context_new() -> ContractTermAssetContext {
  ContractTermAssetContext(
    text: None,
    code: [],
    reference: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditem {
  ContractTermAssetValueditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    entity: Option(ContractTermAssetValueditemEntity),
    identifier: Option(Identifier),
    effective_time: Option(String),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    points: Option(Float),
    net: Option(Money),
    payment: Option(String),
    payment_date: Option(String),
    responsible: Option(Reference),
    recipient: Option(Reference),
    link_id: List(String),
    security_label_number: List(Int),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermAssetValueditemEntity {
  ContractTermAssetValueditemEntityCodeableconcept(entity: Codeableconcept)
  ContractTermAssetValueditemEntityReference(entity: Reference)
}

pub fn contract_term_asset_valueditem_entity_to_json(
  elt: ContractTermAssetValueditemEntity,
) -> Json {
  case elt {
    ContractTermAssetValueditemEntityCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ContractTermAssetValueditemEntityReference(v) -> reference_to_json(v)
  }
}

pub fn contract_term_asset_valueditem_entity_decoder() -> Decoder(
  ContractTermAssetValueditemEntity,
) {
  decode.one_of(
    decode.field(
      "entityCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ContractTermAssetValueditemEntityCodeableconcept),
    [
      decode.field("entityReference", reference_decoder(), decode.success)
      |> decode.map(ContractTermAssetValueditemEntityReference),
    ],
  )
}

pub fn contract_term_asset_valueditem_new() -> ContractTermAssetValueditem {
  ContractTermAssetValueditem(
    security_label_number: [],
    link_id: [],
    recipient: None,
    responsible: None,
    payment_date: None,
    payment: None,
    net: None,
    points: None,
    factor: None,
    unit_price: None,
    quantity: None,
    effective_time: None,
    identifier: None,
    entity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermAction {
  ContractTermAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    do_not_perform: Option(Bool),
    type_: Codeableconcept,
    subject: List(ContractTermActionSubject),
    intent: Codeableconcept,
    link_id: List(String),
    status: Codeableconcept,
    context: Option(Reference),
    context_link_id: List(String),
    occurrence: Option(ContractTermActionOccurrence),
    requester: List(Reference),
    requester_link_id: List(String),
    performer_type: List(Codeableconcept),
    performer_role: Option(Codeableconcept),
    performer: Option(Reference),
    performer_link_id: List(String),
    reason: List(Codeablereference),
    reason_link_id: List(String),
    note: List(Annotation),
    security_label_number: List(Int),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermActionOccurrence {
  ContractTermActionOccurrenceDatetime(occurrence: String)
  ContractTermActionOccurrencePeriod(occurrence: Period)
  ContractTermActionOccurrenceTiming(occurrence: Timing)
}

pub fn contract_term_action_occurrence_to_json(
  elt: ContractTermActionOccurrence,
) -> Json {
  case elt {
    ContractTermActionOccurrenceDatetime(v) -> json.string(v)
    ContractTermActionOccurrencePeriod(v) -> period_to_json(v)
    ContractTermActionOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn contract_term_action_occurrence_decoder() -> Decoder(
  ContractTermActionOccurrence,
) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ContractTermActionOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ContractTermActionOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ContractTermActionOccurrenceTiming),
    ],
  )
}

pub fn contract_term_action_new(
  status status: Codeableconcept,
  intent intent: Codeableconcept,
  type_ type_: Codeableconcept,
) -> ContractTermAction {
  ContractTermAction(
    security_label_number: [],
    note: [],
    reason_link_id: [],
    reason: [],
    performer_link_id: [],
    performer: None,
    performer_role: None,
    performer_type: [],
    requester_link_id: [],
    requester: [],
    occurrence: None,
    context_link_id: [],
    context: None,
    status:,
    link_id: [],
    intent:,
    subject: [],
    type_:,
    do_not_perform: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractTermActionSubject {
  ContractTermActionSubject(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: List(Reference),
    role: Option(Codeableconcept),
  )
}

pub fn contract_term_action_subject_new() -> ContractTermActionSubject {
  ContractTermActionSubject(
    role: None,
    reference: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractSigner {
  ContractSigner(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Coding,
    party: Reference,
    signature: List(Signature),
  )
}

pub fn contract_signer_new(
  party party: Reference,
  type_ type_: Coding,
) -> ContractSigner {
  ContractSigner(
    signature: [],
    party:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractFriendly {
  ContractFriendly(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractFriendlyContent,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractFriendlyContent {
  ContractFriendlyContentAttachment(content: Attachment)
  ContractFriendlyContentReference(content: Reference)
}

pub fn contract_friendly_content_to_json(elt: ContractFriendlyContent) -> Json {
  case elt {
    ContractFriendlyContentAttachment(v) -> attachment_to_json(v)
    ContractFriendlyContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_friendly_content_decoder() -> Decoder(ContractFriendlyContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractFriendlyContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractFriendlyContentReference),
    ],
  )
}

pub fn contract_friendly_new(
  content content: ContractFriendlyContent,
) -> ContractFriendly {
  ContractFriendly(content:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractLegal {
  ContractLegal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractLegalContent,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractLegalContent {
  ContractLegalContentAttachment(content: Attachment)
  ContractLegalContentReference(content: Reference)
}

pub fn contract_legal_content_to_json(elt: ContractLegalContent) -> Json {
  case elt {
    ContractLegalContentAttachment(v) -> attachment_to_json(v)
    ContractLegalContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_legal_content_decoder() -> Decoder(ContractLegalContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractLegalContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractLegalContentReference),
    ],
  )
}

pub fn contract_legal_new(
  content content: ContractLegalContent,
) -> ContractLegal {
  ContractLegal(content:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractRule {
  ContractRule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    content: ContractRuleContent,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Contract#resource
pub type ContractRuleContent {
  ContractRuleContentAttachment(content: Attachment)
  ContractRuleContentReference(content: Reference)
}

pub fn contract_rule_content_to_json(elt: ContractRuleContent) -> Json {
  case elt {
    ContractRuleContentAttachment(v) -> attachment_to_json(v)
    ContractRuleContentReference(v) -> reference_to_json(v)
  }
}

pub fn contract_rule_content_decoder() -> Decoder(ContractRuleContent) {
  decode.one_of(
    decode.field("contentAttachment", attachment_decoder(), decode.success)
      |> decode.map(ContractRuleContentAttachment),
    [
      decode.field("contentReference", reference_decoder(), decode.success)
      |> decode.map(ContractRuleContentReference),
    ],
  )
}

pub fn contract_rule_new(content content: ContractRuleContent) -> ContractRule {
  ContractRule(content:, modifier_extension: [], extension: [], id: None)
}

pub fn contract_rule_to_json(contract_rule: ContractRule) -> Json {
  let ContractRule(content:, modifier_extension:, extension:, id:) =
    contract_rule
  let fields = [
    #("content", contract_rule_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_rule_decoder() -> Decoder(ContractRule) {
  use content <- decode.then(contract_rule_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractRule(content:, modifier_extension:, extension:, id:))
}

pub fn contract_legal_to_json(contract_legal: ContractLegal) -> Json {
  let ContractLegal(content:, modifier_extension:, extension:, id:) =
    contract_legal
  let fields = [
    #("content", contract_legal_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_legal_decoder() -> Decoder(ContractLegal) {
  use content <- decode.then(contract_legal_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractLegal(content:, modifier_extension:, extension:, id:))
}

pub fn contract_friendly_to_json(contract_friendly: ContractFriendly) -> Json {
  let ContractFriendly(content:, modifier_extension:, extension:, id:) =
    contract_friendly
  let fields = [
    #("content", contract_friendly_content_to_json(content)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_friendly_decoder() -> Decoder(ContractFriendly) {
  use content <- decode.then(contract_friendly_content_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractFriendly(
    content:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_signer_to_json(contract_signer: ContractSigner) -> Json {
  let ContractSigner(
    signature:,
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_signer
  let fields = [
    #("party", reference_to_json(party)),
    #("type", coding_to_json(type_)),
  ]
  let fields = case signature {
    [] -> fields
    _ -> [#("signature", json.array(signature, signature_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_signer_decoder() -> Decoder(ContractSigner) {
  use signature <- decode.optional_field(
    "signature",
    [],
    decode.list(signature_decoder()),
  )
  use party <- decode.field("party", reference_decoder())
  use type_ <- decode.field("type", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractSigner(
    signature:,
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_action_subject_to_json(
  contract_term_action_subject: ContractTermActionSubject,
) -> Json {
  let ContractTermActionSubject(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_action_subject
  let fields = []
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_action_subject_decoder() -> Decoder(
  ContractTermActionSubject,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermActionSubject(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_action_to_json(
  contract_term_action: ContractTermAction,
) -> Json {
  let ContractTermAction(
    security_label_number:,
    note:,
    reason_link_id:,
    reason:,
    performer_link_id:,
    performer:,
    performer_role:,
    performer_type:,
    requester_link_id:,
    requester:,
    occurrence:,
    context_link_id:,
    context:,
    status:,
    link_id:,
    intent:,
    subject:,
    type_:,
    do_not_perform:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_action
  let fields = [
    #("status", codeableconcept_to_json(status)),
    #("intent", codeableconcept_to_json(intent)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason_link_id {
    [] -> fields
    _ -> [#("reasonLinkId", json.array(reason_link_id, json.string)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case performer_link_id {
    [] -> fields
    _ -> [
      #("performerLinkId", json.array(performer_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_role {
    Some(v) -> [#("performerRole", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    [] -> fields
    _ -> [
      #("performerType", json.array(performer_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requester_link_id {
    [] -> fields
    _ -> [
      #("requesterLinkId", json.array(requester_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case requester {
    [] -> fields
    _ -> [#("requester", json.array(requester, reference_to_json)), ..fields]
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ContractTermActionOccurrenceDatetime(_) -> "Datetime"
          ContractTermActionOccurrencePeriod(_) -> "Period"
          ContractTermActionOccurrenceTiming(_) -> "Timing"
        },
        contract_term_action_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case context_link_id {
    [] -> fields
    _ -> [
      #("contextLinkId", json.array(context_link_id, json.string)),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case subject {
    [] -> fields
    _ -> [
      #("subject", json.array(subject, contract_term_action_subject_to_json)),
      ..fields
    ]
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_action_decoder() -> Decoder(ContractTermAction) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason_link_id <- decode.optional_field(
    "reasonLinkId",
    [],
    decode.list(decode.string),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer_link_id <- decode.optional_field(
    "performerLinkId",
    [],
    decode.list(decode.string),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_role <- decode.optional_field(
    "performerRole",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use requester_link_id <- decode.optional_field(
    "requesterLinkId",
    [],
    decode.list(decode.string),
  )
  use requester <- decode.optional_field(
    "requester",
    [],
    decode.list(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(contract_term_action_occurrence_decoder()),
  )
  use context_link_id <- decode.optional_field(
    "contextLinkId",
    [],
    decode.list(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use intent <- decode.field("intent", codeableconcept_decoder())
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(contract_term_action_subject_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAction(
    security_label_number:,
    note:,
    reason_link_id:,
    reason:,
    performer_link_id:,
    performer:,
    performer_role:,
    performer_type:,
    requester_link_id:,
    requester:,
    occurrence:,
    context_link_id:,
    context:,
    status:,
    link_id:,
    intent:,
    subject:,
    type_:,
    do_not_perform:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_valueditem_to_json(
  contract_term_asset_valueditem: ContractTermAssetValueditem,
) -> Json {
  let ContractTermAssetValueditem(
    security_label_number:,
    link_id:,
    recipient:,
    responsible:,
    payment_date:,
    payment:,
    net:,
    points:,
    factor:,
    unit_price:,
    quantity:,
    effective_time:,
    identifier:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset_valueditem
  let fields = []
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case recipient {
    Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_date {
    Some(v) -> [#("paymentDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case points {
    Some(v) -> [#("points", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effective_time {
    Some(v) -> [#("effectiveTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entity {
    Some(v) -> [
      #(
        "entity"
          <> case v {
          ContractTermAssetValueditemEntityCodeableconcept(_) ->
            "Codeableconcept"
          ContractTermAssetValueditemEntityReference(_) -> "Reference"
        },
        contract_term_asset_valueditem_entity_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_valueditem_decoder() -> Decoder(
  ContractTermAssetValueditem,
) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use recipient <- decode.optional_field(
    "recipient",
    None,
    decode.optional(reference_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_date <- decode.optional_field(
    "paymentDate",
    None,
    decode.optional(decode.string),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(decode.string),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use points <- decode.optional_field(
    "points",
    None,
    decode.optional(decode.float),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use effective_time <- decode.optional_field(
    "effectiveTime",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use entity <- decode.then(
    none_if_omitted(contract_term_asset_valueditem_entity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAssetValueditem(
    security_label_number:,
    link_id:,
    recipient:,
    responsible:,
    payment_date:,
    payment:,
    net:,
    points:,
    factor:,
    unit_price:,
    quantity:,
    effective_time:,
    identifier:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_context_to_json(
  contract_term_asset_context: ContractTermAssetContext,
) -> Json {
  let ContractTermAssetContext(
    text:,
    code:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset_context
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_context_decoder() -> Decoder(
  ContractTermAssetContext,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAssetContext(
    text:,
    code:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_asset_to_json(
  contract_term_asset: ContractTermAsset,
) -> Json {
  let ContractTermAsset(
    valued_item:,
    security_label_number:,
    link_id:,
    text:,
    use_period:,
    period:,
    period_type:,
    condition:,
    context:,
    relationship:,
    subtype:,
    type_reference:,
    type_:,
    scope:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_asset
  let fields = []
  let fields = case valued_item {
    [] -> fields
    _ -> [
      #(
        "valuedItem",
        json.array(valued_item, contract_term_asset_valueditem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_period {
    [] -> fields
    _ -> [#("usePeriod", json.array(use_period, period_to_json)), ..fields]
  }
  let fields = case period {
    [] -> fields
    _ -> [#("period", json.array(period, period_to_json)), ..fields]
  }
  let fields = case period_type {
    [] -> fields
    _ -> [
      #("periodType", json.array(period_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context {
    [] -> fields
    _ -> [
      #("context", json.array(context, contract_term_asset_context_to_json)),
      ..fields
    ]
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subtype {
    [] -> fields
    _ -> [#("subtype", json.array(subtype, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_reference {
    [] -> fields
    _ -> [
      #("typeReference", json.array(type_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case scope {
    Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_asset_decoder() -> Decoder(ContractTermAsset) {
  use valued_item <- decode.optional_field(
    "valuedItem",
    [],
    decode.list(contract_term_asset_valueditem_decoder()),
  )
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use use_period <- decode.optional_field(
    "usePeriod",
    [],
    decode.list(period_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    [],
    decode.list(period_decoder()),
  )
  use period_type <- decode.optional_field(
    "periodType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    [],
    decode.list(contract_term_asset_context_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(coding_decoder()),
  )
  use subtype <- decode.optional_field(
    "subtype",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermAsset(
    valued_item:,
    security_label_number:,
    link_id:,
    text:,
    use_period:,
    period:,
    period_type:,
    condition:,
    context:,
    relationship:,
    subtype:,
    type_reference:,
    type_:,
    scope:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_answer_to_json(
  contract_term_offer_answer: ContractTermOfferAnswer,
) -> Json {
  let ContractTermOfferAnswer(value:, modifier_extension:, extension:, id:) =
    contract_term_offer_answer
  let fields = [
    #("value", contract_term_offer_answer_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_answer_decoder() -> Decoder(ContractTermOfferAnswer) {
  use value <- decode.then(contract_term_offer_answer_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOfferAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_party_to_json(
  contract_term_offer_party: ContractTermOfferParty,
) -> Json {
  let ContractTermOfferParty(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_offer_party
  let fields = [
    #("role", codeableconcept_to_json(role)),
  ]
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_party_decoder() -> Decoder(ContractTermOfferParty) {
  use role <- decode.field("role", codeableconcept_decoder())
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOfferParty(
    role:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_offer_to_json(
  contract_term_offer: ContractTermOffer,
) -> Json {
  let ContractTermOffer(
    security_label_number:,
    link_id:,
    text:,
    answer:,
    decision_mode:,
    decision:,
    type_:,
    topic:,
    party:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_offer
  let fields = []
  let fields = case security_label_number {
    [] -> fields
    _ -> [
      #("securityLabelNumber", json.array(security_label_number, json.int)),
      ..fields
    ]
  }
  let fields = case link_id {
    [] -> fields
    _ -> [#("linkId", json.array(link_id, json.string)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case answer {
    [] -> fields
    _ -> [
      #("answer", json.array(answer, contract_term_offer_answer_to_json)),
      ..fields
    ]
  }
  let fields = case decision_mode {
    [] -> fields
    _ -> [
      #("decisionMode", json.array(decision_mode, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [#("topic", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case party {
    [] -> fields
    _ -> [
      #("party", json.array(party, contract_term_offer_party_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_offer_decoder() -> Decoder(ContractTermOffer) {
  use security_label_number <- decode.optional_field(
    "securityLabelNumber",
    [],
    decode.list(decode.int),
  )
  use link_id <- decode.optional_field("linkId", [], decode.list(decode.string))
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use answer <- decode.optional_field(
    "answer",
    [],
    decode.list(contract_term_offer_answer_decoder()),
  )
  use decision_mode <- decode.optional_field(
    "decisionMode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(reference_decoder()),
  )
  use party <- decode.optional_field(
    "party",
    [],
    decode.list(contract_term_offer_party_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermOffer(
    security_label_number:,
    link_id:,
    text:,
    answer:,
    decision_mode:,
    decision:,
    type_:,
    topic:,
    party:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_securitylabel_to_json(
  contract_term_securitylabel: ContractTermSecuritylabel,
) -> Json {
  let ContractTermSecuritylabel(
    control:,
    category:,
    classification:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term_securitylabel
  let fields = [
    #("classification", coding_to_json(classification)),
  ]
  let fields = case control {
    [] -> fields
    _ -> [#("control", json.array(control, coding_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [#("category", json.array(category, coding_to_json)), ..fields]
  }
  let fields = case number {
    [] -> fields
    _ -> [#("number", json.array(number, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_securitylabel_decoder() -> Decoder(
  ContractTermSecuritylabel,
) {
  use control <- decode.optional_field(
    "control",
    [],
    decode.list(coding_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(coding_decoder()),
  )
  use classification <- decode.field("classification", coding_decoder())
  use number <- decode.optional_field("number", [], decode.list(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTermSecuritylabel(
    control:,
    category:,
    classification:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_term_to_json(contract_term: ContractTerm) -> Json {
  let ContractTerm(
    action:,
    asset:,
    offer:,
    security_label:,
    text:,
    sub_type:,
    type_:,
    topic:,
    applies:,
    issued:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_term
  let fields = [
    #("offer", contract_term_offer_to_json(offer)),
  ]
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, contract_term_action_to_json)),
      ..fields
    ]
  }
  let fields = case asset {
    [] -> fields
    _ -> [#("asset", json.array(asset, contract_term_asset_to_json)), ..fields]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #(
        "securityLabel",
        json.array(security_label, contract_term_securitylabel_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [
      #(
        "topic"
          <> case v {
          ContractTermTopicCodeableconcept(_) -> "Codeableconcept"
          ContractTermTopicReference(_) -> "Reference"
        },
        contract_term_topic_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case applies {
    Some(v) -> [#("applies", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_term_decoder() -> Decoder(ContractTerm) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(contract_term_action_decoder()),
  )
  use asset <- decode.optional_field(
    "asset",
    [],
    decode.list(contract_term_asset_decoder()),
  )
  use offer <- decode.field("offer", contract_term_offer_decoder())
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(contract_term_securitylabel_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.then(none_if_omitted(contract_term_topic_decoder()))
  use applies <- decode.optional_field(
    "applies",
    None,
    decode.optional(period_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractTerm(
    action:,
    asset:,
    offer:,
    security_label:,
    text:,
    sub_type:,
    type_:,
    topic:,
    applies:,
    issued:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_contentdefinition_to_json(
  contract_contentdefinition: ContractContentdefinition,
) -> Json {
  let ContractContentdefinition(
    copyright:,
    publication_status:,
    publication_date:,
    publisher:,
    sub_type:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = contract_contentdefinition
  let fields = [
    #(
      "publicationStatus",
      r5valuesets.contractpublicationstatus_to_json(publication_status),
    ),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publication_date {
    Some(v) -> [#("publicationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn contract_contentdefinition_decoder() -> Decoder(
  ContractContentdefinition,
) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use publication_status <- decode.field(
    "publicationStatus",
    r5valuesets.contractpublicationstatus_decoder(),
  )
  use publication_date <- decode.optional_field(
    "publicationDate",
    None,
    decode.optional(decode.string),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(reference_decoder()),
  )
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ContractContentdefinition(
    copyright:,
    publication_status:,
    publication_date:,
    publisher:,
    sub_type:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn contract_to_json(contract: Contract) -> Json {
  let Contract(
    legally_binding:,
    rule:,
    legal:,
    friendly:,
    signer:,
    relevant_history:,
    supporting_info:,
    term:,
    content_definition:,
    sub_type:,
    type_:,
    topic:,
    scope:,
    author:,
    alias:,
    subtitle:,
    title:,
    name:,
    site:,
    domain:,
    authority:,
    subject:,
    expiration_type:,
    applies:,
    issued:,
    content_derivative:,
    instantiates_uri:,
    instantiates_canonical:,
    legal_state:,
    status:,
    version:,
    url:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = contract
  let fields = []
  let fields = case legally_binding {
    Some(v) -> [
      #(
        "legallyBinding"
          <> case v {
          ContractLegallybindingAttachment(_) -> "Attachment"
          ContractLegallybindingReference(_) -> "Reference"
        },
        contract_legallybinding_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case rule {
    [] -> fields
    _ -> [#("rule", json.array(rule, contract_rule_to_json)), ..fields]
  }
  let fields = case legal {
    [] -> fields
    _ -> [#("legal", json.array(legal, contract_legal_to_json)), ..fields]
  }
  let fields = case friendly {
    [] -> fields
    _ -> [
      #("friendly", json.array(friendly, contract_friendly_to_json)),
      ..fields
    ]
  }
  let fields = case signer {
    [] -> fields
    _ -> [#("signer", json.array(signer, contract_signer_to_json)), ..fields]
  }
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case term {
    [] -> fields
    _ -> [#("term", json.array(term, contract_term_to_json)), ..fields]
  }
  let fields = case content_definition {
    Some(v) -> [
      #("contentDefinition", contract_contentdefinition_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case sub_type {
    [] -> fields
    _ -> [#("subType", json.array(sub_type, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case topic {
    Some(v) -> [
      #(
        "topic"
          <> case v {
          ContractTopicCodeableconcept(_) -> "Codeableconcept"
          ContractTopicReference(_) -> "Reference"
        },
        contract_topic_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case scope {
    Some(v) -> [#("scope", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, reference_to_json)), ..fields]
  }
  let fields = case domain {
    [] -> fields
    _ -> [#("domain", json.array(domain, reference_to_json)), ..fields]
  }
  let fields = case authority {
    [] -> fields
    _ -> [#("authority", json.array(authority, reference_to_json)), ..fields]
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case expiration_type {
    Some(v) -> [#("expirationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case applies {
    Some(v) -> [#("applies", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case content_derivative {
    Some(v) -> [#("contentDerivative", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case legal_state {
    Some(v) -> [#("legalState", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.contractstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Contract")), ..fields]
  json.object(fields)
}

pub fn contract_decoder() -> Decoder(Contract) {
  use legally_binding <- decode.then(
    none_if_omitted(contract_legallybinding_decoder()),
  )
  use rule <- decode.optional_field(
    "rule",
    [],
    decode.list(contract_rule_decoder()),
  )
  use legal <- decode.optional_field(
    "legal",
    [],
    decode.list(contract_legal_decoder()),
  )
  use friendly <- decode.optional_field(
    "friendly",
    [],
    decode.list(contract_friendly_decoder()),
  )
  use signer <- decode.optional_field(
    "signer",
    [],
    decode.list(contract_signer_decoder()),
  )
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    [],
    decode.list(contract_term_decoder()),
  )
  use content_definition <- decode.optional_field(
    "contentDefinition",
    None,
    decode.optional(contract_contentdefinition_decoder()),
  )
  use sub_type <- decode.optional_field(
    "subType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use topic <- decode.then(none_if_omitted(contract_topic_decoder()))
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(reference_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    [],
    decode.list(reference_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use expiration_type <- decode.optional_field(
    "expirationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use applies <- decode.optional_field(
    "applies",
    None,
    decode.optional(period_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use content_derivative <- decode.optional_field(
    "contentDerivative",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(reference_decoder()),
  )
  use legal_state <- decode.optional_field(
    "legalState",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.contractstatus_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Contract",
    decode.failure(contract_new(), "resourceType"),
  )
  decode.success(Contract(
    legally_binding:,
    rule:,
    legal:,
    friendly:,
    signer:,
    relevant_history:,
    supporting_info:,
    term:,
    content_definition:,
    sub_type:,
    type_:,
    topic:,
    scope:,
    author:,
    alias:,
    subtitle:,
    title:,
    name:,
    site:,
    domain:,
    authority:,
    subject:,
    expiration_type:,
    applies:,
    issued:,
    content_derivative:,
    instantiates_uri:,
    instantiates_canonical:,
    legal_state:,
    status:,
    version:,
    url:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type Coverage {
  Coverage(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Fmstatus,
    kind: r5valuesets.Coveragekind,
    payment_by: List(CoveragePaymentby),
    type_: Option(Codeableconcept),
    policy_holder: Option(Reference),
    subscriber: Option(Reference),
    subscriber_id: List(Identifier),
    beneficiary: Reference,
    dependent: Option(String),
    relationship: Option(Codeableconcept),
    period: Option(Period),
    insurer: Option(Reference),
    class: List(CoverageClass),
    order: Option(Int),
    network: Option(String),
    cost_to_beneficiary: List(CoverageCosttobeneficiary),
    subrogation: Option(Bool),
    contract: List(Reference),
    insurance_plan: Option(Reference),
  )
}

pub fn coverage_new(
  beneficiary beneficiary: Reference,
  kind kind: r5valuesets.Coveragekind,
  status status: r5valuesets.Fmstatus,
) -> Coverage {
  Coverage(
    insurance_plan: None,
    contract: [],
    subrogation: None,
    cost_to_beneficiary: [],
    network: None,
    order: None,
    class: [],
    insurer: None,
    period: None,
    relationship: None,
    dependent: None,
    beneficiary:,
    subscriber_id: [],
    subscriber: None,
    policy_holder: None,
    type_: None,
    payment_by: [],
    kind:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type CoveragePaymentby {
  CoveragePaymentby(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    party: Reference,
    responsibility: Option(String),
  )
}

pub fn coverage_paymentby_new(party party: Reference) -> CoveragePaymentby {
  CoveragePaymentby(
    responsibility: None,
    party:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type CoverageClass {
  CoverageClass(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Identifier,
    name: Option(String),
  )
}

pub fn coverage_class_new(
  value value: Identifier,
  type_ type_: Codeableconcept,
) -> CoverageClass {
  CoverageClass(
    name: None,
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiary {
  CoverageCosttobeneficiary(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    category: Option(Codeableconcept),
    network: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    term: Option(Codeableconcept),
    value: Option(CoverageCosttobeneficiaryValue),
    exception: List(CoverageCosttobeneficiaryException),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryValue {
  CoverageCosttobeneficiaryValueQuantity(value: Quantity)
  CoverageCosttobeneficiaryValueMoney(value: Money)
}

pub fn coverage_costtobeneficiary_value_to_json(
  elt: CoverageCosttobeneficiaryValue,
) -> Json {
  case elt {
    CoverageCosttobeneficiaryValueQuantity(v) -> quantity_to_json(v)
    CoverageCosttobeneficiaryValueMoney(v) -> money_to_json(v)
  }
}

pub fn coverage_costtobeneficiary_value_decoder() -> Decoder(
  CoverageCosttobeneficiaryValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(CoverageCosttobeneficiaryValueQuantity),
    [
      decode.field("valueMoney", money_decoder(), decode.success)
      |> decode.map(CoverageCosttobeneficiaryValueMoney),
    ],
  )
}

pub fn coverage_costtobeneficiary_new() -> CoverageCosttobeneficiary {
  CoverageCosttobeneficiary(
    exception: [],
    value: None,
    term: None,
    unit: None,
    network: None,
    category: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Coverage#resource
pub type CoverageCosttobeneficiaryException {
  CoverageCosttobeneficiaryException(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    period: Option(Period),
  )
}

pub fn coverage_costtobeneficiary_exception_new(
  type_ type_: Codeableconcept,
) -> CoverageCosttobeneficiaryException {
  CoverageCosttobeneficiaryException(
    period: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverage_costtobeneficiary_exception_to_json(
  coverage_costtobeneficiary_exception: CoverageCosttobeneficiaryException,
) -> Json {
  let CoverageCosttobeneficiaryException(
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverage_costtobeneficiary_exception
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_costtobeneficiary_exception_decoder() -> Decoder(
  CoverageCosttobeneficiaryException,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageCosttobeneficiaryException(
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_costtobeneficiary_to_json(
  coverage_costtobeneficiary: CoverageCosttobeneficiary,
) -> Json {
  let CoverageCosttobeneficiary(
    exception:,
    value:,
    term:,
    unit:,
    network:,
    category:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverage_costtobeneficiary
  let fields = []
  let fields = case exception {
    [] -> fields
    _ -> [
      #(
        "exception",
        json.array(exception, coverage_costtobeneficiary_exception_to_json),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          CoverageCosttobeneficiaryValueQuantity(_) -> "Quantity"
          CoverageCosttobeneficiaryValueMoney(_) -> "Money"
        },
        coverage_costtobeneficiary_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case network {
    Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_costtobeneficiary_decoder() -> Decoder(
  CoverageCosttobeneficiary,
) {
  use exception <- decode.optional_field(
    "exception",
    [],
    decode.list(coverage_costtobeneficiary_exception_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(coverage_costtobeneficiary_value_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageCosttobeneficiary(
    exception:,
    value:,
    term:,
    unit:,
    network:,
    category:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_class_to_json(coverage_class: CoverageClass) -> Json {
  let CoverageClass(name:, value:, type_:, modifier_extension:, extension:, id:) =
    coverage_class
  let fields = [
    #("value", identifier_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_class_decoder() -> Decoder(CoverageClass) {
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use value <- decode.field("value", identifier_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageClass(
    name:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_paymentby_to_json(coverage_paymentby: CoveragePaymentby) -> Json {
  let CoveragePaymentby(
    responsibility:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverage_paymentby
  let fields = [
    #("party", reference_to_json(party)),
  ]
  let fields = case responsibility {
    Some(v) -> [#("responsibility", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverage_paymentby_decoder() -> Decoder(CoveragePaymentby) {
  use responsibility <- decode.optional_field(
    "responsibility",
    None,
    decode.optional(decode.string),
  )
  use party <- decode.field("party", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoveragePaymentby(
    responsibility:,
    party:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverage_to_json(coverage: Coverage) -> Json {
  let Coverage(
    insurance_plan:,
    contract:,
    subrogation:,
    cost_to_beneficiary:,
    network:,
    order:,
    class:,
    insurer:,
    period:,
    relationship:,
    dependent:,
    beneficiary:,
    subscriber_id:,
    subscriber:,
    policy_holder:,
    type_:,
    payment_by:,
    kind:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverage
  let fields = [
    #("beneficiary", reference_to_json(beneficiary)),
    #("kind", r5valuesets.coveragekind_to_json(kind)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case insurance_plan {
    Some(v) -> [#("insurancePlan", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contract {
    [] -> fields
    _ -> [#("contract", json.array(contract, reference_to_json)), ..fields]
  }
  let fields = case subrogation {
    Some(v) -> [#("subrogation", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case cost_to_beneficiary {
    [] -> fields
    _ -> [
      #(
        "costToBeneficiary",
        json.array(cost_to_beneficiary, coverage_costtobeneficiary_to_json),
      ),
      ..fields
    ]
  }
  let fields = case network {
    Some(v) -> [#("network", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case order {
    Some(v) -> [#("order", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case class {
    [] -> fields
    _ -> [#("class", json.array(class, coverage_class_to_json)), ..fields]
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dependent {
    Some(v) -> [#("dependent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subscriber_id {
    [] -> fields
    _ -> [
      #("subscriberId", json.array(subscriber_id, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case subscriber {
    Some(v) -> [#("subscriber", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy_holder {
    Some(v) -> [#("policyHolder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_by {
    [] -> fields
    _ -> [
      #("paymentBy", json.array(payment_by, coverage_paymentby_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Coverage")), ..fields]
  json.object(fields)
}

pub fn coverage_decoder() -> Decoder(Coverage) {
  use insurance_plan <- decode.optional_field(
    "insurancePlan",
    None,
    decode.optional(reference_decoder()),
  )
  use contract <- decode.optional_field(
    "contract",
    [],
    decode.list(reference_decoder()),
  )
  use subrogation <- decode.optional_field(
    "subrogation",
    None,
    decode.optional(decode.bool),
  )
  use cost_to_beneficiary <- decode.optional_field(
    "costToBeneficiary",
    [],
    decode.list(coverage_costtobeneficiary_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(decode.string),
  )
  use order <- decode.optional_field("order", None, decode.optional(decode.int))
  use class <- decode.optional_field(
    "class",
    [],
    decode.list(coverage_class_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use dependent <- decode.optional_field(
    "dependent",
    None,
    decode.optional(decode.string),
  )
  use beneficiary <- decode.field("beneficiary", reference_decoder())
  use subscriber_id <- decode.optional_field(
    "subscriberId",
    [],
    decode.list(identifier_decoder()),
  )
  use subscriber <- decode.optional_field(
    "subscriber",
    None,
    decode.optional(reference_decoder()),
  )
  use policy_holder <- decode.optional_field(
    "policyHolder",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use payment_by <- decode.optional_field(
    "paymentBy",
    [],
    decode.list(coverage_paymentby_decoder()),
  )
  use kind <- decode.field("kind", r5valuesets.coveragekind_decoder())
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverage",
    decode.failure(coverage_new(beneficiary:, kind:, status:), "resourceType"),
  )
  decode.success(Coverage(
    insurance_plan:,
    contract:,
    subrogation:,
    cost_to_beneficiary:,
    network:,
    order:,
    class:,
    insurer:,
    period:,
    relationship:,
    dependent:,
    beneficiary:,
    subscriber_id:,
    subscriber:,
    policy_holder:,
    type_:,
    payment_by:,
    kind:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type Coverageeligibilityrequest {
  Coverageeligibilityrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Fmstatus,
    priority: Option(Codeableconcept),
    purpose: List(r5valuesets.Eligibilityrequestpurpose),
    patient: Reference,
    event: List(CoverageeligibilityrequestEvent),
    serviced: Option(CoverageeligibilityrequestServiced),
    created: String,
    enterer: Option(Reference),
    provider: Option(Reference),
    insurer: Reference,
    facility: Option(Reference),
    supporting_info: List(CoverageeligibilityrequestSupportinginfo),
    insurance: List(CoverageeligibilityrequestInsurance),
    item: List(CoverageeligibilityrequestItem),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestServiced {
  CoverageeligibilityrequestServicedDate(serviced: String)
  CoverageeligibilityrequestServicedPeriod(serviced: Period)
}

pub fn coverageeligibilityrequest_serviced_to_json(
  elt: CoverageeligibilityrequestServiced,
) -> Json {
  case elt {
    CoverageeligibilityrequestServicedDate(v) -> json.string(v)
    CoverageeligibilityrequestServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityrequest_serviced_decoder() -> Decoder(
  CoverageeligibilityrequestServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(CoverageeligibilityrequestServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityrequestServicedPeriod),
    ],
  )
}

pub fn coverageeligibilityrequest_new(
  insurer insurer: Reference,
  created created: String,
  patient patient: Reference,
  status status: r5valuesets.Fmstatus,
) -> Coverageeligibilityrequest {
  Coverageeligibilityrequest(
    item: [],
    insurance: [],
    supporting_info: [],
    facility: None,
    insurer:,
    provider: None,
    enterer: None,
    created:,
    serviced: None,
    event: [],
    patient:,
    purpose: [],
    priority: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestEvent {
  CoverageeligibilityrequestEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    when: CoverageeligibilityrequestEventWhen,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestEventWhen {
  CoverageeligibilityrequestEventWhenDatetime(when: String)
  CoverageeligibilityrequestEventWhenPeriod(when: Period)
}

pub fn coverageeligibilityrequest_event_when_to_json(
  elt: CoverageeligibilityrequestEventWhen,
) -> Json {
  case elt {
    CoverageeligibilityrequestEventWhenDatetime(v) -> json.string(v)
    CoverageeligibilityrequestEventWhenPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityrequest_event_when_decoder() -> Decoder(
  CoverageeligibilityrequestEventWhen,
) {
  decode.one_of(
    decode.field("whenDateTime", decode.string, decode.success)
      |> decode.map(CoverageeligibilityrequestEventWhenDatetime),
    [
      decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityrequestEventWhenPeriod),
    ],
  )
}

pub fn coverageeligibilityrequest_event_new(
  when when: CoverageeligibilityrequestEventWhen,
  type_ type_: Codeableconcept,
) -> CoverageeligibilityrequestEvent {
  CoverageeligibilityrequestEvent(
    when:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestSupportinginfo {
  CoverageeligibilityrequestSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    information: Reference,
    applies_to_all: Option(Bool),
  )
}

pub fn coverageeligibilityrequest_supportinginfo_new(
  information information: Reference,
  sequence sequence: Int,
) -> CoverageeligibilityrequestSupportinginfo {
  CoverageeligibilityrequestSupportinginfo(
    applies_to_all: None,
    information:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestInsurance {
  CoverageeligibilityrequestInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    focal: Option(Bool),
    coverage: Reference,
    business_arrangement: Option(String),
  )
}

pub fn coverageeligibilityrequest_insurance_new(
  coverage coverage: Reference,
) -> CoverageeligibilityrequestInsurance {
  CoverageeligibilityrequestInsurance(
    business_arrangement: None,
    coverage:,
    focal: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItem {
  CoverageeligibilityrequestItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    supporting_info_sequence: List(Int),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    provider: Option(Reference),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    facility: Option(Reference),
    diagnosis: List(CoverageeligibilityrequestItemDiagnosis),
    detail: List(Reference),
  )
}

pub fn coverageeligibilityrequest_item_new() -> CoverageeligibilityrequestItem {
  CoverageeligibilityrequestItem(
    detail: [],
    diagnosis: [],
    facility: None,
    unit_price: None,
    quantity: None,
    provider: None,
    modifier: [],
    product_or_service: None,
    category: None,
    supporting_info_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosis {
  CoverageeligibilityrequestItemDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    diagnosis: Option(CoverageeligibilityrequestItemDiagnosisDiagnosis),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityRequest#resource
pub type CoverageeligibilityrequestItemDiagnosisDiagnosis {
  CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(
    diagnosis: Codeableconcept,
  )
  CoverageeligibilityrequestItemDiagnosisDiagnosisReference(
    diagnosis: Reference,
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(
  elt: CoverageeligibilityrequestItemDiagnosisDiagnosis,
) -> Json {
  case elt {
    CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(v) ->
      codeableconcept_to_json(v)
    CoverageeligibilityrequestItemDiagnosisDiagnosisReference(v) ->
      reference_to_json(v)
  }
}

pub fn coverageeligibilityrequest_item_diagnosis_diagnosis_decoder() -> Decoder(
  CoverageeligibilityrequestItemDiagnosisDiagnosis,
) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept,
      ),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(CoverageeligibilityrequestItemDiagnosisDiagnosisReference),
    ],
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_new() -> CoverageeligibilityrequestItemDiagnosis {
  CoverageeligibilityrequestItemDiagnosis(
    diagnosis: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverageeligibilityrequest_item_diagnosis_to_json(
  coverageeligibilityrequest_item_diagnosis: CoverageeligibilityrequestItemDiagnosis,
) -> Json {
  let CoverageeligibilityrequestItemDiagnosis(
    diagnosis:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_item_diagnosis
  let fields = []
  let fields = case diagnosis {
    Some(v) -> [
      #(
        "diagnosis"
          <> case v {
          CoverageeligibilityrequestItemDiagnosisDiagnosisCodeableconcept(_) ->
            "Codeableconcept"
          CoverageeligibilityrequestItemDiagnosisDiagnosisReference(_) ->
            "Reference"
        },
        coverageeligibilityrequest_item_diagnosis_diagnosis_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_item_diagnosis_decoder() -> Decoder(
  CoverageeligibilityrequestItemDiagnosis,
) {
  use diagnosis <- decode.then(
    none_if_omitted(
      coverageeligibilityrequest_item_diagnosis_diagnosis_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestItemDiagnosis(
    diagnosis:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_item_to_json(
  coverageeligibilityrequest_item: CoverageeligibilityrequestItem,
) -> Json {
  let CoverageeligibilityrequestItem(
    detail:,
    diagnosis:,
    facility:,
    unit_price:,
    quantity:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    supporting_info_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_item
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #(
        "diagnosis",
        json.array(diagnosis, coverageeligibilityrequest_item_diagnosis_to_json),
      ),
      ..fields
    ]
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_info_sequence {
    [] -> fields
    _ -> [
      #(
        "supportingInfoSequence",
        json.array(supporting_info_sequence, json.int),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_item_decoder() -> Decoder(
  CoverageeligibilityrequestItem,
) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(coverageeligibilityrequest_item_diagnosis_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use supporting_info_sequence <- decode.optional_field(
    "supportingInfoSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestItem(
    detail:,
    diagnosis:,
    facility:,
    unit_price:,
    quantity:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    supporting_info_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_insurance_to_json(
  coverageeligibilityrequest_insurance: CoverageeligibilityrequestInsurance,
) -> Json {
  let CoverageeligibilityrequestInsurance(
    business_arrangement:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case business_arrangement {
    Some(v) -> [#("businessArrangement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case focal {
    Some(v) -> [#("focal", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_insurance_decoder() -> Decoder(
  CoverageeligibilityrequestInsurance,
) {
  use business_arrangement <- decode.optional_field(
    "businessArrangement",
    None,
    decode.optional(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.optional_field(
    "focal",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestInsurance(
    business_arrangement:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_supportinginfo_to_json(
  coverageeligibilityrequest_supportinginfo: CoverageeligibilityrequestSupportinginfo,
) -> Json {
  let CoverageeligibilityrequestSupportinginfo(
    applies_to_all:,
    information:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_supportinginfo
  let fields = [
    #("information", reference_to_json(information)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case applies_to_all {
    Some(v) -> [#("appliesToAll", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_supportinginfo_decoder() -> Decoder(
  CoverageeligibilityrequestSupportinginfo,
) {
  use applies_to_all <- decode.optional_field(
    "appliesToAll",
    None,
    decode.optional(decode.bool),
  )
  use information <- decode.field("information", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestSupportinginfo(
    applies_to_all:,
    information:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_event_to_json(
  coverageeligibilityrequest_event: CoverageeligibilityrequestEvent,
) -> Json {
  let CoverageeligibilityrequestEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityrequest_event
  let fields = [
    #("when", coverageeligibilityrequest_event_when_to_json(when)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityrequest_event_decoder() -> Decoder(
  CoverageeligibilityrequestEvent,
) {
  use when <- decode.then(coverageeligibilityrequest_event_when_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityrequestEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityrequest_to_json(
  coverageeligibilityrequest: Coverageeligibilityrequest,
) -> Json {
  let Coverageeligibilityrequest(
    item:,
    insurance:,
    supporting_info:,
    facility:,
    insurer:,
    provider:,
    enterer:,
    created:,
    serviced:,
    event:,
    patient:,
    purpose:,
    priority:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverageeligibilityrequest
  let fields = [
    #("insurer", reference_to_json(insurer)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, coverageeligibilityrequest_item_to_json)),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, coverageeligibilityrequest_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(
          supporting_info,
          coverageeligibilityrequest_supportinginfo_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          CoverageeligibilityrequestServicedDate(_) -> "Date"
          CoverageeligibilityrequestServicedPeriod(_) -> "Period"
        },
        coverageeligibilityrequest_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [
      #("event", json.array(event, coverageeligibilityrequest_event_to_json)),
      ..fields
    ]
  }
  let fields = case purpose {
    [] -> fields
    _ -> [
      #(
        "purpose",
        json.array(purpose, r5valuesets.eligibilityrequestpurpose_to_json),
      ),
      ..fields
    ]
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Coverageeligibilityrequest")),
    ..fields
  ]
  json.object(fields)
}

pub fn coverageeligibilityrequest_decoder() -> Decoder(
  Coverageeligibilityrequest,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(coverageeligibilityrequest_item_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(coverageeligibilityrequest_insurance_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(coverageeligibilityrequest_supportinginfo_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.field("insurer", reference_decoder())
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use serviced <- decode.then(
    none_if_omitted(coverageeligibilityrequest_serviced_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(coverageeligibilityrequest_event_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(r5valuesets.eligibilityrequestpurpose_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverageeligibilityrequest",
    decode.failure(
      coverageeligibilityrequest_new(insurer:, created:, patient:, status:),
      "resourceType",
    ),
  )
  decode.success(Coverageeligibilityrequest(
    item:,
    insurance:,
    supporting_info:,
    facility:,
    insurer:,
    provider:,
    enterer:,
    created:,
    serviced:,
    event:,
    patient:,
    purpose:,
    priority:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type Coverageeligibilityresponse {
  Coverageeligibilityresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Fmstatus,
    purpose: List(r5valuesets.Eligibilityresponsepurpose),
    patient: Reference,
    event: List(CoverageeligibilityresponseEvent),
    serviced: Option(CoverageeligibilityresponseServiced),
    created: String,
    requestor: Option(Reference),
    request: Reference,
    outcome: r5valuesets.Eligibilityoutcome,
    disposition: Option(String),
    insurer: Reference,
    insurance: List(CoverageeligibilityresponseInsurance),
    pre_auth_ref: Option(String),
    form: Option(Codeableconcept),
    error: List(CoverageeligibilityresponseError),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseServiced {
  CoverageeligibilityresponseServicedDate(serviced: String)
  CoverageeligibilityresponseServicedPeriod(serviced: Period)
}

pub fn coverageeligibilityresponse_serviced_to_json(
  elt: CoverageeligibilityresponseServiced,
) -> Json {
  case elt {
    CoverageeligibilityresponseServicedDate(v) -> json.string(v)
    CoverageeligibilityresponseServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityresponse_serviced_decoder() -> Decoder(
  CoverageeligibilityresponseServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(CoverageeligibilityresponseServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityresponseServicedPeriod),
    ],
  )
}

pub fn coverageeligibilityresponse_new(
  insurer insurer: Reference,
  outcome outcome: r5valuesets.Eligibilityoutcome,
  request request: Reference,
  created created: String,
  patient patient: Reference,
  status status: r5valuesets.Fmstatus,
) -> Coverageeligibilityresponse {
  Coverageeligibilityresponse(
    error: [],
    form: None,
    pre_auth_ref: None,
    insurance: [],
    insurer:,
    disposition: None,
    outcome:,
    request:,
    requestor: None,
    created:,
    serviced: None,
    event: [],
    patient:,
    purpose: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseEvent {
  CoverageeligibilityresponseEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    when: CoverageeligibilityresponseEventWhen,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseEventWhen {
  CoverageeligibilityresponseEventWhenDatetime(when: String)
  CoverageeligibilityresponseEventWhenPeriod(when: Period)
}

pub fn coverageeligibilityresponse_event_when_to_json(
  elt: CoverageeligibilityresponseEventWhen,
) -> Json {
  case elt {
    CoverageeligibilityresponseEventWhenDatetime(v) -> json.string(v)
    CoverageeligibilityresponseEventWhenPeriod(v) -> period_to_json(v)
  }
}

pub fn coverageeligibilityresponse_event_when_decoder() -> Decoder(
  CoverageeligibilityresponseEventWhen,
) {
  decode.one_of(
    decode.field("whenDateTime", decode.string, decode.success)
      |> decode.map(CoverageeligibilityresponseEventWhenDatetime),
    [
      decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(CoverageeligibilityresponseEventWhenPeriod),
    ],
  )
}

pub fn coverageeligibilityresponse_event_new(
  when when: CoverageeligibilityresponseEventWhen,
  type_ type_: Codeableconcept,
) -> CoverageeligibilityresponseEvent {
  CoverageeligibilityresponseEvent(
    when:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsurance {
  CoverageeligibilityresponseInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    coverage: Reference,
    inforce: Option(Bool),
    benefit_period: Option(Period),
    item: List(CoverageeligibilityresponseInsuranceItem),
  )
}

pub fn coverageeligibilityresponse_insurance_new(
  coverage coverage: Reference,
) -> CoverageeligibilityresponseInsurance {
  CoverageeligibilityresponseInsurance(
    item: [],
    benefit_period: None,
    inforce: None,
    coverage:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItem {
  CoverageeligibilityresponseInsuranceItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    provider: Option(Reference),
    excluded: Option(Bool),
    name: Option(String),
    description: Option(String),
    network: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    term: Option(Codeableconcept),
    benefit: List(CoverageeligibilityresponseInsuranceItemBenefit),
    authorization_required: Option(Bool),
    authorization_supporting: List(Codeableconcept),
    authorization_url: Option(String),
  )
}

pub fn coverageeligibilityresponse_insurance_item_new() -> CoverageeligibilityresponseInsuranceItem {
  CoverageeligibilityresponseInsuranceItem(
    authorization_url: None,
    authorization_supporting: [],
    authorization_required: None,
    benefit: [],
    term: None,
    unit: None,
    network: None,
    description: None,
    name: None,
    excluded: None,
    provider: None,
    modifier: [],
    product_or_service: None,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefit {
  CoverageeligibilityresponseInsuranceItemBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Option(CoverageeligibilityresponseInsuranceItemBenefitAllowed),
    used: Option(CoverageeligibilityresponseInsuranceItemBenefitUsed),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitAllowed {
  CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(
    allowed: Int,
  )
  CoverageeligibilityresponseInsuranceItemBenefitAllowedString(allowed: String)
  CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(allowed: Money)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(
  elt: CoverageeligibilityresponseInsuranceItemBenefitAllowed,
) -> Json {
  case elt {
    CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(v) ->
      json.int(v)
    CoverageeligibilityresponseInsuranceItemBenefitAllowedString(v) ->
      json.string(v)
    CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(v) ->
      money_to_json(v)
  }
}

pub fn coverageeligibilityresponse_insurance_item_benefit_allowed_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefitAllowed,
) {
  decode.one_of(
    decode.field("allowedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint,
      ),
    [
      decode.field("allowedString", decode.string, decode.success)
        |> decode.map(
          CoverageeligibilityresponseInsuranceItemBenefitAllowedString,
        ),
      decode.field("allowedMoney", money_decoder(), decode.success)
        |> decode.map(
          CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney,
        ),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseInsuranceItemBenefitUsed {
  CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(used: Int)
  CoverageeligibilityresponseInsuranceItemBenefitUsedString(used: String)
  CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(used: Money)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_used_to_json(
  elt: CoverageeligibilityresponseInsuranceItemBenefitUsed,
) -> Json {
  case elt {
    CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(v) ->
      json.int(v)
    CoverageeligibilityresponseInsuranceItemBenefitUsedString(v) ->
      json.string(v)
    CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(v) ->
      money_to_json(v)
  }
}

pub fn coverageeligibilityresponse_insurance_item_benefit_used_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefitUsed,
) {
  decode.one_of(
    decode.field("usedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint,
      ),
    [
      decode.field("usedString", decode.string, decode.success)
        |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedString),
      decode.field("usedMoney", money_decoder(), decode.success)
        |> decode.map(CoverageeligibilityresponseInsuranceItemBenefitUsedMoney),
    ],
  )
}

pub fn coverageeligibilityresponse_insurance_item_benefit_new(
  type_ type_: Codeableconcept,
) -> CoverageeligibilityresponseInsuranceItemBenefit {
  CoverageeligibilityresponseInsuranceItemBenefit(
    used: None,
    allowed: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/CoverageEligibilityResponse#resource
pub type CoverageeligibilityresponseError {
  CoverageeligibilityresponseError(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    expression: List(String),
  )
}

pub fn coverageeligibilityresponse_error_new(
  code code: Codeableconcept,
) -> CoverageeligibilityresponseError {
  CoverageeligibilityresponseError(
    expression: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn coverageeligibilityresponse_error_to_json(
  coverageeligibilityresponse_error: CoverageeligibilityresponseError,
) -> Json {
  let CoverageeligibilityresponseError(
    expression:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_error
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case expression {
    [] -> fields
    _ -> [#("expression", json.array(expression, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_error_decoder() -> Decoder(
  CoverageeligibilityresponseError,
) {
  use expression <- decode.optional_field(
    "expression",
    [],
    decode.list(decode.string),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseError(
    expression:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_item_benefit_to_json(
  coverageeligibilityresponse_insurance_item_benefit: CoverageeligibilityresponseInsuranceItemBenefit,
) -> Json {
  let CoverageeligibilityresponseInsuranceItemBenefit(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance_item_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case used {
    Some(v) -> [
      #(
        "used"
          <> case v {
          CoverageeligibilityresponseInsuranceItemBenefitUsedUnsignedint(_) ->
            "Unsignedint"
          CoverageeligibilityresponseInsuranceItemBenefitUsedString(_) ->
            "String"
          CoverageeligibilityresponseInsuranceItemBenefitUsedMoney(_) -> "Money"
        },
        coverageeligibilityresponse_insurance_item_benefit_used_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case allowed {
    Some(v) -> [
      #(
        "allowed"
          <> case v {
          CoverageeligibilityresponseInsuranceItemBenefitAllowedUnsignedint(_) ->
            "Unsignedint"
          CoverageeligibilityresponseInsuranceItemBenefitAllowedString(_) ->
            "String"
          CoverageeligibilityresponseInsuranceItemBenefitAllowedMoney(_) ->
            "Money"
        },
        coverageeligibilityresponse_insurance_item_benefit_allowed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_item_benefit_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItemBenefit,
) {
  use used <- decode.then(
    none_if_omitted(
      coverageeligibilityresponse_insurance_item_benefit_used_decoder(),
    ),
  )
  use allowed <- decode.then(
    none_if_omitted(
      coverageeligibilityresponse_insurance_item_benefit_allowed_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsuranceItemBenefit(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_item_to_json(
  coverageeligibilityresponse_insurance_item: CoverageeligibilityresponseInsuranceItem,
) -> Json {
  let CoverageeligibilityresponseInsuranceItem(
    authorization_url:,
    authorization_supporting:,
    authorization_required:,
    benefit:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance_item
  let fields = []
  let fields = case authorization_url {
    Some(v) -> [#("authorizationUrl", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authorization_supporting {
    [] -> fields
    _ -> [
      #(
        "authorizationSupporting",
        json.array(authorization_supporting, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case authorization_required {
    Some(v) -> [#("authorizationRequired", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case benefit {
    [] -> fields
    _ -> [
      #(
        "benefit",
        json.array(
          benefit,
          coverageeligibilityresponse_insurance_item_benefit_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case network {
    Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case excluded {
    Some(v) -> [#("excluded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_item_decoder() -> Decoder(
  CoverageeligibilityresponseInsuranceItem,
) {
  use authorization_url <- decode.optional_field(
    "authorizationUrl",
    None,
    decode.optional(decode.string),
  )
  use authorization_supporting <- decode.optional_field(
    "authorizationSupporting",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use authorization_required <- decode.optional_field(
    "authorizationRequired",
    None,
    decode.optional(decode.bool),
  )
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(coverageeligibilityresponse_insurance_item_benefit_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use excluded <- decode.optional_field(
    "excluded",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsuranceItem(
    authorization_url:,
    authorization_supporting:,
    authorization_required:,
    benefit:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    provider:,
    modifier:,
    product_or_service:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_insurance_to_json(
  coverageeligibilityresponse_insurance: CoverageeligibilityresponseInsurance,
) -> Json {
  let CoverageeligibilityresponseInsurance(
    item:,
    benefit_period:,
    inforce:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #(
        "item",
        json.array(item, coverageeligibilityresponse_insurance_item_to_json),
      ),
      ..fields
    ]
  }
  let fields = case benefit_period {
    Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case inforce {
    Some(v) -> [#("inforce", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_insurance_decoder() -> Decoder(
  CoverageeligibilityresponseInsurance,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(coverageeligibilityresponse_insurance_item_decoder()),
  )
  use benefit_period <- decode.optional_field(
    "benefitPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use inforce <- decode.optional_field(
    "inforce",
    None,
    decode.optional(decode.bool),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseInsurance(
    item:,
    benefit_period:,
    inforce:,
    coverage:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_event_to_json(
  coverageeligibilityresponse_event: CoverageeligibilityresponseEvent,
) -> Json {
  let CoverageeligibilityresponseEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = coverageeligibilityresponse_event
  let fields = [
    #("when", coverageeligibilityresponse_event_when_to_json(when)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn coverageeligibilityresponse_event_decoder() -> Decoder(
  CoverageeligibilityresponseEvent,
) {
  use when <- decode.then(coverageeligibilityresponse_event_when_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(CoverageeligibilityresponseEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn coverageeligibilityresponse_to_json(
  coverageeligibilityresponse: Coverageeligibilityresponse,
) -> Json {
  let Coverageeligibilityresponse(
    error:,
    form:,
    pre_auth_ref:,
    insurance:,
    insurer:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    created:,
    serviced:,
    event:,
    patient:,
    purpose:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = coverageeligibilityresponse
  let fields = [
    #("insurer", reference_to_json(insurer)),
    #("outcome", r5valuesets.eligibilityoutcome_to_json(outcome)),
    #("request", reference_to_json(request)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [
      #("error", json.array(error, coverageeligibilityresponse_error_to_json)),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, coverageeligibilityresponse_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          CoverageeligibilityresponseServicedDate(_) -> "Date"
          CoverageeligibilityresponseServicedPeriod(_) -> "Period"
        },
        coverageeligibilityresponse_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [
      #("event", json.array(event, coverageeligibilityresponse_event_to_json)),
      ..fields
    ]
  }
  let fields = case purpose {
    [] -> fields
    _ -> [
      #(
        "purpose",
        json.array(purpose, r5valuesets.eligibilityresponsepurpose_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Coverageeligibilityresponse")),
    ..fields
  ]
  json.object(fields)
}

pub fn coverageeligibilityresponse_decoder() -> Decoder(
  Coverageeligibilityresponse,
) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(coverageeligibilityresponse_error_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(coverageeligibilityresponse_insurance_decoder()),
  )
  use insurer <- decode.field("insurer", reference_decoder())
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.field(
    "outcome",
    r5valuesets.eligibilityoutcome_decoder(),
  )
  use request <- decode.field("request", reference_decoder())
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use serviced <- decode.then(
    none_if_omitted(coverageeligibilityresponse_serviced_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(coverageeligibilityresponse_event_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(r5valuesets.eligibilityresponsepurpose_decoder()),
  )
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Coverageeligibilityresponse",
    decode.failure(
      coverageeligibilityresponse_new(
        insurer:,
        outcome:,
        request:,
        created:,
        patient:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Coverageeligibilityresponse(
    error:,
    form:,
    pre_auth_ref:,
    insurance:,
    insurer:,
    disposition:,
    outcome:,
    request:,
    requestor:,
    created:,
    serviced:,
    event:,
    patient:,
    purpose:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DetectedIssue#resource
pub type Detectedissue {
  Detectedissue(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Detectedissuestatus,
    category: List(Codeableconcept),
    code: Option(Codeableconcept),
    severity: Option(r5valuesets.Detectedissueseverity),
    subject: Option(Reference),
    encounter: Option(Reference),
    identified: Option(DetectedissueIdentified),
    author: Option(Reference),
    implicated: List(Reference),
    evidence: List(DetectedissueEvidence),
    detail: Option(String),
    reference: Option(String),
    mitigation: List(DetectedissueMitigation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DetectedIssue#resource
pub type DetectedissueIdentified {
  DetectedissueIdentifiedDatetime(identified: String)
  DetectedissueIdentifiedPeriod(identified: Period)
}

pub fn detectedissue_identified_to_json(elt: DetectedissueIdentified) -> Json {
  case elt {
    DetectedissueIdentifiedDatetime(v) -> json.string(v)
    DetectedissueIdentifiedPeriod(v) -> period_to_json(v)
  }
}

pub fn detectedissue_identified_decoder() -> Decoder(DetectedissueIdentified) {
  decode.one_of(
    decode.field("identifiedDateTime", decode.string, decode.success)
      |> decode.map(DetectedissueIdentifiedDatetime),
    [
      decode.field("identifiedPeriod", period_decoder(), decode.success)
      |> decode.map(DetectedissueIdentifiedPeriod),
    ],
  )
}

pub fn detectedissue_new(
  status status: r5valuesets.Detectedissuestatus,
) -> Detectedissue {
  Detectedissue(
    mitigation: [],
    reference: None,
    detail: None,
    evidence: [],
    implicated: [],
    author: None,
    identified: None,
    encounter: None,
    subject: None,
    severity: None,
    code: None,
    category: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DetectedIssue#resource
pub type DetectedissueEvidence {
  DetectedissueEvidence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: List(Codeableconcept),
    detail: List(Reference),
  )
}

pub fn detectedissue_evidence_new() -> DetectedissueEvidence {
  DetectedissueEvidence(
    detail: [],
    code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DetectedIssue#resource
pub type DetectedissueMitigation {
  DetectedissueMitigation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: Codeableconcept,
    date: Option(String),
    author: Option(Reference),
    note: List(Annotation),
  )
}

pub fn detectedissue_mitigation_new(
  action action: Codeableconcept,
) -> DetectedissueMitigation {
  DetectedissueMitigation(
    note: [],
    author: None,
    date: None,
    action:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn detectedissue_mitigation_to_json(
  detectedissue_mitigation: DetectedissueMitigation,
) -> Json {
  let DetectedissueMitigation(
    note:,
    author:,
    date:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ) = detectedissue_mitigation
  let fields = [
    #("action", codeableconcept_to_json(action)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn detectedissue_mitigation_decoder() -> Decoder(DetectedissueMitigation) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use action <- decode.field("action", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DetectedissueMitigation(
    note:,
    author:,
    date:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn detectedissue_evidence_to_json(
  detectedissue_evidence: DetectedissueEvidence,
) -> Json {
  let DetectedissueEvidence(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = detectedissue_evidence
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [#("detail", json.array(detail, reference_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn detectedissue_evidence_decoder() -> Decoder(DetectedissueEvidence) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DetectedissueEvidence(
    detail:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn detectedissue_to_json(detectedissue: Detectedissue) -> Json {
  let Detectedissue(
    mitigation:,
    reference:,
    detail:,
    evidence:,
    implicated:,
    author:,
    identified:,
    encounter:,
    subject:,
    severity:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = detectedissue
  let fields = [
    #("status", r5valuesets.detectedissuestatus_to_json(status)),
  ]
  let fields = case mitigation {
    [] -> fields
    _ -> [
      #("mitigation", json.array(mitigation, detectedissue_mitigation_to_json)),
      ..fields
    ]
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case evidence {
    [] -> fields
    _ -> [
      #("evidence", json.array(evidence, detectedissue_evidence_to_json)),
      ..fields
    ]
  }
  let fields = case implicated {
    [] -> fields
    _ -> [#("implicated", json.array(implicated, reference_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identified {
    Some(v) -> [
      #(
        "identified"
          <> case v {
          DetectedissueIdentifiedDatetime(_) -> "Datetime"
          DetectedissueIdentifiedPeriod(_) -> "Period"
        },
        detectedissue_identified_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case severity {
    Some(v) -> [
      #("severity", r5valuesets.detectedissueseverity_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Detectedissue")), ..fields]
  json.object(fields)
}

pub fn detectedissue_decoder() -> Decoder(Detectedissue) {
  use mitigation <- decode.optional_field(
    "mitigation",
    [],
    decode.list(detectedissue_mitigation_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use evidence <- decode.optional_field(
    "evidence",
    [],
    decode.list(detectedissue_evidence_decoder()),
  )
  use implicated <- decode.optional_field(
    "implicated",
    [],
    decode.list(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use identified <- decode.then(
    none_if_omitted(detectedissue_identified_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use severity <- decode.optional_field(
    "severity",
    None,
    decode.optional(r5valuesets.detectedissueseverity_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.detectedissuestatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Detectedissue",
    decode.failure(detectedissue_new(status:), "resourceType"),
  )
  decode.success(Detectedissue(
    mitigation:,
    reference:,
    detail:,
    evidence:,
    implicated:,
    author:,
    identified:,
    encounter:,
    subject:,
    severity:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type Device {
  Device(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    display_name: Option(String),
    definition: Option(Codeablereference),
    udi_carrier: List(DeviceUdicarrier),
    status: Option(r5valuesets.Devicestatus),
    availability_status: Option(Codeableconcept),
    biological_source_event: Option(Identifier),
    manufacturer: Option(String),
    manufacture_date: Option(String),
    expiration_date: Option(String),
    lot_number: Option(String),
    serial_number: Option(String),
    name: List(DeviceName),
    model_number: Option(String),
    part_number: Option(String),
    category: List(Codeableconcept),
    type_: List(Codeableconcept),
    version: List(DeviceVersion),
    conforms_to: List(DeviceConformsto),
    property: List(DeviceProperty),
    mode: Option(Codeableconcept),
    cycle: Option(Count),
    duration: Option(Duration),
    owner: Option(Reference),
    contact: List(Contactpoint),
    location: Option(Reference),
    url: Option(String),
    endpoint: List(Reference),
    gateway: List(Codeablereference),
    note: List(Annotation),
    safety: List(Codeableconcept),
    parent: Option(Reference),
  )
}

pub fn device_new() -> Device {
  Device(
    parent: None,
    safety: [],
    note: [],
    gateway: [],
    endpoint: [],
    url: None,
    location: None,
    contact: [],
    owner: None,
    duration: None,
    cycle: None,
    mode: None,
    property: [],
    conforms_to: [],
    version: [],
    type_: [],
    category: [],
    part_number: None,
    model_number: None,
    name: [],
    serial_number: None,
    lot_number: None,
    expiration_date: None,
    manufacture_date: None,
    manufacturer: None,
    biological_source_event: None,
    availability_status: None,
    status: None,
    udi_carrier: [],
    definition: None,
    display_name: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DeviceUdicarrier {
  DeviceUdicarrier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device_identifier: String,
    issuer: String,
    jurisdiction: Option(String),
    carrier_aidc: Option(String),
    carrier_hrf: Option(String),
    entry_type: Option(r5valuesets.Udientrytype),
  )
}

pub fn device_udicarrier_new(
  issuer issuer: String,
  device_identifier device_identifier: String,
) -> DeviceUdicarrier {
  DeviceUdicarrier(
    entry_type: None,
    carrier_hrf: None,
    carrier_aidc: None,
    jurisdiction: None,
    issuer:,
    device_identifier:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DeviceName {
  DeviceName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: String,
    type_: r5valuesets.Devicenametype,
    display: Option(Bool),
  )
}

pub fn device_name_new(
  type_ type_: r5valuesets.Devicenametype,
  value value: String,
) -> DeviceName {
  DeviceName(
    display: None,
    type_:,
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DeviceVersion {
  DeviceVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    component: Option(Identifier),
    install_date: Option(String),
    value: String,
  )
}

pub fn device_version_new(value value: String) -> DeviceVersion {
  DeviceVersion(
    value:,
    install_date: None,
    component: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DeviceConformsto {
  DeviceConformsto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    specification: Codeableconcept,
    version: Option(String),
  )
}

pub fn device_conformsto_new(
  specification specification: Codeableconcept,
) -> DeviceConformsto {
  DeviceConformsto(
    version: None,
    specification:,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DeviceProperty {
  DeviceProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: DevicePropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Device#resource
pub type DevicePropertyValue {
  DevicePropertyValueQuantity(value: Quantity)
  DevicePropertyValueCodeableconcept(value: Codeableconcept)
  DevicePropertyValueString(value: String)
  DevicePropertyValueBoolean(value: Bool)
  DevicePropertyValueInteger(value: Int)
  DevicePropertyValueRange(value: Range)
  DevicePropertyValueAttachment(value: Attachment)
}

pub fn device_property_value_to_json(elt: DevicePropertyValue) -> Json {
  case elt {
    DevicePropertyValueQuantity(v) -> quantity_to_json(v)
    DevicePropertyValueCodeableconcept(v) -> codeableconcept_to_json(v)
    DevicePropertyValueString(v) -> json.string(v)
    DevicePropertyValueBoolean(v) -> json.bool(v)
    DevicePropertyValueInteger(v) -> json.int(v)
    DevicePropertyValueRange(v) -> range_to_json(v)
    DevicePropertyValueAttachment(v) -> attachment_to_json(v)
  }
}

pub fn device_property_value_decoder() -> Decoder(DevicePropertyValue) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(DevicePropertyValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(DevicePropertyValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(DevicePropertyValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(DevicePropertyValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(DevicePropertyValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(DevicePropertyValueRange),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(DevicePropertyValueAttachment),
    ],
  )
}

pub fn device_property_new(
  value value: DevicePropertyValue,
  type_ type_: Codeableconcept,
) -> DeviceProperty {
  DeviceProperty(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn device_property_to_json(device_property: DeviceProperty) -> Json {
  let DeviceProperty(value:, type_:, modifier_extension:, extension:, id:) =
    device_property
  let fields = [
    #("value", device_property_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_property_decoder() -> Decoder(DeviceProperty) {
  use value <- decode.then(device_property_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_conformsto_to_json(device_conformsto: DeviceConformsto) -> Json {
  let DeviceConformsto(
    version:,
    specification:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_conformsto
  let fields = [
    #("specification", codeableconcept_to_json(specification)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_conformsto_decoder() -> Decoder(DeviceConformsto) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use specification <- decode.field("specification", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceConformsto(
    version:,
    specification:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_version_to_json(device_version: DeviceVersion) -> Json {
  let DeviceVersion(
    value:,
    install_date:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_version
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case install_date {
    Some(v) -> [#("installDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case component {
    Some(v) -> [#("component", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_version_decoder() -> Decoder(DeviceVersion) {
  use value <- decode.field("value", decode.string)
  use install_date <- decode.optional_field(
    "installDate",
    None,
    decode.optional(decode.string),
  )
  use component <- decode.optional_field(
    "component",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceVersion(
    value:,
    install_date:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_name_to_json(device_name: DeviceName) -> Json {
  let DeviceName(display:, type_:, value:, modifier_extension:, extension:, id:) =
    device_name
  let fields = [
    #("type", r5valuesets.devicenametype_to_json(type_)),
    #("value", json.string(value)),
  ]
  let fields = case display {
    Some(v) -> [#("display", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_name_decoder() -> Decoder(DeviceName) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.bool),
  )
  use type_ <- decode.field("type", r5valuesets.devicenametype_decoder())
  use value <- decode.field("value", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceName(
    display:,
    type_:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_udicarrier_to_json(device_udicarrier: DeviceUdicarrier) -> Json {
  let DeviceUdicarrier(
    entry_type:,
    carrier_hrf:,
    carrier_aidc:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = device_udicarrier
  let fields = [
    #("issuer", json.string(issuer)),
    #("deviceIdentifier", json.string(device_identifier)),
  ]
  let fields = case entry_type {
    Some(v) -> [#("entryType", r5valuesets.udientrytype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case carrier_hrf {
    Some(v) -> [#("carrierHRF", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case carrier_aidc {
    Some(v) -> [#("carrierAIDC", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn device_udicarrier_decoder() -> Decoder(DeviceUdicarrier) {
  use entry_type <- decode.optional_field(
    "entryType",
    None,
    decode.optional(r5valuesets.udientrytype_decoder()),
  )
  use carrier_hrf <- decode.optional_field(
    "carrierHRF",
    None,
    decode.optional(decode.string),
  )
  use carrier_aidc <- decode.optional_field(
    "carrierAIDC",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(decode.string),
  )
  use issuer <- decode.field("issuer", decode.string)
  use device_identifier <- decode.field("deviceIdentifier", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceUdicarrier(
    entry_type:,
    carrier_hrf:,
    carrier_aidc:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn device_to_json(device: Device) -> Json {
  let Device(
    parent:,
    safety:,
    note:,
    gateway:,
    endpoint:,
    url:,
    location:,
    contact:,
    owner:,
    duration:,
    cycle:,
    mode:,
    property:,
    conforms_to:,
    version:,
    type_:,
    category:,
    part_number:,
    model_number:,
    name:,
    serial_number:,
    lot_number:,
    expiration_date:,
    manufacture_date:,
    manufacturer:,
    biological_source_event:,
    availability_status:,
    status:,
    udi_carrier:,
    definition:,
    display_name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = device
  let fields = []
  let fields = case parent {
    Some(v) -> [#("parent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case safety {
    [] -> fields
    _ -> [#("safety", json.array(safety, codeableconcept_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case gateway {
    [] -> fields
    _ -> [
      #("gateway", json.array(gateway, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cycle {
    Some(v) -> [#("cycle", count_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, device_property_to_json)),
      ..fields
    ]
  }
  let fields = case conforms_to {
    [] -> fields
    _ -> [
      #("conformsTo", json.array(conforms_to, device_conformsto_to_json)),
      ..fields
    ]
  }
  let fields = case version {
    [] -> fields
    _ -> [#("version", json.array(version, device_version_to_json)), ..fields]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_number {
    Some(v) -> [#("partNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case model_number {
    Some(v) -> [#("modelNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, device_name_to_json)), ..fields]
  }
  let fields = case serial_number {
    Some(v) -> [#("serialNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacture_date {
    Some(v) -> [#("manufactureDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case biological_source_event {
    Some(v) -> [#("biologicalSourceEvent", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case availability_status {
    Some(v) -> [#("availabilityStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.devicestatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case udi_carrier {
    [] -> fields
    _ -> [
      #("udiCarrier", json.array(udi_carrier, device_udicarrier_to_json)),
      ..fields
    ]
  }
  let fields = case definition {
    Some(v) -> [#("definition", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case display_name {
    Some(v) -> [#("displayName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Device")), ..fields]
  json.object(fields)
}

pub fn device_decoder() -> Decoder(Device) {
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(reference_decoder()),
  )
  use safety <- decode.optional_field(
    "safety",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use gateway <- decode.optional_field(
    "gateway",
    [],
    decode.list(codeablereference_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(duration_decoder()),
  )
  use cycle <- decode.optional_field(
    "cycle",
    None,
    decode.optional(count_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(device_property_decoder()),
  )
  use conforms_to <- decode.optional_field(
    "conformsTo",
    [],
    decode.list(device_conformsto_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(device_version_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use part_number <- decode.optional_field(
    "partNumber",
    None,
    decode.optional(decode.string),
  )
  use model_number <- decode.optional_field(
    "modelNumber",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(device_name_decoder()),
  )
  use serial_number <- decode.optional_field(
    "serialNumber",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use manufacture_date <- decode.optional_field(
    "manufactureDate",
    None,
    decode.optional(decode.string),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(decode.string),
  )
  use biological_source_event <- decode.optional_field(
    "biologicalSourceEvent",
    None,
    decode.optional(identifier_decoder()),
  )
  use availability_status <- decode.optional_field(
    "availabilityStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.devicestatus_decoder()),
  )
  use udi_carrier <- decode.optional_field(
    "udiCarrier",
    [],
    decode.list(device_udicarrier_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use display_name <- decode.optional_field(
    "displayName",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Device",
    decode.failure(device_new(), "resourceType"),
  )
  decode.success(Device(
    parent:,
    safety:,
    note:,
    gateway:,
    endpoint:,
    url:,
    location:,
    contact:,
    owner:,
    duration:,
    cycle:,
    mode:,
    property:,
    conforms_to:,
    version:,
    type_:,
    category:,
    part_number:,
    model_number:,
    name:,
    serial_number:,
    lot_number:,
    expiration_date:,
    manufacture_date:,
    manufacturer:,
    biological_source_event:,
    availability_status:,
    status:,
    udi_carrier:,
    definition:,
    display_name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceAssociation#resource
pub type Deviceassociation {
  Deviceassociation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    device: Reference,
    category: List(Codeableconcept),
    status: Codeableconcept,
    status_reason: List(Codeableconcept),
    subject: Option(Reference),
    body_structure: Option(Reference),
    period: Option(Period),
    operation: List(DeviceassociationOperation),
  )
}

pub fn deviceassociation_new(
  status status: Codeableconcept,
  device device: Reference,
) -> Deviceassociation {
  Deviceassociation(
    operation: [],
    period: None,
    body_structure: None,
    subject: None,
    status_reason: [],
    status:,
    category: [],
    device:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceAssociation#resource
pub type DeviceassociationOperation {
  DeviceassociationOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: Codeableconcept,
    operator: List(Reference),
    period: Option(Period),
  )
}

pub fn deviceassociation_operation_new(
  status status: Codeableconcept,
) -> DeviceassociationOperation {
  DeviceassociationOperation(
    period: None,
    operator: [],
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn deviceassociation_operation_to_json(
  deviceassociation_operation: DeviceassociationOperation,
) -> Json {
  let DeviceassociationOperation(
    period:,
    operator:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = deviceassociation_operation
  let fields = [
    #("status", codeableconcept_to_json(status)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case operator {
    [] -> fields
    _ -> [#("operator", json.array(operator, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn deviceassociation_operation_decoder() -> Decoder(
  DeviceassociationOperation,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use operator <- decode.optional_field(
    "operator",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceassociationOperation(
    period:,
    operator:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn deviceassociation_to_json(deviceassociation: Deviceassociation) -> Json {
  let Deviceassociation(
    operation:,
    period:,
    body_structure:,
    subject:,
    status_reason:,
    status:,
    category:,
    device:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = deviceassociation
  let fields = [
    #("status", codeableconcept_to_json(status)),
    #("device", reference_to_json(device)),
  ]
  let fields = case operation {
    [] -> fields
    _ -> [
      #("operation", json.array(operation, deviceassociation_operation_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_structure {
    Some(v) -> [#("bodyStructure", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Deviceassociation")), ..fields]
  json.object(fields)
}

pub fn deviceassociation_decoder() -> Decoder(Deviceassociation) {
  use operation <- decode.optional_field(
    "operation",
    [],
    decode.list(deviceassociation_operation_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use body_structure <- decode.optional_field(
    "bodyStructure",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use device <- decode.field("device", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Deviceassociation",
    decode.failure(deviceassociation_new(status:, device:), "resourceType"),
  )
  decode.success(Deviceassociation(
    operation:,
    period:,
    body_structure:,
    subject:,
    status_reason:,
    status:,
    category:,
    device:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type Devicedefinition {
  Devicedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    identifier: List(Identifier),
    udi_device_identifier: List(DevicedefinitionUdideviceidentifier),
    regulatory_identifier: List(DevicedefinitionRegulatoryidentifier),
    part_number: Option(String),
    manufacturer: Option(Reference),
    device_name: List(DevicedefinitionDevicename),
    model_number: Option(String),
    classification: List(DevicedefinitionClassification),
    conforms_to: List(DevicedefinitionConformsto),
    has_part: List(DevicedefinitionHaspart),
    packaging: List(DevicedefinitionPackaging),
    version: List(DevicedefinitionVersion),
    safety: List(Codeableconcept),
    shelf_life_storage: List(Productshelflife),
    language_code: List(Codeableconcept),
    property: List(DevicedefinitionProperty),
    owner: Option(Reference),
    contact: List(Contactpoint),
    link: List(DevicedefinitionLink),
    note: List(Annotation),
    material: List(DevicedefinitionMaterial),
    production_identifier_in_udi: List(r5valuesets.Deviceproductidentifierinudi),
    guideline: Option(DevicedefinitionGuideline),
    corrective_action: Option(DevicedefinitionCorrectiveaction),
    charge_item: List(DevicedefinitionChargeitem),
  )
}

pub fn devicedefinition_new() -> Devicedefinition {
  Devicedefinition(
    charge_item: [],
    corrective_action: None,
    guideline: None,
    production_identifier_in_udi: [],
    material: [],
    note: [],
    link: [],
    contact: [],
    owner: None,
    property: [],
    language_code: [],
    shelf_life_storage: [],
    safety: [],
    version: [],
    packaging: [],
    has_part: [],
    conforms_to: [],
    classification: [],
    model_number: None,
    device_name: [],
    manufacturer: None,
    part_number: None,
    regulatory_identifier: [],
    udi_device_identifier: [],
    identifier: [],
    description: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionUdideviceidentifier {
  DevicedefinitionUdideviceidentifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device_identifier: String,
    issuer: String,
    jurisdiction: String,
    market_distribution: List(
      DevicedefinitionUdideviceidentifierMarketdistribution,
    ),
  )
}

pub fn devicedefinition_udideviceidentifier_new(
  jurisdiction jurisdiction: String,
  issuer issuer: String,
  device_identifier device_identifier: String,
) -> DevicedefinitionUdideviceidentifier {
  DevicedefinitionUdideviceidentifier(
    market_distribution: [],
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionUdideviceidentifierMarketdistribution {
  DevicedefinitionUdideviceidentifierMarketdistribution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    market_period: Period,
    sub_jurisdiction: String,
  )
}

pub fn devicedefinition_udideviceidentifier_marketdistribution_new(
  sub_jurisdiction sub_jurisdiction: String,
  market_period market_period: Period,
) -> DevicedefinitionUdideviceidentifierMarketdistribution {
  DevicedefinitionUdideviceidentifierMarketdistribution(
    sub_jurisdiction:,
    market_period:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionRegulatoryidentifier {
  DevicedefinitionRegulatoryidentifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Devicedefinitionregulatoryidentifiertype,
    device_identifier: String,
    issuer: String,
    jurisdiction: String,
  )
}

pub fn devicedefinition_regulatoryidentifier_new(
  jurisdiction jurisdiction: String,
  issuer issuer: String,
  device_identifier device_identifier: String,
  type_ type_: r5valuesets.Devicedefinitionregulatoryidentifiertype,
) -> DevicedefinitionRegulatoryidentifier {
  DevicedefinitionRegulatoryidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionDevicename {
  DevicedefinitionDevicename(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: r5valuesets.Devicenametype,
  )
}

pub fn devicedefinition_devicename_new(
  type_ type_: r5valuesets.Devicenametype,
  name name: String,
) -> DevicedefinitionDevicename {
  DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionClassification {
  DevicedefinitionClassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    justification: List(Relatedartifact),
  )
}

pub fn devicedefinition_classification_new(
  type_ type_: Codeableconcept,
) -> DevicedefinitionClassification {
  DevicedefinitionClassification(
    justification: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionConformsto {
  DevicedefinitionConformsto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    specification: Codeableconcept,
    version: List(String),
    source: List(Relatedartifact),
  )
}

pub fn devicedefinition_conformsto_new(
  specification specification: Codeableconcept,
) -> DevicedefinitionConformsto {
  DevicedefinitionConformsto(
    source: [],
    version: [],
    specification:,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionHaspart {
  DevicedefinitionHaspart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Reference,
    count: Option(Int),
  )
}

pub fn devicedefinition_haspart_new(
  reference reference: Reference,
) -> DevicedefinitionHaspart {
  DevicedefinitionHaspart(
    count: None,
    reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionPackaging {
  DevicedefinitionPackaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    type_: Option(Codeableconcept),
    count: Option(Int),
    distributor: List(DevicedefinitionPackagingDistributor),
  )
}

pub fn devicedefinition_packaging_new() -> DevicedefinitionPackaging {
  DevicedefinitionPackaging(
    distributor: [],
    count: None,
    type_: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionPackagingDistributor {
  DevicedefinitionPackagingDistributor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    organization_reference: List(Reference),
  )
}

pub fn devicedefinition_packaging_distributor_new() -> DevicedefinitionPackagingDistributor {
  DevicedefinitionPackagingDistributor(
    organization_reference: [],
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionVersion {
  DevicedefinitionVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    component: Option(Identifier),
    value: String,
  )
}

pub fn devicedefinition_version_new(
  value value: String,
) -> DevicedefinitionVersion {
  DevicedefinitionVersion(
    value:,
    component: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionProperty {
  DevicedefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: DevicedefinitionPropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionPropertyValue {
  DevicedefinitionPropertyValueQuantity(value: Quantity)
  DevicedefinitionPropertyValueCodeableconcept(value: Codeableconcept)
  DevicedefinitionPropertyValueString(value: String)
  DevicedefinitionPropertyValueBoolean(value: Bool)
  DevicedefinitionPropertyValueInteger(value: Int)
  DevicedefinitionPropertyValueRange(value: Range)
  DevicedefinitionPropertyValueAttachment(value: Attachment)
}

pub fn devicedefinition_property_value_to_json(
  elt: DevicedefinitionPropertyValue,
) -> Json {
  case elt {
    DevicedefinitionPropertyValueQuantity(v) -> quantity_to_json(v)
    DevicedefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    DevicedefinitionPropertyValueString(v) -> json.string(v)
    DevicedefinitionPropertyValueBoolean(v) -> json.bool(v)
    DevicedefinitionPropertyValueInteger(v) -> json.int(v)
    DevicedefinitionPropertyValueRange(v) -> range_to_json(v)
    DevicedefinitionPropertyValueAttachment(v) -> attachment_to_json(v)
  }
}

pub fn devicedefinition_property_value_decoder() -> Decoder(
  DevicedefinitionPropertyValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(DevicedefinitionPropertyValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(DevicedefinitionPropertyValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(DevicedefinitionPropertyValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(DevicedefinitionPropertyValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(DevicedefinitionPropertyValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(DevicedefinitionPropertyValueRange),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(DevicedefinitionPropertyValueAttachment),
    ],
  )
}

pub fn devicedefinition_property_new(
  value value: DevicedefinitionPropertyValue,
  type_ type_: Codeableconcept,
) -> DevicedefinitionProperty {
  DevicedefinitionProperty(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionLink {
  DevicedefinitionLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relation: Coding,
    related_device: Codeablereference,
  )
}

pub fn devicedefinition_link_new(
  related_device related_device: Codeablereference,
  relation relation: Coding,
) -> DevicedefinitionLink {
  DevicedefinitionLink(
    related_device:,
    relation:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionMaterial {
  DevicedefinitionMaterial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Codeableconcept,
    alternate: Option(Bool),
    allergenic_indicator: Option(Bool),
  )
}

pub fn devicedefinition_material_new(
  substance substance: Codeableconcept,
) -> DevicedefinitionMaterial {
  DevicedefinitionMaterial(
    allergenic_indicator: None,
    alternate: None,
    substance:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionGuideline {
  DevicedefinitionGuideline(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    use_context: List(Usagecontext),
    usage_instruction: Option(String),
    related_artifact: List(Relatedartifact),
    indication: List(Codeableconcept),
    contraindication: List(Codeableconcept),
    warning: List(Codeableconcept),
    intended_use: Option(String),
  )
}

pub fn devicedefinition_guideline_new() -> DevicedefinitionGuideline {
  DevicedefinitionGuideline(
    intended_use: None,
    warning: [],
    contraindication: [],
    indication: [],
    related_artifact: [],
    usage_instruction: None,
    use_context: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionCorrectiveaction {
  DevicedefinitionCorrectiveaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    recall: Bool,
    scope: Option(r5valuesets.Devicecorrectiveactionscope),
    period: Period,
  )
}

pub fn devicedefinition_correctiveaction_new(
  period period: Period,
  recall recall: Bool,
) -> DevicedefinitionCorrectiveaction {
  DevicedefinitionCorrectiveaction(
    period:,
    scope: None,
    recall:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDefinition#resource
pub type DevicedefinitionChargeitem {
  DevicedefinitionChargeitem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    charge_item_code: Codeablereference,
    count: Quantity,
    effective_period: Option(Period),
    use_context: List(Usagecontext),
  )
}

pub fn devicedefinition_chargeitem_new(
  count count: Quantity,
  charge_item_code charge_item_code: Codeablereference,
) -> DevicedefinitionChargeitem {
  DevicedefinitionChargeitem(
    use_context: [],
    effective_period: None,
    count:,
    charge_item_code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicedefinition_chargeitem_to_json(
  devicedefinition_chargeitem: DevicedefinitionChargeitem,
) -> Json {
  let DevicedefinitionChargeitem(
    use_context:,
    effective_period:,
    count:,
    charge_item_code:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_chargeitem
  let fields = [
    #("count", quantity_to_json(count)),
    #("chargeItemCode", codeablereference_to_json(charge_item_code)),
  ]
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_chargeitem_decoder() -> Decoder(
  DevicedefinitionChargeitem,
) {
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use count <- decode.field("count", quantity_decoder())
  use charge_item_code <- decode.field(
    "chargeItemCode",
    codeablereference_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionChargeitem(
    use_context:,
    effective_period:,
    count:,
    charge_item_code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_correctiveaction_to_json(
  devicedefinition_correctiveaction: DevicedefinitionCorrectiveaction,
) -> Json {
  let DevicedefinitionCorrectiveaction(
    period:,
    scope:,
    recall:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_correctiveaction
  let fields = [
    #("period", period_to_json(period)),
    #("recall", json.bool(recall)),
  ]
  let fields = case scope {
    Some(v) -> [
      #("scope", r5valuesets.devicecorrectiveactionscope_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_correctiveaction_decoder() -> Decoder(
  DevicedefinitionCorrectiveaction,
) {
  use period <- decode.field("period", period_decoder())
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(r5valuesets.devicecorrectiveactionscope_decoder()),
  )
  use recall <- decode.field("recall", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionCorrectiveaction(
    period:,
    scope:,
    recall:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_guideline_to_json(
  devicedefinition_guideline: DevicedefinitionGuideline,
) -> Json {
  let DevicedefinitionGuideline(
    intended_use:,
    warning:,
    contraindication:,
    indication:,
    related_artifact:,
    usage_instruction:,
    use_context:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_guideline
  let fields = []
  let fields = case intended_use {
    Some(v) -> [#("intendedUse", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case warning {
    [] -> fields
    _ -> [#("warning", json.array(warning, codeableconcept_to_json)), ..fields]
  }
  let fields = case contraindication {
    [] -> fields
    _ -> [
      #(
        "contraindication",
        json.array(contraindication, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case indication {
    [] -> fields
    _ -> [
      #("indication", json.array(indication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case usage_instruction {
    Some(v) -> [#("usageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_guideline_decoder() -> Decoder(
  DevicedefinitionGuideline,
) {
  use intended_use <- decode.optional_field(
    "intendedUse",
    None,
    decode.optional(decode.string),
  )
  use warning <- decode.optional_field(
    "warning",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use contraindication <- decode.optional_field(
    "contraindication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use usage_instruction <- decode.optional_field(
    "usageInstruction",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionGuideline(
    intended_use:,
    warning:,
    contraindication:,
    indication:,
    related_artifact:,
    usage_instruction:,
    use_context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_material_to_json(
  devicedefinition_material: DevicedefinitionMaterial,
) -> Json {
  let DevicedefinitionMaterial(
    allergenic_indicator:,
    alternate:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_material
  let fields = [
    #("substance", codeableconcept_to_json(substance)),
  ]
  let fields = case allergenic_indicator {
    Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case alternate {
    Some(v) -> [#("alternate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_material_decoder() -> Decoder(DevicedefinitionMaterial) {
  use allergenic_indicator <- decode.optional_field(
    "allergenicIndicator",
    None,
    decode.optional(decode.bool),
  )
  use alternate <- decode.optional_field(
    "alternate",
    None,
    decode.optional(decode.bool),
  )
  use substance <- decode.field("substance", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionMaterial(
    allergenic_indicator:,
    alternate:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_link_to_json(
  devicedefinition_link: DevicedefinitionLink,
) -> Json {
  let DevicedefinitionLink(
    related_device:,
    relation:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_link
  let fields = [
    #("relatedDevice", codeablereference_to_json(related_device)),
    #("relation", coding_to_json(relation)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_link_decoder() -> Decoder(DevicedefinitionLink) {
  use related_device <- decode.field(
    "relatedDevice",
    codeablereference_decoder(),
  )
  use relation <- decode.field("relation", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionLink(
    related_device:,
    relation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_property_to_json(
  devicedefinition_property: DevicedefinitionProperty,
) -> Json {
  let DevicedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_property
  let fields = [
    #("value", devicedefinition_property_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_property_decoder() -> Decoder(DevicedefinitionProperty) {
  use value <- decode.then(devicedefinition_property_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_version_to_json(
  devicedefinition_version: DevicedefinitionVersion,
) -> Json {
  let DevicedefinitionVersion(
    value:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_version
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case component {
    Some(v) -> [#("component", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_version_decoder() -> Decoder(DevicedefinitionVersion) {
  use value <- decode.field("value", decode.string)
  use component <- decode.optional_field(
    "component",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionVersion(
    value:,
    component:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_packaging_distributor_to_json(
  devicedefinition_packaging_distributor: DevicedefinitionPackagingDistributor,
) -> Json {
  let DevicedefinitionPackagingDistributor(
    organization_reference:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_packaging_distributor
  let fields = []
  let fields = case organization_reference {
    [] -> fields
    _ -> [
      #(
        "organizationReference",
        json.array(organization_reference, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_packaging_distributor_decoder() -> Decoder(
  DevicedefinitionPackagingDistributor,
) {
  use organization_reference <- decode.optional_field(
    "organizationReference",
    [],
    decode.list(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionPackagingDistributor(
    organization_reference:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_packaging_to_json(
  devicedefinition_packaging: DevicedefinitionPackaging,
) -> Json {
  let DevicedefinitionPackaging(
    distributor:,
    count:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_packaging
  let fields = []
  let fields = case distributor {
    [] -> fields
    _ -> [
      #(
        "distributor",
        json.array(distributor, devicedefinition_packaging_distributor_to_json),
      ),
      ..fields
    ]
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_packaging_decoder() -> Decoder(
  DevicedefinitionPackaging,
) {
  use distributor <- decode.optional_field(
    "distributor",
    [],
    decode.list(devicedefinition_packaging_distributor_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionPackaging(
    distributor:,
    count:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_haspart_to_json(
  devicedefinition_haspart: DevicedefinitionHaspart,
) -> Json {
  let DevicedefinitionHaspart(
    count:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_haspart
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_haspart_decoder() -> Decoder(DevicedefinitionHaspart) {
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use reference <- decode.field("reference", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionHaspart(
    count:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_conformsto_to_json(
  devicedefinition_conformsto: DevicedefinitionConformsto,
) -> Json {
  let DevicedefinitionConformsto(
    source:,
    version:,
    specification:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_conformsto
  let fields = [
    #("specification", codeableconcept_to_json(specification)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, relatedartifact_to_json)), ..fields]
  }
  let fields = case version {
    [] -> fields
    _ -> [#("version", json.array(version, json.string)), ..fields]
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_conformsto_decoder() -> Decoder(
  DevicedefinitionConformsto,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(decode.string),
  )
  use specification <- decode.field("specification", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionConformsto(
    source:,
    version:,
    specification:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_classification_to_json(
  devicedefinition_classification: DevicedefinitionClassification,
) -> Json {
  let DevicedefinitionClassification(
    justification:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_classification
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case justification {
    [] -> fields
    _ -> [
      #("justification", json.array(justification, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_classification_decoder() -> Decoder(
  DevicedefinitionClassification,
) {
  use justification <- decode.optional_field(
    "justification",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionClassification(
    justification:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_devicename_to_json(
  devicedefinition_devicename: DevicedefinitionDevicename,
) -> Json {
  let DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_devicename
  let fields = [
    #("type", r5valuesets.devicenametype_to_json(type_)),
    #("name", json.string(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_devicename_decoder() -> Decoder(
  DevicedefinitionDevicename,
) {
  use type_ <- decode.field("type", r5valuesets.devicenametype_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionDevicename(
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_regulatoryidentifier_to_json(
  devicedefinition_regulatoryidentifier: DevicedefinitionRegulatoryidentifier,
) -> Json {
  let DevicedefinitionRegulatoryidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_regulatoryidentifier
  let fields = [
    #("jurisdiction", json.string(jurisdiction)),
    #("issuer", json.string(issuer)),
    #("deviceIdentifier", json.string(device_identifier)),
    #(
      "type",
      r5valuesets.devicedefinitionregulatoryidentifiertype_to_json(type_),
    ),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_regulatoryidentifier_decoder() -> Decoder(
  DevicedefinitionRegulatoryidentifier,
) {
  use jurisdiction <- decode.field("jurisdiction", decode.string)
  use issuer <- decode.field("issuer", decode.string)
  use device_identifier <- decode.field("deviceIdentifier", decode.string)
  use type_ <- decode.field(
    "type",
    r5valuesets.devicedefinitionregulatoryidentifiertype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionRegulatoryidentifier(
    jurisdiction:,
    issuer:,
    device_identifier:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_udideviceidentifier_marketdistribution_to_json(
  devicedefinition_udideviceidentifier_marketdistribution: DevicedefinitionUdideviceidentifierMarketdistribution,
) -> Json {
  let DevicedefinitionUdideviceidentifierMarketdistribution(
    sub_jurisdiction:,
    market_period:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_udideviceidentifier_marketdistribution
  let fields = [
    #("subJurisdiction", json.string(sub_jurisdiction)),
    #("marketPeriod", period_to_json(market_period)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_udideviceidentifier_marketdistribution_decoder() -> Decoder(
  DevicedefinitionUdideviceidentifierMarketdistribution,
) {
  use sub_jurisdiction <- decode.field("subJurisdiction", decode.string)
  use market_period <- decode.field("marketPeriod", period_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionUdideviceidentifierMarketdistribution(
    sub_jurisdiction:,
    market_period:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_udideviceidentifier_to_json(
  devicedefinition_udideviceidentifier: DevicedefinitionUdideviceidentifier,
) -> Json {
  let DevicedefinitionUdideviceidentifier(
    market_distribution:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedefinition_udideviceidentifier
  let fields = [
    #("jurisdiction", json.string(jurisdiction)),
    #("issuer", json.string(issuer)),
    #("deviceIdentifier", json.string(device_identifier)),
  ]
  let fields = case market_distribution {
    [] -> fields
    _ -> [
      #(
        "marketDistribution",
        json.array(
          market_distribution,
          devicedefinition_udideviceidentifier_marketdistribution_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedefinition_udideviceidentifier_decoder() -> Decoder(
  DevicedefinitionUdideviceidentifier,
) {
  use market_distribution <- decode.optional_field(
    "marketDistribution",
    [],
    decode.list(
      devicedefinition_udideviceidentifier_marketdistribution_decoder(),
    ),
  )
  use jurisdiction <- decode.field("jurisdiction", decode.string)
  use issuer <- decode.field("issuer", decode.string)
  use device_identifier <- decode.field("deviceIdentifier", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedefinitionUdideviceidentifier(
    market_distribution:,
    jurisdiction:,
    issuer:,
    device_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedefinition_to_json(devicedefinition: Devicedefinition) -> Json {
  let Devicedefinition(
    charge_item:,
    corrective_action:,
    guideline:,
    production_identifier_in_udi:,
    material:,
    note:,
    link:,
    contact:,
    owner:,
    property:,
    language_code:,
    shelf_life_storage:,
    safety:,
    version:,
    packaging:,
    has_part:,
    conforms_to:,
    classification:,
    model_number:,
    device_name:,
    manufacturer:,
    part_number:,
    regulatory_identifier:,
    udi_device_identifier:,
    identifier:,
    description:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicedefinition
  let fields = []
  let fields = case charge_item {
    [] -> fields
    _ -> [
      #(
        "chargeItem",
        json.array(charge_item, devicedefinition_chargeitem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case corrective_action {
    Some(v) -> [
      #("correctiveAction", devicedefinition_correctiveaction_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case guideline {
    Some(v) -> [#("guideline", devicedefinition_guideline_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case production_identifier_in_udi {
    [] -> fields
    _ -> [
      #(
        "productionIdentifierInUDI",
        json.array(
          production_identifier_in_udi,
          r5valuesets.deviceproductidentifierinudi_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case material {
    [] -> fields
    _ -> [
      #("material", json.array(material, devicedefinition_material_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, devicedefinition_link_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, devicedefinition_property_to_json)),
      ..fields
    ]
  }
  let fields = case language_code {
    [] -> fields
    _ -> [
      #("languageCode", json.array(language_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case shelf_life_storage {
    [] -> fields
    _ -> [
      #(
        "shelfLifeStorage",
        json.array(shelf_life_storage, productshelflife_to_json),
      ),
      ..fields
    ]
  }
  let fields = case safety {
    [] -> fields
    _ -> [#("safety", json.array(safety, codeableconcept_to_json)), ..fields]
  }
  let fields = case version {
    [] -> fields
    _ -> [
      #("version", json.array(version, devicedefinition_version_to_json)),
      ..fields
    ]
  }
  let fields = case packaging {
    [] -> fields
    _ -> [
      #("packaging", json.array(packaging, devicedefinition_packaging_to_json)),
      ..fields
    ]
  }
  let fields = case has_part {
    [] -> fields
    _ -> [
      #("hasPart", json.array(has_part, devicedefinition_haspart_to_json)),
      ..fields
    ]
  }
  let fields = case conforms_to {
    [] -> fields
    _ -> [
      #(
        "conformsTo",
        json.array(conforms_to, devicedefinition_conformsto_to_json),
      ),
      ..fields
    ]
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #(
        "classification",
        json.array(classification, devicedefinition_classification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case model_number {
    Some(v) -> [#("modelNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device_name {
    [] -> fields
    _ -> [
      #(
        "deviceName",
        json.array(device_name, devicedefinition_devicename_to_json),
      ),
      ..fields
    ]
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_number {
    Some(v) -> [#("partNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case regulatory_identifier {
    [] -> fields
    _ -> [
      #(
        "regulatoryIdentifier",
        json.array(
          regulatory_identifier,
          devicedefinition_regulatoryidentifier_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case udi_device_identifier {
    [] -> fields
    _ -> [
      #(
        "udiDeviceIdentifier",
        json.array(
          udi_device_identifier,
          devicedefinition_udideviceidentifier_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicedefinition")), ..fields]
  json.object(fields)
}

pub fn devicedefinition_decoder() -> Decoder(Devicedefinition) {
  use charge_item <- decode.optional_field(
    "chargeItem",
    [],
    decode.list(devicedefinition_chargeitem_decoder()),
  )
  use corrective_action <- decode.optional_field(
    "correctiveAction",
    None,
    decode.optional(devicedefinition_correctiveaction_decoder()),
  )
  use guideline <- decode.optional_field(
    "guideline",
    None,
    decode.optional(devicedefinition_guideline_decoder()),
  )
  use production_identifier_in_udi <- decode.optional_field(
    "productionIdentifierInUDI",
    [],
    decode.list(r5valuesets.deviceproductidentifierinudi_decoder()),
  )
  use material <- decode.optional_field(
    "material",
    [],
    decode.list(devicedefinition_material_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(devicedefinition_link_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(devicedefinition_property_decoder()),
  )
  use language_code <- decode.optional_field(
    "languageCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use shelf_life_storage <- decode.optional_field(
    "shelfLifeStorage",
    [],
    decode.list(productshelflife_decoder()),
  )
  use safety <- decode.optional_field(
    "safety",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(devicedefinition_version_decoder()),
  )
  use packaging <- decode.optional_field(
    "packaging",
    [],
    decode.list(devicedefinition_packaging_decoder()),
  )
  use has_part <- decode.optional_field(
    "hasPart",
    [],
    decode.list(devicedefinition_haspart_decoder()),
  )
  use conforms_to <- decode.optional_field(
    "conformsTo",
    [],
    decode.list(devicedefinition_conformsto_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(devicedefinition_classification_decoder()),
  )
  use model_number <- decode.optional_field(
    "modelNumber",
    None,
    decode.optional(decode.string),
  )
  use device_name <- decode.optional_field(
    "deviceName",
    [],
    decode.list(devicedefinition_devicename_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(reference_decoder()),
  )
  use part_number <- decode.optional_field(
    "partNumber",
    None,
    decode.optional(decode.string),
  )
  use regulatory_identifier <- decode.optional_field(
    "regulatoryIdentifier",
    [],
    decode.list(devicedefinition_regulatoryidentifier_decoder()),
  )
  use udi_device_identifier <- decode.optional_field(
    "udiDeviceIdentifier",
    [],
    decode.list(devicedefinition_udideviceidentifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicedefinition",
    decode.failure(devicedefinition_new(), "resourceType"),
  )
  decode.success(Devicedefinition(
    charge_item:,
    corrective_action:,
    guideline:,
    production_identifier_in_udi:,
    material:,
    note:,
    link:,
    contact:,
    owner:,
    property:,
    language_code:,
    shelf_life_storage:,
    safety:,
    version:,
    packaging:,
    has_part:,
    conforms_to:,
    classification:,
    model_number:,
    device_name:,
    manufacturer:,
    part_number:,
    regulatory_identifier:,
    udi_device_identifier:,
    identifier:,
    description:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDispense#resource
pub type Devicedispense {
  Devicedispense(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Devicedispensestatus,
    status_reason: Option(Codeablereference),
    category: List(Codeableconcept),
    device: Codeablereference,
    subject: Reference,
    receiver: Option(Reference),
    encounter: Option(Reference),
    supporting_information: List(Reference),
    performer: List(DevicedispensePerformer),
    location: Option(Reference),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
    prepared_date: Option(String),
    when_handed_over: Option(String),
    destination: Option(Reference),
    note: List(Annotation),
    usage_instruction: Option(String),
    event_history: List(Reference),
  )
}

pub fn devicedispense_new(
  subject subject: Reference,
  device device: Codeablereference,
  status status: r5valuesets.Devicedispensestatus,
) -> Devicedispense {
  Devicedispense(
    event_history: [],
    usage_instruction: None,
    note: [],
    destination: None,
    when_handed_over: None,
    prepared_date: None,
    quantity: None,
    type_: None,
    location: None,
    performer: [],
    supporting_information: [],
    encounter: None,
    receiver: None,
    subject:,
    device:,
    category: [],
    status_reason: None,
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceDispense#resource
pub type DevicedispensePerformer {
  DevicedispensePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn devicedispense_performer_new(
  actor actor: Reference,
) -> DevicedispensePerformer {
  DevicedispensePerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicedispense_performer_to_json(
  devicedispense_performer: DevicedispensePerformer,
) -> Json {
  let DevicedispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicedispense_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicedispense_performer_decoder() -> Decoder(DevicedispensePerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicedispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicedispense_to_json(devicedispense: Devicedispense) -> Json {
  let Devicedispense(
    event_history:,
    usage_instruction:,
    note:,
    destination:,
    when_handed_over:,
    prepared_date:,
    quantity:,
    type_:,
    location:,
    performer:,
    supporting_information:,
    encounter:,
    receiver:,
    subject:,
    device:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicedispense
  let fields = [
    #("subject", reference_to_json(subject)),
    #("device", codeablereference_to_json(device)),
    #("status", r5valuesets.devicedispensestatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case usage_instruction {
    Some(v) -> [#("usageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case when_handed_over {
    Some(v) -> [#("whenHandedOver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prepared_date {
    Some(v) -> [#("preparedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, devicedispense_performer_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case receiver {
    Some(v) -> [#("receiver", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicedispense")), ..fields]
  json.object(fields)
}

pub fn devicedispense_decoder() -> Decoder(Devicedispense) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use usage_instruction <- decode.optional_field(
    "usageInstruction",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use when_handed_over <- decode.optional_field(
    "whenHandedOver",
    None,
    decode.optional(decode.string),
  )
  use prepared_date <- decode.optional_field(
    "preparedDate",
    None,
    decode.optional(decode.string),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(devicedispense_performer_decoder()),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use receiver <- decode.optional_field(
    "receiver",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use device <- decode.field("device", codeablereference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.devicedispensestatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicedispense",
    decode.failure(
      devicedispense_new(subject:, device:, status:),
      "resourceType",
    ),
  )
  decode.success(Devicedispense(
    event_history:,
    usage_instruction:,
    note:,
    destination:,
    when_handed_over:,
    prepared_date:,
    quantity:,
    type_:,
    location:,
    performer:,
    supporting_information:,
    encounter:,
    receiver:,
    subject:,
    device:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceMetric#resource
pub type Devicemetric {
  Devicemetric(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Codeableconcept,
    unit: Option(Codeableconcept),
    device: Reference,
    operational_status: Option(r5valuesets.Metricoperationalstatus),
    color: Option(r5valuesets.Colorcodes),
    category: r5valuesets.Metriccategory,
    measurement_frequency: Option(Quantity),
    calibration: List(DevicemetricCalibration),
  )
}

pub fn devicemetric_new(
  category category: r5valuesets.Metriccategory,
  device device: Reference,
  type_ type_: Codeableconcept,
) -> Devicemetric {
  Devicemetric(
    calibration: [],
    measurement_frequency: None,
    category:,
    color: None,
    operational_status: None,
    device:,
    unit: None,
    type_:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceMetric#resource
pub type DevicemetricCalibration {
  DevicemetricCalibration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Metriccalibrationtype),
    state: Option(r5valuesets.Metriccalibrationstate),
    time: Option(String),
  )
}

pub fn devicemetric_calibration_new() -> DevicemetricCalibration {
  DevicemetricCalibration(
    time: None,
    state: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicemetric_calibration_to_json(
  devicemetric_calibration: DevicemetricCalibration,
) -> Json {
  let DevicemetricCalibration(
    time:,
    state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicemetric_calibration
  let fields = []
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case state {
    Some(v) -> [
      #("state", r5valuesets.metriccalibrationstate_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.metriccalibrationtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicemetric_calibration_decoder() -> Decoder(DevicemetricCalibration) {
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use state <- decode.optional_field(
    "state",
    None,
    decode.optional(r5valuesets.metriccalibrationstate_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.metriccalibrationtype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicemetricCalibration(
    time:,
    state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicemetric_to_json(devicemetric: Devicemetric) -> Json {
  let Devicemetric(
    calibration:,
    measurement_frequency:,
    category:,
    color:,
    operational_status:,
    device:,
    unit:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicemetric
  let fields = [
    #("category", r5valuesets.metriccategory_to_json(category)),
    #("device", reference_to_json(device)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case calibration {
    [] -> fields
    _ -> [
      #(
        "calibration",
        json.array(calibration, devicemetric_calibration_to_json),
      ),
      ..fields
    ]
  }
  let fields = case measurement_frequency {
    Some(v) -> [#("measurementFrequency", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case color {
    Some(v) -> [#("color", r5valuesets.colorcodes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case operational_status {
    Some(v) -> [
      #("operationalStatus", r5valuesets.metricoperationalstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicemetric")), ..fields]
  json.object(fields)
}

pub fn devicemetric_decoder() -> Decoder(Devicemetric) {
  use calibration <- decode.optional_field(
    "calibration",
    [],
    decode.list(devicemetric_calibration_decoder()),
  )
  use measurement_frequency <- decode.optional_field(
    "measurementFrequency",
    None,
    decode.optional(quantity_decoder()),
  )
  use category <- decode.field("category", r5valuesets.metriccategory_decoder())
  use color <- decode.optional_field(
    "color",
    None,
    decode.optional(r5valuesets.colorcodes_decoder()),
  )
  use operational_status <- decode.optional_field(
    "operationalStatus",
    None,
    decode.optional(r5valuesets.metricoperationalstatus_decoder()),
  )
  use device <- decode.field("device", reference_decoder())
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicemetric",
    decode.failure(devicemetric_new(category:, device:, type_:), "resourceType"),
  )
  decode.success(Devicemetric(
    calibration:,
    measurement_frequency:,
    category:,
    color:,
    operational_status:,
    device:,
    unit:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceRequest#resource
pub type Devicerequest {
  Devicerequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    group_identifier: Option(Identifier),
    status: Option(r5valuesets.Requeststatus),
    intent: r5valuesets.Requestintent,
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    code: Codeablereference,
    quantity: Option(Int),
    parameter: List(DevicerequestParameter),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(DevicerequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    performer: Option(Codeablereference),
    reason: List(Codeablereference),
    as_needed: Option(Bool),
    as_needed_for: Option(Codeableconcept),
    insurance: List(Reference),
    supporting_info: List(Reference),
    note: List(Annotation),
    relevant_history: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceRequest#resource
pub type DevicerequestOccurrence {
  DevicerequestOccurrenceDatetime(occurrence: String)
  DevicerequestOccurrencePeriod(occurrence: Period)
  DevicerequestOccurrenceTiming(occurrence: Timing)
}

pub fn devicerequest_occurrence_to_json(elt: DevicerequestOccurrence) -> Json {
  case elt {
    DevicerequestOccurrenceDatetime(v) -> json.string(v)
    DevicerequestOccurrencePeriod(v) -> period_to_json(v)
    DevicerequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn devicerequest_occurrence_decoder() -> Decoder(DevicerequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(DevicerequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(DevicerequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(DevicerequestOccurrenceTiming),
    ],
  )
}

pub fn devicerequest_new(
  subject subject: Reference,
  code code: Codeablereference,
  intent intent: r5valuesets.Requestintent,
) -> Devicerequest {
  Devicerequest(
    relevant_history: [],
    note: [],
    supporting_info: [],
    insurance: [],
    as_needed_for: None,
    as_needed: None,
    reason: [],
    performer: None,
    requester: None,
    authored_on: None,
    occurrence: None,
    encounter: None,
    subject:,
    parameter: [],
    quantity: None,
    code:,
    do_not_perform: None,
    priority: None,
    intent:,
    status: None,
    group_identifier: None,
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameter {
  DevicerequestParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    value: Option(DevicerequestParameterValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceRequest#resource
pub type DevicerequestParameterValue {
  DevicerequestParameterValueCodeableconcept(value: Codeableconcept)
  DevicerequestParameterValueQuantity(value: Quantity)
  DevicerequestParameterValueRange(value: Range)
  DevicerequestParameterValueBoolean(value: Bool)
}

pub fn devicerequest_parameter_value_to_json(
  elt: DevicerequestParameterValue,
) -> Json {
  case elt {
    DevicerequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    DevicerequestParameterValueQuantity(v) -> quantity_to_json(v)
    DevicerequestParameterValueRange(v) -> range_to_json(v)
    DevicerequestParameterValueBoolean(v) -> json.bool(v)
  }
}

pub fn devicerequest_parameter_value_decoder() -> Decoder(
  DevicerequestParameterValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(DevicerequestParameterValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(DevicerequestParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(DevicerequestParameterValueRange),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(DevicerequestParameterValueBoolean),
    ],
  )
}

pub fn devicerequest_parameter_new() -> DevicerequestParameter {
  DevicerequestParameter(
    value: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn devicerequest_parameter_to_json(
  devicerequest_parameter: DevicerequestParameter,
) -> Json {
  let DevicerequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = devicerequest_parameter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          DevicerequestParameterValueCodeableconcept(_) -> "Codeableconcept"
          DevicerequestParameterValueQuantity(_) -> "Quantity"
          DevicerequestParameterValueRange(_) -> "Range"
          DevicerequestParameterValueBoolean(_) -> "Boolean"
        },
        devicerequest_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn devicerequest_parameter_decoder() -> Decoder(DevicerequestParameter) {
  use value <- decode.then(
    none_if_omitted(devicerequest_parameter_value_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DevicerequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn devicerequest_to_json(devicerequest: Devicerequest) -> Json {
  let Devicerequest(
    relevant_history:,
    note:,
    supporting_info:,
    insurance:,
    as_needed_for:,
    as_needed:,
    reason:,
    performer:,
    requester:,
    authored_on:,
    occurrence:,
    encounter:,
    subject:,
    parameter:,
    quantity:,
    code:,
    do_not_perform:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = devicerequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", codeablereference_to_json(code)),
    #("intent", r5valuesets.requestintent_to_json(intent)),
  ]
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case as_needed_for {
    Some(v) -> [#("asNeededFor", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [#("asNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case performer {
    Some(v) -> [#("performer", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          DevicerequestOccurrenceDatetime(_) -> "Datetime"
          DevicerequestOccurrencePeriod(_) -> "Period"
          DevicerequestOccurrenceTiming(_) -> "Timing"
        },
        devicerequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, devicerequest_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.requeststatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Devicerequest")), ..fields]
  json.object(fields)
}

pub fn devicerequest_decoder() -> Decoder(Devicerequest) {
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use as_needed_for <- decode.optional_field(
    "asNeededFor",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed <- decode.optional_field(
    "asNeeded",
    None,
    decode.optional(decode.bool),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(devicerequest_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(devicerequest_parameter_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use code <- decode.field("code", codeablereference_decoder())
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.requestintent_decoder())
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.requeststatus_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Devicerequest",
    decode.failure(devicerequest_new(subject:, code:, intent:), "resourceType"),
  )
  decode.success(Devicerequest(
    relevant_history:,
    note:,
    supporting_info:,
    insurance:,
    as_needed_for:,
    as_needed:,
    reason:,
    performer:,
    requester:,
    authored_on:,
    occurrence:,
    encounter:,
    subject:,
    parameter:,
    quantity:,
    code:,
    do_not_perform:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceUsage#resource
pub type Deviceusage {
  Deviceusage(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    status: r5valuesets.Deviceusagestatus,
    category: List(Codeableconcept),
    patient: Reference,
    derived_from: List(Reference),
    context: Option(Reference),
    timing: Option(DeviceusageTiming),
    date_asserted: Option(String),
    usage_status: Option(Codeableconcept),
    usage_reason: List(Codeableconcept),
    adherence: Option(DeviceusageAdherence),
    information_source: Option(Reference),
    device: Codeablereference,
    reason: List(Codeablereference),
    body_site: Option(Codeablereference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceUsage#resource
pub type DeviceusageTiming {
  DeviceusageTimingTiming(timing: Timing)
  DeviceusageTimingPeriod(timing: Period)
  DeviceusageTimingDatetime(timing: String)
}

pub fn deviceusage_timing_to_json(elt: DeviceusageTiming) -> Json {
  case elt {
    DeviceusageTimingTiming(v) -> timing_to_json(v)
    DeviceusageTimingPeriod(v) -> period_to_json(v)
    DeviceusageTimingDatetime(v) -> json.string(v)
  }
}

pub fn deviceusage_timing_decoder() -> Decoder(DeviceusageTiming) {
  decode.one_of(
    decode.field("timingTiming", timing_decoder(), decode.success)
      |> decode.map(DeviceusageTimingTiming),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(DeviceusageTimingPeriod),
      decode.field("timingDateTime", decode.string, decode.success)
        |> decode.map(DeviceusageTimingDatetime),
    ],
  )
}

pub fn deviceusage_new(
  device device: Codeablereference,
  patient patient: Reference,
  status status: r5valuesets.Deviceusagestatus,
) -> Deviceusage {
  Deviceusage(
    note: [],
    body_site: None,
    reason: [],
    device:,
    information_source: None,
    adherence: None,
    usage_reason: [],
    usage_status: None,
    date_asserted: None,
    timing: None,
    context: None,
    derived_from: [],
    patient:,
    category: [],
    status:,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DeviceUsage#resource
pub type DeviceusageAdherence {
  DeviceusageAdherence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    reason: List(Codeableconcept),
  )
}

pub fn deviceusage_adherence_new(
  code code: Codeableconcept,
) -> DeviceusageAdherence {
  DeviceusageAdherence(
    reason: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn deviceusage_adherence_to_json(
  deviceusage_adherence: DeviceusageAdherence,
) -> Json {
  let DeviceusageAdherence(reason:, code:, modifier_extension:, extension:, id:) =
    deviceusage_adherence
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn deviceusage_adherence_decoder() -> Decoder(DeviceusageAdherence) {
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DeviceusageAdherence(
    reason:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn deviceusage_to_json(deviceusage: Deviceusage) -> Json {
  let Deviceusage(
    note:,
    body_site:,
    reason:,
    device:,
    information_source:,
    adherence:,
    usage_reason:,
    usage_status:,
    date_asserted:,
    timing:,
    context:,
    derived_from:,
    patient:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = deviceusage
  let fields = [
    #("device", codeablereference_to_json(device)),
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.deviceusagestatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case information_source {
    Some(v) -> [#("informationSource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case adherence {
    Some(v) -> [#("adherence", deviceusage_adherence_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case usage_reason {
    [] -> fields
    _ -> [
      #("usageReason", json.array(usage_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case usage_status {
    Some(v) -> [#("usageStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date_asserted {
    Some(v) -> [#("dateAsserted", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          DeviceusageTimingTiming(_) -> "Timing"
          DeviceusageTimingPeriod(_) -> "Period"
          DeviceusageTimingDatetime(_) -> "Datetime"
        },
        deviceusage_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case context {
    Some(v) -> [#("context", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Deviceusage")), ..fields]
  json.object(fields)
}

pub fn deviceusage_decoder() -> Decoder(Deviceusage) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use device <- decode.field("device", codeablereference_decoder())
  use information_source <- decode.optional_field(
    "informationSource",
    None,
    decode.optional(reference_decoder()),
  )
  use adherence <- decode.optional_field(
    "adherence",
    None,
    decode.optional(deviceusage_adherence_decoder()),
  )
  use usage_reason <- decode.optional_field(
    "usageReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use usage_status <- decode.optional_field(
    "usageStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use date_asserted <- decode.optional_field(
    "dateAsserted",
    None,
    decode.optional(decode.string),
  )
  use timing <- decode.then(none_if_omitted(deviceusage_timing_decoder()))
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(reference_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.deviceusagestatus_decoder())
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Deviceusage",
    decode.failure(deviceusage_new(device:, patient:, status:), "resourceType"),
  )
  decode.success(Deviceusage(
    note:,
    body_site:,
    reason:,
    device:,
    information_source:,
    adherence:,
    usage_reason:,
    usage_status:,
    date_asserted:,
    timing:,
    context:,
    derived_from:,
    patient:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DiagnosticReport#resource
pub type Diagnosticreport {
  Diagnosticreport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    status: r5valuesets.Diagnosticreportstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Option(Reference),
    encounter: Option(Reference),
    effective: Option(DiagnosticreportEffective),
    issued: Option(String),
    performer: List(Reference),
    results_interpreter: List(Reference),
    specimen: List(Reference),
    result: List(Reference),
    note: List(Annotation),
    study: List(Reference),
    supporting_info: List(DiagnosticreportSupportinginfo),
    media: List(DiagnosticreportMedia),
    composition: Option(Reference),
    conclusion: Option(String),
    conclusion_code: List(Codeableconcept),
    presented_form: List(Attachment),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportEffective {
  DiagnosticreportEffectiveDatetime(effective: String)
  DiagnosticreportEffectivePeriod(effective: Period)
}

pub fn diagnosticreport_effective_to_json(
  elt: DiagnosticreportEffective,
) -> Json {
  case elt {
    DiagnosticreportEffectiveDatetime(v) -> json.string(v)
    DiagnosticreportEffectivePeriod(v) -> period_to_json(v)
  }
}

pub fn diagnosticreport_effective_decoder() -> Decoder(
  DiagnosticreportEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(DiagnosticreportEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
      |> decode.map(DiagnosticreportEffectivePeriod),
    ],
  )
}

pub fn diagnosticreport_new(
  code code: Codeableconcept,
  status status: r5valuesets.Diagnosticreportstatus,
) -> Diagnosticreport {
  Diagnosticreport(
    presented_form: [],
    conclusion_code: [],
    conclusion: None,
    composition: None,
    media: [],
    supporting_info: [],
    study: [],
    note: [],
    result: [],
    specimen: [],
    results_interpreter: [],
    performer: [],
    issued: None,
    effective: None,
    encounter: None,
    subject: None,
    code:,
    category: [],
    status:,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportSupportinginfo {
  DiagnosticreportSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    reference: Reference,
  )
}

pub fn diagnosticreport_supportinginfo_new(
  reference reference: Reference,
  type_ type_: Codeableconcept,
) -> DiagnosticreportSupportinginfo {
  DiagnosticreportSupportinginfo(
    reference:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DiagnosticReport#resource
pub type DiagnosticreportMedia {
  DiagnosticreportMedia(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    comment: Option(String),
    link: Reference,
  )
}

pub fn diagnosticreport_media_new(link link: Reference) -> DiagnosticreportMedia {
  DiagnosticreportMedia(
    link:,
    comment: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn diagnosticreport_media_to_json(
  diagnosticreport_media: DiagnosticreportMedia,
) -> Json {
  let DiagnosticreportMedia(
    link:,
    comment:,
    modifier_extension:,
    extension:,
    id:,
  ) = diagnosticreport_media
  let fields = [
    #("link", reference_to_json(link)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn diagnosticreport_media_decoder() -> Decoder(DiagnosticreportMedia) {
  use link <- decode.field("link", reference_decoder())
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DiagnosticreportMedia(
    link:,
    comment:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn diagnosticreport_supportinginfo_to_json(
  diagnosticreport_supportinginfo: DiagnosticreportSupportinginfo,
) -> Json {
  let DiagnosticreportSupportinginfo(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = diagnosticreport_supportinginfo
  let fields = [
    #("reference", reference_to_json(reference)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn diagnosticreport_supportinginfo_decoder() -> Decoder(
  DiagnosticreportSupportinginfo,
) {
  use reference <- decode.field("reference", reference_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DiagnosticreportSupportinginfo(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn diagnosticreport_to_json(diagnosticreport: Diagnosticreport) -> Json {
  let Diagnosticreport(
    presented_form:,
    conclusion_code:,
    conclusion:,
    composition:,
    media:,
    supporting_info:,
    study:,
    note:,
    result:,
    specimen:,
    results_interpreter:,
    performer:,
    issued:,
    effective:,
    encounter:,
    subject:,
    code:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = diagnosticreport
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.diagnosticreportstatus_to_json(status)),
  ]
  let fields = case presented_form {
    [] -> fields
    _ -> [
      #("presentedForm", json.array(presented_form, attachment_to_json)),
      ..fields
    ]
  }
  let fields = case conclusion_code {
    [] -> fields
    _ -> [
      #("conclusionCode", json.array(conclusion_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case conclusion {
    Some(v) -> [#("conclusion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case composition {
    Some(v) -> [#("composition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case media {
    [] -> fields
    _ -> [
      #("media", json.array(media, diagnosticreport_media_to_json)),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, diagnosticreport_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case study {
    [] -> fields
    _ -> [#("study", json.array(study, reference_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case result {
    [] -> fields
    _ -> [#("result", json.array(result, reference_to_json)), ..fields]
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case results_interpreter {
    [] -> fields
    _ -> [
      #(
        "resultsInterpreter",
        json.array(results_interpreter, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          DiagnosticreportEffectiveDatetime(_) -> "Datetime"
          DiagnosticreportEffectivePeriod(_) -> "Period"
        },
        diagnosticreport_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Diagnosticreport")), ..fields]
  json.object(fields)
}

pub fn diagnosticreport_decoder() -> Decoder(Diagnosticreport) {
  use presented_form <- decode.optional_field(
    "presentedForm",
    [],
    decode.list(attachment_decoder()),
  )
  use conclusion_code <- decode.optional_field(
    "conclusionCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use conclusion <- decode.optional_field(
    "conclusion",
    None,
    decode.optional(decode.string),
  )
  use composition <- decode.optional_field(
    "composition",
    None,
    decode.optional(reference_decoder()),
  )
  use media <- decode.optional_field(
    "media",
    [],
    decode.list(diagnosticreport_media_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(diagnosticreport_supportinginfo_decoder()),
  )
  use study <- decode.optional_field(
    "study",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use result <- decode.optional_field(
    "result",
    [],
    decode.list(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use results_interpreter <- decode.optional_field(
    "resultsInterpreter",
    [],
    decode.list(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(diagnosticreport_effective_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.diagnosticreportstatus_decoder(),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Diagnosticreport",
    decode.failure(diagnosticreport_new(code:, status:), "resourceType"),
  )
  decode.success(Diagnosticreport(
    presented_form:,
    conclusion_code:,
    conclusion:,
    composition:,
    media:,
    supporting_info:,
    study:,
    note:,
    result:,
    specimen:,
    results_interpreter:,
    performer:,
    issued:,
    effective:,
    encounter:,
    subject:,
    code:,
    category:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type Documentreference {
  Documentreference(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    version: Option(String),
    based_on: List(Reference),
    status: r5valuesets.Documentreferencestatus,
    doc_status: Option(r5valuesets.Compositionstatus),
    modality: List(Codeableconcept),
    type_: Option(Codeableconcept),
    category: List(Codeableconcept),
    subject: Option(Reference),
    context: List(Reference),
    event: List(Codeablereference),
    body_site: List(Codeablereference),
    facility_type: Option(Codeableconcept),
    practice_setting: Option(Codeableconcept),
    period: Option(Period),
    date: Option(String),
    author: List(Reference),
    attester: List(DocumentreferenceAttester),
    custodian: Option(Reference),
    relates_to: List(DocumentreferenceRelatesto),
    description: Option(String),
    security_label: List(Codeableconcept),
    content: List(DocumentreferenceContent),
  )
}

pub fn documentreference_new(
  status status: r5valuesets.Documentreferencestatus,
) -> Documentreference {
  Documentreference(
    content: [],
    security_label: [],
    description: None,
    relates_to: [],
    custodian: None,
    attester: [],
    author: [],
    date: None,
    period: None,
    practice_setting: None,
    facility_type: None,
    body_site: [],
    event: [],
    context: [],
    subject: None,
    category: [],
    type_: None,
    modality: [],
    doc_status: None,
    status:,
    based_on: [],
    version: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceAttester {
  DocumentreferenceAttester(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    mode: Codeableconcept,
    time: Option(String),
    party: Option(Reference),
  )
}

pub fn documentreference_attester_new(
  mode mode: Codeableconcept,
) -> DocumentreferenceAttester {
  DocumentreferenceAttester(
    party: None,
    time: None,
    mode:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceRelatesto {
  DocumentreferenceRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    target: Reference,
  )
}

pub fn documentreference_relatesto_new(
  target target: Reference,
  code code: Codeableconcept,
) -> DocumentreferenceRelatesto {
  DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContent {
  DocumentreferenceContent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    attachment: Attachment,
    profile: List(DocumentreferenceContentProfile),
  )
}

pub fn documentreference_content_new(
  attachment attachment: Attachment,
) -> DocumentreferenceContent {
  DocumentreferenceContent(
    profile: [],
    attachment:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContentProfile {
  DocumentreferenceContentProfile(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: DocumentreferenceContentProfileValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/DocumentReference#resource
pub type DocumentreferenceContentProfileValue {
  DocumentreferenceContentProfileValueCoding(value: Coding)
  DocumentreferenceContentProfileValueUri(value: String)
  DocumentreferenceContentProfileValueCanonical(value: String)
}

pub fn documentreference_content_profile_value_to_json(
  elt: DocumentreferenceContentProfileValue,
) -> Json {
  case elt {
    DocumentreferenceContentProfileValueCoding(v) -> coding_to_json(v)
    DocumentreferenceContentProfileValueUri(v) -> json.string(v)
    DocumentreferenceContentProfileValueCanonical(v) -> json.string(v)
  }
}

pub fn documentreference_content_profile_value_decoder() -> Decoder(
  DocumentreferenceContentProfileValue,
) {
  decode.one_of(
    decode.field("valueCoding", coding_decoder(), decode.success)
      |> decode.map(DocumentreferenceContentProfileValueCoding),
    [
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(DocumentreferenceContentProfileValueUri),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(DocumentreferenceContentProfileValueCanonical),
    ],
  )
}

pub fn documentreference_content_profile_new(
  value value: DocumentreferenceContentProfileValue,
) -> DocumentreferenceContentProfile {
  DocumentreferenceContentProfile(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn documentreference_content_profile_to_json(
  documentreference_content_profile: DocumentreferenceContentProfile,
) -> Json {
  let DocumentreferenceContentProfile(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_content_profile
  let fields = [
    #("value", documentreference_content_profile_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_content_profile_decoder() -> Decoder(
  DocumentreferenceContentProfile,
) {
  use value <- decode.then(documentreference_content_profile_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceContentProfile(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_content_to_json(
  documentreference_content: DocumentreferenceContent,
) -> Json {
  let DocumentreferenceContent(
    profile:,
    attachment:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_content
  let fields = [
    #("attachment", attachment_to_json(attachment)),
  ]
  let fields = case profile {
    [] -> fields
    _ -> [
      #(
        "profile",
        json.array(profile, documentreference_content_profile_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_content_decoder() -> Decoder(DocumentreferenceContent) {
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(documentreference_content_profile_decoder()),
  )
  use attachment <- decode.field("attachment", attachment_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceContent(
    profile:,
    attachment:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_relatesto_to_json(
  documentreference_relatesto: DocumentreferenceRelatesto,
) -> Json {
  let DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_relatesto
  let fields = [
    #("target", reference_to_json(target)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_relatesto_decoder() -> Decoder(
  DocumentreferenceRelatesto,
) {
  use target <- decode.field("target", reference_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_attester_to_json(
  documentreference_attester: DocumentreferenceAttester,
) -> Json {
  let DocumentreferenceAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ) = documentreference_attester
  let fields = [
    #("mode", codeableconcept_to_json(mode)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case time {
    Some(v) -> [#("time", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn documentreference_attester_decoder() -> Decoder(
  DocumentreferenceAttester,
) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use time <- decode.optional_field(
    "time",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(DocumentreferenceAttester(
    party:,
    time:,
    mode:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn documentreference_to_json(documentreference: Documentreference) -> Json {
  let Documentreference(
    content:,
    security_label:,
    description:,
    relates_to:,
    custodian:,
    attester:,
    author:,
    date:,
    period:,
    practice_setting:,
    facility_type:,
    body_site:,
    event:,
    context:,
    subject:,
    category:,
    type_:,
    modality:,
    doc_status:,
    status:,
    based_on:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = documentreference
  let fields = [
    #("status", r5valuesets.documentreferencestatus_to_json(status)),
  ]
  let fields = case content {
    [] -> fields
    _ -> [
      #("content", json.array(content, documentreference_content_to_json)),
      ..fields
    ]
  }
  let fields = case security_label {
    [] -> fields
    _ -> [
      #("securityLabel", json.array(security_label, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #(
        "relatesTo",
        json.array(relates_to, documentreference_relatesto_to_json),
      ),
      ..fields
    ]
  }
  let fields = case custodian {
    Some(v) -> [#("custodian", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case attester {
    [] -> fields
    _ -> [
      #("attester", json.array(attester, documentreference_attester_to_json)),
      ..fields
    ]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case practice_setting {
    Some(v) -> [#("practiceSetting", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case facility_type {
    Some(v) -> [#("facilityType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case event {
    [] -> fields
    _ -> [#("event", json.array(event, codeablereference_to_json)), ..fields]
  }
  let fields = case context {
    [] -> fields
    _ -> [#("context", json.array(context, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modality {
    [] -> fields
    _ -> [
      #("modality", json.array(modality, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case doc_status {
    Some(v) -> [
      #("docStatus", r5valuesets.compositionstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Documentreference")), ..fields]
  json.object(fields)
}

pub fn documentreference_decoder() -> Decoder(Documentreference) {
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(documentreference_content_decoder()),
  )
  use security_label <- decode.optional_field(
    "securityLabel",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(documentreference_relatesto_decoder()),
  )
  use custodian <- decode.optional_field(
    "custodian",
    None,
    decode.optional(reference_decoder()),
  )
  use attester <- decode.optional_field(
    "attester",
    [],
    decode.list(documentreference_attester_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use practice_setting <- decode.optional_field(
    "practiceSetting",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use facility_type <- decode.optional_field(
    "facilityType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeablereference_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(codeablereference_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modality <- decode.optional_field(
    "modality",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use doc_status <- decode.optional_field(
    "docStatus",
    None,
    decode.optional(r5valuesets.compositionstatus_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.documentreferencestatus_decoder(),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Documentreference",
    decode.failure(documentreference_new(status:), "resourceType"),
  )
  decode.success(Documentreference(
    content:,
    security_label:,
    description:,
    relates_to:,
    custodian:,
    attester:,
    author:,
    date:,
    period:,
    practice_setting:,
    facility_type:,
    body_site:,
    event:,
    context:,
    subject:,
    category:,
    type_:,
    modality:,
    doc_status:,
    status:,
    based_on:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/DomainResource#resource
pub type Domainresource {
  Domainresource(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn domainresource_new() -> Domainresource {
  Domainresource(
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn domainresource_to_json(domainresource: Domainresource) -> Json {
  let Domainresource(
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = domainresource
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Domainresource")), ..fields]
  json.object(fields)
}

pub fn domainresource_decoder() -> Decoder(Domainresource) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Domainresource",
    decode.failure(domainresource_new(), "resourceType"),
  )
  decode.success(Domainresource(
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type Encounter {
  Encounter(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Encounterstatus,
    class: List(Codeableconcept),
    priority: Option(Codeableconcept),
    type_: List(Codeableconcept),
    service_type: List(Codeablereference),
    subject: Option(Reference),
    subject_status: Option(Codeableconcept),
    episode_of_care: List(Reference),
    based_on: List(Reference),
    care_team: List(Reference),
    part_of: Option(Reference),
    service_provider: Option(Reference),
    participant: List(EncounterParticipant),
    appointment: List(Reference),
    virtual_service: List(Virtualservicedetail),
    actual_period: Option(Period),
    planned_start_date: Option(String),
    planned_end_date: Option(String),
    length: Option(Duration),
    reason: List(EncounterReason),
    diagnosis: List(EncounterDiagnosis),
    account: List(Reference),
    diet_preference: List(Codeableconcept),
    special_arrangement: List(Codeableconcept),
    special_courtesy: List(Codeableconcept),
    admission: Option(EncounterAdmission),
    location: List(EncounterLocation),
  )
}

pub fn encounter_new(status status: r5valuesets.Encounterstatus) -> Encounter {
  Encounter(
    location: [],
    admission: None,
    special_courtesy: [],
    special_arrangement: [],
    diet_preference: [],
    account: [],
    diagnosis: [],
    reason: [],
    length: None,
    planned_end_date: None,
    planned_start_date: None,
    actual_period: None,
    virtual_service: [],
    appointment: [],
    participant: [],
    service_provider: None,
    part_of: None,
    care_team: [],
    based_on: [],
    episode_of_care: [],
    subject_status: None,
    subject: None,
    service_type: [],
    type_: [],
    priority: None,
    class: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type EncounterParticipant {
  EncounterParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    period: Option(Period),
    actor: Option(Reference),
  )
}

pub fn encounter_participant_new() -> EncounterParticipant {
  EncounterParticipant(
    actor: None,
    period: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type EncounterReason {
  EncounterReason(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    use_: List(Codeableconcept),
    value: List(Codeablereference),
  )
}

pub fn encounter_reason_new() -> EncounterReason {
  EncounterReason(
    value: [],
    use_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type EncounterDiagnosis {
  EncounterDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    condition: List(Codeablereference),
    use_: List(Codeableconcept),
  )
}

pub fn encounter_diagnosis_new() -> EncounterDiagnosis {
  EncounterDiagnosis(
    use_: [],
    condition: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type EncounterAdmission {
  EncounterAdmission(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    pre_admission_identifier: Option(Identifier),
    origin: Option(Reference),
    admit_source: Option(Codeableconcept),
    re_admission: Option(Codeableconcept),
    destination: Option(Reference),
    discharge_disposition: Option(Codeableconcept),
  )
}

pub fn encounter_admission_new() -> EncounterAdmission {
  EncounterAdmission(
    discharge_disposition: None,
    destination: None,
    re_admission: None,
    admit_source: None,
    origin: None,
    pre_admission_identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Encounter#resource
pub type EncounterLocation {
  EncounterLocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    location: Reference,
    status: Option(r5valuesets.Encounterlocationstatus),
    form: Option(Codeableconcept),
    period: Option(Period),
  )
}

pub fn encounter_location_new(location location: Reference) -> EncounterLocation {
  EncounterLocation(
    period: None,
    form: None,
    status: None,
    location:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn encounter_location_to_json(encounter_location: EncounterLocation) -> Json {
  let EncounterLocation(
    period:,
    form:,
    status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_location
  let fields = [
    #("location", reference_to_json(location)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.encounterlocationstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_location_decoder() -> Decoder(EncounterLocation) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.encounterlocationstatus_decoder()),
  )
  use location <- decode.field("location", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterLocation(
    period:,
    form:,
    status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_admission_to_json(
  encounter_admission: EncounterAdmission,
) -> Json {
  let EncounterAdmission(
    discharge_disposition:,
    destination:,
    re_admission:,
    admit_source:,
    origin:,
    pre_admission_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_admission
  let fields = []
  let fields = case discharge_disposition {
    Some(v) -> [#("dischargeDisposition", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case re_admission {
    Some(v) -> [#("reAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case admit_source {
    Some(v) -> [#("admitSource", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    Some(v) -> [#("origin", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_admission_identifier {
    Some(v) -> [#("preAdmissionIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_admission_decoder() -> Decoder(EncounterAdmission) {
  use discharge_disposition <- decode.optional_field(
    "dischargeDisposition",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use re_admission <- decode.optional_field(
    "reAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use admit_source <- decode.optional_field(
    "admitSource",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use origin <- decode.optional_field(
    "origin",
    None,
    decode.optional(reference_decoder()),
  )
  use pre_admission_identifier <- decode.optional_field(
    "preAdmissionIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterAdmission(
    discharge_disposition:,
    destination:,
    re_admission:,
    admit_source:,
    origin:,
    pre_admission_identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_diagnosis_to_json(
  encounter_diagnosis: EncounterDiagnosis,
) -> Json {
  let EncounterDiagnosis(
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_diagnosis
  let fields = []
  let fields = case use_ {
    [] -> fields
    _ -> [#("use", json.array(use_, codeableconcept_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_diagnosis_decoder() -> Decoder(EncounterDiagnosis) {
  use use_ <- decode.optional_field(
    "use",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterDiagnosis(
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_reason_to_json(encounter_reason: EncounterReason) -> Json {
  let EncounterReason(value:, use_:, modifier_extension:, extension:, id:) =
    encounter_reason
  let fields = []
  let fields = case value {
    [] -> fields
    _ -> [#("value", json.array(value, codeablereference_to_json)), ..fields]
  }
  let fields = case use_ {
    [] -> fields
    _ -> [#("use", json.array(use_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_reason_decoder() -> Decoder(EncounterReason) {
  use value <- decode.optional_field(
    "value",
    [],
    decode.list(codeablereference_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterReason(
    value:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_participant_to_json(
  encounter_participant: EncounterParticipant,
) -> Json {
  let EncounterParticipant(
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounter_participant
  let fields = []
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounter_participant_decoder() -> Decoder(EncounterParticipant) {
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterParticipant(
    actor:,
    period:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounter_to_json(encounter: Encounter) -> Json {
  let Encounter(
    location:,
    admission:,
    special_courtesy:,
    special_arrangement:,
    diet_preference:,
    account:,
    diagnosis:,
    reason:,
    length:,
    planned_end_date:,
    planned_start_date:,
    actual_period:,
    virtual_service:,
    appointment:,
    participant:,
    service_provider:,
    part_of:,
    care_team:,
    based_on:,
    episode_of_care:,
    subject_status:,
    subject:,
    service_type:,
    type_:,
    priority:,
    class:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = encounter
  let fields = [
    #("status", r5valuesets.encounterstatus_to_json(status)),
  ]
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, encounter_location_to_json)),
      ..fields
    ]
  }
  let fields = case admission {
    Some(v) -> [#("admission", encounter_admission_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case special_courtesy {
    [] -> fields
    _ -> [
      #(
        "specialCourtesy",
        json.array(special_courtesy, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case special_arrangement {
    [] -> fields
    _ -> [
      #(
        "specialArrangement",
        json.array(special_arrangement, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case diet_preference {
    [] -> fields
    _ -> [
      #("dietPreference", json.array(diet_preference, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, encounter_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, encounter_reason_to_json)), ..fields]
  }
  let fields = case length {
    Some(v) -> [#("length", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case planned_end_date {
    Some(v) -> [#("plannedEndDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case planned_start_date {
    Some(v) -> [#("plannedStartDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case actual_period {
    Some(v) -> [#("actualPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case virtual_service {
    [] -> fields
    _ -> [
      #(
        "virtualService",
        json.array(virtual_service, virtualservicedetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case appointment {
    [] -> fields
    _ -> [
      #("appointment", json.array(appointment, reference_to_json)),
      ..fields
    ]
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, encounter_participant_to_json)),
      ..fields
    ]
  }
  let fields = case service_provider {
    Some(v) -> [#("serviceProvider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case care_team {
    [] -> fields
    _ -> [#("careTeam", json.array(care_team, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case episode_of_care {
    [] -> fields
    _ -> [
      #("episodeOfCare", json.array(episode_of_care, reference_to_json)),
      ..fields
    ]
  }
  let fields = case subject_status {
    Some(v) -> [#("subjectStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case class {
    [] -> fields
    _ -> [#("class", json.array(class, codeableconcept_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Encounter")), ..fields]
  json.object(fields)
}

pub fn encounter_decoder() -> Decoder(Encounter) {
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(encounter_location_decoder()),
  )
  use admission <- decode.optional_field(
    "admission",
    None,
    decode.optional(encounter_admission_decoder()),
  )
  use special_courtesy <- decode.optional_field(
    "specialCourtesy",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use special_arrangement <- decode.optional_field(
    "specialArrangement",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diet_preference <- decode.optional_field(
    "dietPreference",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(encounter_diagnosis_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(encounter_reason_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(duration_decoder()),
  )
  use planned_end_date <- decode.optional_field(
    "plannedEndDate",
    None,
    decode.optional(decode.string),
  )
  use planned_start_date <- decode.optional_field(
    "plannedStartDate",
    None,
    decode.optional(decode.string),
  )
  use actual_period <- decode.optional_field(
    "actualPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use virtual_service <- decode.optional_field(
    "virtualService",
    [],
    decode.list(virtualservicedetail_decoder()),
  )
  use appointment <- decode.optional_field(
    "appointment",
    [],
    decode.list(reference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(encounter_participant_decoder()),
  )
  use service_provider <- decode.optional_field(
    "serviceProvider",
    None,
    decode.optional(reference_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use episode_of_care <- decode.optional_field(
    "episodeOfCare",
    [],
    decode.list(reference_decoder()),
  )
  use subject_status <- decode.optional_field(
    "subjectStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeablereference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use class <- decode.optional_field(
    "class",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.encounterstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Encounter",
    decode.failure(encounter_new(status:), "resourceType"),
  )
  decode.success(Encounter(
    location:,
    admission:,
    special_courtesy:,
    special_arrangement:,
    diet_preference:,
    account:,
    diagnosis:,
    reason:,
    length:,
    planned_end_date:,
    planned_start_date:,
    actual_period:,
    virtual_service:,
    appointment:,
    participant:,
    service_provider:,
    part_of:,
    care_team:,
    based_on:,
    episode_of_care:,
    subject_status:,
    subject:,
    service_type:,
    type_:,
    priority:,
    class:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EncounterHistory#resource
pub type Encounterhistory {
  Encounterhistory(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    encounter: Option(Reference),
    identifier: List(Identifier),
    status: r5valuesets.Encounterstatus,
    class: Codeableconcept,
    type_: List(Codeableconcept),
    service_type: List(Codeablereference),
    subject: Option(Reference),
    subject_status: Option(Codeableconcept),
    actual_period: Option(Period),
    planned_start_date: Option(String),
    planned_end_date: Option(String),
    length: Option(Duration),
    location: List(EncounterhistoryLocation),
  )
}

pub fn encounterhistory_new(
  class class: Codeableconcept,
  status status: r5valuesets.Encounterstatus,
) -> Encounterhistory {
  Encounterhistory(
    location: [],
    length: None,
    planned_end_date: None,
    planned_start_date: None,
    actual_period: None,
    subject_status: None,
    subject: None,
    service_type: [],
    type_: [],
    class:,
    status:,
    identifier: [],
    encounter: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EncounterHistory#resource
pub type EncounterhistoryLocation {
  EncounterhistoryLocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    location: Reference,
    form: Option(Codeableconcept),
  )
}

pub fn encounterhistory_location_new(
  location location: Reference,
) -> EncounterhistoryLocation {
  EncounterhistoryLocation(
    form: None,
    location:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn encounterhistory_location_to_json(
  encounterhistory_location: EncounterhistoryLocation,
) -> Json {
  let EncounterhistoryLocation(
    form:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ) = encounterhistory_location
  let fields = [
    #("location", reference_to_json(location)),
  ]
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn encounterhistory_location_decoder() -> Decoder(EncounterhistoryLocation) {
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.field("location", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EncounterhistoryLocation(
    form:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn encounterhistory_to_json(encounterhistory: Encounterhistory) -> Json {
  let Encounterhistory(
    location:,
    length:,
    planned_end_date:,
    planned_start_date:,
    actual_period:,
    subject_status:,
    subject:,
    service_type:,
    type_:,
    class:,
    status:,
    identifier:,
    encounter:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = encounterhistory
  let fields = [
    #("class", codeableconcept_to_json(class)),
    #("status", r5valuesets.encounterstatus_to_json(status)),
  ]
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, encounterhistory_location_to_json)),
      ..fields
    ]
  }
  let fields = case length {
    Some(v) -> [#("length", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case planned_end_date {
    Some(v) -> [#("plannedEndDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case planned_start_date {
    Some(v) -> [#("plannedStartDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case actual_period {
    Some(v) -> [#("actualPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject_status {
    Some(v) -> [#("subjectStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Encounterhistory")), ..fields]
  json.object(fields)
}

pub fn encounterhistory_decoder() -> Decoder(Encounterhistory) {
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(encounterhistory_location_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(duration_decoder()),
  )
  use planned_end_date <- decode.optional_field(
    "plannedEndDate",
    None,
    decode.optional(decode.string),
  )
  use planned_start_date <- decode.optional_field(
    "plannedStartDate",
    None,
    decode.optional(decode.string),
  )
  use actual_period <- decode.optional_field(
    "actualPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use subject_status <- decode.optional_field(
    "subjectStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeablereference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use class <- decode.field("class", codeableconcept_decoder())
  use status <- decode.field("status", r5valuesets.encounterstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Encounterhistory",
    decode.failure(encounterhistory_new(class:, status:), "resourceType"),
  )
  decode.success(Encounterhistory(
    location:,
    length:,
    planned_end_date:,
    planned_start_date:,
    actual_period:,
    subject_status:,
    subject:,
    service_type:,
    type_:,
    class:,
    status:,
    identifier:,
    encounter:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Endpoint#resource
pub type Endpoint {
  Endpoint(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Endpointstatus,
    connection_type: List(Codeableconcept),
    name: Option(String),
    description: Option(String),
    environment_type: List(Codeableconcept),
    managing_organization: Option(Reference),
    contact: List(Contactpoint),
    period: Option(Period),
    payload: List(EndpointPayload),
    address: String,
    header: List(String),
  )
}

pub fn endpoint_new(
  address address: String,
  status status: r5valuesets.Endpointstatus,
) -> Endpoint {
  Endpoint(
    header: [],
    address:,
    payload: [],
    period: None,
    contact: [],
    managing_organization: None,
    environment_type: [],
    description: None,
    name: None,
    connection_type: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Endpoint#resource
pub type EndpointPayload {
  EndpointPayload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    mime_type: List(String),
  )
}

pub fn endpoint_payload_new() -> EndpointPayload {
  EndpointPayload(
    mime_type: [],
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn endpoint_payload_to_json(endpoint_payload: EndpointPayload) -> Json {
  let EndpointPayload(mime_type:, type_:, modifier_extension:, extension:, id:) =
    endpoint_payload
  let fields = []
  let fields = case mime_type {
    [] -> fields
    _ -> [#("mimeType", json.array(mime_type, json.string)), ..fields]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn endpoint_payload_decoder() -> Decoder(EndpointPayload) {
  use mime_type <- decode.optional_field(
    "mimeType",
    [],
    decode.list(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EndpointPayload(
    mime_type:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn endpoint_to_json(endpoint: Endpoint) -> Json {
  let Endpoint(
    header:,
    address:,
    payload:,
    period:,
    contact:,
    managing_organization:,
    environment_type:,
    description:,
    name:,
    connection_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = endpoint
  let fields = [
    #("address", json.string(address)),
    #("status", r5valuesets.endpointstatus_to_json(status)),
  ]
  let fields = case header {
    [] -> fields
    _ -> [#("header", json.array(header, json.string)), ..fields]
  }
  let fields = case payload {
    [] -> fields
    _ -> [#("payload", json.array(payload, endpoint_payload_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case environment_type {
    [] -> fields
    _ -> [
      #(
        "environmentType",
        json.array(environment_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case connection_type {
    [] -> fields
    _ -> [
      #("connectionType", json.array(connection_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Endpoint")), ..fields]
  json.object(fields)
}

pub fn endpoint_decoder() -> Decoder(Endpoint) {
  use header <- decode.optional_field("header", [], decode.list(decode.string))
  use address <- decode.field("address", decode.string)
  use payload <- decode.optional_field(
    "payload",
    [],
    decode.list(endpoint_payload_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use environment_type <- decode.optional_field(
    "environmentType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use connection_type <- decode.optional_field(
    "connectionType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.endpointstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Endpoint",
    decode.failure(endpoint_new(address:, status:), "resourceType"),
  )
  decode.success(Endpoint(
    header:,
    address:,
    payload:,
    period:,
    contact:,
    managing_organization:,
    environment_type:,
    description:,
    name:,
    connection_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EnrollmentRequest#resource
pub type Enrollmentrequest {
  Enrollmentrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Fmstatus),
    created: Option(String),
    insurer: Option(Reference),
    provider: Option(Reference),
    candidate: Option(Reference),
    coverage: Option(Reference),
  )
}

pub fn enrollmentrequest_new() -> Enrollmentrequest {
  Enrollmentrequest(
    coverage: None,
    candidate: None,
    provider: None,
    insurer: None,
    created: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn enrollmentrequest_to_json(enrollmentrequest: Enrollmentrequest) -> Json {
  let Enrollmentrequest(
    coverage:,
    candidate:,
    provider:,
    insurer:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = enrollmentrequest
  let fields = []
  let fields = case coverage {
    Some(v) -> [#("coverage", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case candidate {
    Some(v) -> [#("candidate", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.fmstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Enrollmentrequest")), ..fields]
  json.object(fields)
}

pub fn enrollmentrequest_decoder() -> Decoder(Enrollmentrequest) {
  use coverage <- decode.optional_field(
    "coverage",
    None,
    decode.optional(reference_decoder()),
  )
  use candidate <- decode.optional_field(
    "candidate",
    None,
    decode.optional(reference_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.fmstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Enrollmentrequest",
    decode.failure(enrollmentrequest_new(), "resourceType"),
  )
  decode.success(Enrollmentrequest(
    coverage:,
    candidate:,
    provider:,
    insurer:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EnrollmentResponse#resource
pub type Enrollmentresponse {
  Enrollmentresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Fmstatus),
    request: Option(Reference),
    outcome: Option(r5valuesets.Enrollmentoutcome),
    disposition: Option(String),
    created: Option(String),
    organization: Option(Reference),
    request_provider: Option(Reference),
  )
}

pub fn enrollmentresponse_new() -> Enrollmentresponse {
  Enrollmentresponse(
    request_provider: None,
    organization: None,
    created: None,
    disposition: None,
    outcome: None,
    request: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn enrollmentresponse_to_json(
  enrollmentresponse: Enrollmentresponse,
) -> Json {
  let Enrollmentresponse(
    request_provider:,
    organization:,
    created:,
    disposition:,
    outcome:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = enrollmentresponse
  let fields = []
  let fields = case request_provider {
    Some(v) -> [#("requestProvider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case created {
    Some(v) -> [#("created", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [
      #("outcome", r5valuesets.enrollmentoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.fmstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Enrollmentresponse")), ..fields]
  json.object(fields)
}

pub fn enrollmentresponse_decoder() -> Decoder(Enrollmentresponse) {
  use request_provider <- decode.optional_field(
    "requestProvider",
    None,
    decode.optional(reference_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.optional_field(
    "created",
    None,
    decode.optional(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(r5valuesets.enrollmentoutcome_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.fmstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Enrollmentresponse",
    decode.failure(enrollmentresponse_new(), "resourceType"),
  )
  decode.success(Enrollmentresponse(
    request_provider:,
    organization:,
    created:,
    disposition:,
    outcome:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EpisodeOfCare#resource
pub type Episodeofcare {
  Episodeofcare(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Episodeofcarestatus,
    status_history: List(EpisodeofcareStatushistory),
    type_: List(Codeableconcept),
    reason: List(EpisodeofcareReason),
    diagnosis: List(EpisodeofcareDiagnosis),
    patient: Reference,
    managing_organization: Option(Reference),
    period: Option(Period),
    referral_request: List(Reference),
    care_manager: Option(Reference),
    care_team: List(Reference),
    account: List(Reference),
  )
}

pub fn episodeofcare_new(
  patient patient: Reference,
  status status: r5valuesets.Episodeofcarestatus,
) -> Episodeofcare {
  Episodeofcare(
    account: [],
    care_team: [],
    care_manager: None,
    referral_request: [],
    period: None,
    managing_organization: None,
    patient:,
    diagnosis: [],
    reason: [],
    type_: [],
    status_history: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareStatushistory {
  EpisodeofcareStatushistory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r5valuesets.Episodeofcarestatus,
    period: Period,
  )
}

pub fn episodeofcare_statushistory_new(
  period period: Period,
  status status: r5valuesets.Episodeofcarestatus,
) -> EpisodeofcareStatushistory {
  EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareReason {
  EpisodeofcareReason(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    use_: Option(Codeableconcept),
    value: List(Codeablereference),
  )
}

pub fn episodeofcare_reason_new() -> EpisodeofcareReason {
  EpisodeofcareReason(
    value: [],
    use_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EpisodeOfCare#resource
pub type EpisodeofcareDiagnosis {
  EpisodeofcareDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    condition: List(Codeablereference),
    use_: Option(Codeableconcept),
  )
}

pub fn episodeofcare_diagnosis_new() -> EpisodeofcareDiagnosis {
  EpisodeofcareDiagnosis(
    use_: None,
    condition: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn episodeofcare_diagnosis_to_json(
  episodeofcare_diagnosis: EpisodeofcareDiagnosis,
) -> Json {
  let EpisodeofcareDiagnosis(
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ) = episodeofcare_diagnosis
  let fields = []
  let fields = case use_ {
    Some(v) -> [#("use", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn episodeofcare_diagnosis_decoder() -> Decoder(EpisodeofcareDiagnosis) {
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EpisodeofcareDiagnosis(
    use_:,
    condition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn episodeofcare_reason_to_json(
  episodeofcare_reason: EpisodeofcareReason,
) -> Json {
  let EpisodeofcareReason(value:, use_:, modifier_extension:, extension:, id:) =
    episodeofcare_reason
  let fields = []
  let fields = case value {
    [] -> fields
    _ -> [#("value", json.array(value, codeablereference_to_json)), ..fields]
  }
  let fields = case use_ {
    Some(v) -> [#("use", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn episodeofcare_reason_decoder() -> Decoder(EpisodeofcareReason) {
  use value <- decode.optional_field(
    "value",
    [],
    decode.list(codeablereference_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EpisodeofcareReason(
    value:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn episodeofcare_statushistory_to_json(
  episodeofcare_statushistory: EpisodeofcareStatushistory,
) -> Json {
  let EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ) = episodeofcare_statushistory
  let fields = [
    #("period", period_to_json(period)),
    #("status", r5valuesets.episodeofcarestatus_to_json(status)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn episodeofcare_statushistory_decoder() -> Decoder(
  EpisodeofcareStatushistory,
) {
  use period <- decode.field("period", period_decoder())
  use status <- decode.field(
    "status",
    r5valuesets.episodeofcarestatus_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EpisodeofcareStatushistory(
    period:,
    status:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn episodeofcare_to_json(episodeofcare: Episodeofcare) -> Json {
  let Episodeofcare(
    account:,
    care_team:,
    care_manager:,
    referral_request:,
    period:,
    managing_organization:,
    patient:,
    diagnosis:,
    reason:,
    type_:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = episodeofcare
  let fields = [
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.episodeofcarestatus_to_json(status)),
  ]
  let fields = case account {
    [] -> fields
    _ -> [#("account", json.array(account, reference_to_json)), ..fields]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [#("careTeam", json.array(care_team, reference_to_json)), ..fields]
  }
  let fields = case care_manager {
    Some(v) -> [#("careManager", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case referral_request {
    [] -> fields
    _ -> [
      #("referralRequest", json.array(referral_request, reference_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #("diagnosis", json.array(diagnosis, episodeofcare_diagnosis_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [
      #("reason", json.array(reason, episodeofcare_reason_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case status_history {
    [] -> fields
    _ -> [
      #(
        "statusHistory",
        json.array(status_history, episodeofcare_statushistory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Episodeofcare")), ..fields]
  json.object(fields)
}

pub fn episodeofcare_decoder() -> Decoder(Episodeofcare) {
  use account <- decode.optional_field(
    "account",
    [],
    decode.list(reference_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(reference_decoder()),
  )
  use care_manager <- decode.optional_field(
    "careManager",
    None,
    decode.optional(reference_decoder()),
  )
  use referral_request <- decode.optional_field(
    "referralRequest",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(episodeofcare_diagnosis_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(episodeofcare_reason_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_history <- decode.optional_field(
    "statusHistory",
    [],
    decode.list(episodeofcare_statushistory_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.episodeofcarestatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Episodeofcare",
    decode.failure(episodeofcare_new(patient:, status:), "resourceType"),
  )
  decode.success(Episodeofcare(
    account:,
    care_team:,
    care_manager:,
    referral_request:,
    period:,
    managing_organization:,
    patient:,
    diagnosis:,
    reason:,
    type_:,
    status_history:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EventDefinition#resource
pub type Eventdefinition {
  Eventdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(EventdefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(EventdefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    trigger: List(Triggerdefinition),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EventDefinition#resource
pub type EventdefinitionVersionalgorithm {
  EventdefinitionVersionalgorithmString(version_algorithm: String)
  EventdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn eventdefinition_versionalgorithm_to_json(
  elt: EventdefinitionVersionalgorithm,
) -> Json {
  case elt {
    EventdefinitionVersionalgorithmString(v) -> json.string(v)
    EventdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn eventdefinition_versionalgorithm_decoder() -> Decoder(
  EventdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(EventdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(EventdefinitionVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EventDefinition#resource
pub type EventdefinitionSubject {
  EventdefinitionSubjectCodeableconcept(subject: Codeableconcept)
  EventdefinitionSubjectReference(subject: Reference)
}

pub fn eventdefinition_subject_to_json(elt: EventdefinitionSubject) -> Json {
  case elt {
    EventdefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    EventdefinitionSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn eventdefinition_subject_decoder() -> Decoder(EventdefinitionSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(EventdefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(EventdefinitionSubjectReference),
    ],
  )
}

pub fn eventdefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Eventdefinition {
  Eventdefinition(
    trigger: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn eventdefinition_to_json(eventdefinition: Eventdefinition) -> Json {
  let Eventdefinition(
    trigger:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = eventdefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case trigger {
    [] -> fields
    _ -> [
      #("trigger", json.array(trigger, triggerdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          EventdefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          EventdefinitionSubjectReference(_) -> "Reference"
        },
        eventdefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          EventdefinitionVersionalgorithmString(_) -> "String"
          EventdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        eventdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Eventdefinition")), ..fields]
  json.object(fields)
}

pub fn eventdefinition_decoder() -> Decoder(Eventdefinition) {
  use trigger <- decode.optional_field(
    "trigger",
    [],
    decode.list(triggerdefinition_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(eventdefinition_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(eventdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Eventdefinition",
    decode.failure(eventdefinition_new(status:), "resourceType"),
  )
  decode.success(Eventdefinition(
    trigger:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type Evidence {
  Evidence(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(EvidenceVersionalgorithm),
    name: Option(String),
    title: Option(String),
    cite_as: Option(EvidenceCiteas),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    use_context: List(Usagecontext),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    related_artifact: List(Relatedartifact),
    description: Option(String),
    assertion: Option(String),
    note: List(Annotation),
    variable_definition: List(EvidenceVariabledefinition),
    synthesis_type: Option(Codeableconcept),
    study_design: List(Codeableconcept),
    statistic: List(EvidenceStatistic),
    certainty: List(EvidenceCertainty),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceVersionalgorithm {
  EvidenceVersionalgorithmString(version_algorithm: String)
  EvidenceVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn evidence_versionalgorithm_to_json(elt: EvidenceVersionalgorithm) -> Json {
  case elt {
    EvidenceVersionalgorithmString(v) -> json.string(v)
    EvidenceVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn evidence_versionalgorithm_decoder() -> Decoder(EvidenceVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(EvidenceVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(EvidenceVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceCiteas {
  EvidenceCiteasReference(cite_as: Reference)
  EvidenceCiteasMarkdown(cite_as: String)
}

pub fn evidence_citeas_to_json(elt: EvidenceCiteas) -> Json {
  case elt {
    EvidenceCiteasReference(v) -> reference_to_json(v)
    EvidenceCiteasMarkdown(v) -> json.string(v)
  }
}

pub fn evidence_citeas_decoder() -> Decoder(EvidenceCiteas) {
  decode.one_of(
    decode.field("citeAsReference", reference_decoder(), decode.success)
      |> decode.map(EvidenceCiteasReference),
    [
      decode.field("citeAsMarkdown", decode.string, decode.success)
      |> decode.map(EvidenceCiteasMarkdown),
    ],
  )
}

pub fn evidence_new(status status: r5valuesets.Publicationstatus) -> Evidence {
  Evidence(
    certainty: [],
    statistic: [],
    study_design: [],
    synthesis_type: None,
    variable_definition: [],
    note: [],
    assertion: None,
    description: None,
    related_artifact: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    use_context: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    contact: [],
    publisher: None,
    last_review_date: None,
    approval_date: None,
    date: None,
    experimental: None,
    status:,
    cite_as: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceVariabledefinition {
  EvidenceVariabledefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    variable_role: Codeableconcept,
    observed: Option(Reference),
    intended: Option(Reference),
    directness_match: Option(Codeableconcept),
  )
}

pub fn evidence_variabledefinition_new(
  variable_role variable_role: Codeableconcept,
) -> EvidenceVariabledefinition {
  EvidenceVariabledefinition(
    directness_match: None,
    intended: None,
    observed: None,
    variable_role:,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceStatistic {
  EvidenceStatistic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    statistic_type: Option(Codeableconcept),
    category: Option(Codeableconcept),
    quantity: Option(Quantity),
    number_of_events: Option(Int),
    number_affected: Option(Int),
    sample_size: Option(EvidenceStatisticSamplesize),
    attribute_estimate: List(EvidenceStatisticAttributeestimate),
    model_characteristic: List(EvidenceStatisticModelcharacteristic),
  )
}

pub fn evidence_statistic_new() -> EvidenceStatistic {
  EvidenceStatistic(
    model_characteristic: [],
    attribute_estimate: [],
    sample_size: None,
    number_affected: None,
    number_of_events: None,
    quantity: None,
    category: None,
    statistic_type: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceStatisticSamplesize {
  EvidenceStatisticSamplesize(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    number_of_studies: Option(Int),
    number_of_participants: Option(Int),
    known_data_count: Option(Int),
  )
}

pub fn evidence_statistic_samplesize_new() -> EvidenceStatisticSamplesize {
  EvidenceStatisticSamplesize(
    known_data_count: None,
    number_of_participants: None,
    number_of_studies: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceStatisticAttributeestimate {
  EvidenceStatisticAttributeestimate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
    level: Option(Float),
    range: Option(Range),
  )
}

pub fn evidence_statistic_attributeestimate_new() -> EvidenceStatisticAttributeestimate {
  EvidenceStatisticAttributeestimate(
    range: None,
    level: None,
    quantity: None,
    type_: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceStatisticModelcharacteristic {
  EvidenceStatisticModelcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: Option(Quantity),
    variable: List(EvidenceStatisticModelcharacteristicVariable),
  )
}

pub fn evidence_statistic_modelcharacteristic_new(
  code code: Codeableconcept,
) -> EvidenceStatisticModelcharacteristic {
  EvidenceStatisticModelcharacteristic(
    variable: [],
    value: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceStatisticModelcharacteristicVariable {
  EvidenceStatisticModelcharacteristicVariable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    variable_definition: Reference,
    handling: Option(r5valuesets.Variablehandling),
    value_category: List(Codeableconcept),
    value_quantity: List(Quantity),
    value_range: List(Range),
  )
}

pub fn evidence_statistic_modelcharacteristic_variable_new(
  variable_definition variable_definition: Reference,
) -> EvidenceStatisticModelcharacteristicVariable {
  EvidenceStatisticModelcharacteristicVariable(
    value_range: [],
    value_quantity: [],
    value_category: [],
    handling: None,
    variable_definition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Evidence#resource
pub type EvidenceCertainty {
  EvidenceCertainty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    type_: Option(Codeableconcept),
    rating: Option(Codeableconcept),
    rater: Option(String),
  )
}

pub fn evidence_certainty_new() -> EvidenceCertainty {
  EvidenceCertainty(
    rater: None,
    rating: None,
    type_: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidence_certainty_to_json(evidence_certainty: EvidenceCertainty) -> Json {
  let EvidenceCertainty(
    rater:,
    rating:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_certainty
  let fields = []
  let fields = case rater {
    Some(v) -> [#("rater", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rating {
    Some(v) -> [#("rating", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_certainty_decoder() -> Decoder(EvidenceCertainty) {
  use rater <- decode.optional_field(
    "rater",
    None,
    decode.optional(decode.string),
  )
  use rating <- decode.optional_field(
    "rating",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceCertainty(
    rater:,
    rating:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_modelcharacteristic_variable_to_json(
  evidence_statistic_modelcharacteristic_variable: EvidenceStatisticModelcharacteristicVariable,
) -> Json {
  let EvidenceStatisticModelcharacteristicVariable(
    value_range:,
    value_quantity:,
    value_category:,
    handling:,
    variable_definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_modelcharacteristic_variable
  let fields = [
    #("variableDefinition", reference_to_json(variable_definition)),
  ]
  let fields = case value_range {
    [] -> fields
    _ -> [#("valueRange", json.array(value_range, range_to_json)), ..fields]
  }
  let fields = case value_quantity {
    [] -> fields
    _ -> [
      #("valueQuantity", json.array(value_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case value_category {
    [] -> fields
    _ -> [
      #("valueCategory", json.array(value_category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case handling {
    Some(v) -> [
      #("handling", r5valuesets.variablehandling_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_modelcharacteristic_variable_decoder() -> Decoder(
  EvidenceStatisticModelcharacteristicVariable,
) {
  use value_range <- decode.optional_field(
    "valueRange",
    [],
    decode.list(range_decoder()),
  )
  use value_quantity <- decode.optional_field(
    "valueQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use value_category <- decode.optional_field(
    "valueCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use handling <- decode.optional_field(
    "handling",
    None,
    decode.optional(r5valuesets.variablehandling_decoder()),
  )
  use variable_definition <- decode.field(
    "variableDefinition",
    reference_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticModelcharacteristicVariable(
    value_range:,
    value_quantity:,
    value_category:,
    handling:,
    variable_definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_modelcharacteristic_to_json(
  evidence_statistic_modelcharacteristic: EvidenceStatisticModelcharacteristic,
) -> Json {
  let EvidenceStatisticModelcharacteristic(
    variable:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_modelcharacteristic
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case variable {
    [] -> fields
    _ -> [
      #(
        "variable",
        json.array(
          variable,
          evidence_statistic_modelcharacteristic_variable_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_modelcharacteristic_decoder() -> Decoder(
  EvidenceStatisticModelcharacteristic,
) {
  use variable <- decode.optional_field(
    "variable",
    [],
    decode.list(evidence_statistic_modelcharacteristic_variable_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticModelcharacteristic(
    variable:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_attributeestimate_to_json(
  evidence_statistic_attributeestimate: EvidenceStatisticAttributeestimate,
) -> Json {
  let EvidenceStatisticAttributeestimate(
    range:,
    level:,
    quantity:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_attributeestimate
  let fields = []
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case level {
    Some(v) -> [#("level", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_attributeestimate_decoder() -> Decoder(
  EvidenceStatisticAttributeestimate,
) {
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use level <- decode.optional_field(
    "level",
    None,
    decode.optional(decode.float),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticAttributeestimate(
    range:,
    level:,
    quantity:,
    type_:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_samplesize_to_json(
  evidence_statistic_samplesize: EvidenceStatisticSamplesize,
) -> Json {
  let EvidenceStatisticSamplesize(
    known_data_count:,
    number_of_participants:,
    number_of_studies:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic_samplesize
  let fields = []
  let fields = case known_data_count {
    Some(v) -> [#("knownDataCount", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_participants {
    Some(v) -> [#("numberOfParticipants", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_studies {
    Some(v) -> [#("numberOfStudies", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_samplesize_decoder() -> Decoder(
  EvidenceStatisticSamplesize,
) {
  use known_data_count <- decode.optional_field(
    "knownDataCount",
    None,
    decode.optional(decode.int),
  )
  use number_of_participants <- decode.optional_field(
    "numberOfParticipants",
    None,
    decode.optional(decode.int),
  )
  use number_of_studies <- decode.optional_field(
    "numberOfStudies",
    None,
    decode.optional(decode.int),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatisticSamplesize(
    known_data_count:,
    number_of_participants:,
    number_of_studies:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_statistic_to_json(evidence_statistic: EvidenceStatistic) -> Json {
  let EvidenceStatistic(
    model_characteristic:,
    attribute_estimate:,
    sample_size:,
    number_affected:,
    number_of_events:,
    quantity:,
    category:,
    statistic_type:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_statistic
  let fields = []
  let fields = case model_characteristic {
    [] -> fields
    _ -> [
      #(
        "modelCharacteristic",
        json.array(
          model_characteristic,
          evidence_statistic_modelcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case attribute_estimate {
    [] -> fields
    _ -> [
      #(
        "attributeEstimate",
        json.array(
          attribute_estimate,
          evidence_statistic_attributeestimate_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case sample_size {
    Some(v) -> [
      #("sampleSize", evidence_statistic_samplesize_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case number_affected {
    Some(v) -> [#("numberAffected", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_events {
    Some(v) -> [#("numberOfEvents", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case statistic_type {
    Some(v) -> [#("statisticType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_statistic_decoder() -> Decoder(EvidenceStatistic) {
  use model_characteristic <- decode.optional_field(
    "modelCharacteristic",
    [],
    decode.list(evidence_statistic_modelcharacteristic_decoder()),
  )
  use attribute_estimate <- decode.optional_field(
    "attributeEstimate",
    [],
    decode.list(evidence_statistic_attributeestimate_decoder()),
  )
  use sample_size <- decode.optional_field(
    "sampleSize",
    None,
    decode.optional(evidence_statistic_samplesize_decoder()),
  )
  use number_affected <- decode.optional_field(
    "numberAffected",
    None,
    decode.optional(decode.int),
  )
  use number_of_events <- decode.optional_field(
    "numberOfEvents",
    None,
    decode.optional(decode.int),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use statistic_type <- decode.optional_field(
    "statisticType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceStatistic(
    model_characteristic:,
    attribute_estimate:,
    sample_size:,
    number_affected:,
    number_of_events:,
    quantity:,
    category:,
    statistic_type:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_variabledefinition_to_json(
  evidence_variabledefinition: EvidenceVariabledefinition,
) -> Json {
  let EvidenceVariabledefinition(
    directness_match:,
    intended:,
    observed:,
    variable_role:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidence_variabledefinition
  let fields = [
    #("variableRole", codeableconcept_to_json(variable_role)),
  ]
  let fields = case directness_match {
    Some(v) -> [#("directnessMatch", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case intended {
    Some(v) -> [#("intended", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case observed {
    Some(v) -> [#("observed", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidence_variabledefinition_decoder() -> Decoder(
  EvidenceVariabledefinition,
) {
  use directness_match <- decode.optional_field(
    "directnessMatch",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use intended <- decode.optional_field(
    "intended",
    None,
    decode.optional(reference_decoder()),
  )
  use observed <- decode.optional_field(
    "observed",
    None,
    decode.optional(reference_decoder()),
  )
  use variable_role <- decode.field("variableRole", codeableconcept_decoder())
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidenceVariabledefinition(
    directness_match:,
    intended:,
    observed:,
    variable_role:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidence_to_json(evidence: Evidence) -> Json {
  let Evidence(
    certainty:,
    statistic:,
    study_design:,
    synthesis_type:,
    variable_definition:,
    note:,
    assertion:,
    description:,
    related_artifact:,
    copyright_label:,
    copyright:,
    purpose:,
    use_context:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    last_review_date:,
    approval_date:,
    date:,
    experimental:,
    status:,
    cite_as:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidence
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case certainty {
    [] -> fields
    _ -> [
      #("certainty", json.array(certainty, evidence_certainty_to_json)),
      ..fields
    ]
  }
  let fields = case statistic {
    [] -> fields
    _ -> [
      #("statistic", json.array(statistic, evidence_statistic_to_json)),
      ..fields
    ]
  }
  let fields = case study_design {
    [] -> fields
    _ -> [
      #("studyDesign", json.array(study_design, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case synthesis_type {
    Some(v) -> [#("synthesisType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case variable_definition {
    [] -> fields
    _ -> [
      #(
        "variableDefinition",
        json.array(variable_definition, evidence_variabledefinition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case assertion {
    Some(v) -> [#("assertion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case cite_as {
    Some(v) -> [
      #(
        "citeAs"
          <> case v {
          EvidenceCiteasReference(_) -> "Reference"
          EvidenceCiteasMarkdown(_) -> "Markdown"
        },
        evidence_citeas_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          EvidenceVersionalgorithmString(_) -> "String"
          EvidenceVersionalgorithmCoding(_) -> "Coding"
        },
        evidence_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidence")), ..fields]
  json.object(fields)
}

pub fn evidence_decoder() -> Decoder(Evidence) {
  use certainty <- decode.optional_field(
    "certainty",
    [],
    decode.list(evidence_certainty_decoder()),
  )
  use statistic <- decode.optional_field(
    "statistic",
    [],
    decode.list(evidence_statistic_decoder()),
  )
  use study_design <- decode.optional_field(
    "studyDesign",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use synthesis_type <- decode.optional_field(
    "synthesisType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use variable_definition <- decode.optional_field(
    "variableDefinition",
    [],
    decode.list(evidence_variabledefinition_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use assertion <- decode.optional_field(
    "assertion",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use cite_as <- decode.then(none_if_omitted(evidence_citeas_decoder()))
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(evidence_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidence",
    decode.failure(evidence_new(status:), "resourceType"),
  )
  decode.success(Evidence(
    certainty:,
    statistic:,
    study_design:,
    synthesis_type:,
    variable_definition:,
    note:,
    assertion:,
    description:,
    related_artifact:,
    copyright_label:,
    copyright:,
    purpose:,
    use_context:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    last_review_date:,
    approval_date:,
    date:,
    experimental:,
    status:,
    cite_as:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type Evidencereport {
  Evidencereport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    status: r5valuesets.Publicationstatus,
    use_context: List(Usagecontext),
    identifier: List(Identifier),
    related_identifier: List(Identifier),
    cite_as: Option(EvidencereportCiteas),
    type_: Option(Codeableconcept),
    note: List(Annotation),
    related_artifact: List(Relatedartifact),
    subject: EvidencereportSubject,
    publisher: Option(String),
    contact: List(Contactdetail),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    relates_to: List(EvidencereportRelatesto),
    section: List(EvidencereportSection),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportCiteas {
  EvidencereportCiteasReference(cite_as: Reference)
  EvidencereportCiteasMarkdown(cite_as: String)
}

pub fn evidencereport_citeas_to_json(elt: EvidencereportCiteas) -> Json {
  case elt {
    EvidencereportCiteasReference(v) -> reference_to_json(v)
    EvidencereportCiteasMarkdown(v) -> json.string(v)
  }
}

pub fn evidencereport_citeas_decoder() -> Decoder(EvidencereportCiteas) {
  decode.one_of(
    decode.field("citeAsReference", reference_decoder(), decode.success)
      |> decode.map(EvidencereportCiteasReference),
    [
      decode.field("citeAsMarkdown", decode.string, decode.success)
      |> decode.map(EvidencereportCiteasMarkdown),
    ],
  )
}

pub fn evidencereport_new(
  subject subject: EvidencereportSubject,
  status status: r5valuesets.Publicationstatus,
) -> Evidencereport {
  Evidencereport(
    section: [],
    relates_to: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    contact: [],
    publisher: None,
    subject:,
    related_artifact: [],
    note: [],
    type_: None,
    cite_as: None,
    related_identifier: [],
    identifier: [],
    use_context: [],
    status:,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubject {
  EvidencereportSubject(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    characteristic: List(EvidencereportSubjectCharacteristic),
    note: List(Annotation),
  )
}

pub fn evidencereport_subject_new() -> EvidencereportSubject {
  EvidencereportSubject(
    note: [],
    characteristic: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubjectCharacteristic {
  EvidencereportSubjectCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: EvidencereportSubjectCharacteristicValue,
    exclude: Option(Bool),
    period: Option(Period),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSubjectCharacteristicValue {
  EvidencereportSubjectCharacteristicValueReference(value: Reference)
  EvidencereportSubjectCharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  EvidencereportSubjectCharacteristicValueBoolean(value: Bool)
  EvidencereportSubjectCharacteristicValueQuantity(value: Quantity)
  EvidencereportSubjectCharacteristicValueRange(value: Range)
}

pub fn evidencereport_subject_characteristic_value_to_json(
  elt: EvidencereportSubjectCharacteristicValue,
) -> Json {
  case elt {
    EvidencereportSubjectCharacteristicValueReference(v) -> reference_to_json(v)
    EvidencereportSubjectCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencereportSubjectCharacteristicValueBoolean(v) -> json.bool(v)
    EvidencereportSubjectCharacteristicValueQuantity(v) -> quantity_to_json(v)
    EvidencereportSubjectCharacteristicValueRange(v) -> range_to_json(v)
  }
}

pub fn evidencereport_subject_characteristic_value_decoder() -> Decoder(
  EvidencereportSubjectCharacteristicValue,
) {
  decode.one_of(
    decode.field("valueReference", reference_decoder(), decode.success)
      |> decode.map(EvidencereportSubjectCharacteristicValueReference),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(EvidencereportSubjectCharacteristicValueCodeableconcept),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(EvidencereportSubjectCharacteristicValueRange),
    ],
  )
}

pub fn evidencereport_subject_characteristic_new(
  value value: EvidencereportSubjectCharacteristicValue,
  code code: Codeableconcept,
) -> EvidencereportSubjectCharacteristic {
  EvidencereportSubjectCharacteristic(
    period: None,
    exclude: None,
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportRelatesto {
  EvidencereportRelatesto(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Reportrelationtype,
    target: EvidencereportRelatestoTarget,
  )
}

pub fn evidencereport_relatesto_new(
  target target: EvidencereportRelatestoTarget,
  code code: r5valuesets.Reportrelationtype,
) -> EvidencereportRelatesto {
  EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportRelatestoTarget {
  EvidencereportRelatestoTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: Option(Identifier),
    display: Option(String),
    resource: Option(Reference),
  )
}

pub fn evidencereport_relatesto_target_new() -> EvidencereportRelatestoTarget {
  EvidencereportRelatestoTarget(
    resource: None,
    display: None,
    identifier: None,
    url: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceReport#resource
pub type EvidencereportSection {
  EvidencereportSection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    focus: Option(Codeableconcept),
    focus_reference: Option(Reference),
    author: List(Reference),
    text: Option(Narrative),
    mode: Option(r5valuesets.Listmode),
    ordered_by: Option(Codeableconcept),
    entry_classifier: List(Codeableconcept),
    entry_reference: List(Reference),
    entry_quantity: List(Quantity),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn evidencereport_section_new() -> EvidencereportSection {
  EvidencereportSection(
    empty_reason: None,
    entry_quantity: [],
    entry_reference: [],
    entry_classifier: [],
    ordered_by: None,
    mode: None,
    text: None,
    author: [],
    focus_reference: None,
    focus: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidencereport_section_to_json(
  evidencereport_section: EvidencereportSection,
) -> Json {
  let EvidencereportSection(
    empty_reason:,
    entry_quantity:,
    entry_reference:,
    entry_classifier:,
    ordered_by:,
    mode:,
    text:,
    author:,
    focus_reference:,
    focus:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_section
  let fields = []
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry_quantity {
    [] -> fields
    _ -> [
      #("entryQuantity", json.array(entry_quantity, quantity_to_json)),
      ..fields
    ]
  }
  let fields = case entry_reference {
    [] -> fields
    _ -> [
      #("entryReference", json.array(entry_reference, reference_to_json)),
      ..fields
    ]
  }
  let fields = case entry_classifier {
    [] -> fields
    _ -> [
      #(
        "entryClassifier",
        json.array(entry_classifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case mode {
    Some(v) -> [#("mode", r5valuesets.listmode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, reference_to_json)), ..fields]
  }
  let fields = case focus_reference {
    Some(v) -> [#("focusReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_section_decoder() -> Decoder(EvidencereportSection) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry_quantity <- decode.optional_field(
    "entryQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use entry_reference <- decode.optional_field(
    "entryReference",
    [],
    decode.list(reference_decoder()),
  )
  use entry_classifier <- decode.optional_field(
    "entryClassifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r5valuesets.listmode_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(reference_decoder()),
  )
  use focus_reference <- decode.optional_field(
    "focusReference",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSection(
    empty_reason:,
    entry_quantity:,
    entry_reference:,
    entry_classifier:,
    ordered_by:,
    mode:,
    text:,
    author:,
    focus_reference:,
    focus:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_relatesto_target_to_json(
  evidencereport_relatesto_target: EvidencereportRelatestoTarget,
) -> Json {
  let EvidencereportRelatestoTarget(
    resource:,
    display:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_relatesto_target
  let fields = []
  let fields = case resource {
    Some(v) -> [#("resource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_relatesto_target_decoder() -> Decoder(
  EvidencereportRelatestoTarget,
) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(reference_decoder()),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportRelatestoTarget(
    resource:,
    display:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_relatesto_to_json(
  evidencereport_relatesto: EvidencereportRelatesto,
) -> Json {
  let EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_relatesto
  let fields = [
    #("target", evidencereport_relatesto_target_to_json(target)),
    #("code", r5valuesets.reportrelationtype_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_relatesto_decoder() -> Decoder(EvidencereportRelatesto) {
  use target <- decode.field(
    "target",
    evidencereport_relatesto_target_decoder(),
  )
  use code <- decode.field("code", r5valuesets.reportrelationtype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportRelatesto(
    target:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_subject_characteristic_to_json(
  evidencereport_subject_characteristic: EvidencereportSubjectCharacteristic,
) -> Json {
  let EvidencereportSubjectCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_subject_characteristic
  let fields = [
    #("value", evidencereport_subject_characteristic_value_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exclude {
    Some(v) -> [#("exclude", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_subject_characteristic_decoder() -> Decoder(
  EvidencereportSubjectCharacteristic,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use exclude <- decode.optional_field(
    "exclude",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.then(
    evidencereport_subject_characteristic_value_decoder(),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSubjectCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_subject_to_json(
  evidencereport_subject: EvidencereportSubject,
) -> Json {
  let EvidencereportSubject(
    note:,
    characteristic:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencereport_subject
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(
          characteristic,
          evidencereport_subject_characteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencereport_subject_decoder() -> Decoder(EvidencereportSubject) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(evidencereport_subject_characteristic_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencereportSubject(
    note:,
    characteristic:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencereport_to_json(evidencereport: Evidencereport) -> Json {
  let Evidencereport(
    section:,
    relates_to:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    subject:,
    related_artifact:,
    note:,
    type_:,
    cite_as:,
    related_identifier:,
    identifier:,
    use_context:,
    status:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidencereport
  let fields = [
    #("subject", evidencereport_subject_to_json(subject)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case section {
    [] -> fields
    _ -> [
      #("section", json.array(section, evidencereport_section_to_json)),
      ..fields
    ]
  }
  let fields = case relates_to {
    [] -> fields
    _ -> [
      #("relatesTo", json.array(relates_to, evidencereport_relatesto_to_json)),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cite_as {
    Some(v) -> [
      #(
        "citeAs"
          <> case v {
          EvidencereportCiteasReference(_) -> "Reference"
          EvidencereportCiteasMarkdown(_) -> "Markdown"
        },
        evidencereport_citeas_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_identifier {
    [] -> fields
    _ -> [
      #("relatedIdentifier", json.array(related_identifier, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidencereport")), ..fields]
  json.object(fields)
}

pub fn evidencereport_decoder() -> Decoder(Evidencereport) {
  use section <- decode.optional_field(
    "section",
    [],
    decode.list(evidencereport_section_decoder()),
  )
  use relates_to <- decode.optional_field(
    "relatesTo",
    [],
    decode.list(evidencereport_relatesto_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.field("subject", evidencereport_subject_decoder())
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use cite_as <- decode.then(none_if_omitted(evidencereport_citeas_decoder()))
  use related_identifier <- decode.optional_field(
    "relatedIdentifier",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidencereport",
    decode.failure(evidencereport_new(subject:, status:), "resourceType"),
  )
  decode.success(Evidencereport(
    section:,
    relates_to:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    contact:,
    publisher:,
    subject:,
    related_artifact:,
    note:,
    type_:,
    cite_as:,
    related_identifier:,
    identifier:,
    use_context:,
    status:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type Evidencevariable {
  Evidencevariable(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(EvidencevariableVersionalgorithm),
    name: Option(String),
    title: Option(String),
    short_title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    note: List(Annotation),
    use_context: List(Usagecontext),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    actual: Option(Bool),
    characteristic: List(EvidencevariableCharacteristic),
    handling: Option(r5valuesets.Variablehandling),
    category: List(EvidencevariableCategory),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableVersionalgorithm {
  EvidencevariableVersionalgorithmString(version_algorithm: String)
  EvidencevariableVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn evidencevariable_versionalgorithm_to_json(
  elt: EvidencevariableVersionalgorithm,
) -> Json {
  case elt {
    EvidencevariableVersionalgorithmString(v) -> json.string(v)
    EvidencevariableVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn evidencevariable_versionalgorithm_decoder() -> Decoder(
  EvidencevariableVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(EvidencevariableVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(EvidencevariableVersionalgorithmCoding),
    ],
  )
}

pub fn evidencevariable_new(
  status status: r5valuesets.Publicationstatus,
) -> Evidencevariable {
  Evidencevariable(
    category: [],
    handling: None,
    characteristic: [],
    actual: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    use_context: [],
    note: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    short_title: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristic {
  EvidencevariableCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    description: Option(String),
    note: List(Annotation),
    exclude: Option(Bool),
    definition_reference: Option(Reference),
    definition_canonical: Option(String),
    definition_codeable_concept: Option(Codeableconcept),
    definition_expression: Option(Expression),
    definition_id: Option(String),
    definition_by_type_and_value: Option(
      EvidencevariableCharacteristicDefinitionbytypeandvalue,
    ),
    definition_by_combination: Option(
      EvidencevariableCharacteristicDefinitionbycombination,
    ),
    instances: Option(EvidencevariableCharacteristicInstances),
    duration: Option(EvidencevariableCharacteristicDuration),
    time_from_event: List(EvidencevariableCharacteristicTimefromevent),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicInstances {
  EvidencevariableCharacteristicInstancesQuantity(instances: Quantity)
  EvidencevariableCharacteristicInstancesRange(instances: Range)
}

pub fn evidencevariable_characteristic_instances_to_json(
  elt: EvidencevariableCharacteristicInstances,
) -> Json {
  case elt {
    EvidencevariableCharacteristicInstancesQuantity(v) -> quantity_to_json(v)
    EvidencevariableCharacteristicInstancesRange(v) -> range_to_json(v)
  }
}

pub fn evidencevariable_characteristic_instances_decoder() -> Decoder(
  EvidencevariableCharacteristicInstances,
) {
  decode.one_of(
    decode.field("instancesQuantity", quantity_decoder(), decode.success)
      |> decode.map(EvidencevariableCharacteristicInstancesQuantity),
    [
      decode.field("instancesRange", range_decoder(), decode.success)
      |> decode.map(EvidencevariableCharacteristicInstancesRange),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDuration {
  EvidencevariableCharacteristicDurationQuantity(duration: Quantity)
  EvidencevariableCharacteristicDurationRange(duration: Range)
}

pub fn evidencevariable_characteristic_duration_to_json(
  elt: EvidencevariableCharacteristicDuration,
) -> Json {
  case elt {
    EvidencevariableCharacteristicDurationQuantity(v) -> quantity_to_json(v)
    EvidencevariableCharacteristicDurationRange(v) -> range_to_json(v)
  }
}

pub fn evidencevariable_characteristic_duration_decoder() -> Decoder(
  EvidencevariableCharacteristicDuration,
) {
  decode.one_of(
    decode.field("durationQuantity", quantity_decoder(), decode.success)
      |> decode.map(EvidencevariableCharacteristicDurationQuantity),
    [
      decode.field("durationRange", range_decoder(), decode.success)
      |> decode.map(EvidencevariableCharacteristicDurationRange),
    ],
  )
}

pub fn evidencevariable_characteristic_new() -> EvidencevariableCharacteristic {
  EvidencevariableCharacteristic(
    time_from_event: [],
    duration: None,
    instances: None,
    definition_by_combination: None,
    definition_by_type_and_value: None,
    definition_id: None,
    definition_expression: None,
    definition_codeable_concept: None,
    definition_canonical: None,
    definition_reference: None,
    exclude: None,
    note: [],
    description: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDefinitionbytypeandvalue {
  EvidencevariableCharacteristicDefinitionbytypeandvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    method: List(Codeableconcept),
    device: Option(Reference),
    value: EvidencevariableCharacteristicDefinitionbytypeandvalueValue,
    offset: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDefinitionbytypeandvalueValue {
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueCodeableconcept(
    value: Codeableconcept,
  )
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueBoolean(
    value: Bool,
  )
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueQuantity(
    value: Quantity,
  )
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueRange(value: Range)
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueReference(
    value: Reference,
  )
  EvidencevariableCharacteristicDefinitionbytypeandvalueValueId(value: String)
}

pub fn evidencevariable_characteristic_definitionbytypeandvalue_value_to_json(
  elt: EvidencevariableCharacteristicDefinitionbytypeandvalueValue,
) -> Json {
  case elt {
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueCodeableconcept(
      v,
    ) -> codeableconcept_to_json(v)
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueBoolean(v) ->
      json.bool(v)
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueQuantity(v) ->
      quantity_to_json(v)
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueRange(v) ->
      range_to_json(v)
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueReference(v) ->
      reference_to_json(v)
    EvidencevariableCharacteristicDefinitionbytypeandvalueValueId(v) ->
      json.string(v)
  }
}

pub fn evidencevariable_characteristic_definitionbytypeandvalue_value_decoder() -> Decoder(
  EvidencevariableCharacteristicDefinitionbytypeandvalueValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        EvidencevariableCharacteristicDefinitionbytypeandvalueValueCodeableconcept,
      ),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(
          EvidencevariableCharacteristicDefinitionbytypeandvalueValueBoolean,
        ),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(
          EvidencevariableCharacteristicDefinitionbytypeandvalueValueQuantity,
        ),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(
          EvidencevariableCharacteristicDefinitionbytypeandvalueValueRange,
        ),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(
          EvidencevariableCharacteristicDefinitionbytypeandvalueValueReference,
        ),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(
          EvidencevariableCharacteristicDefinitionbytypeandvalueValueId,
        ),
    ],
  )
}

pub fn evidencevariable_characteristic_definitionbytypeandvalue_new(
  value value: EvidencevariableCharacteristicDefinitionbytypeandvalueValue,
  type_ type_: Codeableconcept,
) -> EvidencevariableCharacteristicDefinitionbytypeandvalue {
  EvidencevariableCharacteristicDefinitionbytypeandvalue(
    offset: None,
    value:,
    device: None,
    method: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicDefinitionbycombination {
  EvidencevariableCharacteristicDefinitionbycombination(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Characteristiccombination,
    threshold: Option(Int),
  )
}

pub fn evidencevariable_characteristic_definitionbycombination_new(
  code code: r5valuesets.Characteristiccombination,
) -> EvidencevariableCharacteristicDefinitionbycombination {
  EvidencevariableCharacteristicDefinitionbycombination(
    threshold: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicTimefromevent {
  EvidencevariableCharacteristicTimefromevent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    note: List(Annotation),
    event: Option(EvidencevariableCharacteristicTimefromeventEvent),
    quantity: Option(Quantity),
    range: Option(Range),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCharacteristicTimefromeventEvent {
  EvidencevariableCharacteristicTimefromeventEventCodeableconcept(
    event: Codeableconcept,
  )
  EvidencevariableCharacteristicTimefromeventEventReference(event: Reference)
  EvidencevariableCharacteristicTimefromeventEventDatetime(event: String)
  EvidencevariableCharacteristicTimefromeventEventId(event: String)
}

pub fn evidencevariable_characteristic_timefromevent_event_to_json(
  elt: EvidencevariableCharacteristicTimefromeventEvent,
) -> Json {
  case elt {
    EvidencevariableCharacteristicTimefromeventEventCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencevariableCharacteristicTimefromeventEventReference(v) ->
      reference_to_json(v)
    EvidencevariableCharacteristicTimefromeventEventDatetime(v) ->
      json.string(v)
    EvidencevariableCharacteristicTimefromeventEventId(v) -> json.string(v)
  }
}

pub fn evidencevariable_characteristic_timefromevent_event_decoder() -> Decoder(
  EvidencevariableCharacteristicTimefromeventEvent,
) {
  decode.one_of(
    decode.field(
      "eventCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        EvidencevariableCharacteristicTimefromeventEventCodeableconcept,
      ),
    [
      decode.field("eventReference", reference_decoder(), decode.success)
        |> decode.map(EvidencevariableCharacteristicTimefromeventEventReference),
      decode.field("eventDateTime", decode.string, decode.success)
        |> decode.map(EvidencevariableCharacteristicTimefromeventEventDatetime),
      decode.field("eventId", decode.string, decode.success)
        |> decode.map(EvidencevariableCharacteristicTimefromeventEventId),
    ],
  )
}

pub fn evidencevariable_characteristic_timefromevent_new() -> EvidencevariableCharacteristicTimefromevent {
  EvidencevariableCharacteristicTimefromevent(
    range: None,
    quantity: None,
    event: None,
    note: [],
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCategory {
  EvidencevariableCategory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    value: Option(EvidencevariableCategoryValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/EvidenceVariable#resource
pub type EvidencevariableCategoryValue {
  EvidencevariableCategoryValueCodeableconcept(value: Codeableconcept)
  EvidencevariableCategoryValueQuantity(value: Quantity)
  EvidencevariableCategoryValueRange(value: Range)
}

pub fn evidencevariable_category_value_to_json(
  elt: EvidencevariableCategoryValue,
) -> Json {
  case elt {
    EvidencevariableCategoryValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    EvidencevariableCategoryValueQuantity(v) -> quantity_to_json(v)
    EvidencevariableCategoryValueRange(v) -> range_to_json(v)
  }
}

pub fn evidencevariable_category_value_decoder() -> Decoder(
  EvidencevariableCategoryValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(EvidencevariableCategoryValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(EvidencevariableCategoryValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(EvidencevariableCategoryValueRange),
    ],
  )
}

pub fn evidencevariable_category_new() -> EvidencevariableCategory {
  EvidencevariableCategory(
    value: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn evidencevariable_category_to_json(
  evidencevariable_category: EvidencevariableCategory,
) -> Json {
  let EvidencevariableCategory(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_category
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          EvidencevariableCategoryValueCodeableconcept(_) -> "Codeableconcept"
          EvidencevariableCategoryValueQuantity(_) -> "Quantity"
          EvidencevariableCategoryValueRange(_) -> "Range"
        },
        evidencevariable_category_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_category_decoder() -> Decoder(EvidencevariableCategory) {
  use value <- decode.then(
    none_if_omitted(evidencevariable_category_value_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCategory(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_timefromevent_to_json(
  evidencevariable_characteristic_timefromevent: EvidencevariableCharacteristicTimefromevent,
) -> Json {
  let EvidencevariableCharacteristicTimefromevent(
    range:,
    quantity:,
    event:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic_timefromevent
  let fields = []
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    Some(v) -> [
      #(
        "event"
          <> case v {
          EvidencevariableCharacteristicTimefromeventEventCodeableconcept(_) ->
            "Codeableconcept"
          EvidencevariableCharacteristicTimefromeventEventReference(_) ->
            "Reference"
          EvidencevariableCharacteristicTimefromeventEventDatetime(_) ->
            "Datetime"
          EvidencevariableCharacteristicTimefromeventEventId(_) -> "Id"
        },
        evidencevariable_characteristic_timefromevent_event_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_timefromevent_decoder() -> Decoder(
  EvidencevariableCharacteristicTimefromevent,
) {
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use event <- decode.then(
    none_if_omitted(
      evidencevariable_characteristic_timefromevent_event_decoder(),
    ),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristicTimefromevent(
    range:,
    quantity:,
    event:,
    note:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_definitionbycombination_to_json(
  evidencevariable_characteristic_definitionbycombination: EvidencevariableCharacteristicDefinitionbycombination,
) -> Json {
  let EvidencevariableCharacteristicDefinitionbycombination(
    threshold:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic_definitionbycombination
  let fields = [
    #("code", r5valuesets.characteristiccombination_to_json(code)),
  ]
  let fields = case threshold {
    Some(v) -> [#("threshold", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_definitionbycombination_decoder() -> Decoder(
  EvidencevariableCharacteristicDefinitionbycombination,
) {
  use threshold <- decode.optional_field(
    "threshold",
    None,
    decode.optional(decode.int),
  )
  use code <- decode.field(
    "code",
    r5valuesets.characteristiccombination_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristicDefinitionbycombination(
    threshold:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_definitionbytypeandvalue_to_json(
  evidencevariable_characteristic_definitionbytypeandvalue: EvidencevariableCharacteristicDefinitionbytypeandvalue,
) -> Json {
  let EvidencevariableCharacteristicDefinitionbytypeandvalue(
    offset:,
    value:,
    device:,
    method:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic_definitionbytypeandvalue
  let fields = [
    #(
      "value",
      evidencevariable_characteristic_definitionbytypeandvalue_value_to_json(
        value,
      ),
    ),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case offset {
    Some(v) -> [#("offset", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    [] -> fields
    _ -> [#("method", json.array(method, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_definitionbytypeandvalue_decoder() -> Decoder(
  EvidencevariableCharacteristicDefinitionbytypeandvalue,
) {
  use offset <- decode.optional_field(
    "offset",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    evidencevariable_characteristic_definitionbytypeandvalue_value_decoder(),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristicDefinitionbytypeandvalue(
    offset:,
    value:,
    device:,
    method:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_characteristic_to_json(
  evidencevariable_characteristic: EvidencevariableCharacteristic,
) -> Json {
  let EvidencevariableCharacteristic(
    time_from_event:,
    duration:,
    instances:,
    definition_by_combination:,
    definition_by_type_and_value:,
    definition_id:,
    definition_expression:,
    definition_codeable_concept:,
    definition_canonical:,
    definition_reference:,
    exclude:,
    note:,
    description:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = evidencevariable_characteristic
  let fields = []
  let fields = case time_from_event {
    [] -> fields
    _ -> [
      #(
        "timeFromEvent",
        json.array(
          time_from_event,
          evidencevariable_characteristic_timefromevent_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case duration {
    Some(v) -> [
      #(
        "duration"
          <> case v {
          EvidencevariableCharacteristicDurationQuantity(_) -> "Quantity"
          EvidencevariableCharacteristicDurationRange(_) -> "Range"
        },
        evidencevariable_characteristic_duration_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case instances {
    Some(v) -> [
      #(
        "instances"
          <> case v {
          EvidencevariableCharacteristicInstancesQuantity(_) -> "Quantity"
          EvidencevariableCharacteristicInstancesRange(_) -> "Range"
        },
        evidencevariable_characteristic_instances_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition_by_combination {
    Some(v) -> [
      #(
        "definitionByCombination",
        evidencevariable_characteristic_definitionbycombination_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition_by_type_and_value {
    Some(v) -> [
      #(
        "definitionByTypeAndValue",
        evidencevariable_characteristic_definitionbytypeandvalue_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition_id {
    Some(v) -> [#("definitionId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition_expression {
    Some(v) -> [#("definitionExpression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case definition_codeable_concept {
    Some(v) -> [
      #("definitionCodeableConcept", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition_canonical {
    Some(v) -> [#("definitionCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition_reference {
    Some(v) -> [#("definitionReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case exclude {
    Some(v) -> [#("exclude", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn evidencevariable_characteristic_decoder() -> Decoder(
  EvidencevariableCharacteristic,
) {
  use time_from_event <- decode.optional_field(
    "timeFromEvent",
    [],
    decode.list(evidencevariable_characteristic_timefromevent_decoder()),
  )
  use duration <- decode.then(
    none_if_omitted(evidencevariable_characteristic_duration_decoder()),
  )
  use instances <- decode.then(
    none_if_omitted(evidencevariable_characteristic_instances_decoder()),
  )
  use definition_by_combination <- decode.optional_field(
    "definitionByCombination",
    None,
    decode.optional(
      evidencevariable_characteristic_definitionbycombination_decoder(),
    ),
  )
  use definition_by_type_and_value <- decode.optional_field(
    "definitionByTypeAndValue",
    None,
    decode.optional(
      evidencevariable_characteristic_definitionbytypeandvalue_decoder(),
    ),
  )
  use definition_id <- decode.optional_field(
    "definitionId",
    None,
    decode.optional(decode.string),
  )
  use definition_expression <- decode.optional_field(
    "definitionExpression",
    None,
    decode.optional(expression_decoder()),
  )
  use definition_codeable_concept <- decode.optional_field(
    "definitionCodeableConcept",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use definition_canonical <- decode.optional_field(
    "definitionCanonical",
    None,
    decode.optional(decode.string),
  )
  use definition_reference <- decode.optional_field(
    "definitionReference",
    None,
    decode.optional(reference_decoder()),
  )
  use exclude <- decode.optional_field(
    "exclude",
    None,
    decode.optional(decode.bool),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(EvidencevariableCharacteristic(
    time_from_event:,
    duration:,
    instances:,
    definition_by_combination:,
    definition_by_type_and_value:,
    definition_id:,
    definition_expression:,
    definition_codeable_concept:,
    definition_canonical:,
    definition_reference:,
    exclude:,
    note:,
    description:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn evidencevariable_to_json(evidencevariable: Evidencevariable) -> Json {
  let Evidencevariable(
    category:,
    handling:,
    characteristic:,
    actual:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    use_context:,
    note:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    short_title:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = evidencevariable
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, evidencevariable_category_to_json)),
      ..fields
    ]
  }
  let fields = case handling {
    Some(v) -> [
      #("handling", r5valuesets.variablehandling_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, evidencevariable_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case short_title {
    Some(v) -> [#("shortTitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          EvidencevariableVersionalgorithmString(_) -> "String"
          EvidencevariableVersionalgorithmCoding(_) -> "Coding"
        },
        evidencevariable_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Evidencevariable")), ..fields]
  json.object(fields)
}

pub fn evidencevariable_decoder() -> Decoder(Evidencevariable) {
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(evidencevariable_category_decoder()),
  )
  use handling <- decode.optional_field(
    "handling",
    None,
    decode.optional(r5valuesets.variablehandling_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(evidencevariable_characteristic_decoder()),
  )
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use short_title <- decode.optional_field(
    "shortTitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(evidencevariable_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Evidencevariable",
    decode.failure(evidencevariable_new(status:), "resourceType"),
  )
  decode.success(Evidencevariable(
    category:,
    handling:,
    characteristic:,
    actual:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    use_context:,
    note:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    short_title:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type Examplescenario {
  Examplescenario(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ExamplescenarioVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    actor: List(ExamplescenarioActor),
    instance: List(ExamplescenarioInstance),
    process: List(ExamplescenarioProcess),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioVersionalgorithm {
  ExamplescenarioVersionalgorithmString(version_algorithm: String)
  ExamplescenarioVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn examplescenario_versionalgorithm_to_json(
  elt: ExamplescenarioVersionalgorithm,
) -> Json {
  case elt {
    ExamplescenarioVersionalgorithmString(v) -> json.string(v)
    ExamplescenarioVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn examplescenario_versionalgorithm_decoder() -> Decoder(
  ExamplescenarioVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ExamplescenarioVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ExamplescenarioVersionalgorithmCoding),
    ],
  )
}

pub fn examplescenario_new(
  status status: r5valuesets.Publicationstatus,
) -> Examplescenario {
  Examplescenario(
    process: [],
    instance: [],
    actor: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioActor {
  ExamplescenarioActor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    key: String,
    type_: r5valuesets.Examplescenarioactortype,
    title: String,
    description: Option(String),
  )
}

pub fn examplescenario_actor_new(
  title title: String,
  type_ type_: r5valuesets.Examplescenarioactortype,
  key key: String,
) -> ExamplescenarioActor {
  ExamplescenarioActor(
    description: None,
    title:,
    type_:,
    key:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstance {
  ExamplescenarioInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    key: String,
    structure_type: Coding,
    structure_version: Option(String),
    structure_profile: Option(ExamplescenarioInstanceStructureprofile),
    title: String,
    description: Option(String),
    content: Option(Reference),
    version: List(ExamplescenarioInstanceVersion),
    contained_instance: List(ExamplescenarioInstanceContainedinstance),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceStructureprofile {
  ExamplescenarioInstanceStructureprofileCanonical(structure_profile: String)
  ExamplescenarioInstanceStructureprofileUri(structure_profile: String)
}

pub fn examplescenario_instance_structureprofile_to_json(
  elt: ExamplescenarioInstanceStructureprofile,
) -> Json {
  case elt {
    ExamplescenarioInstanceStructureprofileCanonical(v) -> json.string(v)
    ExamplescenarioInstanceStructureprofileUri(v) -> json.string(v)
  }
}

pub fn examplescenario_instance_structureprofile_decoder() -> Decoder(
  ExamplescenarioInstanceStructureprofile,
) {
  decode.one_of(
    decode.field("structureProfileCanonical", decode.string, decode.success)
      |> decode.map(ExamplescenarioInstanceStructureprofileCanonical),
    [
      decode.field("structureProfileUri", decode.string, decode.success)
      |> decode.map(ExamplescenarioInstanceStructureprofileUri),
    ],
  )
}

pub fn examplescenario_instance_new(
  title title: String,
  structure_type structure_type: Coding,
  key key: String,
) -> ExamplescenarioInstance {
  ExamplescenarioInstance(
    contained_instance: [],
    version: [],
    content: None,
    description: None,
    title:,
    structure_profile: None,
    structure_version: None,
    structure_type:,
    key:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceVersion {
  ExamplescenarioInstanceVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    key: String,
    title: String,
    description: Option(String),
    content: Option(Reference),
  )
}

pub fn examplescenario_instance_version_new(
  title title: String,
  key key: String,
) -> ExamplescenarioInstanceVersion {
  ExamplescenarioInstanceVersion(
    content: None,
    description: None,
    title:,
    key:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioInstanceContainedinstance {
  ExamplescenarioInstanceContainedinstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    instance_reference: String,
    version_reference: Option(String),
  )
}

pub fn examplescenario_instance_containedinstance_new(
  instance_reference instance_reference: String,
) -> ExamplescenarioInstanceContainedinstance {
  ExamplescenarioInstanceContainedinstance(
    version_reference: None,
    instance_reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcess {
  ExamplescenarioProcess(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: String,
    description: Option(String),
    pre_conditions: Option(String),
    post_conditions: Option(String),
    step: List(ExamplescenarioProcessStep),
  )
}

pub fn examplescenario_process_new(
  title title: String,
) -> ExamplescenarioProcess {
  ExamplescenarioProcess(
    step: [],
    post_conditions: None,
    pre_conditions: None,
    description: None,
    title:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStep {
  ExamplescenarioProcessStep(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: Option(String),
    workflow: Option(String),
    operation: Option(ExamplescenarioProcessStepOperation),
    alternative: List(ExamplescenarioProcessStepAlternative),
    pause: Option(Bool),
  )
}

pub fn examplescenario_process_step_new() -> ExamplescenarioProcessStep {
  ExamplescenarioProcessStep(
    pause: None,
    alternative: [],
    operation: None,
    workflow: None,
    number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepOperation {
  ExamplescenarioProcessStepOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Coding),
    title: String,
    initiator: Option(String),
    receiver: Option(String),
    description: Option(String),
    initiator_active: Option(Bool),
    receiver_active: Option(Bool),
  )
}

pub fn examplescenario_process_step_operation_new(
  title title: String,
) -> ExamplescenarioProcessStepOperation {
  ExamplescenarioProcessStepOperation(
    receiver_active: None,
    initiator_active: None,
    description: None,
    receiver: None,
    initiator: None,
    title:,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExampleScenario#resource
pub type ExamplescenarioProcessStepAlternative {
  ExamplescenarioProcessStepAlternative(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: String,
    description: Option(String),
  )
}

pub fn examplescenario_process_step_alternative_new(
  title title: String,
) -> ExamplescenarioProcessStepAlternative {
  ExamplescenarioProcessStepAlternative(
    description: None,
    title:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn examplescenario_process_step_alternative_to_json(
  examplescenario_process_step_alternative: ExamplescenarioProcessStepAlternative,
) -> Json {
  let ExamplescenarioProcessStepAlternative(
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step_alternative
  let fields = [
    #("title", json.string(title)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_alternative_decoder() -> Decoder(
  ExamplescenarioProcessStepAlternative,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStepAlternative(
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_step_operation_to_json(
  examplescenario_process_step_operation: ExamplescenarioProcessStepOperation,
) -> Json {
  let ExamplescenarioProcessStepOperation(
    receiver_active:,
    initiator_active:,
    description:,
    receiver:,
    initiator:,
    title:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step_operation
  let fields = [
    #("title", json.string(title)),
  ]
  let fields = case receiver_active {
    Some(v) -> [#("receiverActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case initiator_active {
    Some(v) -> [#("initiatorActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case receiver {
    Some(v) -> [#("receiver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case initiator {
    Some(v) -> [#("initiator", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_operation_decoder() -> Decoder(
  ExamplescenarioProcessStepOperation,
) {
  use receiver_active <- decode.optional_field(
    "receiverActive",
    None,
    decode.optional(decode.bool),
  )
  use initiator_active <- decode.optional_field(
    "initiatorActive",
    None,
    decode.optional(decode.bool),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use receiver <- decode.optional_field(
    "receiver",
    None,
    decode.optional(decode.string),
  )
  use initiator <- decode.optional_field(
    "initiator",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(coding_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStepOperation(
    receiver_active:,
    initiator_active:,
    description:,
    receiver:,
    initiator:,
    title:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_step_to_json(
  examplescenario_process_step: ExamplescenarioProcessStep,
) -> Json {
  let ExamplescenarioProcessStep(
    pause:,
    alternative:,
    operation:,
    workflow:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process_step
  let fields = []
  let fields = case pause {
    Some(v) -> [#("pause", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case alternative {
    [] -> fields
    _ -> [
      #(
        "alternative",
        json.array(
          alternative,
          examplescenario_process_step_alternative_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", examplescenario_process_step_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case workflow {
    Some(v) -> [#("workflow", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_step_decoder() -> Decoder(
  ExamplescenarioProcessStep,
) {
  use pause <- decode.optional_field(
    "pause",
    None,
    decode.optional(decode.bool),
  )
  use alternative <- decode.optional_field(
    "alternative",
    [],
    decode.list(examplescenario_process_step_alternative_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(examplescenario_process_step_operation_decoder()),
  )
  use workflow <- decode.optional_field(
    "workflow",
    None,
    decode.optional(decode.string),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcessStep(
    pause:,
    alternative:,
    operation:,
    workflow:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_process_to_json(
  examplescenario_process: ExamplescenarioProcess,
) -> Json {
  let ExamplescenarioProcess(
    step:,
    post_conditions:,
    pre_conditions:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_process
  let fields = [
    #("title", json.string(title)),
  ]
  let fields = case step {
    [] -> fields
    _ -> [
      #("step", json.array(step, examplescenario_process_step_to_json)),
      ..fields
    ]
  }
  let fields = case post_conditions {
    Some(v) -> [#("postConditions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case pre_conditions {
    Some(v) -> [#("preConditions", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_process_decoder() -> Decoder(ExamplescenarioProcess) {
  use step <- decode.optional_field(
    "step",
    [],
    decode.list(examplescenario_process_step_decoder()),
  )
  use post_conditions <- decode.optional_field(
    "postConditions",
    None,
    decode.optional(decode.string),
  )
  use pre_conditions <- decode.optional_field(
    "preConditions",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioProcess(
    step:,
    post_conditions:,
    pre_conditions:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_containedinstance_to_json(
  examplescenario_instance_containedinstance: ExamplescenarioInstanceContainedinstance,
) -> Json {
  let ExamplescenarioInstanceContainedinstance(
    version_reference:,
    instance_reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance_containedinstance
  let fields = [
    #("instanceReference", json.string(instance_reference)),
  ]
  let fields = case version_reference {
    Some(v) -> [#("versionReference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_containedinstance_decoder() -> Decoder(
  ExamplescenarioInstanceContainedinstance,
) {
  use version_reference <- decode.optional_field(
    "versionReference",
    None,
    decode.optional(decode.string),
  )
  use instance_reference <- decode.field("instanceReference", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstanceContainedinstance(
    version_reference:,
    instance_reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_version_to_json(
  examplescenario_instance_version: ExamplescenarioInstanceVersion,
) -> Json {
  let ExamplescenarioInstanceVersion(
    content:,
    description:,
    title:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance_version
  let fields = [
    #("title", json.string(title)),
    #("key", json.string(key)),
  ]
  let fields = case content {
    Some(v) -> [#("content", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_version_decoder() -> Decoder(
  ExamplescenarioInstanceVersion,
) {
  use content <- decode.optional_field(
    "content",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use key <- decode.field("key", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstanceVersion(
    content:,
    description:,
    title:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_instance_to_json(
  examplescenario_instance: ExamplescenarioInstance,
) -> Json {
  let ExamplescenarioInstance(
    contained_instance:,
    version:,
    content:,
    description:,
    title:,
    structure_profile:,
    structure_version:,
    structure_type:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_instance
  let fields = [
    #("title", json.string(title)),
    #("structureType", coding_to_json(structure_type)),
    #("key", json.string(key)),
  ]
  let fields = case contained_instance {
    [] -> fields
    _ -> [
      #(
        "containedInstance",
        json.array(
          contained_instance,
          examplescenario_instance_containedinstance_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case version {
    [] -> fields
    _ -> [
      #(
        "version",
        json.array(version, examplescenario_instance_version_to_json),
      ),
      ..fields
    ]
  }
  let fields = case content {
    Some(v) -> [#("content", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case structure_profile {
    Some(v) -> [
      #(
        "structureProfile"
          <> case v {
          ExamplescenarioInstanceStructureprofileCanonical(_) -> "Canonical"
          ExamplescenarioInstanceStructureprofileUri(_) -> "Uri"
        },
        examplescenario_instance_structureprofile_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case structure_version {
    Some(v) -> [#("structureVersion", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_instance_decoder() -> Decoder(ExamplescenarioInstance) {
  use contained_instance <- decode.optional_field(
    "containedInstance",
    [],
    decode.list(examplescenario_instance_containedinstance_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(examplescenario_instance_version_decoder()),
  )
  use content <- decode.optional_field(
    "content",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use structure_profile <- decode.then(
    none_if_omitted(examplescenario_instance_structureprofile_decoder()),
  )
  use structure_version <- decode.optional_field(
    "structureVersion",
    None,
    decode.optional(decode.string),
  )
  use structure_type <- decode.field("structureType", coding_decoder())
  use key <- decode.field("key", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioInstance(
    contained_instance:,
    version:,
    content:,
    description:,
    title:,
    structure_profile:,
    structure_version:,
    structure_type:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_actor_to_json(
  examplescenario_actor: ExamplescenarioActor,
) -> Json {
  let ExamplescenarioActor(
    description:,
    title:,
    type_:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ) = examplescenario_actor
  let fields = [
    #("title", json.string(title)),
    #("type", r5valuesets.examplescenarioactortype_to_json(type_)),
    #("key", json.string(key)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn examplescenario_actor_decoder() -> Decoder(ExamplescenarioActor) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.field("title", decode.string)
  use type_ <- decode.field(
    "type",
    r5valuesets.examplescenarioactortype_decoder(),
  )
  use key <- decode.field("key", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExamplescenarioActor(
    description:,
    title:,
    type_:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn examplescenario_to_json(examplescenario: Examplescenario) -> Json {
  let Examplescenario(
    process:,
    instance:,
    actor:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = examplescenario
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case process {
    [] -> fields
    _ -> [
      #("process", json.array(process, examplescenario_process_to_json)),
      ..fields
    ]
  }
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, examplescenario_instance_to_json)),
      ..fields
    ]
  }
  let fields = case actor {
    [] -> fields
    _ -> [
      #("actor", json.array(actor, examplescenario_actor_to_json)),
      ..fields
    ]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ExamplescenarioVersionalgorithmString(_) -> "String"
          ExamplescenarioVersionalgorithmCoding(_) -> "Coding"
        },
        examplescenario_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Examplescenario")), ..fields]
  json.object(fields)
}

pub fn examplescenario_decoder() -> Decoder(Examplescenario) {
  use process <- decode.optional_field(
    "process",
    [],
    decode.list(examplescenario_process_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(examplescenario_instance_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(examplescenario_actor_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(examplescenario_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Examplescenario",
    decode.failure(examplescenario_new(status:), "resourceType"),
  )
  decode.success(Examplescenario(
    process:,
    instance:,
    actor:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type Explanationofbenefit {
  Explanationofbenefit(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    trace_number: List(Identifier),
    status: r5valuesets.Explanationofbenefitstatus,
    type_: Codeableconcept,
    sub_type: Option(Codeableconcept),
    use_: r5valuesets.Claimuse,
    patient: Reference,
    billable_period: Option(Period),
    created: String,
    enterer: Option(Reference),
    insurer: Option(Reference),
    provider: Option(Reference),
    priority: Option(Codeableconcept),
    funds_reserve_requested: Option(Codeableconcept),
    funds_reserve: Option(Codeableconcept),
    related: List(ExplanationofbenefitRelated),
    prescription: Option(Reference),
    original_prescription: Option(Reference),
    event: List(ExplanationofbenefitEvent),
    payee: Option(ExplanationofbenefitPayee),
    referral: Option(Reference),
    encounter: List(Reference),
    facility: Option(Reference),
    claim: Option(Reference),
    claim_response: Option(Reference),
    outcome: r5valuesets.Claimoutcome,
    decision: Option(Codeableconcept),
    disposition: Option(String),
    pre_auth_ref: List(String),
    pre_auth_ref_period: List(Period),
    diagnosis_related_group: Option(Codeableconcept),
    care_team: List(ExplanationofbenefitCareteam),
    supporting_info: List(ExplanationofbenefitSupportinginfo),
    diagnosis: List(ExplanationofbenefitDiagnosis),
    procedure: List(ExplanationofbenefitProcedure),
    precedence: Option(Int),
    insurance: List(ExplanationofbenefitInsurance),
    accident: Option(ExplanationofbenefitAccident),
    patient_paid: Option(Money),
    item: List(ExplanationofbenefitItem),
    add_item: List(ExplanationofbenefitAdditem),
    total: List(ExplanationofbenefitTotal),
    payment: Option(ExplanationofbenefitPayment),
    form_code: Option(Codeableconcept),
    form: Option(Attachment),
    process_note: List(ExplanationofbenefitProcessnote),
    benefit_period: Option(Period),
    benefit_balance: List(ExplanationofbenefitBenefitbalance),
  )
}

pub fn explanationofbenefit_new(
  outcome outcome: r5valuesets.Claimoutcome,
  created created: String,
  patient patient: Reference,
  use_ use_: r5valuesets.Claimuse,
  type_ type_: Codeableconcept,
  status status: r5valuesets.Explanationofbenefitstatus,
) -> Explanationofbenefit {
  Explanationofbenefit(
    benefit_balance: [],
    benefit_period: None,
    process_note: [],
    form: None,
    form_code: None,
    payment: None,
    total: [],
    add_item: [],
    item: [],
    patient_paid: None,
    accident: None,
    insurance: [],
    precedence: None,
    procedure: [],
    diagnosis: [],
    supporting_info: [],
    care_team: [],
    diagnosis_related_group: None,
    pre_auth_ref_period: [],
    pre_auth_ref: [],
    disposition: None,
    decision: None,
    outcome:,
    claim_response: None,
    claim: None,
    facility: None,
    encounter: [],
    referral: None,
    payee: None,
    event: [],
    original_prescription: None,
    prescription: None,
    related: [],
    funds_reserve: None,
    funds_reserve_requested: None,
    priority: None,
    provider: None,
    insurer: None,
    enterer: None,
    created:,
    billable_period: None,
    patient:,
    use_:,
    sub_type: None,
    type_:,
    status:,
    trace_number: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitRelated {
  ExplanationofbenefitRelated(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    claim: Option(Reference),
    relationship: Option(Codeableconcept),
    reference: Option(Identifier),
  )
}

pub fn explanationofbenefit_related_new() -> ExplanationofbenefitRelated {
  ExplanationofbenefitRelated(
    reference: None,
    relationship: None,
    claim: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitEvent {
  ExplanationofbenefitEvent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    when: ExplanationofbenefitEventWhen,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitEventWhen {
  ExplanationofbenefitEventWhenDatetime(when: String)
  ExplanationofbenefitEventWhenPeriod(when: Period)
}

pub fn explanationofbenefit_event_when_to_json(
  elt: ExplanationofbenefitEventWhen,
) -> Json {
  case elt {
    ExplanationofbenefitEventWhenDatetime(v) -> json.string(v)
    ExplanationofbenefitEventWhenPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_event_when_decoder() -> Decoder(
  ExplanationofbenefitEventWhen,
) {
  decode.one_of(
    decode.field("whenDateTime", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitEventWhenDatetime),
    [
      decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitEventWhenPeriod),
    ],
  )
}

pub fn explanationofbenefit_event_new(
  when when: ExplanationofbenefitEventWhen,
  type_ type_: Codeableconcept,
) -> ExplanationofbenefitEvent {
  ExplanationofbenefitEvent(
    when:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayee {
  ExplanationofbenefitPayee(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    party: Option(Reference),
  )
}

pub fn explanationofbenefit_payee_new() -> ExplanationofbenefitPayee {
  ExplanationofbenefitPayee(
    party: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitCareteam {
  ExplanationofbenefitCareteam(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    provider: Reference,
    responsible: Option(Bool),
    role: Option(Codeableconcept),
    specialty: Option(Codeableconcept),
  )
}

pub fn explanationofbenefit_careteam_new(
  provider provider: Reference,
  sequence sequence: Int,
) -> ExplanationofbenefitCareteam {
  ExplanationofbenefitCareteam(
    specialty: None,
    role: None,
    responsible: None,
    provider:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfo {
  ExplanationofbenefitSupportinginfo(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    category: Codeableconcept,
    code: Option(Codeableconcept),
    timing: Option(ExplanationofbenefitSupportinginfoTiming),
    value: Option(ExplanationofbenefitSupportinginfoValue),
    reason: Option(Coding),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoTiming {
  ExplanationofbenefitSupportinginfoTimingDate(timing: String)
  ExplanationofbenefitSupportinginfoTimingPeriod(timing: Period)
}

pub fn explanationofbenefit_supportinginfo_timing_to_json(
  elt: ExplanationofbenefitSupportinginfoTiming,
) -> Json {
  case elt {
    ExplanationofbenefitSupportinginfoTimingDate(v) -> json.string(v)
    ExplanationofbenefitSupportinginfoTimingPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_supportinginfo_timing_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfoTiming,
) {
  decode.one_of(
    decode.field("timingDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoTimingDate),
    [
      decode.field("timingPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoTimingPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitSupportinginfoValue {
  ExplanationofbenefitSupportinginfoValueBoolean(value: Bool)
  ExplanationofbenefitSupportinginfoValueString(value: String)
  ExplanationofbenefitSupportinginfoValueQuantity(value: Quantity)
  ExplanationofbenefitSupportinginfoValueAttachment(value: Attachment)
  ExplanationofbenefitSupportinginfoValueReference(value: Reference)
  ExplanationofbenefitSupportinginfoValueIdentifier(value: Identifier)
}

pub fn explanationofbenefit_supportinginfo_value_to_json(
  elt: ExplanationofbenefitSupportinginfoValue,
) -> Json {
  case elt {
    ExplanationofbenefitSupportinginfoValueBoolean(v) -> json.bool(v)
    ExplanationofbenefitSupportinginfoValueString(v) -> json.string(v)
    ExplanationofbenefitSupportinginfoValueQuantity(v) -> quantity_to_json(v)
    ExplanationofbenefitSupportinginfoValueAttachment(v) ->
      attachment_to_json(v)
    ExplanationofbenefitSupportinginfoValueReference(v) -> reference_to_json(v)
    ExplanationofbenefitSupportinginfoValueIdentifier(v) ->
      identifier_to_json(v)
  }
}

pub fn explanationofbenefit_supportinginfo_value_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfoValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(ExplanationofbenefitSupportinginfoValueBoolean),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueQuantity),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueReference),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitSupportinginfoValueIdentifier),
    ],
  )
}

pub fn explanationofbenefit_supportinginfo_new(
  category category: Codeableconcept,
  sequence sequence: Int,
) -> ExplanationofbenefitSupportinginfo {
  ExplanationofbenefitSupportinginfo(
    reason: None,
    value: None,
    timing: None,
    code: None,
    category:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosis {
  ExplanationofbenefitDiagnosis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    diagnosis: ExplanationofbenefitDiagnosisDiagnosis,
    type_: List(Codeableconcept),
    on_admission: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitDiagnosisDiagnosis {
  ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(
    diagnosis: Codeableconcept,
  )
  ExplanationofbenefitDiagnosisDiagnosisReference(diagnosis: Reference)
}

pub fn explanationofbenefit_diagnosis_diagnosis_to_json(
  elt: ExplanationofbenefitDiagnosisDiagnosis,
) -> Json {
  case elt {
    ExplanationofbenefitDiagnosisDiagnosisCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitDiagnosisDiagnosisReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_diagnosis_diagnosis_decoder() -> Decoder(
  ExplanationofbenefitDiagnosisDiagnosis,
) {
  decode.one_of(
    decode.field(
      "diagnosisCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitDiagnosisDiagnosisCodeableconcept),
    [
      decode.field("diagnosisReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitDiagnosisDiagnosisReference),
    ],
  )
}

pub fn explanationofbenefit_diagnosis_new(
  diagnosis diagnosis: ExplanationofbenefitDiagnosisDiagnosis,
  sequence sequence: Int,
) -> ExplanationofbenefitDiagnosis {
  ExplanationofbenefitDiagnosis(
    on_admission: None,
    type_: [],
    diagnosis:,
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedure {
  ExplanationofbenefitProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    type_: List(Codeableconcept),
    date: Option(String),
    procedure: ExplanationofbenefitProcedureProcedure,
    udi: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcedureProcedure {
  ExplanationofbenefitProcedureProcedureCodeableconcept(
    procedure: Codeableconcept,
  )
  ExplanationofbenefitProcedureProcedureReference(procedure: Reference)
}

pub fn explanationofbenefit_procedure_procedure_to_json(
  elt: ExplanationofbenefitProcedureProcedure,
) -> Json {
  case elt {
    ExplanationofbenefitProcedureProcedureCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitProcedureProcedureReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_procedure_procedure_decoder() -> Decoder(
  ExplanationofbenefitProcedureProcedure,
) {
  decode.one_of(
    decode.field(
      "procedureCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitProcedureProcedureCodeableconcept),
    [
      decode.field("procedureReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitProcedureProcedureReference),
    ],
  )
}

pub fn explanationofbenefit_procedure_new(
  procedure procedure: ExplanationofbenefitProcedureProcedure,
  sequence sequence: Int,
) -> ExplanationofbenefitProcedure {
  ExplanationofbenefitProcedure(
    udi: [],
    procedure:,
    date: None,
    type_: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitInsurance {
  ExplanationofbenefitInsurance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    focal: Bool,
    coverage: Reference,
    pre_auth_ref: List(String),
  )
}

pub fn explanationofbenefit_insurance_new(
  coverage coverage: Reference,
  focal focal: Bool,
) -> ExplanationofbenefitInsurance {
  ExplanationofbenefitInsurance(
    pre_auth_ref: [],
    coverage:,
    focal:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccident {
  ExplanationofbenefitAccident(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: Option(String),
    type_: Option(Codeableconcept),
    location: Option(ExplanationofbenefitAccidentLocation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAccidentLocation {
  ExplanationofbenefitAccidentLocationAddress(location: Address)
  ExplanationofbenefitAccidentLocationReference(location: Reference)
}

pub fn explanationofbenefit_accident_location_to_json(
  elt: ExplanationofbenefitAccidentLocation,
) -> Json {
  case elt {
    ExplanationofbenefitAccidentLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitAccidentLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_accident_location_decoder() -> Decoder(
  ExplanationofbenefitAccidentLocation,
) {
  decode.one_of(
    decode.field("locationAddress", address_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAccidentLocationAddress),
    [
      decode.field("locationReference", reference_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAccidentLocationReference),
    ],
  )
}

pub fn explanationofbenefit_accident_new() -> ExplanationofbenefitAccident {
  ExplanationofbenefitAccident(
    location: None,
    type_: None,
    date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItem {
  ExplanationofbenefitItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    care_team_sequence: List(Int),
    diagnosis_sequence: List(Int),
    procedure_sequence: List(Int),
    information_sequence: List(Int),
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    request: List(Reference),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ExplanationofbenefitItemServiced),
    location: Option(ExplanationofbenefitItemLocation),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
    body_site: List(ExplanationofbenefitItemBodysite),
    encounter: List(Reference),
    note_number: List(Int),
    review_outcome: Option(ExplanationofbenefitItemReviewoutcome),
    adjudication: List(ExplanationofbenefitItemAdjudication),
    detail: List(ExplanationofbenefitItemDetail),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemServiced {
  ExplanationofbenefitItemServicedDate(serviced: String)
  ExplanationofbenefitItemServicedPeriod(serviced: Period)
}

pub fn explanationofbenefit_item_serviced_to_json(
  elt: ExplanationofbenefitItemServiced,
) -> Json {
  case elt {
    ExplanationofbenefitItemServicedDate(v) -> json.string(v)
    ExplanationofbenefitItemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_item_serviced_decoder() -> Decoder(
  ExplanationofbenefitItemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitItemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitItemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemLocation {
  ExplanationofbenefitItemLocationCodeableconcept(location: Codeableconcept)
  ExplanationofbenefitItemLocationAddress(location: Address)
  ExplanationofbenefitItemLocationReference(location: Reference)
}

pub fn explanationofbenefit_item_location_to_json(
  elt: ExplanationofbenefitItemLocation,
) -> Json {
  case elt {
    ExplanationofbenefitItemLocationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitItemLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitItemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_item_location_decoder() -> Decoder(
  ExplanationofbenefitItemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitItemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitItemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitItemLocationReference),
    ],
  )
}

pub fn explanationofbenefit_item_new(
  sequence sequence: Int,
) -> ExplanationofbenefitItem {
  ExplanationofbenefitItem(
    detail: [],
    adjudication: [],
    review_outcome: None,
    note_number: [],
    encounter: [],
    body_site: [],
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    request: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    trace_number: [],
    information_sequence: [],
    procedure_sequence: [],
    diagnosis_sequence: [],
    care_team_sequence: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemBodysite {
  ExplanationofbenefitItemBodysite(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: List(Codeablereference),
    sub_site: List(Codeableconcept),
  )
}

pub fn explanationofbenefit_item_bodysite_new() -> ExplanationofbenefitItemBodysite {
  ExplanationofbenefitItemBodysite(
    sub_site: [],
    site: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemReviewoutcome {
  ExplanationofbenefitItemReviewoutcome(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    decision: Option(Codeableconcept),
    reason: List(Codeableconcept),
    pre_auth_ref: Option(String),
    pre_auth_period: Option(Period),
  )
}

pub fn explanationofbenefit_item_reviewoutcome_new() -> ExplanationofbenefitItemReviewoutcome {
  ExplanationofbenefitItemReviewoutcome(
    pre_auth_period: None,
    pre_auth_ref: None,
    reason: [],
    decision: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemAdjudication {
  ExplanationofbenefitItemAdjudication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    reason: Option(Codeableconcept),
    amount: Option(Money),
    quantity: Option(Quantity),
  )
}

pub fn explanationofbenefit_item_adjudication_new(
  category category: Codeableconcept,
) -> ExplanationofbenefitItemAdjudication {
  ExplanationofbenefitItemAdjudication(
    quantity: None,
    amount: None,
    reason: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetail {
  ExplanationofbenefitItemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
    note_number: List(Int),
    sub_detail: List(ExplanationofbenefitItemDetailSubdetail),
  )
}

pub fn explanationofbenefit_item_detail_new(
  sequence sequence: Int,
) -> ExplanationofbenefitItemDetail {
  ExplanationofbenefitItemDetail(
    sub_detail: [],
    note_number: [],
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    program_code: [],
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    trace_number: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitItemDetailSubdetail {
  ExplanationofbenefitItemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Int,
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    category: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    udi: List(Reference),
    note_number: List(Int),
  )
}

pub fn explanationofbenefit_item_detail_subdetail_new(
  sequence sequence: Int,
) -> ExplanationofbenefitItemDetailSubdetail {
  ExplanationofbenefitItemDetailSubdetail(
    note_number: [],
    udi: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    program_code: [],
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    category: None,
    revenue: None,
    trace_number: [],
    sequence:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditem {
  ExplanationofbenefitAdditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item_sequence: List(Int),
    detail_sequence: List(Int),
    sub_detail_sequence: List(Int),
    trace_number: List(Identifier),
    provider: List(Reference),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    request: List(Reference),
    modifier: List(Codeableconcept),
    program_code: List(Codeableconcept),
    serviced: Option(ExplanationofbenefitAdditemServiced),
    location: Option(ExplanationofbenefitAdditemLocation),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    body_site: List(ExplanationofbenefitAdditemBodysite),
    note_number: List(Int),
    detail: List(ExplanationofbenefitAdditemDetail),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemServiced {
  ExplanationofbenefitAdditemServicedDate(serviced: String)
  ExplanationofbenefitAdditemServicedPeriod(serviced: Period)
}

pub fn explanationofbenefit_additem_serviced_to_json(
  elt: ExplanationofbenefitAdditemServiced,
) -> Json {
  case elt {
    ExplanationofbenefitAdditemServicedDate(v) -> json.string(v)
    ExplanationofbenefitAdditemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn explanationofbenefit_additem_serviced_decoder() -> Decoder(
  ExplanationofbenefitAdditemServiced,
) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(ExplanationofbenefitAdditemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitAdditemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemLocation {
  ExplanationofbenefitAdditemLocationCodeableconcept(location: Codeableconcept)
  ExplanationofbenefitAdditemLocationAddress(location: Address)
  ExplanationofbenefitAdditemLocationReference(location: Reference)
}

pub fn explanationofbenefit_additem_location_to_json(
  elt: ExplanationofbenefitAdditemLocation,
) -> Json {
  case elt {
    ExplanationofbenefitAdditemLocationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ExplanationofbenefitAdditemLocationAddress(v) -> address_to_json(v)
    ExplanationofbenefitAdditemLocationReference(v) -> reference_to_json(v)
  }
}

pub fn explanationofbenefit_additem_location_decoder() -> Decoder(
  ExplanationofbenefitAdditemLocation,
) {
  decode.one_of(
    decode.field(
      "locationCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ExplanationofbenefitAdditemLocationCodeableconcept),
    [
      decode.field("locationAddress", address_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitAdditemLocationAddress),
      decode.field("locationReference", reference_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitAdditemLocationReference),
    ],
  )
}

pub fn explanationofbenefit_additem_new() -> ExplanationofbenefitAdditem {
  ExplanationofbenefitAdditem(
    detail: [],
    note_number: [],
    body_site: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    location: None,
    serviced: None,
    program_code: [],
    modifier: [],
    request: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    provider: [],
    trace_number: [],
    sub_detail_sequence: [],
    detail_sequence: [],
    item_sequence: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemBodysite {
  ExplanationofbenefitAdditemBodysite(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    site: List(Codeablereference),
    sub_site: List(Codeableconcept),
  )
}

pub fn explanationofbenefit_additem_bodysite_new() -> ExplanationofbenefitAdditemBodysite {
  ExplanationofbenefitAdditemBodysite(
    sub_site: [],
    site: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetail {
  ExplanationofbenefitAdditemDetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    note_number: List(Int),
    sub_detail: List(ExplanationofbenefitAdditemDetailSubdetail),
  )
}

pub fn explanationofbenefit_additem_detail_new() -> ExplanationofbenefitAdditemDetail {
  ExplanationofbenefitAdditemDetail(
    sub_detail: [],
    note_number: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    trace_number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitAdditemDetailSubdetail {
  ExplanationofbenefitAdditemDetailSubdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    trace_number: List(Identifier),
    revenue: Option(Codeableconcept),
    product_or_service: Option(Codeableconcept),
    product_or_service_end: Option(Codeableconcept),
    modifier: List(Codeableconcept),
    patient_paid: Option(Money),
    quantity: Option(Quantity),
    unit_price: Option(Money),
    factor: Option(Float),
    tax: Option(Money),
    net: Option(Money),
    note_number: List(Int),
  )
}

pub fn explanationofbenefit_additem_detail_subdetail_new() -> ExplanationofbenefitAdditemDetailSubdetail {
  ExplanationofbenefitAdditemDetailSubdetail(
    note_number: [],
    net: None,
    tax: None,
    factor: None,
    unit_price: None,
    quantity: None,
    patient_paid: None,
    modifier: [],
    product_or_service_end: None,
    product_or_service: None,
    revenue: None,
    trace_number: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitTotal {
  ExplanationofbenefitTotal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    amount: Money,
  )
}

pub fn explanationofbenefit_total_new(
  amount amount: Money,
  category category: Codeableconcept,
) -> ExplanationofbenefitTotal {
  ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitPayment {
  ExplanationofbenefitPayment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    adjustment: Option(Money),
    adjustment_reason: Option(Codeableconcept),
    date: Option(String),
    amount: Option(Money),
    identifier: Option(Identifier),
  )
}

pub fn explanationofbenefit_payment_new() -> ExplanationofbenefitPayment {
  ExplanationofbenefitPayment(
    identifier: None,
    amount: None,
    date: None,
    adjustment_reason: None,
    adjustment: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitProcessnote {
  ExplanationofbenefitProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    number: Option(Int),
    type_: Option(Codeableconcept),
    text: Option(String),
    language: Option(Codeableconcept),
  )
}

pub fn explanationofbenefit_processnote_new() -> ExplanationofbenefitProcessnote {
  ExplanationofbenefitProcessnote(
    language: None,
    text: None,
    type_: None,
    number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalance {
  ExplanationofbenefitBenefitbalance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    excluded: Option(Bool),
    name: Option(String),
    description: Option(String),
    network: Option(Codeableconcept),
    unit: Option(Codeableconcept),
    term: Option(Codeableconcept),
    financial: List(ExplanationofbenefitBenefitbalanceFinancial),
  )
}

pub fn explanationofbenefit_benefitbalance_new(
  category category: Codeableconcept,
) -> ExplanationofbenefitBenefitbalance {
  ExplanationofbenefitBenefitbalance(
    financial: [],
    term: None,
    unit: None,
    network: None,
    description: None,
    name: None,
    excluded: None,
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancial {
  ExplanationofbenefitBenefitbalanceFinancial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Option(ExplanationofbenefitBenefitbalanceFinancialAllowed),
    used: Option(ExplanationofbenefitBenefitbalanceFinancialUsed),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialAllowed {
  ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(allowed: Int)
  ExplanationofbenefitBenefitbalanceFinancialAllowedString(allowed: String)
  ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(allowed: Money)
}

pub fn explanationofbenefit_benefitbalance_financial_allowed_to_json(
  elt: ExplanationofbenefitBenefitbalanceFinancialAllowed,
) -> Json {
  case elt {
    ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(v) ->
      json.int(v)
    ExplanationofbenefitBenefitbalanceFinancialAllowedString(v) ->
      json.string(v)
    ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(v) ->
      money_to_json(v)
  }
}

pub fn explanationofbenefit_benefitbalance_financial_allowed_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancialAllowed,
) {
  decode.one_of(
    decode.field("allowedUnsignedInt", decode.int, decode.success)
      |> decode.map(
        ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint,
      ),
    [
      decode.field("allowedString", decode.string, decode.success)
        |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedString),
      decode.field("allowedMoney", money_decoder(), decode.success)
        |> decode.map(ExplanationofbenefitBenefitbalanceFinancialAllowedMoney),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ExplanationOfBenefit#resource
pub type ExplanationofbenefitBenefitbalanceFinancialUsed {
  ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(used: Int)
  ExplanationofbenefitBenefitbalanceFinancialUsedMoney(used: Money)
}

pub fn explanationofbenefit_benefitbalance_financial_used_to_json(
  elt: ExplanationofbenefitBenefitbalanceFinancialUsed,
) -> Json {
  case elt {
    ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(v) -> json.int(v)
    ExplanationofbenefitBenefitbalanceFinancialUsedMoney(v) -> money_to_json(v)
  }
}

pub fn explanationofbenefit_benefitbalance_financial_used_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancialUsed,
) {
  decode.one_of(
    decode.field("usedUnsignedInt", decode.int, decode.success)
      |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint),
    [
      decode.field("usedMoney", money_decoder(), decode.success)
      |> decode.map(ExplanationofbenefitBenefitbalanceFinancialUsedMoney),
    ],
  )
}

pub fn explanationofbenefit_benefitbalance_financial_new(
  type_ type_: Codeableconcept,
) -> ExplanationofbenefitBenefitbalanceFinancial {
  ExplanationofbenefitBenefitbalanceFinancial(
    used: None,
    allowed: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn explanationofbenefit_benefitbalance_financial_to_json(
  explanationofbenefit_benefitbalance_financial: ExplanationofbenefitBenefitbalanceFinancial,
) -> Json {
  let ExplanationofbenefitBenefitbalanceFinancial(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_benefitbalance_financial
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case used {
    Some(v) -> [
      #(
        "used"
          <> case v {
          ExplanationofbenefitBenefitbalanceFinancialUsedUnsignedint(_) ->
            "Unsignedint"
          ExplanationofbenefitBenefitbalanceFinancialUsedMoney(_) -> "Money"
        },
        explanationofbenefit_benefitbalance_financial_used_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case allowed {
    Some(v) -> [
      #(
        "allowed"
          <> case v {
          ExplanationofbenefitBenefitbalanceFinancialAllowedUnsignedint(_) ->
            "Unsignedint"
          ExplanationofbenefitBenefitbalanceFinancialAllowedString(_) ->
            "String"
          ExplanationofbenefitBenefitbalanceFinancialAllowedMoney(_) -> "Money"
        },
        explanationofbenefit_benefitbalance_financial_allowed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_benefitbalance_financial_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalanceFinancial,
) {
  use used <- decode.then(
    none_if_omitted(
      explanationofbenefit_benefitbalance_financial_used_decoder(),
    ),
  )
  use allowed <- decode.then(
    none_if_omitted(
      explanationofbenefit_benefitbalance_financial_allowed_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitBenefitbalanceFinancial(
    used:,
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_benefitbalance_to_json(
  explanationofbenefit_benefitbalance: ExplanationofbenefitBenefitbalance,
) -> Json {
  let ExplanationofbenefitBenefitbalance(
    financial:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_benefitbalance
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case financial {
    [] -> fields
    _ -> [
      #(
        "financial",
        json.array(
          financial,
          explanationofbenefit_benefitbalance_financial_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case term {
    Some(v) -> [#("term", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case network {
    Some(v) -> [#("network", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case excluded {
    Some(v) -> [#("excluded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_benefitbalance_decoder() -> Decoder(
  ExplanationofbenefitBenefitbalance,
) {
  use financial <- decode.optional_field(
    "financial",
    [],
    decode.list(explanationofbenefit_benefitbalance_financial_decoder()),
  )
  use term <- decode.optional_field(
    "term",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use excluded <- decode.optional_field(
    "excluded",
    None,
    decode.optional(decode.bool),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitBenefitbalance(
    financial:,
    term:,
    unit:,
    network:,
    description:,
    name:,
    excluded:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_processnote_to_json(
  explanationofbenefit_processnote: ExplanationofbenefitProcessnote,
) -> Json {
  let ExplanationofbenefitProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_processnote
  let fields = []
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_processnote_decoder() -> Decoder(
  ExplanationofbenefitProcessnote,
) {
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitProcessnote(
    language:,
    text:,
    type_:,
    number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_payment_to_json(
  explanationofbenefit_payment: ExplanationofbenefitPayment,
) -> Json {
  let ExplanationofbenefitPayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_payment
  let fields = []
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment_reason {
    Some(v) -> [#("adjustmentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case adjustment {
    Some(v) -> [#("adjustment", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_payment_decoder() -> Decoder(
  ExplanationofbenefitPayment,
) {
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use adjustment_reason <- decode.optional_field(
    "adjustmentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use adjustment <- decode.optional_field(
    "adjustment",
    None,
    decode.optional(money_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitPayment(
    identifier:,
    amount:,
    date:,
    adjustment_reason:,
    adjustment:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_total_to_json(
  explanationofbenefit_total: ExplanationofbenefitTotal,
) -> Json {
  let ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_total
  let fields = [
    #("amount", money_to_json(amount)),
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_total_decoder() -> Decoder(
  ExplanationofbenefitTotal,
) {
  use amount <- decode.field("amount", money_decoder())
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitTotal(
    amount:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_detail_subdetail_to_json(
  explanationofbenefit_additem_detail_subdetail: ExplanationofbenefitAdditemDetailSubdetail,
) -> Json {
  let ExplanationofbenefitAdditemDetailSubdetail(
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem_detail_subdetail
  let fields = []
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_detail_subdetail_decoder() -> Decoder(
  ExplanationofbenefitAdditemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditemDetailSubdetail(
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_detail_to_json(
  explanationofbenefit_additem_detail: ExplanationofbenefitAdditemDetail,
) -> Json {
  let ExplanationofbenefitAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem_detail
  let fields = []
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(
          sub_detail,
          explanationofbenefit_additem_detail_subdetail_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_detail_decoder() -> Decoder(
  ExplanationofbenefitAdditemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(explanationofbenefit_additem_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditemDetail(
    sub_detail:,
    note_number:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    trace_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_bodysite_to_json(
  explanationofbenefit_additem_bodysite: ExplanationofbenefitAdditemBodysite,
) -> Json {
  let ExplanationofbenefitAdditemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem_bodysite
  let fields = []
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, codeablereference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_bodysite_decoder() -> Decoder(
  ExplanationofbenefitAdditemBodysite,
) {
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_additem_to_json(
  explanationofbenefit_additem: ExplanationofbenefitAdditem,
) -> Json {
  let ExplanationofbenefitAdditem(
    detail:,
    note_number:,
    body_site:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    provider:,
    trace_number:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_additem
  let fields = []
  let fields = case detail {
    [] -> fields
    _ -> [
      #(
        "detail",
        json.array(detail, explanationofbenefit_additem_detail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #(
        "bodySite",
        json.array(body_site, explanationofbenefit_additem_bodysite_to_json),
      ),
      ..fields
    ]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitAdditemLocationCodeableconcept(_) ->
            "Codeableconcept"
          ExplanationofbenefitAdditemLocationAddress(_) -> "Address"
          ExplanationofbenefitAdditemLocationReference(_) -> "Reference"
        },
        explanationofbenefit_additem_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ExplanationofbenefitAdditemServicedDate(_) -> "Date"
          ExplanationofbenefitAdditemServicedPeriod(_) -> "Period"
        },
        explanationofbenefit_additem_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    [] -> fields
    _ -> [#("provider", json.array(provider, reference_to_json)), ..fields]
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case sub_detail_sequence {
    [] -> fields
    _ -> [
      #("subDetailSequence", json.array(sub_detail_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case detail_sequence {
    [] -> fields
    _ -> [#("detailSequence", json.array(detail_sequence, json.int)), ..fields]
  }
  let fields = case item_sequence {
    [] -> fields
    _ -> [#("itemSequence", json.array(item_sequence, json.int)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_additem_decoder() -> Decoder(
  ExplanationofbenefitAdditem,
) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(explanationofbenefit_additem_detail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(explanationofbenefit_additem_bodysite_decoder()),
  )
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_additem_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(explanationofbenefit_additem_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    [],
    decode.list(reference_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sub_detail_sequence <- decode.optional_field(
    "subDetailSequence",
    [],
    decode.list(decode.int),
  )
  use detail_sequence <- decode.optional_field(
    "detailSequence",
    [],
    decode.list(decode.int),
  )
  use item_sequence <- decode.optional_field(
    "itemSequence",
    [],
    decode.list(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAdditem(
    detail:,
    note_number:,
    body_site:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    revenue:,
    provider:,
    trace_number:,
    sub_detail_sequence:,
    detail_sequence:,
    item_sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_detail_subdetail_to_json(
  explanationofbenefit_item_detail_subdetail: ExplanationofbenefitItemDetailSubdetail,
) -> Json {
  let ExplanationofbenefitItemDetailSubdetail(
    note_number:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_detail_subdetail
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_detail_subdetail_decoder() -> Decoder(
  ExplanationofbenefitItemDetailSubdetail,
) {
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemDetailSubdetail(
    note_number:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_detail_to_json(
  explanationofbenefit_item_detail: ExplanationofbenefitItemDetail,
) -> Json {
  let ExplanationofbenefitItemDetail(
    sub_detail:,
    note_number:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_detail
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case sub_detail {
    [] -> fields
    _ -> [
      #(
        "subDetail",
        json.array(
          sub_detail,
          explanationofbenefit_item_detail_subdetail_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_detail_decoder() -> Decoder(
  ExplanationofbenefitItemDetail,
) {
  use sub_detail <- decode.optional_field(
    "subDetail",
    [],
    decode.list(explanationofbenefit_item_detail_subdetail_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemDetail(
    sub_detail:,
    note_number:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    program_code:,
    modifier:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_adjudication_to_json(
  explanationofbenefit_item_adjudication: ExplanationofbenefitItemAdjudication,
) -> Json {
  let ExplanationofbenefitItemAdjudication(
    quantity:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_adjudication
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_adjudication_decoder() -> Decoder(
  ExplanationofbenefitItemAdjudication,
) {
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemAdjudication(
    quantity:,
    amount:,
    reason:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_reviewoutcome_to_json(
  explanationofbenefit_item_reviewoutcome: ExplanationofbenefitItemReviewoutcome,
) -> Json {
  let ExplanationofbenefitItemReviewoutcome(
    pre_auth_period:,
    pre_auth_ref:,
    reason:,
    decision:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_reviewoutcome
  let fields = []
  let fields = case pre_auth_period {
    Some(v) -> [#("preAuthPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case pre_auth_ref {
    Some(v) -> [#("preAuthRef", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_reviewoutcome_decoder() -> Decoder(
  ExplanationofbenefitItemReviewoutcome,
) {
  use pre_auth_period <- decode.optional_field(
    "preAuthPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    None,
    decode.optional(decode.string),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemReviewoutcome(
    pre_auth_period:,
    pre_auth_ref:,
    reason:,
    decision:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_bodysite_to_json(
  explanationofbenefit_item_bodysite: ExplanationofbenefitItemBodysite,
) -> Json {
  let ExplanationofbenefitItemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item_bodysite
  let fields = []
  let fields = case sub_site {
    [] -> fields
    _ -> [#("subSite", json.array(sub_site, codeableconcept_to_json)), ..fields]
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, codeablereference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_bodysite_decoder() -> Decoder(
  ExplanationofbenefitItemBodysite,
) {
  use sub_site <- decode.optional_field(
    "subSite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItemBodysite(
    sub_site:,
    site:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_item_to_json(
  explanationofbenefit_item: ExplanationofbenefitItem,
) -> Json {
  let ExplanationofbenefitItem(
    detail:,
    adjudication:,
    review_outcome:,
    note_number:,
    encounter:,
    body_site:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_item
  let fields = [
    #("sequence", json.int(sequence)),
  ]
  let fields = case detail {
    [] -> fields
    _ -> [
      #("detail", json.array(detail, explanationofbenefit_item_detail_to_json)),
      ..fields
    ]
  }
  let fields = case adjudication {
    [] -> fields
    _ -> [
      #(
        "adjudication",
        json.array(adjudication, explanationofbenefit_item_adjudication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case review_outcome {
    Some(v) -> [
      #("reviewOutcome", explanationofbenefit_item_reviewoutcome_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case note_number {
    [] -> fields
    _ -> [#("noteNumber", json.array(note_number, json.int)), ..fields]
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #(
        "bodySite",
        json.array(body_site, explanationofbenefit_item_bodysite_to_json),
      ),
      ..fields
    ]
  }
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case net {
    Some(v) -> [#("net", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tax {
    Some(v) -> [#("tax", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case factor {
    Some(v) -> [#("factor", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case unit_price {
    Some(v) -> [#("unitPrice", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitItemLocationCodeableconcept(_) ->
            "Codeableconcept"
          ExplanationofbenefitItemLocationAddress(_) -> "Address"
          ExplanationofbenefitItemLocationReference(_) -> "Reference"
        },
        explanationofbenefit_item_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          ExplanationofbenefitItemServicedDate(_) -> "Date"
          ExplanationofbenefitItemServicedPeriod(_) -> "Period"
        },
        explanationofbenefit_item_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case program_code {
    [] -> fields
    _ -> [
      #("programCode", json.array(program_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #("modifier", json.array(modifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case product_or_service_end {
    Some(v) -> [#("productOrServiceEnd", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_or_service {
    Some(v) -> [#("productOrService", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case revenue {
    Some(v) -> [#("revenue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case information_sequence {
    [] -> fields
    _ -> [
      #("informationSequence", json.array(information_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case procedure_sequence {
    [] -> fields
    _ -> [
      #("procedureSequence", json.array(procedure_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case diagnosis_sequence {
    [] -> fields
    _ -> [
      #("diagnosisSequence", json.array(diagnosis_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case care_team_sequence {
    [] -> fields
    _ -> [
      #("careTeamSequence", json.array(care_team_sequence, json.int)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_item_decoder() -> Decoder(ExplanationofbenefitItem) {
  use detail <- decode.optional_field(
    "detail",
    [],
    decode.list(explanationofbenefit_item_detail_decoder()),
  )
  use adjudication <- decode.optional_field(
    "adjudication",
    [],
    decode.list(explanationofbenefit_item_adjudication_decoder()),
  )
  use review_outcome <- decode.optional_field(
    "reviewOutcome",
    None,
    decode.optional(explanationofbenefit_item_reviewoutcome_decoder()),
  )
  use note_number <- decode.optional_field(
    "noteNumber",
    [],
    decode.list(decode.int),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(explanationofbenefit_item_bodysite_decoder()),
  )
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use net <- decode.optional_field(
    "net",
    None,
    decode.optional(money_decoder()),
  )
  use tax <- decode.optional_field(
    "tax",
    None,
    decode.optional(money_decoder()),
  )
  use factor <- decode.optional_field(
    "factor",
    None,
    decode.optional(decode.float),
  )
  use unit_price <- decode.optional_field(
    "unitPrice",
    None,
    decode.optional(money_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_item_location_decoder()),
  )
  use serviced <- decode.then(
    none_if_omitted(explanationofbenefit_item_serviced_decoder()),
  )
  use program_code <- decode.optional_field(
    "programCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use product_or_service_end <- decode.optional_field(
    "productOrServiceEnd",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_or_service <- decode.optional_field(
    "productOrService",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use revenue <- decode.optional_field(
    "revenue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use information_sequence <- decode.optional_field(
    "informationSequence",
    [],
    decode.list(decode.int),
  )
  use procedure_sequence <- decode.optional_field(
    "procedureSequence",
    [],
    decode.list(decode.int),
  )
  use diagnosis_sequence <- decode.optional_field(
    "diagnosisSequence",
    [],
    decode.list(decode.int),
  )
  use care_team_sequence <- decode.optional_field(
    "careTeamSequence",
    [],
    decode.list(decode.int),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitItem(
    detail:,
    adjudication:,
    review_outcome:,
    note_number:,
    encounter:,
    body_site:,
    udi:,
    net:,
    tax:,
    factor:,
    unit_price:,
    quantity:,
    patient_paid:,
    location:,
    serviced:,
    program_code:,
    modifier:,
    request:,
    product_or_service_end:,
    product_or_service:,
    category:,
    revenue:,
    trace_number:,
    information_sequence:,
    procedure_sequence:,
    diagnosis_sequence:,
    care_team_sequence:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_accident_to_json(
  explanationofbenefit_accident: ExplanationofbenefitAccident,
) -> Json {
  let ExplanationofbenefitAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_accident
  let fields = []
  let fields = case location {
    Some(v) -> [
      #(
        "location"
          <> case v {
          ExplanationofbenefitAccidentLocationAddress(_) -> "Address"
          ExplanationofbenefitAccidentLocationReference(_) -> "Reference"
        },
        explanationofbenefit_accident_location_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_accident_decoder() -> Decoder(
  ExplanationofbenefitAccident,
) {
  use location <- decode.then(
    none_if_omitted(explanationofbenefit_accident_location_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitAccident(
    location:,
    type_:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_insurance_to_json(
  explanationofbenefit_insurance: ExplanationofbenefitInsurance,
) -> Json {
  let ExplanationofbenefitInsurance(
    pre_auth_ref:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_insurance
  let fields = [
    #("coverage", reference_to_json(coverage)),
    #("focal", json.bool(focal)),
  ]
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_insurance_decoder() -> Decoder(
  ExplanationofbenefitInsurance,
) {
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use coverage <- decode.field("coverage", reference_decoder())
  use focal <- decode.field("focal", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitInsurance(
    pre_auth_ref:,
    coverage:,
    focal:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_procedure_to_json(
  explanationofbenefit_procedure: ExplanationofbenefitProcedure,
) -> Json {
  let ExplanationofbenefitProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_procedure
  let fields = [
    #("procedure", explanationofbenefit_procedure_procedure_to_json(procedure)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case udi {
    [] -> fields
    _ -> [#("udi", json.array(udi, reference_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_procedure_decoder() -> Decoder(
  ExplanationofbenefitProcedure,
) {
  use udi <- decode.optional_field("udi", [], decode.list(reference_decoder()))
  use procedure <- decode.then(
    explanationofbenefit_procedure_procedure_decoder(),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitProcedure(
    udi:,
    procedure:,
    date:,
    type_:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_diagnosis_to_json(
  explanationofbenefit_diagnosis: ExplanationofbenefitDiagnosis,
) -> Json {
  let ExplanationofbenefitDiagnosis(
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_diagnosis
  let fields = [
    #("diagnosis", explanationofbenefit_diagnosis_diagnosis_to_json(diagnosis)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case on_admission {
    Some(v) -> [#("onAdmission", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_diagnosis_decoder() -> Decoder(
  ExplanationofbenefitDiagnosis,
) {
  use on_admission <- decode.optional_field(
    "onAdmission",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use diagnosis <- decode.then(
    explanationofbenefit_diagnosis_diagnosis_decoder(),
  )
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitDiagnosis(
    on_admission:,
    type_:,
    diagnosis:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_supportinginfo_to_json(
  explanationofbenefit_supportinginfo: ExplanationofbenefitSupportinginfo,
) -> Json {
  let ExplanationofbenefitSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_supportinginfo
  let fields = [
    #("category", codeableconcept_to_json(category)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ExplanationofbenefitSupportinginfoValueBoolean(_) -> "Boolean"
          ExplanationofbenefitSupportinginfoValueString(_) -> "String"
          ExplanationofbenefitSupportinginfoValueQuantity(_) -> "Quantity"
          ExplanationofbenefitSupportinginfoValueAttachment(_) -> "Attachment"
          ExplanationofbenefitSupportinginfoValueReference(_) -> "Reference"
          ExplanationofbenefitSupportinginfoValueIdentifier(_) -> "Identifier"
        },
        explanationofbenefit_supportinginfo_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          ExplanationofbenefitSupportinginfoTimingDate(_) -> "Date"
          ExplanationofbenefitSupportinginfoTimingPeriod(_) -> "Period"
        },
        explanationofbenefit_supportinginfo_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_supportinginfo_decoder() -> Decoder(
  ExplanationofbenefitSupportinginfo,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(coding_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(explanationofbenefit_supportinginfo_value_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(explanationofbenefit_supportinginfo_timing_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitSupportinginfo(
    reason:,
    value:,
    timing:,
    code:,
    category:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_careteam_to_json(
  explanationofbenefit_careteam: ExplanationofbenefitCareteam,
) -> Json {
  let ExplanationofbenefitCareteam(
    specialty:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_careteam
  let fields = [
    #("provider", reference_to_json(provider)),
    #("sequence", json.int(sequence)),
  ]
  let fields = case specialty {
    Some(v) -> [#("specialty", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_careteam_decoder() -> Decoder(
  ExplanationofbenefitCareteam,
) {
  use specialty <- decode.optional_field(
    "specialty",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.bool),
  )
  use provider <- decode.field("provider", reference_decoder())
  use sequence <- decode.field("sequence", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitCareteam(
    specialty:,
    role:,
    responsible:,
    provider:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_payee_to_json(
  explanationofbenefit_payee: ExplanationofbenefitPayee,
) -> Json {
  let ExplanationofbenefitPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_payee
  let fields = []
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_payee_decoder() -> Decoder(
  ExplanationofbenefitPayee,
) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitPayee(
    party:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_event_to_json(
  explanationofbenefit_event: ExplanationofbenefitEvent,
) -> Json {
  let ExplanationofbenefitEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_event
  let fields = [
    #("when", explanationofbenefit_event_when_to_json(when)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_event_decoder() -> Decoder(
  ExplanationofbenefitEvent,
) {
  use when <- decode.then(explanationofbenefit_event_when_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitEvent(
    when:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_related_to_json(
  explanationofbenefit_related: ExplanationofbenefitRelated,
) -> Json {
  let ExplanationofbenefitRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ) = explanationofbenefit_related
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    Some(v) -> [#("relationship", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn explanationofbenefit_related_decoder() -> Decoder(
  ExplanationofbenefitRelated,
) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(identifier_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ExplanationofbenefitRelated(
    reference:,
    relationship:,
    claim:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn explanationofbenefit_to_json(
  explanationofbenefit: Explanationofbenefit,
) -> Json {
  let Explanationofbenefit(
    benefit_balance:,
    benefit_period:,
    process_note:,
    form:,
    form_code:,
    payment:,
    total:,
    add_item:,
    item:,
    patient_paid:,
    accident:,
    insurance:,
    precedence:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    diagnosis_related_group:,
    pre_auth_ref_period:,
    pre_auth_ref:,
    disposition:,
    decision:,
    outcome:,
    claim_response:,
    claim:,
    facility:,
    encounter:,
    referral:,
    payee:,
    event:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    funds_reserve_requested:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = explanationofbenefit
  let fields = [
    #("outcome", r5valuesets.claimoutcome_to_json(outcome)),
    #("created", json.string(created)),
    #("patient", reference_to_json(patient)),
    #("use", r5valuesets.claimuse_to_json(use_)),
    #("type", codeableconcept_to_json(type_)),
    #("status", r5valuesets.explanationofbenefitstatus_to_json(status)),
  ]
  let fields = case benefit_balance {
    [] -> fields
    _ -> [
      #(
        "benefitBalance",
        json.array(benefit_balance, explanationofbenefit_benefitbalance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case benefit_period {
    Some(v) -> [#("benefitPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, explanationofbenefit_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form {
    Some(v) -> [#("form", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", explanationofbenefit_payment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    [] -> fields
    _ -> [
      #("total", json.array(total, explanationofbenefit_total_to_json)),
      ..fields
    ]
  }
  let fields = case add_item {
    [] -> fields
    _ -> [
      #("addItem", json.array(add_item, explanationofbenefit_additem_to_json)),
      ..fields
    ]
  }
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, explanationofbenefit_item_to_json)),
      ..fields
    ]
  }
  let fields = case patient_paid {
    Some(v) -> [#("patientPaid", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case accident {
    Some(v) -> [
      #("accident", explanationofbenefit_accident_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case insurance {
    [] -> fields
    _ -> [
      #(
        "insurance",
        json.array(insurance, explanationofbenefit_insurance_to_json),
      ),
      ..fields
    ]
  }
  let fields = case precedence {
    Some(v) -> [#("precedence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #(
        "procedure",
        json.array(procedure, explanationofbenefit_procedure_to_json),
      ),
      ..fields
    ]
  }
  let fields = case diagnosis {
    [] -> fields
    _ -> [
      #(
        "diagnosis",
        json.array(diagnosis, explanationofbenefit_diagnosis_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, explanationofbenefit_supportinginfo_to_json),
      ),
      ..fields
    ]
  }
  let fields = case care_team {
    [] -> fields
    _ -> [
      #(
        "careTeam",
        json.array(care_team, explanationofbenefit_careteam_to_json),
      ),
      ..fields
    ]
  }
  let fields = case diagnosis_related_group {
    Some(v) -> [
      #("diagnosisRelatedGroup", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case pre_auth_ref_period {
    [] -> fields
    _ -> [
      #("preAuthRefPeriod", json.array(pre_auth_ref_period, period_to_json)),
      ..fields
    ]
  }
  let fields = case pre_auth_ref {
    [] -> fields
    _ -> [#("preAuthRef", json.array(pre_auth_ref, json.string)), ..fields]
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case decision {
    Some(v) -> [#("decision", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim_response {
    Some(v) -> [#("claimResponse", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case claim {
    Some(v) -> [#("claim", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case facility {
    Some(v) -> [#("facility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    [] -> fields
    _ -> [#("encounter", json.array(encounter, reference_to_json)), ..fields]
  }
  let fields = case referral {
    Some(v) -> [#("referral", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", explanationofbenefit_payee_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case event {
    [] -> fields
    _ -> [
      #("event", json.array(event, explanationofbenefit_event_to_json)),
      ..fields
    ]
  }
  let fields = case original_prescription {
    Some(v) -> [#("originalPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prescription {
    Some(v) -> [#("prescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related {
    [] -> fields
    _ -> [
      #("related", json.array(related, explanationofbenefit_related_to_json)),
      ..fields
    ]
  }
  let fields = case funds_reserve {
    Some(v) -> [#("fundsReserve", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case funds_reserve_requested {
    Some(v) -> [
      #("fundsReserveRequested", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case provider {
    Some(v) -> [#("provider", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case insurer {
    Some(v) -> [#("insurer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case billable_period {
    Some(v) -> [#("billablePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sub_type {
    Some(v) -> [#("subType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case trace_number {
    [] -> fields
    _ -> [
      #("traceNumber", json.array(trace_number, identifier_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Explanationofbenefit")),
    ..fields
  ]
  json.object(fields)
}

pub fn explanationofbenefit_decoder() -> Decoder(Explanationofbenefit) {
  use benefit_balance <- decode.optional_field(
    "benefitBalance",
    [],
    decode.list(explanationofbenefit_benefitbalance_decoder()),
  )
  use benefit_period <- decode.optional_field(
    "benefitPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(explanationofbenefit_processnote_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(attachment_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(explanationofbenefit_payment_decoder()),
  )
  use total <- decode.optional_field(
    "total",
    [],
    decode.list(explanationofbenefit_total_decoder()),
  )
  use add_item <- decode.optional_field(
    "addItem",
    [],
    decode.list(explanationofbenefit_additem_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(explanationofbenefit_item_decoder()),
  )
  use patient_paid <- decode.optional_field(
    "patientPaid",
    None,
    decode.optional(money_decoder()),
  )
  use accident <- decode.optional_field(
    "accident",
    None,
    decode.optional(explanationofbenefit_accident_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(explanationofbenefit_insurance_decoder()),
  )
  use precedence <- decode.optional_field(
    "precedence",
    None,
    decode.optional(decode.int),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(explanationofbenefit_procedure_decoder()),
  )
  use diagnosis <- decode.optional_field(
    "diagnosis",
    [],
    decode.list(explanationofbenefit_diagnosis_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(explanationofbenefit_supportinginfo_decoder()),
  )
  use care_team <- decode.optional_field(
    "careTeam",
    [],
    decode.list(explanationofbenefit_careteam_decoder()),
  )
  use diagnosis_related_group <- decode.optional_field(
    "diagnosisRelatedGroup",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use pre_auth_ref_period <- decode.optional_field(
    "preAuthRefPeriod",
    [],
    decode.list(period_decoder()),
  )
  use pre_auth_ref <- decode.optional_field(
    "preAuthRef",
    [],
    decode.list(decode.string),
  )
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use decision <- decode.optional_field(
    "decision",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use outcome <- decode.field("outcome", r5valuesets.claimoutcome_decoder())
  use claim_response <- decode.optional_field(
    "claimResponse",
    None,
    decode.optional(reference_decoder()),
  )
  use claim <- decode.optional_field(
    "claim",
    None,
    decode.optional(reference_decoder()),
  )
  use facility <- decode.optional_field(
    "facility",
    None,
    decode.optional(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    [],
    decode.list(reference_decoder()),
  )
  use referral <- decode.optional_field(
    "referral",
    None,
    decode.optional(reference_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(explanationofbenefit_payee_decoder()),
  )
  use event <- decode.optional_field(
    "event",
    [],
    decode.list(explanationofbenefit_event_decoder()),
  )
  use original_prescription <- decode.optional_field(
    "originalPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use prescription <- decode.optional_field(
    "prescription",
    None,
    decode.optional(reference_decoder()),
  )
  use related <- decode.optional_field(
    "related",
    [],
    decode.list(explanationofbenefit_related_decoder()),
  )
  use funds_reserve <- decode.optional_field(
    "fundsReserve",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use funds_reserve_requested <- decode.optional_field(
    "fundsReserveRequested",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use provider <- decode.optional_field(
    "provider",
    None,
    decode.optional(reference_decoder()),
  )
  use insurer <- decode.optional_field(
    "insurer",
    None,
    decode.optional(reference_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use billable_period <- decode.optional_field(
    "billablePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use use_ <- decode.field("use", r5valuesets.claimuse_decoder())
  use sub_type <- decode.optional_field(
    "subType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use status <- decode.field(
    "status",
    r5valuesets.explanationofbenefitstatus_decoder(),
  )
  use trace_number <- decode.optional_field(
    "traceNumber",
    [],
    decode.list(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Explanationofbenefit",
    decode.failure(
      explanationofbenefit_new(
        outcome:,
        created:,
        patient:,
        use_:,
        type_:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Explanationofbenefit(
    benefit_balance:,
    benefit_period:,
    process_note:,
    form:,
    form_code:,
    payment:,
    total:,
    add_item:,
    item:,
    patient_paid:,
    accident:,
    insurance:,
    precedence:,
    procedure:,
    diagnosis:,
    supporting_info:,
    care_team:,
    diagnosis_related_group:,
    pre_auth_ref_period:,
    pre_auth_ref:,
    disposition:,
    decision:,
    outcome:,
    claim_response:,
    claim:,
    facility:,
    encounter:,
    referral:,
    payee:,
    event:,
    original_prescription:,
    prescription:,
    related:,
    funds_reserve:,
    funds_reserve_requested:,
    priority:,
    provider:,
    insurer:,
    enterer:,
    created:,
    billable_period:,
    patient:,
    use_:,
    sub_type:,
    type_:,
    status:,
    trace_number:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type Familymemberhistory {
  Familymemberhistory(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    status: r5valuesets.Historystatus,
    data_absent_reason: Option(Codeableconcept),
    patient: Reference,
    date: Option(String),
    participant: List(FamilymemberhistoryParticipant),
    name: Option(String),
    relationship: Codeableconcept,
    sex: Option(Codeableconcept),
    born: Option(FamilymemberhistoryBorn),
    age: Option(FamilymemberhistoryAge),
    estimated_age: Option(Bool),
    deceased: Option(FamilymemberhistoryDeceased),
    reason: List(Codeablereference),
    note: List(Annotation),
    condition: List(FamilymemberhistoryCondition),
    procedure: List(FamilymemberhistoryProcedure),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryBorn {
  FamilymemberhistoryBornPeriod(born: Period)
  FamilymemberhistoryBornDate(born: String)
  FamilymemberhistoryBornString(born: String)
}

pub fn familymemberhistory_born_to_json(elt: FamilymemberhistoryBorn) -> Json {
  case elt {
    FamilymemberhistoryBornPeriod(v) -> period_to_json(v)
    FamilymemberhistoryBornDate(v) -> json.string(v)
    FamilymemberhistoryBornString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_born_decoder() -> Decoder(FamilymemberhistoryBorn) {
  decode.one_of(
    decode.field("bornPeriod", period_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryBornPeriod),
    [
      decode.field("bornDate", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryBornDate),
      decode.field("bornString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryBornString),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryAge {
  FamilymemberhistoryAgeAge(age: Age)
  FamilymemberhistoryAgeRange(age: Range)
  FamilymemberhistoryAgeString(age: String)
}

pub fn familymemberhistory_age_to_json(elt: FamilymemberhistoryAge) -> Json {
  case elt {
    FamilymemberhistoryAgeAge(v) -> age_to_json(v)
    FamilymemberhistoryAgeRange(v) -> range_to_json(v)
    FamilymemberhistoryAgeString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_age_decoder() -> Decoder(FamilymemberhistoryAge) {
  decode.one_of(
    decode.field("ageAge", age_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryAgeAge),
    [
      decode.field("ageRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryAgeRange),
      decode.field("ageString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryAgeString),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryDeceased {
  FamilymemberhistoryDeceasedBoolean(deceased: Bool)
  FamilymemberhistoryDeceasedAge(deceased: Age)
  FamilymemberhistoryDeceasedRange(deceased: Range)
  FamilymemberhistoryDeceasedDate(deceased: String)
  FamilymemberhistoryDeceasedString(deceased: String)
}

pub fn familymemberhistory_deceased_to_json(
  elt: FamilymemberhistoryDeceased,
) -> Json {
  case elt {
    FamilymemberhistoryDeceasedBoolean(v) -> json.bool(v)
    FamilymemberhistoryDeceasedAge(v) -> age_to_json(v)
    FamilymemberhistoryDeceasedRange(v) -> range_to_json(v)
    FamilymemberhistoryDeceasedDate(v) -> json.string(v)
    FamilymemberhistoryDeceasedString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_deceased_decoder() -> Decoder(
  FamilymemberhistoryDeceased,
) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(FamilymemberhistoryDeceasedBoolean),
    [
      decode.field("deceasedAge", age_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryDeceasedAge),
      decode.field("deceasedRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryDeceasedRange),
      decode.field("deceasedDate", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryDeceasedDate),
      decode.field("deceasedString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryDeceasedString),
    ],
  )
}

pub fn familymemberhistory_new(
  relationship relationship: Codeableconcept,
  patient patient: Reference,
  status status: r5valuesets.Historystatus,
) -> Familymemberhistory {
  Familymemberhistory(
    procedure: [],
    condition: [],
    note: [],
    reason: [],
    deceased: None,
    estimated_age: None,
    age: None,
    born: None,
    sex: None,
    relationship:,
    name: None,
    participant: [],
    date: None,
    patient:,
    data_absent_reason: None,
    status:,
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryParticipant {
  FamilymemberhistoryParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn familymemberhistory_participant_new(
  actor actor: Reference,
) -> FamilymemberhistoryParticipant {
  FamilymemberhistoryParticipant(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryCondition {
  FamilymemberhistoryCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    outcome: Option(Codeableconcept),
    contributed_to_death: Option(Bool),
    onset: Option(FamilymemberhistoryConditionOnset),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryConditionOnset {
  FamilymemberhistoryConditionOnsetAge(onset: Age)
  FamilymemberhistoryConditionOnsetRange(onset: Range)
  FamilymemberhistoryConditionOnsetPeriod(onset: Period)
  FamilymemberhistoryConditionOnsetString(onset: String)
}

pub fn familymemberhistory_condition_onset_to_json(
  elt: FamilymemberhistoryConditionOnset,
) -> Json {
  case elt {
    FamilymemberhistoryConditionOnsetAge(v) -> age_to_json(v)
    FamilymemberhistoryConditionOnsetRange(v) -> range_to_json(v)
    FamilymemberhistoryConditionOnsetPeriod(v) -> period_to_json(v)
    FamilymemberhistoryConditionOnsetString(v) -> json.string(v)
  }
}

pub fn familymemberhistory_condition_onset_decoder() -> Decoder(
  FamilymemberhistoryConditionOnset,
) {
  decode.one_of(
    decode.field("onsetAge", age_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryConditionOnsetAge),
    [
      decode.field("onsetRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetRange),
      decode.field("onsetPeriod", period_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetPeriod),
      decode.field("onsetString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryConditionOnsetString),
    ],
  )
}

pub fn familymemberhistory_condition_new(
  code code: Codeableconcept,
) -> FamilymemberhistoryCondition {
  FamilymemberhistoryCondition(
    note: [],
    onset: None,
    contributed_to_death: None,
    outcome: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryProcedure {
  FamilymemberhistoryProcedure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    outcome: Option(Codeableconcept),
    contributed_to_death: Option(Bool),
    performed: Option(FamilymemberhistoryProcedurePerformed),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/FamilyMemberHistory#resource
pub type FamilymemberhistoryProcedurePerformed {
  FamilymemberhistoryProcedurePerformedAge(performed: Age)
  FamilymemberhistoryProcedurePerformedRange(performed: Range)
  FamilymemberhistoryProcedurePerformedPeriod(performed: Period)
  FamilymemberhistoryProcedurePerformedString(performed: String)
  FamilymemberhistoryProcedurePerformedDatetime(performed: String)
}

pub fn familymemberhistory_procedure_performed_to_json(
  elt: FamilymemberhistoryProcedurePerformed,
) -> Json {
  case elt {
    FamilymemberhistoryProcedurePerformedAge(v) -> age_to_json(v)
    FamilymemberhistoryProcedurePerformedRange(v) -> range_to_json(v)
    FamilymemberhistoryProcedurePerformedPeriod(v) -> period_to_json(v)
    FamilymemberhistoryProcedurePerformedString(v) -> json.string(v)
    FamilymemberhistoryProcedurePerformedDatetime(v) -> json.string(v)
  }
}

pub fn familymemberhistory_procedure_performed_decoder() -> Decoder(
  FamilymemberhistoryProcedurePerformed,
) {
  decode.one_of(
    decode.field("performedAge", age_decoder(), decode.success)
      |> decode.map(FamilymemberhistoryProcedurePerformedAge),
    [
      decode.field("performedRange", range_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryProcedurePerformedRange),
      decode.field("performedPeriod", period_decoder(), decode.success)
        |> decode.map(FamilymemberhistoryProcedurePerformedPeriod),
      decode.field("performedString", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryProcedurePerformedString),
      decode.field("performedDateTime", decode.string, decode.success)
        |> decode.map(FamilymemberhistoryProcedurePerformedDatetime),
    ],
  )
}

pub fn familymemberhistory_procedure_new(
  code code: Codeableconcept,
) -> FamilymemberhistoryProcedure {
  FamilymemberhistoryProcedure(
    note: [],
    performed: None,
    contributed_to_death: None,
    outcome: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn familymemberhistory_procedure_to_json(
  familymemberhistory_procedure: FamilymemberhistoryProcedure,
) -> Json {
  let FamilymemberhistoryProcedure(
    note:,
    performed:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = familymemberhistory_procedure
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case performed {
    Some(v) -> [
      #(
        "performed"
          <> case v {
          FamilymemberhistoryProcedurePerformedAge(_) -> "Age"
          FamilymemberhistoryProcedurePerformedRange(_) -> "Range"
          FamilymemberhistoryProcedurePerformedPeriod(_) -> "Period"
          FamilymemberhistoryProcedurePerformedString(_) -> "String"
          FamilymemberhistoryProcedurePerformedDatetime(_) -> "Datetime"
        },
        familymemberhistory_procedure_performed_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case contributed_to_death {
    Some(v) -> [#("contributedToDeath", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn familymemberhistory_procedure_decoder() -> Decoder(
  FamilymemberhistoryProcedure,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use performed <- decode.then(
    none_if_omitted(familymemberhistory_procedure_performed_decoder()),
  )
  use contributed_to_death <- decode.optional_field(
    "contributedToDeath",
    None,
    decode.optional(decode.bool),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(FamilymemberhistoryProcedure(
    note:,
    performed:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn familymemberhistory_condition_to_json(
  familymemberhistory_condition: FamilymemberhistoryCondition,
) -> Json {
  let FamilymemberhistoryCondition(
    note:,
    onset:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = familymemberhistory_condition
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case onset {
    Some(v) -> [
      #(
        "onset"
          <> case v {
          FamilymemberhistoryConditionOnsetAge(_) -> "Age"
          FamilymemberhistoryConditionOnsetRange(_) -> "Range"
          FamilymemberhistoryConditionOnsetPeriod(_) -> "Period"
          FamilymemberhistoryConditionOnsetString(_) -> "String"
        },
        familymemberhistory_condition_onset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case contributed_to_death {
    Some(v) -> [#("contributedToDeath", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn familymemberhistory_condition_decoder() -> Decoder(
  FamilymemberhistoryCondition,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use onset <- decode.then(
    none_if_omitted(familymemberhistory_condition_onset_decoder()),
  )
  use contributed_to_death <- decode.optional_field(
    "contributedToDeath",
    None,
    decode.optional(decode.bool),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(FamilymemberhistoryCondition(
    note:,
    onset:,
    contributed_to_death:,
    outcome:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn familymemberhistory_participant_to_json(
  familymemberhistory_participant: FamilymemberhistoryParticipant,
) -> Json {
  let FamilymemberhistoryParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = familymemberhistory_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn familymemberhistory_participant_decoder() -> Decoder(
  FamilymemberhistoryParticipant,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(FamilymemberhistoryParticipant(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn familymemberhistory_to_json(
  familymemberhistory: Familymemberhistory,
) -> Json {
  let Familymemberhistory(
    procedure:,
    condition:,
    note:,
    reason:,
    deceased:,
    estimated_age:,
    age:,
    born:,
    sex:,
    relationship:,
    name:,
    participant:,
    date:,
    patient:,
    data_absent_reason:,
    status:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = familymemberhistory
  let fields = [
    #("relationship", codeableconcept_to_json(relationship)),
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.historystatus_to_json(status)),
  ]
  let fields = case procedure {
    [] -> fields
    _ -> [
      #(
        "procedure",
        json.array(procedure, familymemberhistory_procedure_to_json),
      ),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, familymemberhistory_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          FamilymemberhistoryDeceasedBoolean(_) -> "Boolean"
          FamilymemberhistoryDeceasedAge(_) -> "Age"
          FamilymemberhistoryDeceasedRange(_) -> "Range"
          FamilymemberhistoryDeceasedDate(_) -> "Date"
          FamilymemberhistoryDeceasedString(_) -> "String"
        },
        familymemberhistory_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case estimated_age {
    Some(v) -> [#("estimatedAge", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [
      #(
        "age"
          <> case v {
          FamilymemberhistoryAgeAge(_) -> "Age"
          FamilymemberhistoryAgeRange(_) -> "Range"
          FamilymemberhistoryAgeString(_) -> "String"
        },
        familymemberhistory_age_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case born {
    Some(v) -> [
      #(
        "born"
          <> case v {
          FamilymemberhistoryBornPeriod(_) -> "Period"
          FamilymemberhistoryBornDate(_) -> "Date"
          FamilymemberhistoryBornString(_) -> "String"
        },
        familymemberhistory_born_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case sex {
    Some(v) -> [#("sex", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, familymemberhistory_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Familymemberhistory")), ..fields]
  json.object(fields)
}

pub fn familymemberhistory_decoder() -> Decoder(Familymemberhistory) {
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(familymemberhistory_procedure_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(familymemberhistory_condition_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use deceased <- decode.then(
    none_if_omitted(familymemberhistory_deceased_decoder()),
  )
  use estimated_age <- decode.optional_field(
    "estimatedAge",
    None,
    decode.optional(decode.bool),
  )
  use age <- decode.then(none_if_omitted(familymemberhistory_age_decoder()))
  use born <- decode.then(none_if_omitted(familymemberhistory_born_decoder()))
  use sex <- decode.optional_field(
    "sex",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use relationship <- decode.field("relationship", codeableconcept_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(familymemberhistory_participant_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use patient <- decode.field("patient", reference_decoder())
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.historystatus_decoder())
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Familymemberhistory",
    decode.failure(
      familymemberhistory_new(relationship:, patient:, status:),
      "resourceType",
    ),
  )
  decode.success(Familymemberhistory(
    procedure:,
    condition:,
    note:,
    reason:,
    deceased:,
    estimated_age:,
    age:,
    born:,
    sex:,
    relationship:,
    name:,
    participant:,
    date:,
    patient:,
    data_absent_reason:,
    status:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Flag#resource
pub type Flag {
  Flag(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Flagstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Reference,
    period: Option(Period),
    encounter: Option(Reference),
    author: Option(Reference),
  )
}

pub fn flag_new(
  subject subject: Reference,
  code code: Codeableconcept,
  status status: r5valuesets.Flagstatus,
) -> Flag {
  Flag(
    author: None,
    encounter: None,
    period: None,
    subject:,
    code:,
    category: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn flag_to_json(flag: Flag) -> Json {
  let Flag(
    author:,
    encounter:,
    period:,
    subject:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = flag
  let fields = [
    #("subject", reference_to_json(subject)),
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.flagstatus_to_json(status)),
  ]
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Flag")), ..fields]
  json.object(fields)
}

pub fn flag_decoder() -> Decoder(Flag) {
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.flagstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Flag",
    decode.failure(flag_new(subject:, code:, status:), "resourceType"),
  )
  decode.success(Flag(
    author:,
    encounter:,
    period:,
    subject:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/FormularyItem#resource
pub type Formularyitem {
  Formularyitem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Option(Codeableconcept),
    status: Option(r5valuesets.Formularyitemstatus),
  )
}

pub fn formularyitem_new() -> Formularyitem {
  Formularyitem(
    status: None,
    code: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn formularyitem_to_json(formularyitem: Formularyitem) -> Json {
  let Formularyitem(
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = formularyitem
  let fields = []
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.formularyitemstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Formularyitem")), ..fields]
  json.object(fields)
}

pub fn formularyitem_decoder() -> Decoder(Formularyitem) {
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.formularyitemstatus_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Formularyitem",
    decode.failure(formularyitem_new(), "resourceType"),
  )
  decode.success(Formularyitem(
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type Genomicstudy {
  Genomicstudy(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Genomicstudystatus,
    type_: List(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    start_date: Option(String),
    based_on: List(Reference),
    referrer: Option(Reference),
    interpreter: List(Reference),
    reason: List(Codeablereference),
    instantiates_canonical: Option(String),
    instantiates_uri: Option(String),
    note: List(Annotation),
    description: Option(String),
    analysis: List(GenomicstudyAnalysis),
  )
}

pub fn genomicstudy_new(
  subject subject: Reference,
  status status: r5valuesets.Genomicstudystatus,
) -> Genomicstudy {
  Genomicstudy(
    analysis: [],
    description: None,
    note: [],
    instantiates_uri: None,
    instantiates_canonical: None,
    reason: [],
    interpreter: [],
    referrer: None,
    based_on: [],
    start_date: None,
    encounter: None,
    subject:,
    type_: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysis {
  GenomicstudyAnalysis(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    method_type: List(Codeableconcept),
    change_type: List(Codeableconcept),
    genome_build: Option(Codeableconcept),
    instantiates_canonical: Option(String),
    instantiates_uri: Option(String),
    title: Option(String),
    focus: List(Reference),
    specimen: List(Reference),
    date: Option(String),
    note: List(Annotation),
    protocol_performed: Option(Reference),
    regions_studied: List(Reference),
    regions_called: List(Reference),
    input: List(GenomicstudyAnalysisInput),
    output: List(GenomicstudyAnalysisOutput),
    performer: List(GenomicstudyAnalysisPerformer),
    device: List(GenomicstudyAnalysisDevice),
  )
}

pub fn genomicstudy_analysis_new() -> GenomicstudyAnalysis {
  GenomicstudyAnalysis(
    device: [],
    performer: [],
    output: [],
    input: [],
    regions_called: [],
    regions_studied: [],
    protocol_performed: None,
    note: [],
    date: None,
    specimen: [],
    focus: [],
    title: None,
    instantiates_uri: None,
    instantiates_canonical: None,
    genome_build: None,
    change_type: [],
    method_type: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysisInput {
  GenomicstudyAnalysisInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    file: Option(Reference),
    type_: Option(Codeableconcept),
    generated_by: Option(GenomicstudyAnalysisInputGeneratedby),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysisInputGeneratedby {
  GenomicstudyAnalysisInputGeneratedbyIdentifier(generated_by: Identifier)
  GenomicstudyAnalysisInputGeneratedbyReference(generated_by: Reference)
}

pub fn genomicstudy_analysis_input_generatedby_to_json(
  elt: GenomicstudyAnalysisInputGeneratedby,
) -> Json {
  case elt {
    GenomicstudyAnalysisInputGeneratedbyIdentifier(v) -> identifier_to_json(v)
    GenomicstudyAnalysisInputGeneratedbyReference(v) -> reference_to_json(v)
  }
}

pub fn genomicstudy_analysis_input_generatedby_decoder() -> Decoder(
  GenomicstudyAnalysisInputGeneratedby,
) {
  decode.one_of(
    decode.field("generatedByIdentifier", identifier_decoder(), decode.success)
      |> decode.map(GenomicstudyAnalysisInputGeneratedbyIdentifier),
    [
      decode.field("generatedByReference", reference_decoder(), decode.success)
      |> decode.map(GenomicstudyAnalysisInputGeneratedbyReference),
    ],
  )
}

pub fn genomicstudy_analysis_input_new() -> GenomicstudyAnalysisInput {
  GenomicstudyAnalysisInput(
    generated_by: None,
    type_: None,
    file: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysisOutput {
  GenomicstudyAnalysisOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    file: Option(Reference),
    type_: Option(Codeableconcept),
  )
}

pub fn genomicstudy_analysis_output_new() -> GenomicstudyAnalysisOutput {
  GenomicstudyAnalysisOutput(
    type_: None,
    file: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysisPerformer {
  GenomicstudyAnalysisPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    actor: Option(Reference),
    role: Option(Codeableconcept),
  )
}

pub fn genomicstudy_analysis_performer_new() -> GenomicstudyAnalysisPerformer {
  GenomicstudyAnalysisPerformer(
    role: None,
    actor: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GenomicStudy#resource
pub type GenomicstudyAnalysisDevice {
  GenomicstudyAnalysisDevice(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device: Option(Reference),
    function: Option(Codeableconcept),
  )
}

pub fn genomicstudy_analysis_device_new() -> GenomicstudyAnalysisDevice {
  GenomicstudyAnalysisDevice(
    function: None,
    device: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn genomicstudy_analysis_device_to_json(
  genomicstudy_analysis_device: GenomicstudyAnalysisDevice,
) -> Json {
  let GenomicstudyAnalysisDevice(
    function:,
    device:,
    modifier_extension:,
    extension:,
    id:,
  ) = genomicstudy_analysis_device
  let fields = []
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn genomicstudy_analysis_device_decoder() -> Decoder(
  GenomicstudyAnalysisDevice,
) {
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GenomicstudyAnalysisDevice(
    function:,
    device:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn genomicstudy_analysis_performer_to_json(
  genomicstudy_analysis_performer: GenomicstudyAnalysisPerformer,
) -> Json {
  let GenomicstudyAnalysisPerformer(
    role:,
    actor:,
    modifier_extension:,
    extension:,
    id:,
  ) = genomicstudy_analysis_performer
  let fields = []
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn genomicstudy_analysis_performer_decoder() -> Decoder(
  GenomicstudyAnalysisPerformer,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GenomicstudyAnalysisPerformer(
    role:,
    actor:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn genomicstudy_analysis_output_to_json(
  genomicstudy_analysis_output: GenomicstudyAnalysisOutput,
) -> Json {
  let GenomicstudyAnalysisOutput(
    type_:,
    file:,
    modifier_extension:,
    extension:,
    id:,
  ) = genomicstudy_analysis_output
  let fields = []
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case file {
    Some(v) -> [#("file", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn genomicstudy_analysis_output_decoder() -> Decoder(
  GenomicstudyAnalysisOutput,
) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use file <- decode.optional_field(
    "file",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GenomicstudyAnalysisOutput(
    type_:,
    file:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn genomicstudy_analysis_input_to_json(
  genomicstudy_analysis_input: GenomicstudyAnalysisInput,
) -> Json {
  let GenomicstudyAnalysisInput(
    generated_by:,
    type_:,
    file:,
    modifier_extension:,
    extension:,
    id:,
  ) = genomicstudy_analysis_input
  let fields = []
  let fields = case generated_by {
    Some(v) -> [
      #(
        "generatedBy"
          <> case v {
          GenomicstudyAnalysisInputGeneratedbyIdentifier(_) -> "Identifier"
          GenomicstudyAnalysisInputGeneratedbyReference(_) -> "Reference"
        },
        genomicstudy_analysis_input_generatedby_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case file {
    Some(v) -> [#("file", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn genomicstudy_analysis_input_decoder() -> Decoder(
  GenomicstudyAnalysisInput,
) {
  use generated_by <- decode.then(
    none_if_omitted(genomicstudy_analysis_input_generatedby_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use file <- decode.optional_field(
    "file",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GenomicstudyAnalysisInput(
    generated_by:,
    type_:,
    file:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn genomicstudy_analysis_to_json(
  genomicstudy_analysis: GenomicstudyAnalysis,
) -> Json {
  let GenomicstudyAnalysis(
    device:,
    performer:,
    output:,
    input:,
    regions_called:,
    regions_studied:,
    protocol_performed:,
    note:,
    date:,
    specimen:,
    focus:,
    title:,
    instantiates_uri:,
    instantiates_canonical:,
    genome_build:,
    change_type:,
    method_type:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = genomicstudy_analysis
  let fields = []
  let fields = case device {
    [] -> fields
    _ -> [
      #("device", json.array(device, genomicstudy_analysis_device_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, genomicstudy_analysis_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case output {
    [] -> fields
    _ -> [
      #("output", json.array(output, genomicstudy_analysis_output_to_json)),
      ..fields
    ]
  }
  let fields = case input {
    [] -> fields
    _ -> [
      #("input", json.array(input, genomicstudy_analysis_input_to_json)),
      ..fields
    ]
  }
  let fields = case regions_called {
    [] -> fields
    _ -> [
      #("regionsCalled", json.array(regions_called, reference_to_json)),
      ..fields
    ]
  }
  let fields = case regions_studied {
    [] -> fields
    _ -> [
      #("regionsStudied", json.array(regions_studied, reference_to_json)),
      ..fields
    ]
  }
  let fields = case protocol_performed {
    Some(v) -> [#("protocolPerformed", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case genome_build {
    Some(v) -> [#("genomeBuild", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case change_type {
    [] -> fields
    _ -> [
      #("changeType", json.array(change_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case method_type {
    [] -> fields
    _ -> [
      #("methodType", json.array(method_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn genomicstudy_analysis_decoder() -> Decoder(GenomicstudyAnalysis) {
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(genomicstudy_analysis_device_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(genomicstudy_analysis_performer_decoder()),
  )
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(genomicstudy_analysis_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(genomicstudy_analysis_input_decoder()),
  )
  use regions_called <- decode.optional_field(
    "regionsCalled",
    [],
    decode.list(reference_decoder()),
  )
  use regions_studied <- decode.optional_field(
    "regionsStudied",
    [],
    decode.list(reference_decoder()),
  )
  use protocol_performed <- decode.optional_field(
    "protocolPerformed",
    None,
    decode.optional(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(decode.string),
  )
  use genome_build <- decode.optional_field(
    "genomeBuild",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use change_type <- decode.optional_field(
    "changeType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use method_type <- decode.optional_field(
    "methodType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GenomicstudyAnalysis(
    device:,
    performer:,
    output:,
    input:,
    regions_called:,
    regions_studied:,
    protocol_performed:,
    note:,
    date:,
    specimen:,
    focus:,
    title:,
    instantiates_uri:,
    instantiates_canonical:,
    genome_build:,
    change_type:,
    method_type:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn genomicstudy_to_json(genomicstudy: Genomicstudy) -> Json {
  let Genomicstudy(
    analysis:,
    description:,
    note:,
    instantiates_uri:,
    instantiates_canonical:,
    reason:,
    interpreter:,
    referrer:,
    based_on:,
    start_date:,
    encounter:,
    subject:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = genomicstudy
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.genomicstudystatus_to_json(status)),
  ]
  let fields = case analysis {
    [] -> fields
    _ -> [
      #("analysis", json.array(analysis, genomicstudy_analysis_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case interpreter {
    [] -> fields
    _ -> [
      #("interpreter", json.array(interpreter, reference_to_json)),
      ..fields
    ]
  }
  let fields = case referrer {
    Some(v) -> [#("referrer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case start_date {
    Some(v) -> [#("startDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Genomicstudy")), ..fields]
  json.object(fields)
}

pub fn genomicstudy_decoder() -> Decoder(Genomicstudy) {
  use analysis <- decode.optional_field(
    "analysis",
    [],
    decode.list(genomicstudy_analysis_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(decode.string),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use interpreter <- decode.optional_field(
    "interpreter",
    [],
    decode.list(reference_decoder()),
  )
  use referrer <- decode.optional_field(
    "referrer",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use start_date <- decode.optional_field(
    "startDate",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.genomicstudystatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Genomicstudy",
    decode.failure(genomicstudy_new(subject:, status:), "resourceType"),
  )
  decode.success(Genomicstudy(
    analysis:,
    description:,
    note:,
    instantiates_uri:,
    instantiates_canonical:,
    reason:,
    interpreter:,
    referrer:,
    based_on:,
    start_date:,
    encounter:,
    subject:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Goal#resource
pub type Goal {
  Goal(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    lifecycle_status: r5valuesets.Goalstatus,
    achievement_status: Option(Codeableconcept),
    category: List(Codeableconcept),
    continuous: Option(Bool),
    priority: Option(Codeableconcept),
    description: Codeableconcept,
    subject: Reference,
    start: Option(GoalStart),
    target: List(GoalTarget),
    status_date: Option(String),
    status_reason: Option(String),
    source: Option(Reference),
    addresses: List(Reference),
    note: List(Annotation),
    outcome: List(Codeablereference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Goal#resource
pub type GoalStart {
  GoalStartDate(start: String)
  GoalStartCodeableconcept(start: Codeableconcept)
}

pub fn goal_start_to_json(elt: GoalStart) -> Json {
  case elt {
    GoalStartDate(v) -> json.string(v)
    GoalStartCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn goal_start_decoder() -> Decoder(GoalStart) {
  decode.one_of(
    decode.field("startDate", decode.string, decode.success)
      |> decode.map(GoalStartDate),
    [
      decode.field(
        "startCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(GoalStartCodeableconcept),
    ],
  )
}

pub fn goal_new(
  subject subject: Reference,
  description description: Codeableconcept,
  lifecycle_status lifecycle_status: r5valuesets.Goalstatus,
) -> Goal {
  Goal(
    outcome: [],
    note: [],
    addresses: [],
    source: None,
    status_reason: None,
    status_date: None,
    target: [],
    start: None,
    subject:,
    description:,
    priority: None,
    continuous: None,
    category: [],
    achievement_status: None,
    lifecycle_status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Goal#resource
pub type GoalTarget {
  GoalTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    measure: Option(Codeableconcept),
    detail: Option(GoalTargetDetail),
    due: Option(GoalTargetDue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Goal#resource
pub type GoalTargetDetail {
  GoalTargetDetailQuantity(detail: Quantity)
  GoalTargetDetailRange(detail: Range)
  GoalTargetDetailCodeableconcept(detail: Codeableconcept)
  GoalTargetDetailString(detail: String)
  GoalTargetDetailBoolean(detail: Bool)
  GoalTargetDetailInteger(detail: Int)
  GoalTargetDetailRatio(detail: Ratio)
}

pub fn goal_target_detail_to_json(elt: GoalTargetDetail) -> Json {
  case elt {
    GoalTargetDetailQuantity(v) -> quantity_to_json(v)
    GoalTargetDetailRange(v) -> range_to_json(v)
    GoalTargetDetailCodeableconcept(v) -> codeableconcept_to_json(v)
    GoalTargetDetailString(v) -> json.string(v)
    GoalTargetDetailBoolean(v) -> json.bool(v)
    GoalTargetDetailInteger(v) -> json.int(v)
    GoalTargetDetailRatio(v) -> ratio_to_json(v)
  }
}

pub fn goal_target_detail_decoder() -> Decoder(GoalTargetDetail) {
  decode.one_of(
    decode.field("detailQuantity", quantity_decoder(), decode.success)
      |> decode.map(GoalTargetDetailQuantity),
    [
      decode.field("detailRange", range_decoder(), decode.success)
        |> decode.map(GoalTargetDetailRange),
      decode.field(
        "detailCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(GoalTargetDetailCodeableconcept),
      decode.field("detailString", decode.string, decode.success)
        |> decode.map(GoalTargetDetailString),
      decode.field("detailBoolean", decode.bool, decode.success)
        |> decode.map(GoalTargetDetailBoolean),
      decode.field("detailInteger", decode.int, decode.success)
        |> decode.map(GoalTargetDetailInteger),
      decode.field("detailRatio", ratio_decoder(), decode.success)
        |> decode.map(GoalTargetDetailRatio),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Goal#resource
pub type GoalTargetDue {
  GoalTargetDueDate(due: String)
  GoalTargetDueDuration(due: Duration)
}

pub fn goal_target_due_to_json(elt: GoalTargetDue) -> Json {
  case elt {
    GoalTargetDueDate(v) -> json.string(v)
    GoalTargetDueDuration(v) -> duration_to_json(v)
  }
}

pub fn goal_target_due_decoder() -> Decoder(GoalTargetDue) {
  decode.one_of(
    decode.field("dueDate", decode.string, decode.success)
      |> decode.map(GoalTargetDueDate),
    [
      decode.field("dueDuration", duration_decoder(), decode.success)
      |> decode.map(GoalTargetDueDuration),
    ],
  )
}

pub fn goal_target_new() -> GoalTarget {
  GoalTarget(
    due: None,
    detail: None,
    measure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn goal_target_to_json(goal_target: GoalTarget) -> Json {
  let GoalTarget(due:, detail:, measure:, modifier_extension:, extension:, id:) =
    goal_target
  let fields = []
  let fields = case due {
    Some(v) -> [
      #(
        "due"
          <> case v {
          GoalTargetDueDate(_) -> "Date"
          GoalTargetDueDuration(_) -> "Duration"
        },
        goal_target_due_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [
      #(
        "detail"
          <> case v {
          GoalTargetDetailQuantity(_) -> "Quantity"
          GoalTargetDetailRange(_) -> "Range"
          GoalTargetDetailCodeableconcept(_) -> "Codeableconcept"
          GoalTargetDetailString(_) -> "String"
          GoalTargetDetailBoolean(_) -> "Boolean"
          GoalTargetDetailInteger(_) -> "Integer"
          GoalTargetDetailRatio(_) -> "Ratio"
        },
        goal_target_detail_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case measure {
    Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn goal_target_decoder() -> Decoder(GoalTarget) {
  use due <- decode.then(none_if_omitted(goal_target_due_decoder()))
  use detail <- decode.then(none_if_omitted(goal_target_detail_decoder()))
  use measure <- decode.optional_field(
    "measure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn goal_to_json(goal: Goal) -> Json {
  let Goal(
    outcome:,
    note:,
    addresses:,
    source:,
    status_reason:,
    status_date:,
    target:,
    start:,
    subject:,
    description:,
    priority:,
    continuous:,
    category:,
    achievement_status:,
    lifecycle_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = goal
  let fields = [
    #("subject", reference_to_json(subject)),
    #("description", codeableconcept_to_json(description)),
    #("lifecycleStatus", r5valuesets.goalstatus_to_json(lifecycle_status)),
  ]
  let fields = case outcome {
    [] -> fields
    _ -> [
      #("outcome", json.array(outcome, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [#("addresses", json.array(addresses, reference_to_json)), ..fields]
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, goal_target_to_json)), ..fields]
  }
  let fields = case start {
    Some(v) -> [
      #(
        "start"
          <> case v {
          GoalStartDate(_) -> "Date"
          GoalStartCodeableconcept(_) -> "Codeableconcept"
        },
        goal_start_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case continuous {
    Some(v) -> [#("continuous", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case achievement_status {
    Some(v) -> [#("achievementStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Goal")), ..fields]
  json.object(fields)
}

pub fn goal_decoder() -> Decoder(Goal) {
  use outcome <- decode.optional_field(
    "outcome",
    [],
    decode.list(codeablereference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(reference_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(decode.string),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(goal_target_decoder()),
  )
  use start <- decode.then(none_if_omitted(goal_start_decoder()))
  use subject <- decode.field("subject", reference_decoder())
  use description <- decode.field("description", codeableconcept_decoder())
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use continuous <- decode.optional_field(
    "continuous",
    None,
    decode.optional(decode.bool),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use achievement_status <- decode.optional_field(
    "achievementStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use lifecycle_status <- decode.field(
    "lifecycleStatus",
    r5valuesets.goalstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Goal",
    decode.failure(
      goal_new(subject:, description:, lifecycle_status:),
      "resourceType",
    ),
  )
  decode.success(Goal(
    outcome:,
    note:,
    addresses:,
    source:,
    status_reason:,
    status_date:,
    target:,
    start:,
    subject:,
    description:,
    priority:,
    continuous:,
    category:,
    achievement_status:,
    lifecycle_status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/GraphDefinition#resource
pub type Graphdefinition {
  Graphdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(GraphdefinitionVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    start: Option(String),
    node: List(GraphdefinitionNode),
    link: List(GraphdefinitionLink),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionVersionalgorithm {
  GraphdefinitionVersionalgorithmString(version_algorithm: String)
  GraphdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn graphdefinition_versionalgorithm_to_json(
  elt: GraphdefinitionVersionalgorithm,
) -> Json {
  case elt {
    GraphdefinitionVersionalgorithmString(v) -> json.string(v)
    GraphdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn graphdefinition_versionalgorithm_decoder() -> Decoder(
  GraphdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(GraphdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(GraphdefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn graphdefinition_new(
  status status: r5valuesets.Publicationstatus,
  name name: String,
) -> Graphdefinition {
  Graphdefinition(
    link: [],
    node: [],
    start: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionNode {
  GraphdefinitionNode(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    node_id: String,
    description: Option(String),
    type_: r5valuesets.Versionindependentallresourcetypes,
    profile: Option(String),
  )
}

pub fn graphdefinition_node_new(
  type_ type_: r5valuesets.Versionindependentallresourcetypes,
  node_id node_id: String,
) -> GraphdefinitionNode {
  GraphdefinitionNode(
    profile: None,
    type_:,
    description: None,
    node_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLink {
  GraphdefinitionLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    min: Option(Int),
    max: Option(String),
    source_id: String,
    path: Option(String),
    slice_name: Option(String),
    target_id: String,
    params: Option(String),
    compartment: List(GraphdefinitionLinkCompartment),
  )
}

pub fn graphdefinition_link_new(
  target_id target_id: String,
  source_id source_id: String,
) -> GraphdefinitionLink {
  GraphdefinitionLink(
    compartment: [],
    params: None,
    target_id:,
    slice_name: None,
    path: None,
    source_id:,
    max: None,
    min: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GraphDefinition#resource
pub type GraphdefinitionLinkCompartment {
  GraphdefinitionLinkCompartment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    use_: r5valuesets.Graphcompartmentuse,
    rule: r5valuesets.Graphcompartmentrule,
    code: r5valuesets.Compartmenttype,
    expression: Option(String),
    description: Option(String),
  )
}

pub fn graphdefinition_link_compartment_new(
  code code: r5valuesets.Compartmenttype,
  rule rule: r5valuesets.Graphcompartmentrule,
  use_ use_: r5valuesets.Graphcompartmentuse,
) -> GraphdefinitionLinkCompartment {
  GraphdefinitionLinkCompartment(
    description: None,
    expression: None,
    code:,
    rule:,
    use_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn graphdefinition_link_compartment_to_json(
  graphdefinition_link_compartment: GraphdefinitionLinkCompartment,
) -> Json {
  let GraphdefinitionLinkCompartment(
    description:,
    expression:,
    code:,
    rule:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_link_compartment
  let fields = [
    #("code", r5valuesets.compartmenttype_to_json(code)),
    #("rule", r5valuesets.graphcompartmentrule_to_json(rule)),
    #("use", r5valuesets.graphcompartmentuse_to_json(use_)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_link_compartment_decoder() -> Decoder(
  GraphdefinitionLinkCompartment,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", r5valuesets.compartmenttype_decoder())
  use rule <- decode.field("rule", r5valuesets.graphcompartmentrule_decoder())
  use use_ <- decode.field("use", r5valuesets.graphcompartmentuse_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionLinkCompartment(
    description:,
    expression:,
    code:,
    rule:,
    use_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_link_to_json(
  graphdefinition_link: GraphdefinitionLink,
) -> Json {
  let GraphdefinitionLink(
    compartment:,
    params:,
    target_id:,
    slice_name:,
    path:,
    source_id:,
    max:,
    min:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_link
  let fields = [
    #("targetId", json.string(target_id)),
    #("sourceId", json.string(source_id)),
  ]
  let fields = case compartment {
    [] -> fields
    _ -> [
      #(
        "compartment",
        json.array(compartment, graphdefinition_link_compartment_to_json),
      ),
      ..fields
    ]
  }
  let fields = case params {
    Some(v) -> [#("params", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case slice_name {
    Some(v) -> [#("sliceName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_link_decoder() -> Decoder(GraphdefinitionLink) {
  use compartment <- decode.optional_field(
    "compartment",
    [],
    decode.list(graphdefinition_link_compartment_decoder()),
  )
  use params <- decode.optional_field(
    "params",
    None,
    decode.optional(decode.string),
  )
  use target_id <- decode.field("targetId", decode.string)
  use slice_name <- decode.optional_field(
    "sliceName",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use source_id <- decode.field("sourceId", decode.string)
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionLink(
    compartment:,
    params:,
    target_id:,
    slice_name:,
    path:,
    source_id:,
    max:,
    min:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_node_to_json(
  graphdefinition_node: GraphdefinitionNode,
) -> Json {
  let GraphdefinitionNode(
    profile:,
    type_:,
    description:,
    node_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = graphdefinition_node
  let fields = [
    #("type", r5valuesets.versionindependentallresourcetypes_to_json(type_)),
    #("nodeId", json.string(node_id)),
  ]
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn graphdefinition_node_decoder() -> Decoder(GraphdefinitionNode) {
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.versionindependentallresourcetypes_decoder(),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use node_id <- decode.field("nodeId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GraphdefinitionNode(
    profile:,
    type_:,
    description:,
    node_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn graphdefinition_to_json(graphdefinition: Graphdefinition) -> Json {
  let Graphdefinition(
    link:,
    node:,
    start:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = graphdefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, graphdefinition_link_to_json)), ..fields]
  }
  let fields = case node {
    [] -> fields
    _ -> [#("node", json.array(node, graphdefinition_node_to_json)), ..fields]
  }
  let fields = case start {
    Some(v) -> [#("start", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          GraphdefinitionVersionalgorithmString(_) -> "String"
          GraphdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        graphdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Graphdefinition")), ..fields]
  json.object(fields)
}

pub fn graphdefinition_decoder() -> Decoder(Graphdefinition) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(graphdefinition_link_decoder()),
  )
  use node <- decode.optional_field(
    "node",
    [],
    decode.list(graphdefinition_node_decoder()),
  )
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(graphdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Graphdefinition",
    decode.failure(graphdefinition_new(status:, name:), "resourceType"),
  )
  decode.success(Graphdefinition(
    link:,
    node:,
    start:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Group#resource
pub type Group {
  Group(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    type_: r5valuesets.Grouptype,
    membership: r5valuesets.Groupmembershipbasis,
    code: Option(Codeableconcept),
    name: Option(String),
    description: Option(String),
    quantity: Option(Int),
    managing_entity: Option(Reference),
    characteristic: List(GroupCharacteristic),
    member: List(GroupMember),
  )
}

pub fn group_new(
  membership membership: r5valuesets.Groupmembershipbasis,
  type_ type_: r5valuesets.Grouptype,
) -> Group {
  Group(
    member: [],
    characteristic: [],
    managing_entity: None,
    quantity: None,
    description: None,
    name: None,
    code: None,
    membership:,
    type_:,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Group#resource
pub type GroupCharacteristic {
  GroupCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: GroupCharacteristicValue,
    exclude: Bool,
    period: Option(Period),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Group#resource
pub type GroupCharacteristicValue {
  GroupCharacteristicValueCodeableconcept(value: Codeableconcept)
  GroupCharacteristicValueBoolean(value: Bool)
  GroupCharacteristicValueQuantity(value: Quantity)
  GroupCharacteristicValueRange(value: Range)
  GroupCharacteristicValueReference(value: Reference)
}

pub fn group_characteristic_value_to_json(elt: GroupCharacteristicValue) -> Json {
  case elt {
    GroupCharacteristicValueCodeableconcept(v) -> codeableconcept_to_json(v)
    GroupCharacteristicValueBoolean(v) -> json.bool(v)
    GroupCharacteristicValueQuantity(v) -> quantity_to_json(v)
    GroupCharacteristicValueRange(v) -> range_to_json(v)
    GroupCharacteristicValueReference(v) -> reference_to_json(v)
  }
}

pub fn group_characteristic_value_decoder() -> Decoder(GroupCharacteristicValue) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(GroupCharacteristicValueCodeableconcept),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(GroupCharacteristicValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(GroupCharacteristicValueReference),
    ],
  )
}

pub fn group_characteristic_new(
  exclude exclude: Bool,
  value value: GroupCharacteristicValue,
  code code: Codeableconcept,
) -> GroupCharacteristic {
  GroupCharacteristic(
    period: None,
    exclude:,
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Group#resource
pub type GroupMember {
  GroupMember(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    entity: Reference,
    period: Option(Period),
    inactive: Option(Bool),
  )
}

pub fn group_member_new(entity entity: Reference) -> GroupMember {
  GroupMember(
    inactive: None,
    period: None,
    entity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn group_member_to_json(group_member: GroupMember) -> Json {
  let GroupMember(
    inactive:,
    period:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ) = group_member
  let fields = [
    #("entity", reference_to_json(entity)),
  ]
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn group_member_decoder() -> Decoder(GroupMember) {
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use entity <- decode.field("entity", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GroupMember(
    inactive:,
    period:,
    entity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn group_characteristic_to_json(
  group_characteristic: GroupCharacteristic,
) -> Json {
  let GroupCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = group_characteristic
  let fields = [
    #("exclude", json.bool(exclude)),
    #("value", group_characteristic_value_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn group_characteristic_decoder() -> Decoder(GroupCharacteristic) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use exclude <- decode.field("exclude", decode.bool)
  use value <- decode.then(group_characteristic_value_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(GroupCharacteristic(
    period:,
    exclude:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn group_to_json(group: Group) -> Json {
  let Group(
    member:,
    characteristic:,
    managing_entity:,
    quantity:,
    description:,
    name:,
    code:,
    membership:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = group
  let fields = [
    #("membership", r5valuesets.groupmembershipbasis_to_json(membership)),
    #("type", r5valuesets.grouptype_to_json(type_)),
  ]
  let fields = case member {
    [] -> fields
    _ -> [#("member", json.array(member, group_member_to_json)), ..fields]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, group_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case managing_entity {
    Some(v) -> [#("managingEntity", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Group")), ..fields]
  json.object(fields)
}

pub fn group_decoder() -> Decoder(Group) {
  use member <- decode.optional_field(
    "member",
    [],
    decode.list(group_member_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(group_characteristic_decoder()),
  )
  use managing_entity <- decode.optional_field(
    "managingEntity",
    None,
    decode.optional(reference_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use membership <- decode.field(
    "membership",
    r5valuesets.groupmembershipbasis_decoder(),
  )
  use type_ <- decode.field("type", r5valuesets.grouptype_decoder())
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Group",
    decode.failure(group_new(membership:, type_:), "resourceType"),
  )
  decode.success(Group(
    member:,
    characteristic:,
    managing_entity:,
    quantity:,
    description:,
    name:,
    code:,
    membership:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/GuidanceResponse#resource
pub type Guidanceresponse {
  Guidanceresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    request_identifier: Option(Identifier),
    identifier: List(Identifier),
    module: GuidanceresponseModule,
    status: r5valuesets.Guidanceresponsestatus,
    subject: Option(Reference),
    encounter: Option(Reference),
    occurrence_date_time: Option(String),
    performer: Option(Reference),
    reason: List(Codeablereference),
    note: List(Annotation),
    evaluation_message: Option(Reference),
    output_parameters: Option(Reference),
    result: List(Reference),
    data_requirement: List(Datarequirement),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/GuidanceResponse#resource
pub type GuidanceresponseModule {
  GuidanceresponseModuleUri(module: String)
  GuidanceresponseModuleCanonical(module: String)
  GuidanceresponseModuleCodeableconcept(module: Codeableconcept)
}

pub fn guidanceresponse_module_to_json(elt: GuidanceresponseModule) -> Json {
  case elt {
    GuidanceresponseModuleUri(v) -> json.string(v)
    GuidanceresponseModuleCanonical(v) -> json.string(v)
    GuidanceresponseModuleCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn guidanceresponse_module_decoder() -> Decoder(GuidanceresponseModule) {
  decode.one_of(
    decode.field("moduleUri", decode.string, decode.success)
      |> decode.map(GuidanceresponseModuleUri),
    [
      decode.field("moduleCanonical", decode.string, decode.success)
        |> decode.map(GuidanceresponseModuleCanonical),
      decode.field(
        "moduleCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(GuidanceresponseModuleCodeableconcept),
    ],
  )
}

pub fn guidanceresponse_new(
  status status: r5valuesets.Guidanceresponsestatus,
  module module: GuidanceresponseModule,
) -> Guidanceresponse {
  Guidanceresponse(
    data_requirement: [],
    result: [],
    output_parameters: None,
    evaluation_message: None,
    note: [],
    reason: [],
    performer: None,
    occurrence_date_time: None,
    encounter: None,
    subject: None,
    status:,
    module:,
    identifier: [],
    request_identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn guidanceresponse_to_json(guidanceresponse: Guidanceresponse) -> Json {
  let Guidanceresponse(
    data_requirement:,
    result:,
    output_parameters:,
    evaluation_message:,
    note:,
    reason:,
    performer:,
    occurrence_date_time:,
    encounter:,
    subject:,
    status:,
    module:,
    identifier:,
    request_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = guidanceresponse
  let fields = [
    #("status", r5valuesets.guidanceresponsestatus_to_json(status)),
    #("module", guidanceresponse_module_to_json(module)),
  ]
  let fields = case data_requirement {
    [] -> fields
    _ -> [
      #(
        "dataRequirement",
        json.array(data_requirement, datarequirement_to_json),
      ),
      ..fields
    ]
  }
  let fields = case result {
    [] -> fields
    _ -> [#("result", json.array(result, reference_to_json)), ..fields]
  }
  let fields = case output_parameters {
    Some(v) -> [#("outputParameters", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case evaluation_message {
    Some(v) -> [#("evaluationMessage", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence_date_time {
    Some(v) -> [#("occurrenceDateTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case request_identifier {
    Some(v) -> [#("requestIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Guidanceresponse")), ..fields]
  json.object(fields)
}

pub fn guidanceresponse_decoder() -> Decoder(Guidanceresponse) {
  use data_requirement <- decode.optional_field(
    "dataRequirement",
    [],
    decode.list(datarequirement_decoder()),
  )
  use result <- decode.optional_field(
    "result",
    [],
    decode.list(reference_decoder()),
  )
  use output_parameters <- decode.optional_field(
    "outputParameters",
    None,
    decode.optional(reference_decoder()),
  )
  use evaluation_message <- decode.optional_field(
    "evaluationMessage",
    None,
    decode.optional(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence_date_time <- decode.optional_field(
    "occurrenceDateTime",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.guidanceresponsestatus_decoder(),
  )
  use module <- decode.then(guidanceresponse_module_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use request_identifier <- decode.optional_field(
    "requestIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Guidanceresponse",
    decode.failure(guidanceresponse_new(status:, module:), "resourceType"),
  )
  decode.success(Guidanceresponse(
    data_requirement:,
    result:,
    output_parameters:,
    evaluation_message:,
    note:,
    reason:,
    performer:,
    occurrence_date_time:,
    encounter:,
    subject:,
    status:,
    module:,
    identifier:,
    request_identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/HealthcareService#resource
pub type Healthcareservice {
  Healthcareservice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    provided_by: Option(Reference),
    offered_in: List(Reference),
    category: List(Codeableconcept),
    type_: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    name: Option(String),
    comment: Option(String),
    extra_details: Option(String),
    photo: Option(Attachment),
    contact: List(Extendedcontactdetail),
    coverage_area: List(Reference),
    service_provision_code: List(Codeableconcept),
    eligibility: List(HealthcareserviceEligibility),
    program: List(Codeableconcept),
    characteristic: List(Codeableconcept),
    communication: List(Codeableconcept),
    referral_method: List(Codeableconcept),
    appointment_required: Option(Bool),
    availability: List(Availability),
    endpoint: List(Reference),
  )
}

pub fn healthcareservice_new() -> Healthcareservice {
  Healthcareservice(
    endpoint: [],
    availability: [],
    appointment_required: None,
    referral_method: [],
    communication: [],
    characteristic: [],
    program: [],
    eligibility: [],
    service_provision_code: [],
    coverage_area: [],
    contact: [],
    photo: None,
    extra_details: None,
    comment: None,
    name: None,
    location: [],
    specialty: [],
    type_: [],
    category: [],
    offered_in: [],
    provided_by: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/HealthcareService#resource
pub type HealthcareserviceEligibility {
  HealthcareserviceEligibility(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    comment: Option(String),
  )
}

pub fn healthcareservice_eligibility_new() -> HealthcareserviceEligibility {
  HealthcareserviceEligibility(
    comment: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn healthcareservice_eligibility_to_json(
  healthcareservice_eligibility: HealthcareserviceEligibility,
) -> Json {
  let HealthcareserviceEligibility(
    comment:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = healthcareservice_eligibility
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn healthcareservice_eligibility_decoder() -> Decoder(
  HealthcareserviceEligibility,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(HealthcareserviceEligibility(
    comment:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn healthcareservice_to_json(healthcareservice: Healthcareservice) -> Json {
  let Healthcareservice(
    endpoint:,
    availability:,
    appointment_required:,
    referral_method:,
    communication:,
    characteristic:,
    program:,
    eligibility:,
    service_provision_code:,
    coverage_area:,
    contact:,
    photo:,
    extra_details:,
    comment:,
    name:,
    location:,
    specialty:,
    type_:,
    category:,
    offered_in:,
    provided_by:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = healthcareservice
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case availability {
    [] -> fields
    _ -> [
      #("availability", json.array(availability, availability_to_json)),
      ..fields
    ]
  }
  let fields = case appointment_required {
    Some(v) -> [#("appointmentRequired", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case referral_method {
    [] -> fields
    _ -> [
      #("referralMethod", json.array(referral_method, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #("communication", json.array(communication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #("characteristic", json.array(characteristic, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case program {
    [] -> fields
    _ -> [#("program", json.array(program, codeableconcept_to_json)), ..fields]
  }
  let fields = case eligibility {
    [] -> fields
    _ -> [
      #(
        "eligibility",
        json.array(eligibility, healthcareservice_eligibility_to_json),
      ),
      ..fields
    ]
  }
  let fields = case service_provision_code {
    [] -> fields
    _ -> [
      #(
        "serviceProvisionCode",
        json.array(service_provision_code, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case photo {
    Some(v) -> [#("photo", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case extra_details {
    Some(v) -> [#("extraDetails", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case offered_in {
    [] -> fields
    _ -> [#("offeredIn", json.array(offered_in, reference_to_json)), ..fields]
  }
  let fields = case provided_by {
    Some(v) -> [#("providedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Healthcareservice")), ..fields]
  json.object(fields)
}

pub fn healthcareservice_decoder() -> Decoder(Healthcareservice) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use availability <- decode.optional_field(
    "availability",
    [],
    decode.list(availability_decoder()),
  )
  use appointment_required <- decode.optional_field(
    "appointmentRequired",
    None,
    decode.optional(decode.bool),
  )
  use referral_method <- decode.optional_field(
    "referralMethod",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use program <- decode.optional_field(
    "program",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use eligibility <- decode.optional_field(
    "eligibility",
    [],
    decode.list(healthcareservice_eligibility_decoder()),
  )
  use service_provision_code <- decode.optional_field(
    "serviceProvisionCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    None,
    decode.optional(attachment_decoder()),
  )
  use extra_details <- decode.optional_field(
    "extraDetails",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use offered_in <- decode.optional_field(
    "offeredIn",
    [],
    decode.list(reference_decoder()),
  )
  use provided_by <- decode.optional_field(
    "providedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Healthcareservice",
    decode.failure(healthcareservice_new(), "resourceType"),
  )
  decode.success(Healthcareservice(
    endpoint:,
    availability:,
    appointment_required:,
    referral_method:,
    communication:,
    characteristic:,
    program:,
    eligibility:,
    service_provision_code:,
    coverage_area:,
    contact:,
    photo:,
    extra_details:,
    comment:,
    name:,
    location:,
    specialty:,
    type_:,
    category:,
    offered_in:,
    provided_by:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingSelection#resource
pub type Imagingselection {
  Imagingselection(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Imagingselectionstatus,
    subject: Option(Reference),
    issued: Option(String),
    performer: List(ImagingselectionPerformer),
    based_on: List(Reference),
    category: List(Codeableconcept),
    code: Codeableconcept,
    study_uid: Option(String),
    derived_from: List(Reference),
    endpoint: List(Reference),
    series_uid: Option(String),
    series_number: Option(Int),
    frame_of_reference_uid: Option(String),
    body_site: Option(Codeablereference),
    focus: List(Reference),
    instance: List(ImagingselectionInstance),
  )
}

pub fn imagingselection_new(
  code code: Codeableconcept,
  status status: r5valuesets.Imagingselectionstatus,
) -> Imagingselection {
  Imagingselection(
    instance: [],
    focus: [],
    body_site: None,
    frame_of_reference_uid: None,
    series_number: None,
    series_uid: None,
    endpoint: [],
    derived_from: [],
    study_uid: None,
    code:,
    category: [],
    based_on: [],
    performer: [],
    issued: None,
    subject: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingSelection#resource
pub type ImagingselectionPerformer {
  ImagingselectionPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Option(Reference),
  )
}

pub fn imagingselection_performer_new() -> ImagingselectionPerformer {
  ImagingselectionPerformer(
    actor: None,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingSelection#resource
pub type ImagingselectionInstance {
  ImagingselectionInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uid: String,
    number: Option(Int),
    sop_class: Option(Coding),
    subset: List(String),
    image_region2_d: List(ImagingselectionInstanceImageregion2d),
    image_region3_d: List(ImagingselectionInstanceImageregion3d),
  )
}

pub fn imagingselection_instance_new(
  uid uid: String,
) -> ImagingselectionInstance {
  ImagingselectionInstance(
    image_region3_d: [],
    image_region2_d: [],
    subset: [],
    sop_class: None,
    number: None,
    uid:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingSelection#resource
pub type ImagingselectionInstanceImageregion2d {
  ImagingselectionInstanceImageregion2d(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    region_type: r5valuesets.Imagingselection2dgraphictype,
    coordinate: List(Float),
  )
}

pub fn imagingselection_instance_imageregion2d_new(
  region_type region_type: r5valuesets.Imagingselection2dgraphictype,
) -> ImagingselectionInstanceImageregion2d {
  ImagingselectionInstanceImageregion2d(
    coordinate: [],
    region_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingSelection#resource
pub type ImagingselectionInstanceImageregion3d {
  ImagingselectionInstanceImageregion3d(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    region_type: r5valuesets.Imagingselection3dgraphictype,
    coordinate: List(Float),
  )
}

pub fn imagingselection_instance_imageregion3d_new(
  region_type region_type: r5valuesets.Imagingselection3dgraphictype,
) -> ImagingselectionInstanceImageregion3d {
  ImagingselectionInstanceImageregion3d(
    coordinate: [],
    region_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn imagingselection_instance_imageregion3d_to_json(
  imagingselection_instance_imageregion3d: ImagingselectionInstanceImageregion3d,
) -> Json {
  let ImagingselectionInstanceImageregion3d(
    coordinate:,
    region_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingselection_instance_imageregion3d
  let fields = [
    #(
      "regionType",
      r5valuesets.imagingselection3dgraphictype_to_json(region_type),
    ),
  ]
  let fields = case coordinate {
    [] -> fields
    _ -> [#("coordinate", json.array(coordinate, json.float)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingselection_instance_imageregion3d_decoder() -> Decoder(
  ImagingselectionInstanceImageregion3d,
) {
  use coordinate <- decode.optional_field(
    "coordinate",
    [],
    decode.list(decode.float),
  )
  use region_type <- decode.field(
    "regionType",
    r5valuesets.imagingselection3dgraphictype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingselectionInstanceImageregion3d(
    coordinate:,
    region_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingselection_instance_imageregion2d_to_json(
  imagingselection_instance_imageregion2d: ImagingselectionInstanceImageregion2d,
) -> Json {
  let ImagingselectionInstanceImageregion2d(
    coordinate:,
    region_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingselection_instance_imageregion2d
  let fields = [
    #(
      "regionType",
      r5valuesets.imagingselection2dgraphictype_to_json(region_type),
    ),
  ]
  let fields = case coordinate {
    [] -> fields
    _ -> [#("coordinate", json.array(coordinate, json.float)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingselection_instance_imageregion2d_decoder() -> Decoder(
  ImagingselectionInstanceImageregion2d,
) {
  use coordinate <- decode.optional_field(
    "coordinate",
    [],
    decode.list(decode.float),
  )
  use region_type <- decode.field(
    "regionType",
    r5valuesets.imagingselection2dgraphictype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingselectionInstanceImageregion2d(
    coordinate:,
    region_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingselection_instance_to_json(
  imagingselection_instance: ImagingselectionInstance,
) -> Json {
  let ImagingselectionInstance(
    image_region3_d:,
    image_region2_d:,
    subset:,
    sop_class:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingselection_instance
  let fields = [
    #("uid", json.string(uid)),
  ]
  let fields = case image_region3_d {
    [] -> fields
    _ -> [
      #(
        "imageRegion3D",
        json.array(
          image_region3_d,
          imagingselection_instance_imageregion3d_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case image_region2_d {
    [] -> fields
    _ -> [
      #(
        "imageRegion2D",
        json.array(
          image_region2_d,
          imagingselection_instance_imageregion2d_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case subset {
    [] -> fields
    _ -> [#("subset", json.array(subset, json.string)), ..fields]
  }
  let fields = case sop_class {
    Some(v) -> [#("sopClass", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingselection_instance_decoder() -> Decoder(ImagingselectionInstance) {
  use image_region3_d <- decode.optional_field(
    "imageRegion3D",
    [],
    decode.list(imagingselection_instance_imageregion3d_decoder()),
  )
  use image_region2_d <- decode.optional_field(
    "imageRegion2D",
    [],
    decode.list(imagingselection_instance_imageregion2d_decoder()),
  )
  use subset <- decode.optional_field("subset", [], decode.list(decode.string))
  use sop_class <- decode.optional_field(
    "sopClass",
    None,
    decode.optional(coding_decoder()),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use uid <- decode.field("uid", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingselectionInstance(
    image_region3_d:,
    image_region2_d:,
    subset:,
    sop_class:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingselection_performer_to_json(
  imagingselection_performer: ImagingselectionPerformer,
) -> Json {
  let ImagingselectionPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingselection_performer
  let fields = []
  let fields = case actor {
    Some(v) -> [#("actor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingselection_performer_decoder() -> Decoder(
  ImagingselectionPerformer,
) {
  use actor <- decode.optional_field(
    "actor",
    None,
    decode.optional(reference_decoder()),
  )
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingselectionPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingselection_to_json(imagingselection: Imagingselection) -> Json {
  let Imagingselection(
    instance:,
    focus:,
    body_site:,
    frame_of_reference_uid:,
    series_number:,
    series_uid:,
    endpoint:,
    derived_from:,
    study_uid:,
    code:,
    category:,
    based_on:,
    performer:,
    issued:,
    subject:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = imagingselection
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.imagingselectionstatus_to_json(status)),
  ]
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, imagingselection_instance_to_json)),
      ..fields
    ]
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case frame_of_reference_uid {
    Some(v) -> [#("frameOfReferenceUid", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case series_number {
    Some(v) -> [#("seriesNumber", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case series_uid {
    Some(v) -> [#("seriesUid", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case study_uid {
    Some(v) -> [#("studyUid", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, imagingselection_performer_to_json)),
      ..fields
    ]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Imagingselection")), ..fields]
  json.object(fields)
}

pub fn imagingselection_decoder() -> Decoder(Imagingselection) {
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(imagingselection_instance_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use frame_of_reference_uid <- decode.optional_field(
    "frameOfReferenceUid",
    None,
    decode.optional(decode.string),
  )
  use series_number <- decode.optional_field(
    "seriesNumber",
    None,
    decode.optional(decode.int),
  )
  use series_uid <- decode.optional_field(
    "seriesUid",
    None,
    decode.optional(decode.string),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use study_uid <- decode.optional_field(
    "studyUid",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(imagingselection_performer_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.imagingselectionstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Imagingselection",
    decode.failure(imagingselection_new(code:, status:), "resourceType"),
  )
  decode.success(Imagingselection(
    instance:,
    focus:,
    body_site:,
    frame_of_reference_uid:,
    series_number:,
    series_uid:,
    endpoint:,
    derived_from:,
    study_uid:,
    code:,
    category:,
    based_on:,
    performer:,
    issued:,
    subject:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingStudy#resource
pub type Imagingstudy {
  Imagingstudy(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Imagingstudystatus,
    modality: List(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    started: Option(String),
    based_on: List(Reference),
    part_of: List(Reference),
    referrer: Option(Reference),
    endpoint: List(Reference),
    number_of_series: Option(Int),
    number_of_instances: Option(Int),
    procedure: List(Codeablereference),
    location: Option(Reference),
    reason: List(Codeablereference),
    note: List(Annotation),
    description: Option(String),
    series: List(ImagingstudySeries),
  )
}

pub fn imagingstudy_new(
  subject subject: Reference,
  status status: r5valuesets.Imagingstudystatus,
) -> Imagingstudy {
  Imagingstudy(
    series: [],
    description: None,
    note: [],
    reason: [],
    location: None,
    procedure: [],
    number_of_instances: None,
    number_of_series: None,
    endpoint: [],
    referrer: None,
    part_of: [],
    based_on: [],
    started: None,
    encounter: None,
    subject:,
    modality: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeries {
  ImagingstudySeries(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uid: String,
    number: Option(Int),
    modality: Codeableconcept,
    description: Option(String),
    number_of_instances: Option(Int),
    endpoint: List(Reference),
    body_site: Option(Codeablereference),
    laterality: Option(Codeableconcept),
    specimen: List(Reference),
    started: Option(String),
    performer: List(ImagingstudySeriesPerformer),
    instance: List(ImagingstudySeriesInstance),
  )
}

pub fn imagingstudy_series_new(
  modality modality: Codeableconcept,
  uid uid: String,
) -> ImagingstudySeries {
  ImagingstudySeries(
    instance: [],
    performer: [],
    started: None,
    specimen: [],
    laterality: None,
    body_site: None,
    endpoint: [],
    number_of_instances: None,
    description: None,
    modality:,
    number: None,
    uid:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesPerformer {
  ImagingstudySeriesPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn imagingstudy_series_performer_new(
  actor actor: Reference,
) -> ImagingstudySeriesPerformer {
  ImagingstudySeriesPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImagingStudy#resource
pub type ImagingstudySeriesInstance {
  ImagingstudySeriesInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uid: String,
    sop_class: Coding,
    number: Option(Int),
    title: Option(String),
  )
}

pub fn imagingstudy_series_instance_new(
  sop_class sop_class: Coding,
  uid uid: String,
) -> ImagingstudySeriesInstance {
  ImagingstudySeriesInstance(
    title: None,
    number: None,
    sop_class:,
    uid:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn imagingstudy_series_instance_to_json(
  imagingstudy_series_instance: ImagingstudySeriesInstance,
) -> Json {
  let ImagingstudySeriesInstance(
    title:,
    number:,
    sop_class:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series_instance
  let fields = [
    #("sopClass", coding_to_json(sop_class)),
    #("uid", json.string(uid)),
  ]
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_instance_decoder() -> Decoder(
  ImagingstudySeriesInstance,
) {
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use sop_class <- decode.field("sopClass", coding_decoder())
  use uid <- decode.field("uid", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeriesInstance(
    title:,
    number:,
    sop_class:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_series_performer_to_json(
  imagingstudy_series_performer: ImagingstudySeriesPerformer,
) -> Json {
  let ImagingstudySeriesPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_performer_decoder() -> Decoder(
  ImagingstudySeriesPerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeriesPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_series_to_json(
  imagingstudy_series: ImagingstudySeries,
) -> Json {
  let ImagingstudySeries(
    instance:,
    performer:,
    started:,
    specimen:,
    laterality:,
    body_site:,
    endpoint:,
    number_of_instances:,
    description:,
    modality:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ) = imagingstudy_series
  let fields = [
    #("modality", codeableconcept_to_json(modality)),
    #("uid", json.string(uid)),
  ]
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, imagingstudy_series_instance_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, imagingstudy_series_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case started {
    Some(v) -> [#("started", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case laterality {
    Some(v) -> [#("laterality", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case number_of_instances {
    Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number {
    Some(v) -> [#("number", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn imagingstudy_series_decoder() -> Decoder(ImagingstudySeries) {
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(imagingstudy_series_instance_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(imagingstudy_series_performer_decoder()),
  )
  use started <- decode.optional_field(
    "started",
    None,
    decode.optional(decode.string),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use laterality <- decode.optional_field(
    "laterality",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use number_of_instances <- decode.optional_field(
    "numberOfInstances",
    None,
    decode.optional(decode.int),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modality <- decode.field("modality", codeableconcept_decoder())
  use number <- decode.optional_field(
    "number",
    None,
    decode.optional(decode.int),
  )
  use uid <- decode.field("uid", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImagingstudySeries(
    instance:,
    performer:,
    started:,
    specimen:,
    laterality:,
    body_site:,
    endpoint:,
    number_of_instances:,
    description:,
    modality:,
    number:,
    uid:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn imagingstudy_to_json(imagingstudy: Imagingstudy) -> Json {
  let Imagingstudy(
    series:,
    description:,
    note:,
    reason:,
    location:,
    procedure:,
    number_of_instances:,
    number_of_series:,
    endpoint:,
    referrer:,
    part_of:,
    based_on:,
    started:,
    encounter:,
    subject:,
    modality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = imagingstudy
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.imagingstudystatus_to_json(status)),
  ]
  let fields = case series {
    [] -> fields
    _ -> [
      #("series", json.array(series, imagingstudy_series_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case procedure {
    [] -> fields
    _ -> [
      #("procedure", json.array(procedure, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case number_of_instances {
    Some(v) -> [#("numberOfInstances", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_series {
    Some(v) -> [#("numberOfSeries", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case referrer {
    Some(v) -> [#("referrer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case started {
    Some(v) -> [#("started", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modality {
    [] -> fields
    _ -> [
      #("modality", json.array(modality, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Imagingstudy")), ..fields]
  json.object(fields)
}

pub fn imagingstudy_decoder() -> Decoder(Imagingstudy) {
  use series <- decode.optional_field(
    "series",
    [],
    decode.list(imagingstudy_series_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    [],
    decode.list(codeablereference_decoder()),
  )
  use number_of_instances <- decode.optional_field(
    "numberOfInstances",
    None,
    decode.optional(decode.int),
  )
  use number_of_series <- decode.optional_field(
    "numberOfSeries",
    None,
    decode.optional(decode.int),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use referrer <- decode.optional_field(
    "referrer",
    None,
    decode.optional(reference_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use started <- decode.optional_field(
    "started",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use modality <- decode.optional_field(
    "modality",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.imagingstudystatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Imagingstudy",
    decode.failure(imagingstudy_new(subject:, status:), "resourceType"),
  )
  decode.success(Imagingstudy(
    series:,
    description:,
    note:,
    reason:,
    location:,
    procedure:,
    number_of_instances:,
    number_of_series:,
    endpoint:,
    referrer:,
    part_of:,
    based_on:,
    started:,
    encounter:,
    subject:,
    modality:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type Immunization {
  Immunization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    status: r5valuesets.Immunizationstatus,
    status_reason: Option(Codeableconcept),
    vaccine_code: Codeableconcept,
    administered_product: Option(Codeablereference),
    manufacturer: Option(Codeablereference),
    lot_number: Option(String),
    expiration_date: Option(String),
    patient: Reference,
    encounter: Option(Reference),
    supporting_information: List(Reference),
    occurrence: ImmunizationOccurrence,
    primary_source: Option(Bool),
    information_source: Option(Codeablereference),
    location: Option(Reference),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    dose_quantity: Option(Quantity),
    performer: List(ImmunizationPerformer),
    note: List(Annotation),
    reason: List(Codeablereference),
    is_subpotent: Option(Bool),
    subpotent_reason: List(Codeableconcept),
    program_eligibility: List(ImmunizationProgrameligibility),
    funding_source: Option(Codeableconcept),
    reaction: List(ImmunizationReaction),
    protocol_applied: List(ImmunizationProtocolapplied),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type ImmunizationOccurrence {
  ImmunizationOccurrenceDatetime(occurrence: String)
  ImmunizationOccurrenceString(occurrence: String)
}

pub fn immunization_occurrence_to_json(elt: ImmunizationOccurrence) -> Json {
  case elt {
    ImmunizationOccurrenceDatetime(v) -> json.string(v)
    ImmunizationOccurrenceString(v) -> json.string(v)
  }
}

pub fn immunization_occurrence_decoder() -> Decoder(ImmunizationOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ImmunizationOccurrenceDatetime),
    [
      decode.field("occurrenceString", decode.string, decode.success)
      |> decode.map(ImmunizationOccurrenceString),
    ],
  )
}

pub fn immunization_new(
  occurrence occurrence: ImmunizationOccurrence,
  patient patient: Reference,
  vaccine_code vaccine_code: Codeableconcept,
  status status: r5valuesets.Immunizationstatus,
) -> Immunization {
  Immunization(
    protocol_applied: [],
    reaction: [],
    funding_source: None,
    program_eligibility: [],
    subpotent_reason: [],
    is_subpotent: None,
    reason: [],
    note: [],
    performer: [],
    dose_quantity: None,
    route: None,
    site: None,
    location: None,
    information_source: None,
    primary_source: None,
    occurrence:,
    supporting_information: [],
    encounter: None,
    patient:,
    expiration_date: None,
    lot_number: None,
    manufacturer: None,
    administered_product: None,
    vaccine_code:,
    status_reason: None,
    status:,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type ImmunizationPerformer {
  ImmunizationPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn immunization_performer_new(
  actor actor: Reference,
) -> ImmunizationPerformer {
  ImmunizationPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type ImmunizationProgrameligibility {
  ImmunizationProgrameligibility(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    program: Codeableconcept,
    program_status: Codeableconcept,
  )
}

pub fn immunization_programeligibility_new(
  program_status program_status: Codeableconcept,
  program program: Codeableconcept,
) -> ImmunizationProgrameligibility {
  ImmunizationProgrameligibility(
    program_status:,
    program:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type ImmunizationReaction {
  ImmunizationReaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    date: Option(String),
    manifestation: Option(Codeablereference),
    reported: Option(Bool),
  )
}

pub fn immunization_reaction_new() -> ImmunizationReaction {
  ImmunizationReaction(
    reported: None,
    manifestation: None,
    date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Immunization#resource
pub type ImmunizationProtocolapplied {
  ImmunizationProtocolapplied(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    series: Option(String),
    authority: Option(Reference),
    target_disease: List(Codeableconcept),
    dose_number: String,
    series_doses: Option(String),
  )
}

pub fn immunization_protocolapplied_new(
  dose_number dose_number: String,
) -> ImmunizationProtocolapplied {
  ImmunizationProtocolapplied(
    series_doses: None,
    dose_number:,
    target_disease: [],
    authority: None,
    series: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn immunization_protocolapplied_to_json(
  immunization_protocolapplied: ImmunizationProtocolapplied,
) -> Json {
  let ImmunizationProtocolapplied(
    series_doses:,
    dose_number:,
    target_disease:,
    authority:,
    series:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_protocolapplied
  let fields = [
    #("doseNumber", json.string(dose_number)),
  ]
  let fields = case series_doses {
    Some(v) -> [#("seriesDoses", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target_disease {
    [] -> fields
    _ -> [
      #("targetDisease", json.array(target_disease, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_protocolapplied_decoder() -> Decoder(
  ImmunizationProtocolapplied,
) {
  use series_doses <- decode.optional_field(
    "seriesDoses",
    None,
    decode.optional(decode.string),
  )
  use dose_number <- decode.field("doseNumber", decode.string)
  use target_disease <- decode.optional_field(
    "targetDisease",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationProtocolapplied(
    series_doses:,
    dose_number:,
    target_disease:,
    authority:,
    series:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_reaction_to_json(
  immunization_reaction: ImmunizationReaction,
) -> Json {
  let ImmunizationReaction(
    reported:,
    manifestation:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_reaction
  let fields = []
  let fields = case reported {
    Some(v) -> [#("reported", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case manifestation {
    Some(v) -> [#("manifestation", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_reaction_decoder() -> Decoder(ImmunizationReaction) {
  use reported <- decode.optional_field(
    "reported",
    None,
    decode.optional(decode.bool),
  )
  use manifestation <- decode.optional_field(
    "manifestation",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationReaction(
    reported:,
    manifestation:,
    date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_programeligibility_to_json(
  immunization_programeligibility: ImmunizationProgrameligibility,
) -> Json {
  let ImmunizationProgrameligibility(
    program_status:,
    program:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_programeligibility
  let fields = [
    #("programStatus", codeableconcept_to_json(program_status)),
    #("program", codeableconcept_to_json(program)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_programeligibility_decoder() -> Decoder(
  ImmunizationProgrameligibility,
) {
  use program_status <- decode.field("programStatus", codeableconcept_decoder())
  use program <- decode.field("program", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationProgrameligibility(
    program_status:,
    program:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_performer_to_json(
  immunization_performer: ImmunizationPerformer,
) -> Json {
  let ImmunizationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunization_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunization_performer_decoder() -> Decoder(ImmunizationPerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunization_to_json(immunization: Immunization) -> Json {
  let Immunization(
    protocol_applied:,
    reaction:,
    funding_source:,
    program_eligibility:,
    subpotent_reason:,
    is_subpotent:,
    reason:,
    note:,
    performer:,
    dose_quantity:,
    route:,
    site:,
    location:,
    information_source:,
    primary_source:,
    occurrence:,
    supporting_information:,
    encounter:,
    patient:,
    expiration_date:,
    lot_number:,
    manufacturer:,
    administered_product:,
    vaccine_code:,
    status_reason:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunization
  let fields = [
    #("occurrence", immunization_occurrence_to_json(occurrence)),
    #("patient", reference_to_json(patient)),
    #("vaccineCode", codeableconcept_to_json(vaccine_code)),
    #("status", r5valuesets.immunizationstatus_to_json(status)),
  ]
  let fields = case protocol_applied {
    [] -> fields
    _ -> [
      #(
        "protocolApplied",
        json.array(protocol_applied, immunization_protocolapplied_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reaction {
    [] -> fields
    _ -> [
      #("reaction", json.array(reaction, immunization_reaction_to_json)),
      ..fields
    ]
  }
  let fields = case funding_source {
    Some(v) -> [#("fundingSource", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case program_eligibility {
    [] -> fields
    _ -> [
      #(
        "programEligibility",
        json.array(program_eligibility, immunization_programeligibility_to_json),
      ),
      ..fields
    ]
  }
  let fields = case subpotent_reason {
    [] -> fields
    _ -> [
      #(
        "subpotentReason",
        json.array(subpotent_reason, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case is_subpotent {
    Some(v) -> [#("isSubpotent", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, immunization_performer_to_json)),
      ..fields
    ]
  }
  let fields = case dose_quantity {
    Some(v) -> [#("doseQuantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case information_source {
    Some(v) -> [#("informationSource", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case primary_source {
    Some(v) -> [#("primarySource", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case manufacturer {
    Some(v) -> [#("manufacturer", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case administered_product {
    Some(v) -> [
      #("administeredProduct", codeablereference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Immunization")), ..fields]
  json.object(fields)
}

pub fn immunization_decoder() -> Decoder(Immunization) {
  use protocol_applied <- decode.optional_field(
    "protocolApplied",
    [],
    decode.list(immunization_protocolapplied_decoder()),
  )
  use reaction <- decode.optional_field(
    "reaction",
    [],
    decode.list(immunization_reaction_decoder()),
  )
  use funding_source <- decode.optional_field(
    "fundingSource",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use program_eligibility <- decode.optional_field(
    "programEligibility",
    [],
    decode.list(immunization_programeligibility_decoder()),
  )
  use subpotent_reason <- decode.optional_field(
    "subpotentReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use is_subpotent <- decode.optional_field(
    "isSubpotent",
    None,
    decode.optional(decode.bool),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(immunization_performer_decoder()),
  )
  use dose_quantity <- decode.optional_field(
    "doseQuantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use primary_source <- decode.optional_field(
    "primarySource",
    None,
    decode.optional(decode.bool),
  )
  use occurrence <- decode.then(immunization_occurrence_decoder())
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use administered_product <- decode.optional_field(
    "administeredProduct",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use vaccine_code <- decode.field("vaccineCode", codeableconcept_decoder())
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.immunizationstatus_decoder())
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunization",
    decode.failure(
      immunization_new(occurrence:, patient:, vaccine_code:, status:),
      "resourceType",
    ),
  )
  decode.success(Immunization(
    protocol_applied:,
    reaction:,
    funding_source:,
    program_eligibility:,
    subpotent_reason:,
    is_subpotent:,
    reason:,
    note:,
    performer:,
    dose_quantity:,
    route:,
    site:,
    location:,
    information_source:,
    primary_source:,
    occurrence:,
    supporting_information:,
    encounter:,
    patient:,
    expiration_date:,
    lot_number:,
    manufacturer:,
    administered_product:,
    vaccine_code:,
    status_reason:,
    status:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ImmunizationEvaluation#resource
pub type Immunizationevaluation {
  Immunizationevaluation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Immunizationevaluationstatus,
    patient: Reference,
    date: Option(String),
    authority: Option(Reference),
    target_disease: Codeableconcept,
    immunization_event: Reference,
    dose_status: Codeableconcept,
    dose_status_reason: List(Codeableconcept),
    description: Option(String),
    series: Option(String),
    dose_number: Option(String),
    series_doses: Option(String),
  )
}

pub fn immunizationevaluation_new(
  dose_status dose_status: Codeableconcept,
  immunization_event immunization_event: Reference,
  target_disease target_disease: Codeableconcept,
  patient patient: Reference,
  status status: r5valuesets.Immunizationevaluationstatus,
) -> Immunizationevaluation {
  Immunizationevaluation(
    series_doses: None,
    dose_number: None,
    series: None,
    description: None,
    dose_status_reason: [],
    dose_status:,
    immunization_event:,
    target_disease:,
    authority: None,
    date: None,
    patient:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn immunizationevaluation_to_json(
  immunizationevaluation: Immunizationevaluation,
) -> Json {
  let Immunizationevaluation(
    series_doses:,
    dose_number:,
    series:,
    description:,
    dose_status_reason:,
    dose_status:,
    immunization_event:,
    target_disease:,
    authority:,
    date:,
    patient:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunizationevaluation
  let fields = [
    #("doseStatus", codeableconcept_to_json(dose_status)),
    #("immunizationEvent", reference_to_json(immunization_event)),
    #("targetDisease", codeableconcept_to_json(target_disease)),
    #("patient", reference_to_json(patient)),
    #("status", r5valuesets.immunizationevaluationstatus_to_json(status)),
  ]
  let fields = case series_doses {
    Some(v) -> [#("seriesDoses", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dose_number {
    Some(v) -> [#("doseNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dose_status_reason {
    [] -> fields
    _ -> [
      #(
        "doseStatusReason",
        json.array(dose_status_reason, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Immunizationevaluation")),
    ..fields
  ]
  json.object(fields)
}

pub fn immunizationevaluation_decoder() -> Decoder(Immunizationevaluation) {
  use series_doses <- decode.optional_field(
    "seriesDoses",
    None,
    decode.optional(decode.string),
  )
  use dose_number <- decode.optional_field(
    "doseNumber",
    None,
    decode.optional(decode.string),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use dose_status_reason <- decode.optional_field(
    "doseStatusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use dose_status <- decode.field("doseStatus", codeableconcept_decoder())
  use immunization_event <- decode.field(
    "immunizationEvent",
    reference_decoder(),
  )
  use target_disease <- decode.field("targetDisease", codeableconcept_decoder())
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use patient <- decode.field("patient", reference_decoder())
  use status <- decode.field(
    "status",
    r5valuesets.immunizationevaluationstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunizationevaluation",
    decode.failure(
      immunizationevaluation_new(
        dose_status:,
        immunization_event:,
        target_disease:,
        patient:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Immunizationevaluation(
    series_doses:,
    dose_number:,
    series:,
    description:,
    dose_status_reason:,
    dose_status:,
    immunization_event:,
    target_disease:,
    authority:,
    date:,
    patient:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ImmunizationRecommendation#resource
pub type Immunizationrecommendation {
  Immunizationrecommendation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    patient: Reference,
    date: String,
    authority: Option(Reference),
    recommendation: List(ImmunizationrecommendationRecommendation),
  )
}

pub fn immunizationrecommendation_new(
  date date: String,
  patient patient: Reference,
) -> Immunizationrecommendation {
  Immunizationrecommendation(
    recommendation: [],
    authority: None,
    date:,
    patient:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendation {
  ImmunizationrecommendationRecommendation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    vaccine_code: List(Codeableconcept),
    target_disease: List(Codeableconcept),
    contraindicated_vaccine_code: List(Codeableconcept),
    forecast_status: Codeableconcept,
    forecast_reason: List(Codeableconcept),
    date_criterion: List(ImmunizationrecommendationRecommendationDatecriterion),
    description: Option(String),
    series: Option(String),
    dose_number: Option(String),
    series_doses: Option(String),
    supporting_immunization: List(Reference),
    supporting_patient_information: List(Reference),
  )
}

pub fn immunizationrecommendation_recommendation_new(
  forecast_status forecast_status: Codeableconcept,
) -> ImmunizationrecommendationRecommendation {
  ImmunizationrecommendationRecommendation(
    supporting_patient_information: [],
    supporting_immunization: [],
    series_doses: None,
    dose_number: None,
    series: None,
    description: None,
    date_criterion: [],
    forecast_reason: [],
    forecast_status:,
    contraindicated_vaccine_code: [],
    target_disease: [],
    vaccine_code: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImmunizationRecommendation#resource
pub type ImmunizationrecommendationRecommendationDatecriterion {
  ImmunizationrecommendationRecommendationDatecriterion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: String,
  )
}

pub fn immunizationrecommendation_recommendation_datecriterion_new(
  value value: String,
  code code: Codeableconcept,
) -> ImmunizationrecommendationRecommendationDatecriterion {
  ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn immunizationrecommendation_recommendation_datecriterion_to_json(
  immunizationrecommendation_recommendation_datecriterion: ImmunizationrecommendationRecommendationDatecriterion,
) -> Json {
  let ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunizationrecommendation_recommendation_datecriterion
  let fields = [
    #("value", json.string(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunizationrecommendation_recommendation_datecriterion_decoder() -> Decoder(
  ImmunizationrecommendationRecommendationDatecriterion,
) {
  use value <- decode.field("value", decode.string)
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationrecommendationRecommendationDatecriterion(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunizationrecommendation_recommendation_to_json(
  immunizationrecommendation_recommendation: ImmunizationrecommendationRecommendation,
) -> Json {
  let ImmunizationrecommendationRecommendation(
    supporting_patient_information:,
    supporting_immunization:,
    series_doses:,
    dose_number:,
    series:,
    description:,
    date_criterion:,
    forecast_reason:,
    forecast_status:,
    contraindicated_vaccine_code:,
    target_disease:,
    vaccine_code:,
    modifier_extension:,
    extension:,
    id:,
  ) = immunizationrecommendation_recommendation
  let fields = [
    #("forecastStatus", codeableconcept_to_json(forecast_status)),
  ]
  let fields = case supporting_patient_information {
    [] -> fields
    _ -> [
      #(
        "supportingPatientInformation",
        json.array(supporting_patient_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_immunization {
    [] -> fields
    _ -> [
      #(
        "supportingImmunization",
        json.array(supporting_immunization, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case series_doses {
    Some(v) -> [#("seriesDoses", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dose_number {
    Some(v) -> [#("doseNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case series {
    Some(v) -> [#("series", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date_criterion {
    [] -> fields
    _ -> [
      #(
        "dateCriterion",
        json.array(
          date_criterion,
          immunizationrecommendation_recommendation_datecriterion_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case forecast_reason {
    [] -> fields
    _ -> [
      #("forecastReason", json.array(forecast_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case contraindicated_vaccine_code {
    [] -> fields
    _ -> [
      #(
        "contraindicatedVaccineCode",
        json.array(contraindicated_vaccine_code, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target_disease {
    [] -> fields
    _ -> [
      #("targetDisease", json.array(target_disease, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case vaccine_code {
    [] -> fields
    _ -> [
      #("vaccineCode", json.array(vaccine_code, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn immunizationrecommendation_recommendation_decoder() -> Decoder(
  ImmunizationrecommendationRecommendation,
) {
  use supporting_patient_information <- decode.optional_field(
    "supportingPatientInformation",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_immunization <- decode.optional_field(
    "supportingImmunization",
    [],
    decode.list(reference_decoder()),
  )
  use series_doses <- decode.optional_field(
    "seriesDoses",
    None,
    decode.optional(decode.string),
  )
  use dose_number <- decode.optional_field(
    "doseNumber",
    None,
    decode.optional(decode.string),
  )
  use series <- decode.optional_field(
    "series",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use date_criterion <- decode.optional_field(
    "dateCriterion",
    [],
    decode.list(
      immunizationrecommendation_recommendation_datecriterion_decoder(),
    ),
  )
  use forecast_reason <- decode.optional_field(
    "forecastReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use forecast_status <- decode.field(
    "forecastStatus",
    codeableconcept_decoder(),
  )
  use contraindicated_vaccine_code <- decode.optional_field(
    "contraindicatedVaccineCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use target_disease <- decode.optional_field(
    "targetDisease",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use vaccine_code <- decode.optional_field(
    "vaccineCode",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImmunizationrecommendationRecommendation(
    supporting_patient_information:,
    supporting_immunization:,
    series_doses:,
    dose_number:,
    series:,
    description:,
    date_criterion:,
    forecast_reason:,
    forecast_status:,
    contraindicated_vaccine_code:,
    target_disease:,
    vaccine_code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn immunizationrecommendation_to_json(
  immunizationrecommendation: Immunizationrecommendation,
) -> Json {
  let Immunizationrecommendation(
    recommendation:,
    authority:,
    date:,
    patient:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = immunizationrecommendation
  let fields = [
    #("date", json.string(date)),
    #("patient", reference_to_json(patient)),
  ]
  let fields = case recommendation {
    [] -> fields
    _ -> [
      #(
        "recommendation",
        json.array(
          recommendation,
          immunizationrecommendation_recommendation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case authority {
    Some(v) -> [#("authority", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Immunizationrecommendation")),
    ..fields
  ]
  json.object(fields)
}

pub fn immunizationrecommendation_decoder() -> Decoder(
  Immunizationrecommendation,
) {
  use recommendation <- decode.optional_field(
    "recommendation",
    [],
    decode.list(immunizationrecommendation_recommendation_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use patient <- decode.field("patient", reference_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Immunizationrecommendation",
    decode.failure(
      immunizationrecommendation_new(date:, patient:),
      "resourceType",
    ),
  )
  decode.success(Immunizationrecommendation(
    recommendation:,
    authority:,
    date:,
    patient:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type Implementationguide {
  Implementationguide(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ImplementationguideVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    package_id: String,
    license: Option(r5valuesets.Spdxlicense),
    fhir_version: List(r5valuesets.Fhirversion),
    depends_on: List(ImplementationguideDependson),
    global: List(ImplementationguideGlobal),
    definition: Option(ImplementationguideDefinition),
    manifest: Option(ImplementationguideManifest),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideVersionalgorithm {
  ImplementationguideVersionalgorithmString(version_algorithm: String)
  ImplementationguideVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn implementationguide_versionalgorithm_to_json(
  elt: ImplementationguideVersionalgorithm,
) -> Json {
  case elt {
    ImplementationguideVersionalgorithmString(v) -> json.string(v)
    ImplementationguideVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn implementationguide_versionalgorithm_decoder() -> Decoder(
  ImplementationguideVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ImplementationguideVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ImplementationguideVersionalgorithmCoding),
    ],
  )
}

pub fn implementationguide_new(
  package_id package_id: String,
  status status: r5valuesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Implementationguide {
  Implementationguide(
    manifest: None,
    definition: None,
    global: [],
    depends_on: [],
    fhir_version: [],
    license: None,
    package_id:,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDependson {
  ImplementationguideDependson(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uri: String,
    package_id: Option(String),
    version: Option(String),
    reason: Option(String),
  )
}

pub fn implementationguide_dependson_new(
  uri uri: String,
) -> ImplementationguideDependson {
  ImplementationguideDependson(
    reason: None,
    version: None,
    package_id: None,
    uri:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideGlobal {
  ImplementationguideGlobal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Resourcetypes,
    profile: String,
  )
}

pub fn implementationguide_global_new(
  profile profile: String,
  type_ type_: r5valuesets.Resourcetypes,
) -> ImplementationguideGlobal {
  ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinition {
  ImplementationguideDefinition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    grouping: List(ImplementationguideDefinitionGrouping),
    resource: List(ImplementationguideDefinitionResource),
    page: Option(ImplementationguideDefinitionPage),
    parameter: List(ImplementationguideDefinitionParameter),
    template: List(ImplementationguideDefinitionTemplate),
  )
}

pub fn implementationguide_definition_new() -> ImplementationguideDefinition {
  ImplementationguideDefinition(
    template: [],
    parameter: [],
    page: None,
    resource: [],
    grouping: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionGrouping {
  ImplementationguideDefinitionGrouping(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    description: Option(String),
  )
}

pub fn implementationguide_definition_grouping_new(
  name name: String,
) -> ImplementationguideDefinitionGrouping {
  ImplementationguideDefinitionGrouping(
    description: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionResource {
  ImplementationguideDefinitionResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Reference,
    fhir_version: List(r5valuesets.Fhirversion),
    name: Option(String),
    description: Option(String),
    is_example: Option(Bool),
    profile: List(String),
    grouping_id: Option(String),
  )
}

pub fn implementationguide_definition_resource_new(
  reference reference: Reference,
) -> ImplementationguideDefinitionResource {
  ImplementationguideDefinitionResource(
    grouping_id: None,
    profile: [],
    is_example: None,
    description: None,
    name: None,
    fhir_version: [],
    reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPage {
  ImplementationguideDefinitionPage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source: Option(ImplementationguideDefinitionPageSource),
    name: String,
    title: String,
    generation: r5valuesets.Guidepagegeneration,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionPageSource {
  ImplementationguideDefinitionPageSourceUrl(source: String)
  ImplementationguideDefinitionPageSourceString(source: String)
  ImplementationguideDefinitionPageSourceMarkdown(source: String)
}

pub fn implementationguide_definition_page_source_to_json(
  elt: ImplementationguideDefinitionPageSource,
) -> Json {
  case elt {
    ImplementationguideDefinitionPageSourceUrl(v) -> json.string(v)
    ImplementationguideDefinitionPageSourceString(v) -> json.string(v)
    ImplementationguideDefinitionPageSourceMarkdown(v) -> json.string(v)
  }
}

pub fn implementationguide_definition_page_source_decoder() -> Decoder(
  ImplementationguideDefinitionPageSource,
) {
  decode.one_of(
    decode.field("sourceUrl", decode.string, decode.success)
      |> decode.map(ImplementationguideDefinitionPageSourceUrl),
    [
      decode.field("sourceString", decode.string, decode.success)
        |> decode.map(ImplementationguideDefinitionPageSourceString),
      decode.field("sourceMarkdown", decode.string, decode.success)
        |> decode.map(ImplementationguideDefinitionPageSourceMarkdown),
    ],
  )
}

pub fn implementationguide_definition_page_new(
  generation generation: r5valuesets.Guidepagegeneration,
  title title: String,
  name name: String,
) -> ImplementationguideDefinitionPage {
  ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    source: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionParameter {
  ImplementationguideDefinitionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Coding,
    value: String,
  )
}

pub fn implementationguide_definition_parameter_new(
  value value: String,
  code code: Coding,
) -> ImplementationguideDefinitionParameter {
  ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideDefinitionTemplate {
  ImplementationguideDefinitionTemplate(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    source: String,
    scope: Option(String),
  )
}

pub fn implementationguide_definition_template_new(
  source source: String,
  code code: String,
) -> ImplementationguideDefinitionTemplate {
  ImplementationguideDefinitionTemplate(
    scope: None,
    source:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifest {
  ImplementationguideManifest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    rendering: Option(String),
    resource: List(ImplementationguideManifestResource),
    page: List(ImplementationguideManifestPage),
    image: List(String),
    other: List(String),
  )
}

pub fn implementationguide_manifest_new() -> ImplementationguideManifest {
  ImplementationguideManifest(
    other: [],
    image: [],
    page: [],
    resource: [],
    rendering: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestResource {
  ImplementationguideManifestResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Reference,
    is_example: Option(Bool),
    profile: List(String),
    relative_path: Option(String),
  )
}

pub fn implementationguide_manifest_resource_new(
  reference reference: Reference,
) -> ImplementationguideManifestResource {
  ImplementationguideManifestResource(
    relative_path: None,
    profile: [],
    is_example: None,
    reference:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ImplementationGuide#resource
pub type ImplementationguideManifestPage {
  ImplementationguideManifestPage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    title: Option(String),
    anchor: List(String),
  )
}

pub fn implementationguide_manifest_page_new(
  name name: String,
) -> ImplementationguideManifestPage {
  ImplementationguideManifestPage(
    anchor: [],
    title: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn implementationguide_manifest_page_to_json(
  implementationguide_manifest_page: ImplementationguideManifestPage,
) -> Json {
  let ImplementationguideManifestPage(
    anchor:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest_page
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case anchor {
    [] -> fields
    _ -> [#("anchor", json.array(anchor, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_page_decoder() -> Decoder(
  ImplementationguideManifestPage,
) {
  use anchor <- decode.optional_field("anchor", [], decode.list(decode.string))
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifestPage(
    anchor:,
    title:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_manifest_resource_to_json(
  implementationguide_manifest_resource: ImplementationguideManifestResource,
) -> Json {
  let ImplementationguideManifestResource(
    relative_path:,
    profile:,
    is_example:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest_resource
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case relative_path {
    Some(v) -> [#("relativePath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case is_example {
    Some(v) -> [#("isExample", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_resource_decoder() -> Decoder(
  ImplementationguideManifestResource,
) {
  use relative_path <- decode.optional_field(
    "relativePath",
    None,
    decode.optional(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use is_example <- decode.optional_field(
    "isExample",
    None,
    decode.optional(decode.bool),
  )
  use reference <- decode.field("reference", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifestResource(
    relative_path:,
    profile:,
    is_example:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_manifest_to_json(
  implementationguide_manifest: ImplementationguideManifest,
) -> Json {
  let ImplementationguideManifest(
    other:,
    image:,
    page:,
    resource:,
    rendering:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_manifest
  let fields = []
  let fields = case other {
    [] -> fields
    _ -> [#("other", json.array(other, json.string)), ..fields]
  }
  let fields = case image {
    [] -> fields
    _ -> [#("image", json.array(image, json.string)), ..fields]
  }
  let fields = case page {
    [] -> fields
    _ -> [
      #("page", json.array(page, implementationguide_manifest_page_to_json)),
      ..fields
    ]
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, implementationguide_manifest_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rendering {
    Some(v) -> [#("rendering", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_manifest_decoder() -> Decoder(
  ImplementationguideManifest,
) {
  use other <- decode.optional_field("other", [], decode.list(decode.string))
  use image <- decode.optional_field("image", [], decode.list(decode.string))
  use page <- decode.optional_field(
    "page",
    [],
    decode.list(implementationguide_manifest_page_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(implementationguide_manifest_resource_decoder()),
  )
  use rendering <- decode.optional_field(
    "rendering",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideManifest(
    other:,
    image:,
    page:,
    resource:,
    rendering:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_template_to_json(
  implementationguide_definition_template: ImplementationguideDefinitionTemplate,
) -> Json {
  let ImplementationguideDefinitionTemplate(
    scope:,
    source:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_template
  let fields = [
    #("source", json.string(source)),
    #("code", json.string(code)),
  ]
  let fields = case scope {
    Some(v) -> [#("scope", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_template_decoder() -> Decoder(
  ImplementationguideDefinitionTemplate,
) {
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.field("source", decode.string)
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionTemplate(
    scope:,
    source:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_parameter_to_json(
  implementationguide_definition_parameter: ImplementationguideDefinitionParameter,
) -> Json {
  let ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_parameter
  let fields = [
    #("value", json.string(value)),
    #("code", coding_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_parameter_decoder() -> Decoder(
  ImplementationguideDefinitionParameter,
) {
  use value <- decode.field("value", decode.string)
  use code <- decode.field("code", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_page_to_json(
  implementationguide_definition_page: ImplementationguideDefinitionPage,
) -> Json {
  let ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_page
  let fields = [
    #("generation", r5valuesets.guidepagegeneration_to_json(generation)),
    #("title", json.string(title)),
    #("name", json.string(name)),
  ]
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          ImplementationguideDefinitionPageSourceUrl(_) -> "Url"
          ImplementationguideDefinitionPageSourceString(_) -> "String"
          ImplementationguideDefinitionPageSourceMarkdown(_) -> "Markdown"
        },
        implementationguide_definition_page_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_page_decoder() -> Decoder(
  ImplementationguideDefinitionPage,
) {
  use generation <- decode.field(
    "generation",
    r5valuesets.guidepagegeneration_decoder(),
  )
  use title <- decode.field("title", decode.string)
  use name <- decode.field("name", decode.string)
  use source <- decode.then(
    none_if_omitted(implementationguide_definition_page_source_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionPage(
    generation:,
    title:,
    name:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_resource_to_json(
  implementationguide_definition_resource: ImplementationguideDefinitionResource,
) -> Json {
  let ImplementationguideDefinitionResource(
    grouping_id:,
    profile:,
    is_example:,
    description:,
    name:,
    fhir_version:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_resource
  let fields = [
    #("reference", reference_to_json(reference)),
  ]
  let fields = case grouping_id {
    Some(v) -> [#("groupingId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case is_example {
    Some(v) -> [#("isExample", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case fhir_version {
    [] -> fields
    _ -> [
      #(
        "fhirVersion",
        json.array(fhir_version, r5valuesets.fhirversion_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_resource_decoder() -> Decoder(
  ImplementationguideDefinitionResource,
) {
  use grouping_id <- decode.optional_field(
    "groupingId",
    None,
    decode.optional(decode.string),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use is_example <- decode.optional_field(
    "isExample",
    None,
    decode.optional(decode.bool),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    [],
    decode.list(r5valuesets.fhirversion_decoder()),
  )
  use reference <- decode.field("reference", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionResource(
    grouping_id:,
    profile:,
    is_example:,
    description:,
    name:,
    fhir_version:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_grouping_to_json(
  implementationguide_definition_grouping: ImplementationguideDefinitionGrouping,
) -> Json {
  let ImplementationguideDefinitionGrouping(
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition_grouping
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_grouping_decoder() -> Decoder(
  ImplementationguideDefinitionGrouping,
) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinitionGrouping(
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_definition_to_json(
  implementationguide_definition: ImplementationguideDefinition,
) -> Json {
  let ImplementationguideDefinition(
    template:,
    parameter:,
    page:,
    resource:,
    grouping:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_definition
  let fields = []
  let fields = case template {
    [] -> fields
    _ -> [
      #(
        "template",
        json.array(template, implementationguide_definition_template_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, implementationguide_definition_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case page {
    Some(v) -> [
      #("page", implementationguide_definition_page_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(resource, implementationguide_definition_resource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case grouping {
    [] -> fields
    _ -> [
      #(
        "grouping",
        json.array(grouping, implementationguide_definition_grouping_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_definition_decoder() -> Decoder(
  ImplementationguideDefinition,
) {
  use template <- decode.optional_field(
    "template",
    [],
    decode.list(implementationguide_definition_template_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(implementationguide_definition_parameter_decoder()),
  )
  use page <- decode.optional_field(
    "page",
    None,
    decode.optional(implementationguide_definition_page_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(implementationguide_definition_resource_decoder()),
  )
  use grouping <- decode.optional_field(
    "grouping",
    [],
    decode.list(implementationguide_definition_grouping_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDefinition(
    template:,
    parameter:,
    page:,
    resource:,
    grouping:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_global_to_json(
  implementationguide_global: ImplementationguideGlobal,
) -> Json {
  let ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_global
  let fields = [
    #("profile", json.string(profile)),
    #("type", r5valuesets.resourcetypes_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_global_decoder() -> Decoder(
  ImplementationguideGlobal,
) {
  use profile <- decode.field("profile", decode.string)
  use type_ <- decode.field("type", r5valuesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideGlobal(
    profile:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_dependson_to_json(
  implementationguide_dependson: ImplementationguideDependson,
) -> Json {
  let ImplementationguideDependson(
    reason:,
    version:,
    package_id:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ) = implementationguide_dependson
  let fields = [
    #("uri", json.string(uri)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case package_id {
    Some(v) -> [#("packageId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn implementationguide_dependson_decoder() -> Decoder(
  ImplementationguideDependson,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use package_id <- decode.optional_field(
    "packageId",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.field("uri", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ImplementationguideDependson(
    reason:,
    version:,
    package_id:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn implementationguide_to_json(
  implementationguide: Implementationguide,
) -> Json {
  let Implementationguide(
    manifest:,
    definition:,
    global:,
    depends_on:,
    fhir_version:,
    license:,
    package_id:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = implementationguide
  let fields = [
    #("packageId", json.string(package_id)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case manifest {
    Some(v) -> [
      #("manifest", implementationguide_manifest_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [
      #("definition", implementationguide_definition_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case global {
    [] -> fields
    _ -> [
      #("global", json.array(global, implementationguide_global_to_json)),
      ..fields
    ]
  }
  let fields = case depends_on {
    [] -> fields
    _ -> [
      #(
        "dependsOn",
        json.array(depends_on, implementationguide_dependson_to_json),
      ),
      ..fields
    ]
  }
  let fields = case fhir_version {
    [] -> fields
    _ -> [
      #(
        "fhirVersion",
        json.array(fhir_version, r5valuesets.fhirversion_to_json),
      ),
      ..fields
    ]
  }
  let fields = case license {
    Some(v) -> [#("license", r5valuesets.spdxlicense_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ImplementationguideVersionalgorithmString(_) -> "String"
          ImplementationguideVersionalgorithmCoding(_) -> "Coding"
        },
        implementationguide_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Implementationguide")), ..fields]
  json.object(fields)
}

pub fn implementationguide_decoder() -> Decoder(Implementationguide) {
  use manifest <- decode.optional_field(
    "manifest",
    None,
    decode.optional(implementationguide_manifest_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(implementationguide_definition_decoder()),
  )
  use global <- decode.optional_field(
    "global",
    [],
    decode.list(implementationguide_global_decoder()),
  )
  use depends_on <- decode.optional_field(
    "dependsOn",
    [],
    decode.list(implementationguide_dependson_decoder()),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    [],
    decode.list(r5valuesets.fhirversion_decoder()),
  )
  use license <- decode.optional_field(
    "license",
    None,
    decode.optional(r5valuesets.spdxlicense_decoder()),
  )
  use package_id <- decode.field("packageId", decode.string)
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(implementationguide_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Implementationguide",
    decode.failure(
      implementationguide_new(package_id:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Implementationguide(
    manifest:,
    definition:,
    global:,
    depends_on:,
    fhir_version:,
    license:,
    package_id:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type Ingredient {
  Ingredient(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    status: r5valuesets.Publicationstatus,
    for: List(Reference),
    role: Codeableconcept,
    function: List(Codeableconcept),
    group: Option(Codeableconcept),
    allergenic_indicator: Option(Bool),
    comment: Option(String),
    manufacturer: List(IngredientManufacturer),
    substance: IngredientSubstance,
  )
}

pub fn ingredient_new(
  substance substance: IngredientSubstance,
  role role: Codeableconcept,
  status status: r5valuesets.Publicationstatus,
) -> Ingredient {
  Ingredient(
    substance:,
    manufacturer: [],
    comment: None,
    allergenic_indicator: None,
    group: None,
    function: [],
    role:,
    for: [],
    status:,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientManufacturer {
  IngredientManufacturer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(r5valuesets.Ingredientmanufacturerrole),
    manufacturer: Reference,
  )
}

pub fn ingredient_manufacturer_new(
  manufacturer manufacturer: Reference,
) -> IngredientManufacturer {
  IngredientManufacturer(
    manufacturer:,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstance {
  IngredientSubstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeablereference,
    strength: List(IngredientSubstanceStrength),
  )
}

pub fn ingredient_substance_new(
  code code: Codeablereference,
) -> IngredientSubstance {
  IngredientSubstance(
    strength: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrength {
  IngredientSubstanceStrength(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    presentation: Option(IngredientSubstanceStrengthPresentation),
    text_presentation: Option(String),
    concentration: Option(IngredientSubstanceStrengthConcentration),
    text_concentration: Option(String),
    basis: Option(Codeableconcept),
    measurement_point: Option(String),
    country: List(Codeableconcept),
    reference_strength: List(IngredientSubstanceStrengthReferencestrength),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthPresentation {
  IngredientSubstanceStrengthPresentationRatio(presentation: Ratio)
  IngredientSubstanceStrengthPresentationRatiorange(presentation: Ratiorange)
  IngredientSubstanceStrengthPresentationCodeableconcept(
    presentation: Codeableconcept,
  )
  IngredientSubstanceStrengthPresentationQuantity(presentation: Quantity)
}

pub fn ingredient_substance_strength_presentation_to_json(
  elt: IngredientSubstanceStrengthPresentation,
) -> Json {
  case elt {
    IngredientSubstanceStrengthPresentationRatio(v) -> ratio_to_json(v)
    IngredientSubstanceStrengthPresentationRatiorange(v) ->
      ratiorange_to_json(v)
    IngredientSubstanceStrengthPresentationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    IngredientSubstanceStrengthPresentationQuantity(v) -> quantity_to_json(v)
  }
}

pub fn ingredient_substance_strength_presentation_decoder() -> Decoder(
  IngredientSubstanceStrengthPresentation,
) {
  decode.one_of(
    decode.field("presentationRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthPresentationRatio),
    [
      decode.field(
        "presentationRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
        |> decode.map(IngredientSubstanceStrengthPresentationRatiorange),
      decode.field(
        "presentationCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(IngredientSubstanceStrengthPresentationCodeableconcept),
      decode.field("presentationQuantity", quantity_decoder(), decode.success)
        |> decode.map(IngredientSubstanceStrengthPresentationQuantity),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthConcentration {
  IngredientSubstanceStrengthConcentrationRatio(concentration: Ratio)
  IngredientSubstanceStrengthConcentrationRatiorange(concentration: Ratiorange)
  IngredientSubstanceStrengthConcentrationCodeableconcept(
    concentration: Codeableconcept,
  )
  IngredientSubstanceStrengthConcentrationQuantity(concentration: Quantity)
}

pub fn ingredient_substance_strength_concentration_to_json(
  elt: IngredientSubstanceStrengthConcentration,
) -> Json {
  case elt {
    IngredientSubstanceStrengthConcentrationRatio(v) -> ratio_to_json(v)
    IngredientSubstanceStrengthConcentrationRatiorange(v) ->
      ratiorange_to_json(v)
    IngredientSubstanceStrengthConcentrationCodeableconcept(v) ->
      codeableconcept_to_json(v)
    IngredientSubstanceStrengthConcentrationQuantity(v) -> quantity_to_json(v)
  }
}

pub fn ingredient_substance_strength_concentration_decoder() -> Decoder(
  IngredientSubstanceStrengthConcentration,
) {
  decode.one_of(
    decode.field("concentrationRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthConcentrationRatio),
    [
      decode.field(
        "concentrationRatioRange",
        ratiorange_decoder(),
        decode.success,
      )
        |> decode.map(IngredientSubstanceStrengthConcentrationRatiorange),
      decode.field(
        "concentrationCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(IngredientSubstanceStrengthConcentrationCodeableconcept),
      decode.field("concentrationQuantity", quantity_decoder(), decode.success)
        |> decode.map(IngredientSubstanceStrengthConcentrationQuantity),
    ],
  )
}

pub fn ingredient_substance_strength_new() -> IngredientSubstanceStrength {
  IngredientSubstanceStrength(
    reference_strength: [],
    country: [],
    measurement_point: None,
    basis: None,
    text_concentration: None,
    concentration: None,
    text_presentation: None,
    presentation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthReferencestrength {
  IngredientSubstanceStrengthReferencestrength(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance: Codeablereference,
    strength: IngredientSubstanceStrengthReferencestrengthStrength,
    measurement_point: Option(String),
    country: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Ingredient#resource
pub type IngredientSubstanceStrengthReferencestrengthStrength {
  IngredientSubstanceStrengthReferencestrengthStrengthRatio(strength: Ratio)
  IngredientSubstanceStrengthReferencestrengthStrengthRatiorange(
    strength: Ratiorange,
  )
  IngredientSubstanceStrengthReferencestrengthStrengthQuantity(
    strength: Quantity,
  )
}

pub fn ingredient_substance_strength_referencestrength_strength_to_json(
  elt: IngredientSubstanceStrengthReferencestrengthStrength,
) -> Json {
  case elt {
    IngredientSubstanceStrengthReferencestrengthStrengthRatio(v) ->
      ratio_to_json(v)
    IngredientSubstanceStrengthReferencestrengthStrengthRatiorange(v) ->
      ratiorange_to_json(v)
    IngredientSubstanceStrengthReferencestrengthStrengthQuantity(v) ->
      quantity_to_json(v)
  }
}

pub fn ingredient_substance_strength_referencestrength_strength_decoder() -> Decoder(
  IngredientSubstanceStrengthReferencestrengthStrength,
) {
  decode.one_of(
    decode.field("strengthRatio", ratio_decoder(), decode.success)
      |> decode.map(IngredientSubstanceStrengthReferencestrengthStrengthRatio),
    [
      decode.field("strengthRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(
          IngredientSubstanceStrengthReferencestrengthStrengthRatiorange,
        ),
      decode.field("strengthQuantity", quantity_decoder(), decode.success)
        |> decode.map(
          IngredientSubstanceStrengthReferencestrengthStrengthQuantity,
        ),
    ],
  )
}

pub fn ingredient_substance_strength_referencestrength_new(
  strength strength: IngredientSubstanceStrengthReferencestrengthStrength,
  substance substance: Codeablereference,
) -> IngredientSubstanceStrengthReferencestrength {
  IngredientSubstanceStrengthReferencestrength(
    country: [],
    measurement_point: None,
    strength:,
    substance:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn ingredient_substance_strength_referencestrength_to_json(
  ingredient_substance_strength_referencestrength: IngredientSubstanceStrengthReferencestrength,
) -> Json {
  let IngredientSubstanceStrengthReferencestrength(
    country:,
    measurement_point:,
    strength:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance_strength_referencestrength
  let fields = [
    #(
      "strength",
      ingredient_substance_strength_referencestrength_strength_to_json(strength),
    ),
    #("substance", codeablereference_to_json(substance)),
  ]
  let fields = case country {
    [] -> fields
    _ -> [#("country", json.array(country, codeableconcept_to_json)), ..fields]
  }
  let fields = case measurement_point {
    Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_strength_referencestrength_decoder() -> Decoder(
  IngredientSubstanceStrengthReferencestrength,
) {
  use country <- decode.optional_field(
    "country",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use measurement_point <- decode.optional_field(
    "measurementPoint",
    None,
    decode.optional(decode.string),
  )
  use strength <- decode.then(
    ingredient_substance_strength_referencestrength_strength_decoder(),
  )
  use substance <- decode.field("substance", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstanceStrengthReferencestrength(
    country:,
    measurement_point:,
    strength:,
    substance:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_substance_strength_to_json(
  ingredient_substance_strength: IngredientSubstanceStrength,
) -> Json {
  let IngredientSubstanceStrength(
    reference_strength:,
    country:,
    measurement_point:,
    basis:,
    text_concentration:,
    concentration:,
    text_presentation:,
    presentation:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance_strength
  let fields = []
  let fields = case reference_strength {
    [] -> fields
    _ -> [
      #(
        "referenceStrength",
        json.array(
          reference_strength,
          ingredient_substance_strength_referencestrength_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case country {
    [] -> fields
    _ -> [#("country", json.array(country, codeableconcept_to_json)), ..fields]
  }
  let fields = case measurement_point {
    Some(v) -> [#("measurementPoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case basis {
    Some(v) -> [#("basis", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text_concentration {
    Some(v) -> [#("textConcentration", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case concentration {
    Some(v) -> [
      #(
        "concentration"
          <> case v {
          IngredientSubstanceStrengthConcentrationRatio(_) -> "Ratio"
          IngredientSubstanceStrengthConcentrationRatiorange(_) -> "Ratiorange"
          IngredientSubstanceStrengthConcentrationCodeableconcept(_) ->
            "Codeableconcept"
          IngredientSubstanceStrengthConcentrationQuantity(_) -> "Quantity"
        },
        ingredient_substance_strength_concentration_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case text_presentation {
    Some(v) -> [#("textPresentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case presentation {
    Some(v) -> [
      #(
        "presentation"
          <> case v {
          IngredientSubstanceStrengthPresentationRatio(_) -> "Ratio"
          IngredientSubstanceStrengthPresentationRatiorange(_) -> "Ratiorange"
          IngredientSubstanceStrengthPresentationCodeableconcept(_) ->
            "Codeableconcept"
          IngredientSubstanceStrengthPresentationQuantity(_) -> "Quantity"
        },
        ingredient_substance_strength_presentation_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_strength_decoder() -> Decoder(
  IngredientSubstanceStrength,
) {
  use reference_strength <- decode.optional_field(
    "referenceStrength",
    [],
    decode.list(ingredient_substance_strength_referencestrength_decoder()),
  )
  use country <- decode.optional_field(
    "country",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use measurement_point <- decode.optional_field(
    "measurementPoint",
    None,
    decode.optional(decode.string),
  )
  use basis <- decode.optional_field(
    "basis",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text_concentration <- decode.optional_field(
    "textConcentration",
    None,
    decode.optional(decode.string),
  )
  use concentration <- decode.then(
    none_if_omitted(ingredient_substance_strength_concentration_decoder()),
  )
  use text_presentation <- decode.optional_field(
    "textPresentation",
    None,
    decode.optional(decode.string),
  )
  use presentation <- decode.then(
    none_if_omitted(ingredient_substance_strength_presentation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstanceStrength(
    reference_strength:,
    country:,
    measurement_point:,
    basis:,
    text_concentration:,
    concentration:,
    text_presentation:,
    presentation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_substance_to_json(
  ingredient_substance: IngredientSubstance,
) -> Json {
  let IngredientSubstance(
    strength:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_substance
  let fields = [
    #("code", codeablereference_to_json(code)),
  ]
  let fields = case strength {
    [] -> fields
    _ -> [
      #("strength", json.array(strength, ingredient_substance_strength_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_substance_decoder() -> Decoder(IngredientSubstance) {
  use strength <- decode.optional_field(
    "strength",
    [],
    decode.list(ingredient_substance_strength_decoder()),
  )
  use code <- decode.field("code", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientSubstance(
    strength:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_manufacturer_to_json(
  ingredient_manufacturer: IngredientManufacturer,
) -> Json {
  let IngredientManufacturer(
    manufacturer:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = ingredient_manufacturer
  let fields = [
    #("manufacturer", reference_to_json(manufacturer)),
  ]
  let fields = case role {
    Some(v) -> [
      #("role", r5valuesets.ingredientmanufacturerrole_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn ingredient_manufacturer_decoder() -> Decoder(IngredientManufacturer) {
  use manufacturer <- decode.field("manufacturer", reference_decoder())
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(r5valuesets.ingredientmanufacturerrole_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(IngredientManufacturer(
    manufacturer:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn ingredient_to_json(ingredient: Ingredient) -> Json {
  let Ingredient(
    substance:,
    manufacturer:,
    comment:,
    allergenic_indicator:,
    group:,
    function:,
    role:,
    for:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = ingredient
  let fields = [
    #("substance", ingredient_substance_to_json(substance)),
    #("role", codeableconcept_to_json(role)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #(
        "manufacturer",
        json.array(manufacturer, ingredient_manufacturer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case allergenic_indicator {
    Some(v) -> [#("allergenicIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case group {
    Some(v) -> [#("group", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case function {
    [] -> fields
    _ -> [
      #("function", json.array(function, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case for {
    [] -> fields
    _ -> [#("for", json.array(for, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Ingredient")), ..fields]
  json.object(fields)
}

pub fn ingredient_decoder() -> Decoder(Ingredient) {
  use substance <- decode.field("substance", ingredient_substance_decoder())
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(ingredient_manufacturer_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use allergenic_indicator <- decode.optional_field(
    "allergenicIndicator",
    None,
    decode.optional(decode.bool),
  )
  use group <- decode.optional_field(
    "group",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use function <- decode.optional_field(
    "function",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use role <- decode.field("role", codeableconcept_decoder())
  use for <- decode.optional_field("for", [], decode.list(reference_decoder()))
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Ingredient",
    decode.failure(ingredient_new(substance:, role:, status:), "resourceType"),
  )
  decode.success(Ingredient(
    substance:,
    manufacturer:,
    comment:,
    allergenic_indicator:,
    group:,
    function:,
    role:,
    for:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type Insuranceplan {
  Insuranceplan(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Publicationstatus),
    type_: List(Codeableconcept),
    name: Option(String),
    alias: List(String),
    period: Option(Period),
    owned_by: Option(Reference),
    administered_by: Option(Reference),
    coverage_area: List(Reference),
    contact: List(Extendedcontactdetail),
    endpoint: List(Reference),
    network: List(Reference),
    coverage: List(InsuranceplanCoverage),
    plan: List(InsuranceplanPlan),
  )
}

pub fn insuranceplan_new() -> Insuranceplan {
  Insuranceplan(
    plan: [],
    coverage: [],
    network: [],
    endpoint: [],
    contact: [],
    coverage_area: [],
    administered_by: None,
    owned_by: None,
    period: None,
    alias: [],
    name: None,
    type_: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverage {
  InsuranceplanCoverage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    network: List(Reference),
    benefit: List(InsuranceplanCoverageBenefit),
  )
}

pub fn insuranceplan_coverage_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanCoverage {
  InsuranceplanCoverage(
    benefit: [],
    network: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefit {
  InsuranceplanCoverageBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    requirement: Option(String),
    limit: List(InsuranceplanCoverageBenefitLimit),
  )
}

pub fn insuranceplan_coverage_benefit_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanCoverageBenefit {
  InsuranceplanCoverageBenefit(
    limit: [],
    requirement: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanCoverageBenefitLimit {
  InsuranceplanCoverageBenefitLimit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: Option(Quantity),
    code: Option(Codeableconcept),
  )
}

pub fn insuranceplan_coverage_benefit_limit_new() -> InsuranceplanCoverageBenefitLimit {
  InsuranceplanCoverageBenefitLimit(
    code: None,
    value: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlan {
  InsuranceplanPlan(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    coverage_area: List(Reference),
    network: List(Reference),
    general_cost: List(InsuranceplanPlanGeneralcost),
    specific_cost: List(InsuranceplanPlanSpecificcost),
  )
}

pub fn insuranceplan_plan_new() -> InsuranceplanPlan {
  InsuranceplanPlan(
    specific_cost: [],
    general_cost: [],
    network: [],
    coverage_area: [],
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanGeneralcost {
  InsuranceplanPlanGeneralcost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    group_size: Option(Int),
    cost: Option(Money),
    comment: Option(String),
  )
}

pub fn insuranceplan_plan_generalcost_new() -> InsuranceplanPlanGeneralcost {
  InsuranceplanPlanGeneralcost(
    comment: None,
    cost: None,
    group_size: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcost {
  InsuranceplanPlanSpecificcost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Codeableconcept,
    benefit: List(InsuranceplanPlanSpecificcostBenefit),
  )
}

pub fn insuranceplan_plan_specificcost_new(
  category category: Codeableconcept,
) -> InsuranceplanPlanSpecificcost {
  InsuranceplanPlanSpecificcost(
    benefit: [],
    category:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefit {
  InsuranceplanPlanSpecificcostBenefit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    cost: List(InsuranceplanPlanSpecificcostBenefitCost),
  )
}

pub fn insuranceplan_plan_specificcost_benefit_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanPlanSpecificcostBenefit {
  InsuranceplanPlanSpecificcostBenefit(
    cost: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InsurancePlan#resource
pub type InsuranceplanPlanSpecificcostBenefitCost {
  InsuranceplanPlanSpecificcostBenefitCost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    applicability: Option(Codeableconcept),
    qualifiers: List(Codeableconcept),
    value: Option(Quantity),
  )
}

pub fn insuranceplan_plan_specificcost_benefit_cost_new(
  type_ type_: Codeableconcept,
) -> InsuranceplanPlanSpecificcostBenefitCost {
  InsuranceplanPlanSpecificcostBenefitCost(
    value: None,
    qualifiers: [],
    applicability: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn insuranceplan_plan_specificcost_benefit_cost_to_json(
  insuranceplan_plan_specificcost_benefit_cost: InsuranceplanPlanSpecificcostBenefitCost,
) -> Json {
  let InsuranceplanPlanSpecificcostBenefitCost(
    value:,
    qualifiers:,
    applicability:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost_benefit_cost
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case qualifiers {
    [] -> fields
    _ -> [
      #("qualifiers", json.array(qualifiers, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case applicability {
    Some(v) -> [#("applicability", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_benefit_cost_decoder() -> Decoder(
  InsuranceplanPlanSpecificcostBenefitCost,
) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use qualifiers <- decode.optional_field(
    "qualifiers",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use applicability <- decode.optional_field(
    "applicability",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcostBenefitCost(
    value:,
    qualifiers:,
    applicability:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_specificcost_benefit_to_json(
  insuranceplan_plan_specificcost_benefit: InsuranceplanPlanSpecificcostBenefit,
) -> Json {
  let InsuranceplanPlanSpecificcostBenefit(
    cost:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case cost {
    [] -> fields
    _ -> [
      #(
        "cost",
        json.array(cost, insuranceplan_plan_specificcost_benefit_cost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_benefit_decoder() -> Decoder(
  InsuranceplanPlanSpecificcostBenefit,
) {
  use cost <- decode.optional_field(
    "cost",
    [],
    decode.list(insuranceplan_plan_specificcost_benefit_cost_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcostBenefit(
    cost:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_specificcost_to_json(
  insuranceplan_plan_specificcost: InsuranceplanPlanSpecificcost,
) -> Json {
  let InsuranceplanPlanSpecificcost(
    benefit:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_specificcost
  let fields = [
    #("category", codeableconcept_to_json(category)),
  ]
  let fields = case benefit {
    [] -> fields
    _ -> [
      #(
        "benefit",
        json.array(benefit, insuranceplan_plan_specificcost_benefit_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_specificcost_decoder() -> Decoder(
  InsuranceplanPlanSpecificcost,
) {
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(insuranceplan_plan_specificcost_benefit_decoder()),
  )
  use category <- decode.field("category", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanSpecificcost(
    benefit:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_generalcost_to_json(
  insuranceplan_plan_generalcost: InsuranceplanPlanGeneralcost,
) -> Json {
  let InsuranceplanPlanGeneralcost(
    comment:,
    cost:,
    group_size:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan_generalcost
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cost {
    Some(v) -> [#("cost", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_size {
    Some(v) -> [#("groupSize", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_generalcost_decoder() -> Decoder(
  InsuranceplanPlanGeneralcost,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use cost <- decode.optional_field(
    "cost",
    None,
    decode.optional(money_decoder()),
  )
  use group_size <- decode.optional_field(
    "groupSize",
    None,
    decode.optional(decode.int),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlanGeneralcost(
    comment:,
    cost:,
    group_size:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_plan_to_json(insuranceplan_plan: InsuranceplanPlan) -> Json {
  let InsuranceplanPlan(
    specific_cost:,
    general_cost:,
    network:,
    coverage_area:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_plan
  let fields = []
  let fields = case specific_cost {
    [] -> fields
    _ -> [
      #(
        "specificCost",
        json.array(specific_cost, insuranceplan_plan_specificcost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case general_cost {
    [] -> fields
    _ -> [
      #(
        "generalCost",
        json.array(general_cost, insuranceplan_plan_generalcost_to_json),
      ),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_plan_decoder() -> Decoder(InsuranceplanPlan) {
  use specific_cost <- decode.optional_field(
    "specificCost",
    [],
    decode.list(insuranceplan_plan_specificcost_decoder()),
  )
  use general_cost <- decode.optional_field(
    "generalCost",
    [],
    decode.list(insuranceplan_plan_generalcost_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanPlan(
    specific_cost:,
    general_cost:,
    network:,
    coverage_area:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_benefit_limit_to_json(
  insuranceplan_coverage_benefit_limit: InsuranceplanCoverageBenefitLimit,
) -> Json {
  let InsuranceplanCoverageBenefitLimit(
    code:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage_benefit_limit
  let fields = []
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [#("value", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_benefit_limit_decoder() -> Decoder(
  InsuranceplanCoverageBenefitLimit,
) {
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverageBenefitLimit(
    code:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_benefit_to_json(
  insuranceplan_coverage_benefit: InsuranceplanCoverageBenefit,
) -> Json {
  let InsuranceplanCoverageBenefit(
    limit:,
    requirement:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage_benefit
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case limit {
    [] -> fields
    _ -> [
      #(
        "limit",
        json.array(limit, insuranceplan_coverage_benefit_limit_to_json),
      ),
      ..fields
    ]
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_benefit_decoder() -> Decoder(
  InsuranceplanCoverageBenefit,
) {
  use limit <- decode.optional_field(
    "limit",
    [],
    decode.list(insuranceplan_coverage_benefit_limit_decoder()),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverageBenefit(
    limit:,
    requirement:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_coverage_to_json(
  insuranceplan_coverage: InsuranceplanCoverage,
) -> Json {
  let InsuranceplanCoverage(
    benefit:,
    network:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = insuranceplan_coverage
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case benefit {
    [] -> fields
    _ -> [
      #("benefit", json.array(benefit, insuranceplan_coverage_benefit_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn insuranceplan_coverage_decoder() -> Decoder(InsuranceplanCoverage) {
  use benefit <- decode.optional_field(
    "benefit",
    [],
    decode.list(insuranceplan_coverage_benefit_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InsuranceplanCoverage(
    benefit:,
    network:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn insuranceplan_to_json(insuranceplan: Insuranceplan) -> Json {
  let Insuranceplan(
    plan:,
    coverage:,
    network:,
    endpoint:,
    contact:,
    coverage_area:,
    administered_by:,
    owned_by:,
    period:,
    alias:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = insuranceplan
  let fields = []
  let fields = case plan {
    [] -> fields
    _ -> [#("plan", json.array(plan, insuranceplan_plan_to_json)), ..fields]
  }
  let fields = case coverage {
    [] -> fields
    _ -> [
      #("coverage", json.array(coverage, insuranceplan_coverage_to_json)),
      ..fields
    ]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case coverage_area {
    [] -> fields
    _ -> [
      #("coverageArea", json.array(coverage_area, reference_to_json)),
      ..fields
    ]
  }
  let fields = case administered_by {
    Some(v) -> [#("administeredBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case owned_by {
    Some(v) -> [#("ownedBy", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.publicationstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Insuranceplan")), ..fields]
  json.object(fields)
}

pub fn insuranceplan_decoder() -> Decoder(Insuranceplan) {
  use plan <- decode.optional_field(
    "plan",
    [],
    decode.list(insuranceplan_plan_decoder()),
  )
  use coverage <- decode.optional_field(
    "coverage",
    [],
    decode.list(insuranceplan_coverage_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use coverage_area <- decode.optional_field(
    "coverageArea",
    [],
    decode.list(reference_decoder()),
  )
  use administered_by <- decode.optional_field(
    "administeredBy",
    None,
    decode.optional(reference_decoder()),
  )
  use owned_by <- decode.optional_field(
    "ownedBy",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.publicationstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Insuranceplan",
    decode.failure(insuranceplan_new(), "resourceType"),
  )
  decode.success(Insuranceplan(
    plan:,
    coverage:,
    network:,
    endpoint:,
    contact:,
    coverage_area:,
    administered_by:,
    owned_by:,
    period:,
    alias:,
    name:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type Inventoryitem {
  Inventoryitem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Inventoryitemstatus,
    category: List(Codeableconcept),
    code: List(Codeableconcept),
    name: List(InventoryitemName),
    responsible_organization: List(InventoryitemResponsibleorganization),
    description: Option(InventoryitemDescription),
    inventory_status: List(Codeableconcept),
    base_unit: Option(Codeableconcept),
    net_content: Option(Quantity),
    association: List(InventoryitemAssociation),
    characteristic: List(InventoryitemCharacteristic),
    instance: Option(InventoryitemInstance),
    product_reference: Option(Reference),
  )
}

pub fn inventoryitem_new(
  status status: r5valuesets.Inventoryitemstatus,
) -> Inventoryitem {
  Inventoryitem(
    product_reference: None,
    instance: None,
    characteristic: [],
    association: [],
    net_content: None,
    base_unit: None,
    inventory_status: [],
    description: None,
    responsible_organization: [],
    name: [],
    code: [],
    category: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemName {
  InventoryitemName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name_type: Coding,
    language: r5valuesets.Languages,
    name: String,
  )
}

pub fn inventoryitem_name_new(
  name name: String,
  language language: r5valuesets.Languages,
  name_type name_type: Coding,
) -> InventoryitemName {
  InventoryitemName(
    name:,
    language:,
    name_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemResponsibleorganization {
  InventoryitemResponsibleorganization(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Codeableconcept,
    organization: Reference,
  )
}

pub fn inventoryitem_responsibleorganization_new(
  organization organization: Reference,
  role role: Codeableconcept,
) -> InventoryitemResponsibleorganization {
  InventoryitemResponsibleorganization(
    organization:,
    role:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemDescription {
  InventoryitemDescription(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(r5valuesets.Languages),
    description: Option(String),
  )
}

pub fn inventoryitem_description_new() -> InventoryitemDescription {
  InventoryitemDescription(
    description: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemAssociation {
  InventoryitemAssociation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    association_type: Codeableconcept,
    related_item: Reference,
    quantity: Ratio,
  )
}

pub fn inventoryitem_association_new(
  quantity quantity: Ratio,
  related_item related_item: Reference,
  association_type association_type: Codeableconcept,
) -> InventoryitemAssociation {
  InventoryitemAssociation(
    quantity:,
    related_item:,
    association_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemCharacteristic {
  InventoryitemCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    characteristic_type: Codeableconcept,
    value: InventoryitemCharacteristicValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemCharacteristicValue {
  InventoryitemCharacteristicValueString(value: String)
  InventoryitemCharacteristicValueInteger(value: Int)
  InventoryitemCharacteristicValueDecimal(value: Float)
  InventoryitemCharacteristicValueBoolean(value: Bool)
  InventoryitemCharacteristicValueUrl(value: String)
  InventoryitemCharacteristicValueDatetime(value: String)
  InventoryitemCharacteristicValueQuantity(value: Quantity)
  InventoryitemCharacteristicValueRange(value: Range)
  InventoryitemCharacteristicValueRatio(value: Ratio)
  InventoryitemCharacteristicValueAnnotation(value: Annotation)
  InventoryitemCharacteristicValueAddress(value: Address)
  InventoryitemCharacteristicValueDuration(value: Duration)
  InventoryitemCharacteristicValueCodeableconcept(value: Codeableconcept)
}

pub fn inventoryitem_characteristic_value_to_json(
  elt: InventoryitemCharacteristicValue,
) -> Json {
  case elt {
    InventoryitemCharacteristicValueString(v) -> json.string(v)
    InventoryitemCharacteristicValueInteger(v) -> json.int(v)
    InventoryitemCharacteristicValueDecimal(v) -> json.float(v)
    InventoryitemCharacteristicValueBoolean(v) -> json.bool(v)
    InventoryitemCharacteristicValueUrl(v) -> json.string(v)
    InventoryitemCharacteristicValueDatetime(v) -> json.string(v)
    InventoryitemCharacteristicValueQuantity(v) -> quantity_to_json(v)
    InventoryitemCharacteristicValueRange(v) -> range_to_json(v)
    InventoryitemCharacteristicValueRatio(v) -> ratio_to_json(v)
    InventoryitemCharacteristicValueAnnotation(v) -> annotation_to_json(v)
    InventoryitemCharacteristicValueAddress(v) -> address_to_json(v)
    InventoryitemCharacteristicValueDuration(v) -> duration_to_json(v)
    InventoryitemCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn inventoryitem_characteristic_value_decoder() -> Decoder(
  InventoryitemCharacteristicValue,
) {
  decode.one_of(
    decode.field("valueString", decode.string, decode.success)
      |> decode.map(InventoryitemCharacteristicValueString),
    [
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(InventoryitemCharacteristicValueInteger),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(InventoryitemCharacteristicValueDecimal),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(InventoryitemCharacteristicValueBoolean),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(InventoryitemCharacteristicValueUrl),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(InventoryitemCharacteristicValueDatetime),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueRatio),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueAnnotation),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueAddress),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(InventoryitemCharacteristicValueDuration),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(InventoryitemCharacteristicValueCodeableconcept),
    ],
  )
}

pub fn inventoryitem_characteristic_new(
  value value: InventoryitemCharacteristicValue,
  characteristic_type characteristic_type: Codeableconcept,
) -> InventoryitemCharacteristic {
  InventoryitemCharacteristic(
    value:,
    characteristic_type:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryItem#resource
pub type InventoryitemInstance {
  InventoryitemInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    lot_number: Option(String),
    expiry: Option(String),
    subject: Option(Reference),
    location: Option(Reference),
  )
}

pub fn inventoryitem_instance_new() -> InventoryitemInstance {
  InventoryitemInstance(
    location: None,
    subject: None,
    expiry: None,
    lot_number: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn inventoryitem_instance_to_json(
  inventoryitem_instance: InventoryitemInstance,
) -> Json {
  let InventoryitemInstance(
    location:,
    subject:,
    expiry:,
    lot_number:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_instance
  let fields = []
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expiry {
    Some(v) -> [#("expiry", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_instance_decoder() -> Decoder(InventoryitemInstance) {
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use expiry <- decode.optional_field(
    "expiry",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemInstance(
    location:,
    subject:,
    expiry:,
    lot_number:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_characteristic_to_json(
  inventoryitem_characteristic: InventoryitemCharacteristic,
) -> Json {
  let InventoryitemCharacteristic(
    value:,
    characteristic_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_characteristic
  let fields = [
    #("value", inventoryitem_characteristic_value_to_json(value)),
    #("characteristicType", codeableconcept_to_json(characteristic_type)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_characteristic_decoder() -> Decoder(
  InventoryitemCharacteristic,
) {
  use value <- decode.then(inventoryitem_characteristic_value_decoder())
  use characteristic_type <- decode.field(
    "characteristicType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemCharacteristic(
    value:,
    characteristic_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_association_to_json(
  inventoryitem_association: InventoryitemAssociation,
) -> Json {
  let InventoryitemAssociation(
    quantity:,
    related_item:,
    association_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_association
  let fields = [
    #("quantity", ratio_to_json(quantity)),
    #("relatedItem", reference_to_json(related_item)),
    #("associationType", codeableconcept_to_json(association_type)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_association_decoder() -> Decoder(InventoryitemAssociation) {
  use quantity <- decode.field("quantity", ratio_decoder())
  use related_item <- decode.field("relatedItem", reference_decoder())
  use association_type <- decode.field(
    "associationType",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemAssociation(
    quantity:,
    related_item:,
    association_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_description_to_json(
  inventoryitem_description: InventoryitemDescription,
) -> Json {
  let InventoryitemDescription(
    description:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_description
  let fields = []
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", r5valuesets.languages_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_description_decoder() -> Decoder(InventoryitemDescription) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(r5valuesets.languages_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemDescription(
    description:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_responsibleorganization_to_json(
  inventoryitem_responsibleorganization: InventoryitemResponsibleorganization,
) -> Json {
  let InventoryitemResponsibleorganization(
    organization:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_responsibleorganization
  let fields = [
    #("organization", reference_to_json(organization)),
    #("role", codeableconcept_to_json(role)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_responsibleorganization_decoder() -> Decoder(
  InventoryitemResponsibleorganization,
) {
  use organization <- decode.field("organization", reference_decoder())
  use role <- decode.field("role", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemResponsibleorganization(
    organization:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_name_to_json(inventoryitem_name: InventoryitemName) -> Json {
  let InventoryitemName(
    name:,
    language:,
    name_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryitem_name
  let fields = [
    #("name", json.string(name)),
    #("language", r5valuesets.languages_to_json(language)),
    #("nameType", coding_to_json(name_type)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryitem_name_decoder() -> Decoder(InventoryitemName) {
  use name <- decode.field("name", decode.string)
  use language <- decode.field("language", r5valuesets.languages_decoder())
  use name_type <- decode.field("nameType", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryitemName(
    name:,
    language:,
    name_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryitem_to_json(inventoryitem: Inventoryitem) -> Json {
  let Inventoryitem(
    product_reference:,
    instance:,
    characteristic:,
    association:,
    net_content:,
    base_unit:,
    inventory_status:,
    description:,
    responsible_organization:,
    name:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = inventoryitem
  let fields = [
    #("status", r5valuesets.inventoryitemstatus_to_json(status)),
  ]
  let fields = case product_reference {
    Some(v) -> [#("productReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case instance {
    Some(v) -> [#("instance", inventoryitem_instance_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, inventoryitem_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case association {
    [] -> fields
    _ -> [
      #(
        "association",
        json.array(association, inventoryitem_association_to_json),
      ),
      ..fields
    ]
  }
  let fields = case net_content {
    Some(v) -> [#("netContent", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case base_unit {
    Some(v) -> [#("baseUnit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case inventory_status {
    [] -> fields
    _ -> [
      #(
        "inventoryStatus",
        json.array(inventory_status, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [
      #("description", inventoryitem_description_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case responsible_organization {
    [] -> fields
    _ -> [
      #(
        "responsibleOrganization",
        json.array(
          responsible_organization,
          inventoryitem_responsibleorganization_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, inventoryitem_name_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Inventoryitem")), ..fields]
  json.object(fields)
}

pub fn inventoryitem_decoder() -> Decoder(Inventoryitem) {
  use product_reference <- decode.optional_field(
    "productReference",
    None,
    decode.optional(reference_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    None,
    decode.optional(inventoryitem_instance_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(inventoryitem_characteristic_decoder()),
  )
  use association <- decode.optional_field(
    "association",
    [],
    decode.list(inventoryitem_association_decoder()),
  )
  use net_content <- decode.optional_field(
    "netContent",
    None,
    decode.optional(quantity_decoder()),
  )
  use base_unit <- decode.optional_field(
    "baseUnit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use inventory_status <- decode.optional_field(
    "inventoryStatus",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(inventoryitem_description_decoder()),
  )
  use responsible_organization <- decode.optional_field(
    "responsibleOrganization",
    [],
    decode.list(inventoryitem_responsibleorganization_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(inventoryitem_name_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.inventoryitemstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Inventoryitem",
    decode.failure(inventoryitem_new(status:), "resourceType"),
  )
  decode.success(Inventoryitem(
    product_reference:,
    instance:,
    characteristic:,
    association:,
    net_content:,
    base_unit:,
    inventory_status:,
    description:,
    responsible_organization:,
    name:,
    code:,
    category:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryReport#resource
pub type Inventoryreport {
  Inventoryreport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Inventoryreportstatus,
    count_type: r5valuesets.Inventoryreportcounttype,
    operation_type: Option(Codeableconcept),
    operation_type_reason: Option(Codeableconcept),
    reported_date_time: String,
    reporter: Option(Reference),
    reporting_period: Option(Period),
    inventory_listing: List(InventoryreportInventorylisting),
    note: List(Annotation),
  )
}

pub fn inventoryreport_new(
  reported_date_time reported_date_time: String,
  count_type count_type: r5valuesets.Inventoryreportcounttype,
  status status: r5valuesets.Inventoryreportstatus,
) -> Inventoryreport {
  Inventoryreport(
    note: [],
    inventory_listing: [],
    reporting_period: None,
    reporter: None,
    reported_date_time:,
    operation_type_reason: None,
    operation_type: None,
    count_type:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryReport#resource
pub type InventoryreportInventorylisting {
  InventoryreportInventorylisting(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    location: Option(Reference),
    item_status: Option(Codeableconcept),
    counting_date_time: Option(String),
    item: List(InventoryreportInventorylistingItem),
  )
}

pub fn inventoryreport_inventorylisting_new() -> InventoryreportInventorylisting {
  InventoryreportInventorylisting(
    item: [],
    counting_date_time: None,
    item_status: None,
    location: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/InventoryReport#resource
pub type InventoryreportInventorylistingItem {
  InventoryreportInventorylistingItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    quantity: Quantity,
    item: Codeablereference,
  )
}

pub fn inventoryreport_inventorylisting_item_new(
  item item: Codeablereference,
  quantity quantity: Quantity,
) -> InventoryreportInventorylistingItem {
  InventoryreportInventorylistingItem(
    item:,
    quantity:,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn inventoryreport_inventorylisting_item_to_json(
  inventoryreport_inventorylisting_item: InventoryreportInventorylistingItem,
) -> Json {
  let InventoryreportInventorylistingItem(
    item:,
    quantity:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryreport_inventorylisting_item
  let fields = [
    #("item", codeablereference_to_json(item)),
    #("quantity", quantity_to_json(quantity)),
  ]
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryreport_inventorylisting_item_decoder() -> Decoder(
  InventoryreportInventorylistingItem,
) {
  use item <- decode.field("item", codeablereference_decoder())
  use quantity <- decode.field("quantity", quantity_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryreportInventorylistingItem(
    item:,
    quantity:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryreport_inventorylisting_to_json(
  inventoryreport_inventorylisting: InventoryreportInventorylisting,
) -> Json {
  let InventoryreportInventorylisting(
    item:,
    counting_date_time:,
    item_status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ) = inventoryreport_inventorylisting
  let fields = []
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, inventoryreport_inventorylisting_item_to_json)),
      ..fields
    ]
  }
  let fields = case counting_date_time {
    Some(v) -> [#("countingDateTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case item_status {
    Some(v) -> [#("itemStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn inventoryreport_inventorylisting_decoder() -> Decoder(
  InventoryreportInventorylisting,
) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(inventoryreport_inventorylisting_item_decoder()),
  )
  use counting_date_time <- decode.optional_field(
    "countingDateTime",
    None,
    decode.optional(decode.string),
  )
  use item_status <- decode.optional_field(
    "itemStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InventoryreportInventorylisting(
    item:,
    counting_date_time:,
    item_status:,
    location:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn inventoryreport_to_json(inventoryreport: Inventoryreport) -> Json {
  let Inventoryreport(
    note:,
    inventory_listing:,
    reporting_period:,
    reporter:,
    reported_date_time:,
    operation_type_reason:,
    operation_type:,
    count_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = inventoryreport
  let fields = [
    #("reportedDateTime", json.string(reported_date_time)),
    #("countType", r5valuesets.inventoryreportcounttype_to_json(count_type)),
    #("status", r5valuesets.inventoryreportstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case inventory_listing {
    [] -> fields
    _ -> [
      #(
        "inventoryListing",
        json.array(inventory_listing, inventoryreport_inventorylisting_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reporting_period {
    Some(v) -> [#("reportingPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reporter {
    Some(v) -> [#("reporter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case operation_type_reason {
    Some(v) -> [#("operationTypeReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case operation_type {
    Some(v) -> [#("operationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Inventoryreport")), ..fields]
  json.object(fields)
}

pub fn inventoryreport_decoder() -> Decoder(Inventoryreport) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use inventory_listing <- decode.optional_field(
    "inventoryListing",
    [],
    decode.list(inventoryreport_inventorylisting_decoder()),
  )
  use reporting_period <- decode.optional_field(
    "reportingPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use reporter <- decode.optional_field(
    "reporter",
    None,
    decode.optional(reference_decoder()),
  )
  use reported_date_time <- decode.field("reportedDateTime", decode.string)
  use operation_type_reason <- decode.optional_field(
    "operationTypeReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use operation_type <- decode.optional_field(
    "operationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use count_type <- decode.field(
    "countType",
    r5valuesets.inventoryreportcounttype_decoder(),
  )
  use status <- decode.field(
    "status",
    r5valuesets.inventoryreportstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Inventoryreport",
    decode.failure(
      inventoryreport_new(reported_date_time:, count_type:, status:),
      "resourceType",
    ),
  )
  decode.success(Inventoryreport(
    note:,
    inventory_listing:,
    reporting_period:,
    reporter:,
    reported_date_time:,
    operation_type_reason:,
    operation_type:,
    count_type:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type Invoice {
  Invoice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Invoicestatus,
    cancelled_reason: Option(String),
    type_: Option(Codeableconcept),
    subject: Option(Reference),
    recipient: Option(Reference),
    date: Option(String),
    creation: Option(String),
    period: Option(InvoicePeriod),
    participant: List(InvoiceParticipant),
    issuer: Option(Reference),
    account: Option(Reference),
    line_item: List(InvoiceLineitem),
    total_price_component: List(Monetarycomponent),
    total_net: Option(Money),
    total_gross: Option(Money),
    payment_terms: Option(String),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type InvoicePeriod {
  InvoicePeriodDate(period: String)
  InvoicePeriodPeriod(period: Period)
}

pub fn invoice_period_to_json(elt: InvoicePeriod) -> Json {
  case elt {
    InvoicePeriodDate(v) -> json.string(v)
    InvoicePeriodPeriod(v) -> period_to_json(v)
  }
}

pub fn invoice_period_decoder() -> Decoder(InvoicePeriod) {
  decode.one_of(
    decode.field("periodDate", decode.string, decode.success)
      |> decode.map(InvoicePeriodDate),
    [
      decode.field("periodPeriod", period_decoder(), decode.success)
      |> decode.map(InvoicePeriodPeriod),
    ],
  )
}

pub fn invoice_new(status status: r5valuesets.Invoicestatus) -> Invoice {
  Invoice(
    note: [],
    payment_terms: None,
    total_gross: None,
    total_net: None,
    total_price_component: [],
    line_item: [],
    account: None,
    issuer: None,
    participant: [],
    period: None,
    creation: None,
    date: None,
    recipient: None,
    subject: None,
    type_: None,
    cancelled_reason: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type InvoiceParticipant {
  InvoiceParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn invoice_participant_new(actor actor: Reference) -> InvoiceParticipant {
  InvoiceParticipant(
    actor:,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type InvoiceLineitem {
  InvoiceLineitem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    serviced: Option(InvoiceLineitemServiced),
    charge_item: InvoiceLineitemChargeitem,
    price_component: List(Monetarycomponent),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type InvoiceLineitemServiced {
  InvoiceLineitemServicedDate(serviced: String)
  InvoiceLineitemServicedPeriod(serviced: Period)
}

pub fn invoice_lineitem_serviced_to_json(elt: InvoiceLineitemServiced) -> Json {
  case elt {
    InvoiceLineitemServicedDate(v) -> json.string(v)
    InvoiceLineitemServicedPeriod(v) -> period_to_json(v)
  }
}

pub fn invoice_lineitem_serviced_decoder() -> Decoder(InvoiceLineitemServiced) {
  decode.one_of(
    decode.field("servicedDate", decode.string, decode.success)
      |> decode.map(InvoiceLineitemServicedDate),
    [
      decode.field("servicedPeriod", period_decoder(), decode.success)
      |> decode.map(InvoiceLineitemServicedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Invoice#resource
pub type InvoiceLineitemChargeitem {
  InvoiceLineitemChargeitemReference(charge_item: Reference)
  InvoiceLineitemChargeitemCodeableconcept(charge_item: Codeableconcept)
}

pub fn invoice_lineitem_chargeitem_to_json(
  elt: InvoiceLineitemChargeitem,
) -> Json {
  case elt {
    InvoiceLineitemChargeitemReference(v) -> reference_to_json(v)
    InvoiceLineitemChargeitemCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn invoice_lineitem_chargeitem_decoder() -> Decoder(
  InvoiceLineitemChargeitem,
) {
  decode.one_of(
    decode.field("chargeItemReference", reference_decoder(), decode.success)
      |> decode.map(InvoiceLineitemChargeitemReference),
    [
      decode.field(
        "chargeItemCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(InvoiceLineitemChargeitemCodeableconcept),
    ],
  )
}

pub fn invoice_lineitem_new(
  charge_item charge_item: InvoiceLineitemChargeitem,
) -> InvoiceLineitem {
  InvoiceLineitem(
    price_component: [],
    charge_item:,
    serviced: None,
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn invoice_lineitem_to_json(invoice_lineitem: InvoiceLineitem) -> Json {
  let InvoiceLineitem(
    price_component:,
    charge_item:,
    serviced:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = invoice_lineitem
  let fields = [
    #("chargeItem", invoice_lineitem_chargeitem_to_json(charge_item)),
  ]
  let fields = case price_component {
    [] -> fields
    _ -> [
      #(
        "priceComponent",
        json.array(price_component, monetarycomponent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case serviced {
    Some(v) -> [
      #(
        "serviced"
          <> case v {
          InvoiceLineitemServicedDate(_) -> "Date"
          InvoiceLineitemServicedPeriod(_) -> "Period"
        },
        invoice_lineitem_serviced_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn invoice_lineitem_decoder() -> Decoder(InvoiceLineitem) {
  use price_component <- decode.optional_field(
    "priceComponent",
    [],
    decode.list(monetarycomponent_decoder()),
  )
  use charge_item <- decode.then(invoice_lineitem_chargeitem_decoder())
  use serviced <- decode.then(
    none_if_omitted(invoice_lineitem_serviced_decoder()),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InvoiceLineitem(
    price_component:,
    charge_item:,
    serviced:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn invoice_participant_to_json(
  invoice_participant: InvoiceParticipant,
) -> Json {
  let InvoiceParticipant(actor:, role:, modifier_extension:, extension:, id:) =
    invoice_participant
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn invoice_participant_decoder() -> Decoder(InvoiceParticipant) {
  use actor <- decode.field("actor", reference_decoder())
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(InvoiceParticipant(
    actor:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn invoice_to_json(invoice: Invoice) -> Json {
  let Invoice(
    note:,
    payment_terms:,
    total_gross:,
    total_net:,
    total_price_component:,
    line_item:,
    account:,
    issuer:,
    participant:,
    period:,
    creation:,
    date:,
    recipient:,
    subject:,
    type_:,
    cancelled_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = invoice
  let fields = [
    #("status", r5valuesets.invoicestatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case payment_terms {
    Some(v) -> [#("paymentTerms", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case total_gross {
    Some(v) -> [#("totalGross", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total_net {
    Some(v) -> [#("totalNet", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case total_price_component {
    [] -> fields
    _ -> [
      #(
        "totalPriceComponent",
        json.array(total_price_component, monetarycomponent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case line_item {
    [] -> fields
    _ -> [
      #("lineItem", json.array(line_item, invoice_lineitem_to_json)),
      ..fields
    ]
  }
  let fields = case account {
    Some(v) -> [#("account", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issuer {
    Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, invoice_participant_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [
      #(
        "period"
          <> case v {
          InvoicePeriodDate(_) -> "Date"
          InvoicePeriodPeriod(_) -> "Period"
        },
        invoice_period_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case creation {
    Some(v) -> [#("creation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case recipient {
    Some(v) -> [#("recipient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cancelled_reason {
    Some(v) -> [#("cancelledReason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Invoice")), ..fields]
  json.object(fields)
}

pub fn invoice_decoder() -> Decoder(Invoice) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use payment_terms <- decode.optional_field(
    "paymentTerms",
    None,
    decode.optional(decode.string),
  )
  use total_gross <- decode.optional_field(
    "totalGross",
    None,
    decode.optional(money_decoder()),
  )
  use total_net <- decode.optional_field(
    "totalNet",
    None,
    decode.optional(money_decoder()),
  )
  use total_price_component <- decode.optional_field(
    "totalPriceComponent",
    [],
    decode.list(monetarycomponent_decoder()),
  )
  use line_item <- decode.optional_field(
    "lineItem",
    [],
    decode.list(invoice_lineitem_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    None,
    decode.optional(reference_decoder()),
  )
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(reference_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(invoice_participant_decoder()),
  )
  use period <- decode.then(none_if_omitted(invoice_period_decoder()))
  use creation <- decode.optional_field(
    "creation",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use recipient <- decode.optional_field(
    "recipient",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use cancelled_reason <- decode.optional_field(
    "cancelledReason",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", r5valuesets.invoicestatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Invoice",
    decode.failure(invoice_new(status:), "resourceType"),
  )
  decode.success(Invoice(
    note:,
    payment_terms:,
    total_gross:,
    total_net:,
    total_price_component:,
    line_item:,
    account:,
    issuer:,
    participant:,
    period:,
    creation:,
    date:,
    recipient:,
    subject:,
    type_:,
    cancelled_reason:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Library#resource
pub type Library {
  Library(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(LibraryVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    type_: Codeableconcept,
    subject: Option(LibrarySubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    parameter: List(Parameterdefinition),
    data_requirement: List(Datarequirement),
    content: List(Attachment),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Library#resource
pub type LibraryVersionalgorithm {
  LibraryVersionalgorithmString(version_algorithm: String)
  LibraryVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn library_versionalgorithm_to_json(elt: LibraryVersionalgorithm) -> Json {
  case elt {
    LibraryVersionalgorithmString(v) -> json.string(v)
    LibraryVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn library_versionalgorithm_decoder() -> Decoder(LibraryVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(LibraryVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(LibraryVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Library#resource
pub type LibrarySubject {
  LibrarySubjectCodeableconcept(subject: Codeableconcept)
  LibrarySubjectReference(subject: Reference)
}

pub fn library_subject_to_json(elt: LibrarySubject) -> Json {
  case elt {
    LibrarySubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    LibrarySubjectReference(v) -> reference_to_json(v)
  }
}

pub fn library_subject_decoder() -> Decoder(LibrarySubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(LibrarySubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(LibrarySubjectReference),
    ],
  )
}

pub fn library_new(
  type_ type_: Codeableconcept,
  status status: r5valuesets.Publicationstatus,
) -> Library {
  Library(
    content: [],
    data_requirement: [],
    parameter: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    type_:,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn library_to_json(library: Library) -> Json {
  let Library(
    content:,
    data_requirement:,
    parameter:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    type_:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = library
  let fields = [
    #("type", codeableconcept_to_json(type_)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case content {
    [] -> fields
    _ -> [#("content", json.array(content, attachment_to_json)), ..fields]
  }
  let fields = case data_requirement {
    [] -> fields
    _ -> [
      #(
        "dataRequirement",
        json.array(data_requirement, datarequirement_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, parameterdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          LibrarySubjectCodeableconcept(_) -> "Codeableconcept"
          LibrarySubjectReference(_) -> "Reference"
        },
        library_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          LibraryVersionalgorithmString(_) -> "String"
          LibraryVersionalgorithmCoding(_) -> "Coding"
        },
        library_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Library")), ..fields]
  json.object(fields)
}

pub fn library_decoder() -> Decoder(Library) {
  use content <- decode.optional_field(
    "content",
    [],
    decode.list(attachment_decoder()),
  )
  use data_requirement <- decode.optional_field(
    "dataRequirement",
    [],
    decode.list(datarequirement_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(parameterdefinition_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(library_subject_decoder()))
  use type_ <- decode.field("type", codeableconcept_decoder())
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(library_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Library",
    decode.failure(library_new(type_:, status:), "resourceType"),
  )
  decode.success(Library(
    content:,
    data_requirement:,
    parameter:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    type_:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Linkage#resource
pub type Linkage {
  Linkage(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    active: Option(Bool),
    author: Option(Reference),
    item: List(LinkageItem),
  )
}

pub fn linkage_new() -> Linkage {
  Linkage(
    item: [],
    author: None,
    active: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Linkage#resource
pub type LinkageItem {
  LinkageItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Linkagetype,
    resource: Reference,
  )
}

pub fn linkage_item_new(
  resource resource: Reference,
  type_ type_: r5valuesets.Linkagetype,
) -> LinkageItem {
  LinkageItem(
    resource:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn linkage_item_to_json(linkage_item: LinkageItem) -> Json {
  let LinkageItem(resource:, type_:, modifier_extension:, extension:, id:) =
    linkage_item
  let fields = [
    #("resource", reference_to_json(resource)),
    #("type", r5valuesets.linkagetype_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn linkage_item_decoder() -> Decoder(LinkageItem) {
  use resource <- decode.field("resource", reference_decoder())
  use type_ <- decode.field("type", r5valuesets.linkagetype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(LinkageItem(
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn linkage_to_json(linkage: Linkage) -> Json {
  let Linkage(
    item:,
    author:,
    active:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = linkage
  let fields = []
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, linkage_item_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Linkage")), ..fields]
  json.object(fields)
}

pub fn linkage_decoder() -> Decoder(Linkage) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(linkage_item_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Linkage",
    decode.failure(linkage_new(), "resourceType"),
  )
  decode.success(Linkage(
    item:,
    author:,
    active:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/List#resource
pub type Listfhir {
  Listfhir(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Liststatus,
    mode: r5valuesets.Listmode,
    title: Option(String),
    code: Option(Codeableconcept),
    subject: List(Reference),
    encounter: Option(Reference),
    date: Option(String),
    source: Option(Reference),
    ordered_by: Option(Codeableconcept),
    note: List(Annotation),
    entry: List(ListEntry),
    empty_reason: Option(Codeableconcept),
  )
}

pub fn listfhir_new(
  mode mode: r5valuesets.Listmode,
  status status: r5valuesets.Liststatus,
) -> Listfhir {
  Listfhir(
    empty_reason: None,
    entry: [],
    note: [],
    ordered_by: None,
    source: None,
    date: None,
    encounter: None,
    subject: [],
    code: None,
    title: None,
    mode:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/List#resource
pub type ListEntry {
  ListEntry(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    flag: Option(Codeableconcept),
    deleted: Option(Bool),
    date: Option(String),
    item: Reference,
  )
}

pub fn list_entry_new(item item: Reference) -> ListEntry {
  ListEntry(
    item:,
    date: None,
    deleted: None,
    flag: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn list_entry_to_json(list_entry: ListEntry) -> Json {
  let ListEntry(
    item:,
    date:,
    deleted:,
    flag:,
    modifier_extension:,
    extension:,
    id:,
  ) = list_entry
  let fields = [
    #("item", reference_to_json(item)),
  ]
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case deleted {
    Some(v) -> [#("deleted", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case flag {
    Some(v) -> [#("flag", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn list_entry_decoder() -> Decoder(ListEntry) {
  use item <- decode.field("item", reference_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use deleted <- decode.optional_field(
    "deleted",
    None,
    decode.optional(decode.bool),
  )
  use flag <- decode.optional_field(
    "flag",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ListEntry(
    item:,
    date:,
    deleted:,
    flag:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn listfhir_to_json(listfhir: Listfhir) -> Json {
  let Listfhir(
    empty_reason:,
    entry:,
    note:,
    ordered_by:,
    source:,
    date:,
    encounter:,
    subject:,
    code:,
    title:,
    mode:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = listfhir
  let fields = [
    #("mode", r5valuesets.listmode_to_json(mode)),
    #("status", r5valuesets.liststatus_to_json(status)),
  ]
  let fields = case empty_reason {
    Some(v) -> [#("emptyReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case entry {
    [] -> fields
    _ -> [#("entry", json.array(entry, list_entry_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case ordered_by {
    Some(v) -> [#("orderedBy", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Listfhir")), ..fields]
  json.object(fields)
}

pub fn listfhir_decoder() -> Decoder(Listfhir) {
  use empty_reason <- decode.optional_field(
    "emptyReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use entry <- decode.optional_field(
    "entry",
    [],
    decode.list(list_entry_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use ordered_by <- decode.optional_field(
    "orderedBy",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.listmode_decoder())
  use status <- decode.field("status", r5valuesets.liststatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Listfhir",
    decode.failure(listfhir_new(mode:, status:), "resourceType"),
  )
  decode.success(Listfhir(
    empty_reason:,
    entry:,
    note:,
    ordered_by:,
    source:,
    date:,
    encounter:,
    subject:,
    code:,
    title:,
    mode:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Location#resource
pub type Location {
  Location(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Locationstatus),
    operational_status: Option(Coding),
    name: Option(String),
    alias: List(String),
    description: Option(String),
    mode: Option(r5valuesets.Locationmode),
    type_: List(Codeableconcept),
    contact: List(Extendedcontactdetail),
    address: Option(Address),
    form: Option(Codeableconcept),
    position: Option(LocationPosition),
    managing_organization: Option(Reference),
    part_of: Option(Reference),
    characteristic: List(Codeableconcept),
    hours_of_operation: List(Availability),
    virtual_service: List(Virtualservicedetail),
    endpoint: List(Reference),
  )
}

pub fn location_new() -> Location {
  Location(
    endpoint: [],
    virtual_service: [],
    hours_of_operation: [],
    characteristic: [],
    part_of: None,
    managing_organization: None,
    position: None,
    form: None,
    address: None,
    contact: [],
    type_: [],
    mode: None,
    description: None,
    alias: [],
    name: None,
    operational_status: None,
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Location#resource
pub type LocationPosition {
  LocationPosition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    longitude: Float,
    latitude: Float,
    altitude: Option(Float),
  )
}

pub fn location_position_new(
  latitude latitude: Float,
  longitude longitude: Float,
) -> LocationPosition {
  LocationPosition(
    altitude: None,
    latitude:,
    longitude:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn location_position_to_json(location_position: LocationPosition) -> Json {
  let LocationPosition(
    altitude:,
    latitude:,
    longitude:,
    modifier_extension:,
    extension:,
    id:,
  ) = location_position
  let fields = [
    #("latitude", json.float(latitude)),
    #("longitude", json.float(longitude)),
  ]
  let fields = case altitude {
    Some(v) -> [#("altitude", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn location_position_decoder() -> Decoder(LocationPosition) {
  use altitude <- decode.optional_field(
    "altitude",
    None,
    decode.optional(decode.float),
  )
  use latitude <- decode.field("latitude", decode.float)
  use longitude <- decode.field("longitude", decode.float)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(LocationPosition(
    altitude:,
    latitude:,
    longitude:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn location_to_json(location: Location) -> Json {
  let Location(
    endpoint:,
    virtual_service:,
    hours_of_operation:,
    characteristic:,
    part_of:,
    managing_organization:,
    position:,
    form:,
    address:,
    contact:,
    type_:,
    mode:,
    description:,
    alias:,
    name:,
    operational_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = location
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case virtual_service {
    [] -> fields
    _ -> [
      #(
        "virtualService",
        json.array(virtual_service, virtualservicedetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case hours_of_operation {
    [] -> fields
    _ -> [
      #(
        "hoursOfOperation",
        json.array(hours_of_operation, availability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #("characteristic", json.array(characteristic, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case position {
    Some(v) -> [#("position", location_position_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case mode {
    Some(v) -> [#("mode", r5valuesets.locationmode_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case operational_status {
    Some(v) -> [#("operationalStatus", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.locationstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Location")), ..fields]
  json.object(fields)
}

pub fn location_decoder() -> Decoder(Location) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use virtual_service <- decode.optional_field(
    "virtualService",
    [],
    decode.list(virtualservicedetail_decoder()),
  )
  use hours_of_operation <- decode.optional_field(
    "hoursOfOperation",
    [],
    decode.list(availability_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use position <- decode.optional_field(
    "position",
    None,
    decode.optional(location_position_decoder()),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use mode <- decode.optional_field(
    "mode",
    None,
    decode.optional(r5valuesets.locationmode_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use operational_status <- decode.optional_field(
    "operationalStatus",
    None,
    decode.optional(coding_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.locationstatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Location",
    decode.failure(location_new(), "resourceType"),
  )
  decode.success(Location(
    endpoint:,
    virtual_service:,
    hours_of_operation:,
    characteristic:,
    part_of:,
    managing_organization:,
    position:,
    form:,
    address:,
    contact:,
    type_:,
    mode:,
    description:,
    alias:,
    name:,
    operational_status:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ManufacturedItemDefinition#resource
pub type Manufactureditemdefinition {
  Manufactureditemdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Publicationstatus,
    name: Option(String),
    manufactured_dose_form: Codeableconcept,
    unit_of_presentation: Option(Codeableconcept),
    manufacturer: List(Reference),
    marketing_status: List(Marketingstatus),
    ingredient: List(Codeableconcept),
    property: List(ManufactureditemdefinitionProperty),
    component: List(ManufactureditemdefinitionComponent),
  )
}

pub fn manufactureditemdefinition_new(
  manufactured_dose_form manufactured_dose_form: Codeableconcept,
  status status: r5valuesets.Publicationstatus,
) -> Manufactureditemdefinition {
  Manufactureditemdefinition(
    component: [],
    property: [],
    ingredient: [],
    marketing_status: [],
    manufacturer: [],
    unit_of_presentation: None,
    manufactured_dose_form:,
    name: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionProperty {
  ManufactureditemdefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(ManufactureditemdefinitionPropertyValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionPropertyValue {
  ManufactureditemdefinitionPropertyValueCodeableconcept(value: Codeableconcept)
  ManufactureditemdefinitionPropertyValueQuantity(value: Quantity)
  ManufactureditemdefinitionPropertyValueDate(value: String)
  ManufactureditemdefinitionPropertyValueBoolean(value: Bool)
  ManufactureditemdefinitionPropertyValueMarkdown(value: String)
  ManufactureditemdefinitionPropertyValueAttachment(value: Attachment)
  ManufactureditemdefinitionPropertyValueReference(value: Reference)
}

pub fn manufactureditemdefinition_property_value_to_json(
  elt: ManufactureditemdefinitionPropertyValue,
) -> Json {
  case elt {
    ManufactureditemdefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ManufactureditemdefinitionPropertyValueQuantity(v) -> quantity_to_json(v)
    ManufactureditemdefinitionPropertyValueDate(v) -> json.string(v)
    ManufactureditemdefinitionPropertyValueBoolean(v) -> json.bool(v)
    ManufactureditemdefinitionPropertyValueMarkdown(v) -> json.string(v)
    ManufactureditemdefinitionPropertyValueAttachment(v) ->
      attachment_to_json(v)
    ManufactureditemdefinitionPropertyValueReference(v) -> reference_to_json(v)
  }
}

pub fn manufactureditemdefinition_property_value_decoder() -> Decoder(
  ManufactureditemdefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(ManufactureditemdefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueBoolean),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueMarkdown),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ManufactureditemdefinitionPropertyValueReference),
    ],
  )
}

pub fn manufactureditemdefinition_property_new(
  type_ type_: Codeableconcept,
) -> ManufactureditemdefinitionProperty {
  ManufactureditemdefinitionProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionComponent {
  ManufactureditemdefinitionComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    function: List(Codeableconcept),
    amount: List(Quantity),
    constituent: List(ManufactureditemdefinitionComponentConstituent),
  )
}

pub fn manufactureditemdefinition_component_new(
  type_ type_: Codeableconcept,
) -> ManufactureditemdefinitionComponent {
  ManufactureditemdefinitionComponent(
    constituent: [],
    amount: [],
    function: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ManufacturedItemDefinition#resource
pub type ManufactureditemdefinitionComponentConstituent {
  ManufactureditemdefinitionComponentConstituent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    amount: List(Quantity),
    location: List(Codeableconcept),
    function: List(Codeableconcept),
    has_ingredient: List(Codeablereference),
  )
}

pub fn manufactureditemdefinition_component_constituent_new() -> ManufactureditemdefinitionComponentConstituent {
  ManufactureditemdefinitionComponentConstituent(
    has_ingredient: [],
    function: [],
    location: [],
    amount: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn manufactureditemdefinition_component_constituent_to_json(
  manufactureditemdefinition_component_constituent: ManufactureditemdefinitionComponentConstituent,
) -> Json {
  let ManufactureditemdefinitionComponentConstituent(
    has_ingredient:,
    function:,
    location:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ) = manufactureditemdefinition_component_constituent
  let fields = []
  let fields = case has_ingredient {
    [] -> fields
    _ -> [
      #("hasIngredient", json.array(has_ingredient, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case function {
    [] -> fields
    _ -> [
      #("function", json.array(function, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, quantity_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn manufactureditemdefinition_component_constituent_decoder() -> Decoder(
  ManufactureditemdefinitionComponentConstituent,
) {
  use has_ingredient <- decode.optional_field(
    "hasIngredient",
    [],
    decode.list(codeablereference_decoder()),
  )
  use function <- decode.optional_field(
    "function",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ManufactureditemdefinitionComponentConstituent(
    has_ingredient:,
    function:,
    location:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn manufactureditemdefinition_component_to_json(
  manufactureditemdefinition_component: ManufactureditemdefinitionComponent,
) -> Json {
  let ManufactureditemdefinitionComponent(
    constituent:,
    amount:,
    function:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = manufactureditemdefinition_component
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case constituent {
    [] -> fields
    _ -> [
      #(
        "constituent",
        json.array(
          constituent,
          manufactureditemdefinition_component_constituent_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, quantity_to_json)), ..fields]
  }
  let fields = case function {
    [] -> fields
    _ -> [
      #("function", json.array(function, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn manufactureditemdefinition_component_decoder() -> Decoder(
  ManufactureditemdefinitionComponent,
) {
  use constituent <- decode.optional_field(
    "constituent",
    [],
    decode.list(manufactureditemdefinition_component_constituent_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(quantity_decoder()),
  )
  use function <- decode.optional_field(
    "function",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ManufactureditemdefinitionComponent(
    constituent:,
    amount:,
    function:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn manufactureditemdefinition_property_to_json(
  manufactureditemdefinition_property: ManufactureditemdefinitionProperty,
) -> Json {
  let ManufactureditemdefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = manufactureditemdefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ManufactureditemdefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          ManufactureditemdefinitionPropertyValueQuantity(_) -> "Quantity"
          ManufactureditemdefinitionPropertyValueDate(_) -> "Date"
          ManufactureditemdefinitionPropertyValueBoolean(_) -> "Boolean"
          ManufactureditemdefinitionPropertyValueMarkdown(_) -> "Markdown"
          ManufactureditemdefinitionPropertyValueAttachment(_) -> "Attachment"
          ManufactureditemdefinitionPropertyValueReference(_) -> "Reference"
        },
        manufactureditemdefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn manufactureditemdefinition_property_decoder() -> Decoder(
  ManufactureditemdefinitionProperty,
) {
  use value <- decode.then(
    none_if_omitted(manufactureditemdefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ManufactureditemdefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn manufactureditemdefinition_to_json(
  manufactureditemdefinition: Manufactureditemdefinition,
) -> Json {
  let Manufactureditemdefinition(
    component:,
    property:,
    ingredient:,
    marketing_status:,
    manufacturer:,
    unit_of_presentation:,
    manufactured_dose_form:,
    name:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = manufactureditemdefinition
  let fields = [
    #("manufacturedDoseForm", codeableconcept_to_json(manufactured_dose_form)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(component, manufactureditemdefinition_component_to_json),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, manufactureditemdefinition_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case marketing_status {
    [] -> fields
    _ -> [
      #(
        "marketingStatus",
        json.array(marketing_status, marketingstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case unit_of_presentation {
    Some(v) -> [#("unitOfPresentation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Manufactureditemdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn manufactureditemdefinition_decoder() -> Decoder(
  Manufactureditemdefinition,
) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(manufactureditemdefinition_component_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(manufactureditemdefinition_property_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use marketing_status <- decode.optional_field(
    "marketingStatus",
    [],
    decode.list(marketingstatus_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use unit_of_presentation <- decode.optional_field(
    "unitOfPresentation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use manufactured_dose_form <- decode.field(
    "manufacturedDoseForm",
    codeableconcept_decoder(),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Manufactureditemdefinition",
    decode.failure(
      manufactureditemdefinition_new(manufactured_dose_form:, status:),
      "resourceType",
    ),
  )
  decode.success(Manufactureditemdefinition(
    component:,
    property:,
    ingredient:,
    marketing_status:,
    manufacturer:,
    unit_of_presentation:,
    manufactured_dose_form:,
    name:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type Measure {
  Measure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(MeasureVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(MeasureSubject),
    basis: Option(r5valuesets.Fhirtypes),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    disclaimer: Option(String),
    scoring: Option(Codeableconcept),
    scoring_unit: Option(Codeableconcept),
    composite_scoring: Option(Codeableconcept),
    type_: List(Codeableconcept),
    risk_adjustment: Option(String),
    rate_aggregation: Option(String),
    rationale: Option(String),
    clinical_recommendation_statement: Option(String),
    improvement_notation: Option(Codeableconcept),
    term: List(MeasureTerm),
    guidance: Option(String),
    group: List(MeasureGroup),
    supplemental_data: List(MeasureSupplementaldata),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureVersionalgorithm {
  MeasureVersionalgorithmString(version_algorithm: String)
  MeasureVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn measure_versionalgorithm_to_json(elt: MeasureVersionalgorithm) -> Json {
  case elt {
    MeasureVersionalgorithmString(v) -> json.string(v)
    MeasureVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn measure_versionalgorithm_decoder() -> Decoder(MeasureVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(MeasureVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(MeasureVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureSubject {
  MeasureSubjectCodeableconcept(subject: Codeableconcept)
  MeasureSubjectReference(subject: Reference)
}

pub fn measure_subject_to_json(elt: MeasureSubject) -> Json {
  case elt {
    MeasureSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    MeasureSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn measure_subject_decoder() -> Decoder(MeasureSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MeasureSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(MeasureSubjectReference),
    ],
  )
}

pub fn measure_new(status status: r5valuesets.Publicationstatus) -> Measure {
  Measure(
    supplemental_data: [],
    group: [],
    guidance: None,
    term: [],
    improvement_notation: None,
    clinical_recommendation_statement: None,
    rationale: None,
    rate_aggregation: None,
    risk_adjustment: None,
    type_: [],
    composite_scoring: None,
    scoring_unit: None,
    scoring: None,
    disclaimer: None,
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    basis: None,
    subject: None,
    experimental: None,
    status:,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureTerm {
  MeasureTerm(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    definition: Option(String),
  )
}

pub fn measure_term_new() -> MeasureTerm {
  MeasureTerm(
    definition: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureGroup {
  MeasureGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    description: Option(String),
    type_: List(Codeableconcept),
    subject: Option(MeasureGroupSubject),
    basis: Option(r5valuesets.Fhirtypes),
    scoring: Option(Codeableconcept),
    scoring_unit: Option(Codeableconcept),
    rate_aggregation: Option(String),
    improvement_notation: Option(Codeableconcept),
    library: List(String),
    population: List(MeasureGroupPopulation),
    stratifier: List(MeasureGroupStratifier),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureGroupSubject {
  MeasureGroupSubjectCodeableconcept(subject: Codeableconcept)
  MeasureGroupSubjectReference(subject: Reference)
}

pub fn measure_group_subject_to_json(elt: MeasureGroupSubject) -> Json {
  case elt {
    MeasureGroupSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    MeasureGroupSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn measure_group_subject_decoder() -> Decoder(MeasureGroupSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MeasureGroupSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(MeasureGroupSubjectReference),
    ],
  )
}

pub fn measure_group_new() -> MeasureGroup {
  MeasureGroup(
    stratifier: [],
    population: [],
    library: [],
    improvement_notation: None,
    rate_aggregation: None,
    scoring_unit: None,
    scoring: None,
    basis: None,
    subject: None,
    type_: [],
    description: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureGroupPopulation {
  MeasureGroupPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Option(Expression),
    group_definition: Option(Reference),
    input_population_id: Option(String),
    aggregate_method: Option(Codeableconcept),
  )
}

pub fn measure_group_population_new() -> MeasureGroupPopulation {
  MeasureGroupPopulation(
    aggregate_method: None,
    input_population_id: None,
    group_definition: None,
    criteria: None,
    description: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureGroupStratifier {
  MeasureGroupStratifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Option(Expression),
    group_definition: Option(Reference),
    component: List(MeasureGroupStratifierComponent),
  )
}

pub fn measure_group_stratifier_new() -> MeasureGroupStratifier {
  MeasureGroupStratifier(
    component: [],
    group_definition: None,
    criteria: None,
    description: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureGroupStratifierComponent {
  MeasureGroupStratifierComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    description: Option(String),
    criteria: Option(Expression),
    group_definition: Option(Reference),
  )
}

pub fn measure_group_stratifier_component_new() -> MeasureGroupStratifierComponent {
  MeasureGroupStratifierComponent(
    group_definition: None,
    criteria: None,
    description: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Measure#resource
pub type MeasureSupplementaldata {
  MeasureSupplementaldata(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    usage: List(Codeableconcept),
    description: Option(String),
    criteria: Expression,
  )
}

pub fn measure_supplementaldata_new(
  criteria criteria: Expression,
) -> MeasureSupplementaldata {
  MeasureSupplementaldata(
    criteria:,
    description: None,
    usage: [],
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn measure_supplementaldata_to_json(
  measure_supplementaldata: MeasureSupplementaldata,
) -> Json {
  let MeasureSupplementaldata(
    criteria:,
    description:,
    usage:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_supplementaldata
  let fields = [
    #("criteria", expression_to_json(criteria)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    [] -> fields
    _ -> [#("usage", json.array(usage, codeableconcept_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_supplementaldata_decoder() -> Decoder(MeasureSupplementaldata) {
  use criteria <- decode.field("criteria", expression_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureSupplementaldata(
    criteria:,
    description:,
    usage:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_stratifier_component_to_json(
  measure_group_stratifier_component: MeasureGroupStratifierComponent,
) -> Json {
  let MeasureGroupStratifierComponent(
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_stratifier_component
  let fields = []
  let fields = case group_definition {
    Some(v) -> [#("groupDefinition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case criteria {
    Some(v) -> [#("criteria", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_stratifier_component_decoder() -> Decoder(
  MeasureGroupStratifierComponent,
) {
  use group_definition <- decode.optional_field(
    "groupDefinition",
    None,
    decode.optional(reference_decoder()),
  )
  use criteria <- decode.optional_field(
    "criteria",
    None,
    decode.optional(expression_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupStratifierComponent(
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_stratifier_to_json(
  measure_group_stratifier: MeasureGroupStratifier,
) -> Json {
  let MeasureGroupStratifier(
    component:,
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_stratifier
  let fields = []
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(component, measure_group_stratifier_component_to_json),
      ),
      ..fields
    ]
  }
  let fields = case group_definition {
    Some(v) -> [#("groupDefinition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case criteria {
    Some(v) -> [#("criteria", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_stratifier_decoder() -> Decoder(MeasureGroupStratifier) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(measure_group_stratifier_component_decoder()),
  )
  use group_definition <- decode.optional_field(
    "groupDefinition",
    None,
    decode.optional(reference_decoder()),
  )
  use criteria <- decode.optional_field(
    "criteria",
    None,
    decode.optional(expression_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupStratifier(
    component:,
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_population_to_json(
  measure_group_population: MeasureGroupPopulation,
) -> Json {
  let MeasureGroupPopulation(
    aggregate_method:,
    input_population_id:,
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group_population
  let fields = []
  let fields = case aggregate_method {
    Some(v) -> [#("aggregateMethod", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case input_population_id {
    Some(v) -> [#("inputPopulationId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case group_definition {
    Some(v) -> [#("groupDefinition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case criteria {
    Some(v) -> [#("criteria", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_population_decoder() -> Decoder(MeasureGroupPopulation) {
  use aggregate_method <- decode.optional_field(
    "aggregateMethod",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use input_population_id <- decode.optional_field(
    "inputPopulationId",
    None,
    decode.optional(decode.string),
  )
  use group_definition <- decode.optional_field(
    "groupDefinition",
    None,
    decode.optional(reference_decoder()),
  )
  use criteria <- decode.optional_field(
    "criteria",
    None,
    decode.optional(expression_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroupPopulation(
    aggregate_method:,
    input_population_id:,
    group_definition:,
    criteria:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_group_to_json(measure_group: MeasureGroup) -> Json {
  let MeasureGroup(
    stratifier:,
    population:,
    library:,
    improvement_notation:,
    rate_aggregation:,
    scoring_unit:,
    scoring:,
    basis:,
    subject:,
    type_:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measure_group
  let fields = []
  let fields = case stratifier {
    [] -> fields
    _ -> [
      #("stratifier", json.array(stratifier, measure_group_stratifier_to_json)),
      ..fields
    ]
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #("population", json.array(population, measure_group_population_to_json)),
      ..fields
    ]
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case improvement_notation {
    Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case rate_aggregation {
    Some(v) -> [#("rateAggregation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case scoring_unit {
    Some(v) -> [#("scoringUnit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scoring {
    Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case basis {
    Some(v) -> [#("basis", r5valuesets.fhirtypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          MeasureGroupSubjectCodeableconcept(_) -> "Codeableconcept"
          MeasureGroupSubjectReference(_) -> "Reference"
        },
        measure_group_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_group_decoder() -> Decoder(MeasureGroup) {
  use stratifier <- decode.optional_field(
    "stratifier",
    [],
    decode.list(measure_group_stratifier_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measure_group_population_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use improvement_notation <- decode.optional_field(
    "improvementNotation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use rate_aggregation <- decode.optional_field(
    "rateAggregation",
    None,
    decode.optional(decode.string),
  )
  use scoring_unit <- decode.optional_field(
    "scoringUnit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use scoring <- decode.optional_field(
    "scoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    None,
    decode.optional(r5valuesets.fhirtypes_decoder()),
  )
  use subject <- decode.then(none_if_omitted(measure_group_subject_decoder()))
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureGroup(
    stratifier:,
    population:,
    library:,
    improvement_notation:,
    rate_aggregation:,
    scoring_unit:,
    scoring:,
    basis:,
    subject:,
    type_:,
    description:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_term_to_json(measure_term: MeasureTerm) -> Json {
  let MeasureTerm(definition:, code:, modifier_extension:, extension:, id:) =
    measure_term
  let fields = []
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measure_term_decoder() -> Decoder(MeasureTerm) {
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasureTerm(
    definition:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measure_to_json(measure: Measure) -> Json {
  let Measure(
    supplemental_data:,
    group:,
    guidance:,
    term:,
    improvement_notation:,
    clinical_recommendation_statement:,
    rationale:,
    rate_aggregation:,
    risk_adjustment:,
    type_:,
    composite_scoring:,
    scoring_unit:,
    scoring:,
    disclaimer:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    basis:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = measure
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case supplemental_data {
    [] -> fields
    _ -> [
      #(
        "supplementalData",
        json.array(supplemental_data, measure_supplementaldata_to_json),
      ),
      ..fields
    ]
  }
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, measure_group_to_json)), ..fields]
  }
  let fields = case guidance {
    Some(v) -> [#("guidance", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case term {
    [] -> fields
    _ -> [#("term", json.array(term, measure_term_to_json)), ..fields]
  }
  let fields = case improvement_notation {
    Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case clinical_recommendation_statement {
    Some(v) -> [#("clinicalRecommendationStatement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rationale {
    Some(v) -> [#("rationale", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case rate_aggregation {
    Some(v) -> [#("rateAggregation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case risk_adjustment {
    Some(v) -> [#("riskAdjustment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case composite_scoring {
    Some(v) -> [#("compositeScoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scoring_unit {
    Some(v) -> [#("scoringUnit", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scoring {
    Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disclaimer {
    Some(v) -> [#("disclaimer", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case basis {
    Some(v) -> [#("basis", r5valuesets.fhirtypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          MeasureSubjectCodeableconcept(_) -> "Codeableconcept"
          MeasureSubjectReference(_) -> "Reference"
        },
        measure_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          MeasureVersionalgorithmString(_) -> "String"
          MeasureVersionalgorithmCoding(_) -> "Coding"
        },
        measure_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Measure")), ..fields]
  json.object(fields)
}

pub fn measure_decoder() -> Decoder(Measure) {
  use supplemental_data <- decode.optional_field(
    "supplementalData",
    [],
    decode.list(measure_supplementaldata_decoder()),
  )
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(measure_group_decoder()),
  )
  use guidance <- decode.optional_field(
    "guidance",
    None,
    decode.optional(decode.string),
  )
  use term <- decode.optional_field(
    "term",
    [],
    decode.list(measure_term_decoder()),
  )
  use improvement_notation <- decode.optional_field(
    "improvementNotation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use clinical_recommendation_statement <- decode.optional_field(
    "clinicalRecommendationStatement",
    None,
    decode.optional(decode.string),
  )
  use rationale <- decode.optional_field(
    "rationale",
    None,
    decode.optional(decode.string),
  )
  use rate_aggregation <- decode.optional_field(
    "rateAggregation",
    None,
    decode.optional(decode.string),
  )
  use risk_adjustment <- decode.optional_field(
    "riskAdjustment",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use composite_scoring <- decode.optional_field(
    "compositeScoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use scoring_unit <- decode.optional_field(
    "scoringUnit",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use scoring <- decode.optional_field(
    "scoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use disclaimer <- decode.optional_field(
    "disclaimer",
    None,
    decode.optional(decode.string),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use basis <- decode.optional_field(
    "basis",
    None,
    decode.optional(r5valuesets.fhirtypes_decoder()),
  )
  use subject <- decode.then(none_if_omitted(measure_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(measure_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Measure",
    decode.failure(measure_new(status:), "resourceType"),
  )
  decode.success(Measure(
    supplemental_data:,
    group:,
    guidance:,
    term:,
    improvement_notation:,
    clinical_recommendation_statement:,
    rationale:,
    rate_aggregation:,
    risk_adjustment:,
    type_:,
    composite_scoring:,
    scoring_unit:,
    scoring:,
    disclaimer:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    basis:,
    subject:,
    experimental:,
    status:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type Measurereport {
  Measurereport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Measurereportstatus,
    type_: r5valuesets.Measurereporttype,
    data_update_type: Option(r5valuesets.Submitdataupdatetype),
    measure: Option(String),
    subject: Option(Reference),
    date: Option(String),
    reporter: Option(Reference),
    reporting_vendor: Option(Reference),
    location: Option(Reference),
    period: Period,
    input_parameters: Option(Reference),
    scoring: Option(Codeableconcept),
    improvement_notation: Option(Codeableconcept),
    group: List(MeasurereportGroup),
    supplemental_data: List(Reference),
    evaluated_resource: List(Reference),
  )
}

pub fn measurereport_new(
  period period: Period,
  type_ type_: r5valuesets.Measurereporttype,
  status status: r5valuesets.Measurereportstatus,
) -> Measurereport {
  Measurereport(
    evaluated_resource: [],
    supplemental_data: [],
    group: [],
    improvement_notation: None,
    scoring: None,
    input_parameters: None,
    period:,
    location: None,
    reporting_vendor: None,
    reporter: None,
    date: None,
    subject: None,
    measure: None,
    data_update_type: None,
    type_:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroup {
  MeasurereportGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    subject: Option(Reference),
    population: List(MeasurereportGroupPopulation),
    measure_score: Option(MeasurereportGroupMeasurescore),
    stratifier: List(MeasurereportGroupStratifier),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupMeasurescore {
  MeasurereportGroupMeasurescoreQuantity(measure_score: Quantity)
  MeasurereportGroupMeasurescoreDatetime(measure_score: String)
  MeasurereportGroupMeasurescoreCodeableconcept(measure_score: Codeableconcept)
  MeasurereportGroupMeasurescorePeriod(measure_score: Period)
  MeasurereportGroupMeasurescoreRange(measure_score: Range)
  MeasurereportGroupMeasurescoreDuration(measure_score: Duration)
}

pub fn measurereport_group_measurescore_to_json(
  elt: MeasurereportGroupMeasurescore,
) -> Json {
  case elt {
    MeasurereportGroupMeasurescoreQuantity(v) -> quantity_to_json(v)
    MeasurereportGroupMeasurescoreDatetime(v) -> json.string(v)
    MeasurereportGroupMeasurescoreCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MeasurereportGroupMeasurescorePeriod(v) -> period_to_json(v)
    MeasurereportGroupMeasurescoreRange(v) -> range_to_json(v)
    MeasurereportGroupMeasurescoreDuration(v) -> duration_to_json(v)
  }
}

pub fn measurereport_group_measurescore_decoder() -> Decoder(
  MeasurereportGroupMeasurescore,
) {
  decode.one_of(
    decode.field("measureScoreQuantity", quantity_decoder(), decode.success)
      |> decode.map(MeasurereportGroupMeasurescoreQuantity),
    [
      decode.field("measureScoreDateTime", decode.string, decode.success)
        |> decode.map(MeasurereportGroupMeasurescoreDatetime),
      decode.field(
        "measureScoreCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(MeasurereportGroupMeasurescoreCodeableconcept),
      decode.field("measureScorePeriod", period_decoder(), decode.success)
        |> decode.map(MeasurereportGroupMeasurescorePeriod),
      decode.field("measureScoreRange", range_decoder(), decode.success)
        |> decode.map(MeasurereportGroupMeasurescoreRange),
      decode.field("measureScoreDuration", duration_decoder(), decode.success)
        |> decode.map(MeasurereportGroupMeasurescoreDuration),
    ],
  )
}

pub fn measurereport_group_new() -> MeasurereportGroup {
  MeasurereportGroup(
    stratifier: [],
    measure_score: None,
    population: [],
    subject: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupPopulation {
  MeasurereportGroupPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    count: Option(Int),
    subject_results: Option(Reference),
    subject_report: List(Reference),
    subjects: Option(Reference),
  )
}

pub fn measurereport_group_population_new() -> MeasurereportGroupPopulation {
  MeasurereportGroupPopulation(
    subjects: None,
    subject_report: [],
    subject_results: None,
    count: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifier {
  MeasurereportGroupStratifier(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    stratum: List(MeasurereportGroupStratifierStratum),
  )
}

pub fn measurereport_group_stratifier_new() -> MeasurereportGroupStratifier {
  MeasurereportGroupStratifier(
    stratum: [],
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratum {
  MeasurereportGroupStratifierStratum(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: Option(MeasurereportGroupStratifierStratumValue),
    component: List(MeasurereportGroupStratifierStratumComponent),
    population: List(MeasurereportGroupStratifierStratumPopulation),
    measure_score: Option(MeasurereportGroupStratifierStratumMeasurescore),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumValue {
  MeasurereportGroupStratifierStratumValueCodeableconcept(
    value: Codeableconcept,
  )
  MeasurereportGroupStratifierStratumValueBoolean(value: Bool)
  MeasurereportGroupStratifierStratumValueQuantity(value: Quantity)
  MeasurereportGroupStratifierStratumValueRange(value: Range)
  MeasurereportGroupStratifierStratumValueReference(value: Reference)
}

pub fn measurereport_group_stratifier_stratum_value_to_json(
  elt: MeasurereportGroupStratifierStratumValue,
) -> Json {
  case elt {
    MeasurereportGroupStratifierStratumValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MeasurereportGroupStratifierStratumValueBoolean(v) -> json.bool(v)
    MeasurereportGroupStratifierStratumValueQuantity(v) -> quantity_to_json(v)
    MeasurereportGroupStratifierStratumValueRange(v) -> range_to_json(v)
    MeasurereportGroupStratifierStratumValueReference(v) -> reference_to_json(v)
  }
}

pub fn measurereport_group_stratifier_stratum_value_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(MeasurereportGroupStratifierStratumValueCodeableconcept),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumValueReference),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumMeasurescore {
  MeasurereportGroupStratifierStratumMeasurescoreQuantity(
    measure_score: Quantity,
  )
  MeasurereportGroupStratifierStratumMeasurescoreDatetime(measure_score: String)
  MeasurereportGroupStratifierStratumMeasurescoreCodeableconcept(
    measure_score: Codeableconcept,
  )
  MeasurereportGroupStratifierStratumMeasurescorePeriod(measure_score: Period)
  MeasurereportGroupStratifierStratumMeasurescoreRange(measure_score: Range)
  MeasurereportGroupStratifierStratumMeasurescoreDuration(
    measure_score: Duration,
  )
}

pub fn measurereport_group_stratifier_stratum_measurescore_to_json(
  elt: MeasurereportGroupStratifierStratumMeasurescore,
) -> Json {
  case elt {
    MeasurereportGroupStratifierStratumMeasurescoreQuantity(v) ->
      quantity_to_json(v)
    MeasurereportGroupStratifierStratumMeasurescoreDatetime(v) -> json.string(v)
    MeasurereportGroupStratifierStratumMeasurescoreCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MeasurereportGroupStratifierStratumMeasurescorePeriod(v) ->
      period_to_json(v)
    MeasurereportGroupStratifierStratumMeasurescoreRange(v) -> range_to_json(v)
    MeasurereportGroupStratifierStratumMeasurescoreDuration(v) ->
      duration_to_json(v)
  }
}

pub fn measurereport_group_stratifier_stratum_measurescore_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumMeasurescore,
) {
  decode.one_of(
    decode.field("measureScoreQuantity", quantity_decoder(), decode.success)
      |> decode.map(MeasurereportGroupStratifierStratumMeasurescoreQuantity),
    [
      decode.field("measureScoreDateTime", decode.string, decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumMeasurescoreDatetime),
      decode.field(
        "measureScoreCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(
          MeasurereportGroupStratifierStratumMeasurescoreCodeableconcept,
        ),
      decode.field("measureScorePeriod", period_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumMeasurescorePeriod),
      decode.field("measureScoreRange", range_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumMeasurescoreRange),
      decode.field("measureScoreDuration", duration_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumMeasurescoreDuration),
    ],
  )
}

pub fn measurereport_group_stratifier_stratum_new() -> MeasurereportGroupStratifierStratum {
  MeasurereportGroupStratifierStratum(
    measure_score: None,
    population: [],
    component: [],
    value: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumComponent {
  MeasurereportGroupStratifierStratumComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Codeableconcept,
    value: MeasurereportGroupStratifierStratumComponentValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumComponentValue {
  MeasurereportGroupStratifierStratumComponentValueCodeableconcept(
    value: Codeableconcept,
  )
  MeasurereportGroupStratifierStratumComponentValueBoolean(value: Bool)
  MeasurereportGroupStratifierStratumComponentValueQuantity(value: Quantity)
  MeasurereportGroupStratifierStratumComponentValueRange(value: Range)
  MeasurereportGroupStratifierStratumComponentValueReference(value: Reference)
}

pub fn measurereport_group_stratifier_stratum_component_value_to_json(
  elt: MeasurereportGroupStratifierStratumComponentValue,
) -> Json {
  case elt {
    MeasurereportGroupStratifierStratumComponentValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MeasurereportGroupStratifierStratumComponentValueBoolean(v) -> json.bool(v)
    MeasurereportGroupStratifierStratumComponentValueQuantity(v) ->
      quantity_to_json(v)
    MeasurereportGroupStratifierStratumComponentValueRange(v) ->
      range_to_json(v)
    MeasurereportGroupStratifierStratumComponentValueReference(v) ->
      reference_to_json(v)
  }
}

pub fn measurereport_group_stratifier_stratum_component_value_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumComponentValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MeasurereportGroupStratifierStratumComponentValueCodeableconcept,
      ),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumComponentValueBoolean),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumComponentValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(MeasurereportGroupStratifierStratumComponentValueRange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(
          MeasurereportGroupStratifierStratumComponentValueReference,
        ),
    ],
  )
}

pub fn measurereport_group_stratifier_stratum_component_new(
  value value: MeasurereportGroupStratifierStratumComponentValue,
  code code: Codeableconcept,
) -> MeasurereportGroupStratifierStratumComponent {
  MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MeasureReport#resource
pub type MeasurereportGroupStratifierStratumPopulation {
  MeasurereportGroupStratifierStratumPopulation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    code: Option(Codeableconcept),
    count: Option(Int),
    subject_results: Option(Reference),
    subject_report: List(Reference),
    subjects: Option(Reference),
  )
}

pub fn measurereport_group_stratifier_stratum_population_new() -> MeasurereportGroupStratifierStratumPopulation {
  MeasurereportGroupStratifierStratumPopulation(
    subjects: None,
    subject_report: [],
    subject_results: None,
    count: None,
    code: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn measurereport_group_stratifier_stratum_population_to_json(
  measurereport_group_stratifier_stratum_population: MeasurereportGroupStratifierStratumPopulation,
) -> Json {
  let MeasurereportGroupStratifierStratumPopulation(
    subjects:,
    subject_report:,
    subject_results:,
    count:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum_population
  let fields = []
  let fields = case subjects {
    Some(v) -> [#("subjects", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject_report {
    [] -> fields
    _ -> [
      #("subjectReport", json.array(subject_report, reference_to_json)),
      ..fields
    ]
  }
  let fields = case subject_results {
    Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_population_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumPopulation,
) {
  use subjects <- decode.optional_field(
    "subjects",
    None,
    decode.optional(reference_decoder()),
  )
  use subject_report <- decode.optional_field(
    "subjectReport",
    [],
    decode.list(reference_decoder()),
  )
  use subject_results <- decode.optional_field(
    "subjectResults",
    None,
    decode.optional(reference_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratumPopulation(
    subjects:,
    subject_report:,
    subject_results:,
    count:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_stratum_component_to_json(
  measurereport_group_stratifier_stratum_component: MeasurereportGroupStratifierStratumComponent,
) -> Json {
  let MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum_component
  let fields = [
    #(
      "value",
      measurereport_group_stratifier_stratum_component_value_to_json(value),
    ),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_component_decoder() -> Decoder(
  MeasurereportGroupStratifierStratumComponent,
) {
  use value <- decode.then(
    measurereport_group_stratifier_stratum_component_value_decoder(),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratumComponent(
    value:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_stratum_to_json(
  measurereport_group_stratifier_stratum: MeasurereportGroupStratifierStratum,
) -> Json {
  let MeasurereportGroupStratifierStratum(
    measure_score:,
    population:,
    component:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier_stratum
  let fields = []
  let fields = case measure_score {
    Some(v) -> [
      #(
        "measureScore"
          <> case v {
          MeasurereportGroupStratifierStratumMeasurescoreQuantity(_) ->
            "Quantity"
          MeasurereportGroupStratifierStratumMeasurescoreDatetime(_) ->
            "Datetime"
          MeasurereportGroupStratifierStratumMeasurescoreCodeableconcept(_) ->
            "Codeableconcept"
          MeasurereportGroupStratifierStratumMeasurescorePeriod(_) -> "Period"
          MeasurereportGroupStratifierStratumMeasurescoreRange(_) -> "Range"
          MeasurereportGroupStratifierStratumMeasurescoreDuration(_) ->
            "Duration"
        },
        measurereport_group_stratifier_stratum_measurescore_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #(
        "population",
        json.array(
          population,
          measurereport_group_stratifier_stratum_population_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(
          component,
          measurereport_group_stratifier_stratum_component_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MeasurereportGroupStratifierStratumValueCodeableconcept(_) ->
            "Codeableconcept"
          MeasurereportGroupStratifierStratumValueBoolean(_) -> "Boolean"
          MeasurereportGroupStratifierStratumValueQuantity(_) -> "Quantity"
          MeasurereportGroupStratifierStratumValueRange(_) -> "Range"
          MeasurereportGroupStratifierStratumValueReference(_) -> "Reference"
        },
        measurereport_group_stratifier_stratum_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_stratum_decoder() -> Decoder(
  MeasurereportGroupStratifierStratum,
) {
  use measure_score <- decode.then(
    none_if_omitted(
      measurereport_group_stratifier_stratum_measurescore_decoder(),
    ),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measurereport_group_stratifier_stratum_population_decoder()),
  )
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(measurereport_group_stratifier_stratum_component_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(measurereport_group_stratifier_stratum_value_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifierStratum(
    measure_score:,
    population:,
    component:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_stratifier_to_json(
  measurereport_group_stratifier: MeasurereportGroupStratifier,
) -> Json {
  let MeasurereportGroupStratifier(
    stratum:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_stratifier
  let fields = []
  let fields = case stratum {
    [] -> fields
    _ -> [
      #(
        "stratum",
        json.array(stratum, measurereport_group_stratifier_stratum_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_stratifier_decoder() -> Decoder(
  MeasurereportGroupStratifier,
) {
  use stratum <- decode.optional_field(
    "stratum",
    [],
    decode.list(measurereport_group_stratifier_stratum_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupStratifier(
    stratum:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_population_to_json(
  measurereport_group_population: MeasurereportGroupPopulation,
) -> Json {
  let MeasurereportGroupPopulation(
    subjects:,
    subject_report:,
    subject_results:,
    count:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group_population
  let fields = []
  let fields = case subjects {
    Some(v) -> [#("subjects", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject_report {
    [] -> fields
    _ -> [
      #("subjectReport", json.array(subject_report, reference_to_json)),
      ..fields
    ]
  }
  let fields = case subject_results {
    Some(v) -> [#("subjectResults", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case count {
    Some(v) -> [#("count", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_population_decoder() -> Decoder(
  MeasurereportGroupPopulation,
) {
  use subjects <- decode.optional_field(
    "subjects",
    None,
    decode.optional(reference_decoder()),
  )
  use subject_report <- decode.optional_field(
    "subjectReport",
    [],
    decode.list(reference_decoder()),
  )
  use subject_results <- decode.optional_field(
    "subjectResults",
    None,
    decode.optional(reference_decoder()),
  )
  use count <- decode.optional_field("count", None, decode.optional(decode.int))
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroupPopulation(
    subjects:,
    subject_report:,
    subject_results:,
    count:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_group_to_json(
  measurereport_group: MeasurereportGroup,
) -> Json {
  let MeasurereportGroup(
    stratifier:,
    measure_score:,
    population:,
    subject:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = measurereport_group
  let fields = []
  let fields = case stratifier {
    [] -> fields
    _ -> [
      #(
        "stratifier",
        json.array(stratifier, measurereport_group_stratifier_to_json),
      ),
      ..fields
    ]
  }
  let fields = case measure_score {
    Some(v) -> [
      #(
        "measureScore"
          <> case v {
          MeasurereportGroupMeasurescoreQuantity(_) -> "Quantity"
          MeasurereportGroupMeasurescoreDatetime(_) -> "Datetime"
          MeasurereportGroupMeasurescoreCodeableconcept(_) -> "Codeableconcept"
          MeasurereportGroupMeasurescorePeriod(_) -> "Period"
          MeasurereportGroupMeasurescoreRange(_) -> "Range"
          MeasurereportGroupMeasurescoreDuration(_) -> "Duration"
        },
        measurereport_group_measurescore_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case population {
    [] -> fields
    _ -> [
      #(
        "population",
        json.array(population, measurereport_group_population_to_json),
      ),
      ..fields
    ]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn measurereport_group_decoder() -> Decoder(MeasurereportGroup) {
  use stratifier <- decode.optional_field(
    "stratifier",
    [],
    decode.list(measurereport_group_stratifier_decoder()),
  )
  use measure_score <- decode.then(
    none_if_omitted(measurereport_group_measurescore_decoder()),
  )
  use population <- decode.optional_field(
    "population",
    [],
    decode.list(measurereport_group_population_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MeasurereportGroup(
    stratifier:,
    measure_score:,
    population:,
    subject:,
    code:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn measurereport_to_json(measurereport: Measurereport) -> Json {
  let Measurereport(
    evaluated_resource:,
    supplemental_data:,
    group:,
    improvement_notation:,
    scoring:,
    input_parameters:,
    period:,
    location:,
    reporting_vendor:,
    reporter:,
    date:,
    subject:,
    measure:,
    data_update_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = measurereport
  let fields = [
    #("period", period_to_json(period)),
    #("type", r5valuesets.measurereporttype_to_json(type_)),
    #("status", r5valuesets.measurereportstatus_to_json(status)),
  ]
  let fields = case evaluated_resource {
    [] -> fields
    _ -> [
      #("evaluatedResource", json.array(evaluated_resource, reference_to_json)),
      ..fields
    ]
  }
  let fields = case supplemental_data {
    [] -> fields
    _ -> [
      #("supplementalData", json.array(supplemental_data, reference_to_json)),
      ..fields
    ]
  }
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, measurereport_group_to_json)), ..fields]
  }
  let fields = case improvement_notation {
    Some(v) -> [#("improvementNotation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case scoring {
    Some(v) -> [#("scoring", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case input_parameters {
    Some(v) -> [#("inputParameters", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reporting_vendor {
    Some(v) -> [#("reportingVendor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reporter {
    Some(v) -> [#("reporter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case measure {
    Some(v) -> [#("measure", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case data_update_type {
    Some(v) -> [
      #("dataUpdateType", r5valuesets.submitdataupdatetype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Measurereport")), ..fields]
  json.object(fields)
}

pub fn measurereport_decoder() -> Decoder(Measurereport) {
  use evaluated_resource <- decode.optional_field(
    "evaluatedResource",
    [],
    decode.list(reference_decoder()),
  )
  use supplemental_data <- decode.optional_field(
    "supplementalData",
    [],
    decode.list(reference_decoder()),
  )
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(measurereport_group_decoder()),
  )
  use improvement_notation <- decode.optional_field(
    "improvementNotation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use scoring <- decode.optional_field(
    "scoring",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use input_parameters <- decode.optional_field(
    "inputParameters",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.field("period", period_decoder())
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use reporting_vendor <- decode.optional_field(
    "reportingVendor",
    None,
    decode.optional(reference_decoder()),
  )
  use reporter <- decode.optional_field(
    "reporter",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use measure <- decode.optional_field(
    "measure",
    None,
    decode.optional(decode.string),
  )
  use data_update_type <- decode.optional_field(
    "dataUpdateType",
    None,
    decode.optional(r5valuesets.submitdataupdatetype_decoder()),
  )
  use type_ <- decode.field("type", r5valuesets.measurereporttype_decoder())
  use status <- decode.field(
    "status",
    r5valuesets.measurereportstatus_decoder(),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Measurereport",
    decode.failure(measurereport_new(period:, type_:, status:), "resourceType"),
  )
  decode.success(Measurereport(
    evaluated_resource:,
    supplemental_data:,
    group:,
    improvement_notation:,
    scoring:,
    input_parameters:,
    period:,
    location:,
    reporting_vendor:,
    reporter:,
    date:,
    subject:,
    measure:,
    data_update_type:,
    type_:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Medication#resource
pub type Medication {
  Medication(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Option(Codeableconcept),
    status: Option(r5valuesets.Medicationstatus),
    marketing_authorization_holder: Option(Reference),
    dose_form: Option(Codeableconcept),
    total_volume: Option(Quantity),
    ingredient: List(MedicationIngredient),
    batch: Option(MedicationBatch),
    definition: Option(Reference),
  )
}

pub fn medication_new() -> Medication {
  Medication(
    definition: None,
    batch: None,
    ingredient: [],
    total_volume: None,
    dose_form: None,
    marketing_authorization_holder: None,
    status: None,
    code: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Medication#resource
pub type MedicationIngredient {
  MedicationIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    is_active: Option(Bool),
    strength: Option(MedicationIngredientStrength),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Medication#resource
pub type MedicationIngredientStrength {
  MedicationIngredientStrengthRatio(strength: Ratio)
  MedicationIngredientStrengthCodeableconcept(strength: Codeableconcept)
  MedicationIngredientStrengthQuantity(strength: Quantity)
}

pub fn medication_ingredient_strength_to_json(
  elt: MedicationIngredientStrength,
) -> Json {
  case elt {
    MedicationIngredientStrengthRatio(v) -> ratio_to_json(v)
    MedicationIngredientStrengthCodeableconcept(v) -> codeableconcept_to_json(v)
    MedicationIngredientStrengthQuantity(v) -> quantity_to_json(v)
  }
}

pub fn medication_ingredient_strength_decoder() -> Decoder(
  MedicationIngredientStrength,
) {
  decode.one_of(
    decode.field("strengthRatio", ratio_decoder(), decode.success)
      |> decode.map(MedicationIngredientStrengthRatio),
    [
      decode.field(
        "strengthCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(MedicationIngredientStrengthCodeableconcept),
      decode.field("strengthQuantity", quantity_decoder(), decode.success)
        |> decode.map(MedicationIngredientStrengthQuantity),
    ],
  )
}

pub fn medication_ingredient_new(
  item item: Codeablereference,
) -> MedicationIngredient {
  MedicationIngredient(
    strength: None,
    is_active: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Medication#resource
pub type MedicationBatch {
  MedicationBatch(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    lot_number: Option(String),
    expiration_date: Option(String),
  )
}

pub fn medication_batch_new() -> MedicationBatch {
  MedicationBatch(
    expiration_date: None,
    lot_number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medication_batch_to_json(medication_batch: MedicationBatch) -> Json {
  let MedicationBatch(
    expiration_date:,
    lot_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = medication_batch
  let fields = []
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medication_batch_decoder() -> Decoder(MedicationBatch) {
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationBatch(
    expiration_date:,
    lot_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medication_ingredient_to_json(
  medication_ingredient: MedicationIngredient,
) -> Json {
  let MedicationIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = medication_ingredient
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case strength {
    Some(v) -> [
      #(
        "strength"
          <> case v {
          MedicationIngredientStrengthRatio(_) -> "Ratio"
          MedicationIngredientStrengthCodeableconcept(_) -> "Codeableconcept"
          MedicationIngredientStrengthQuantity(_) -> "Quantity"
        },
        medication_ingredient_strength_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case is_active {
    Some(v) -> [#("isActive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medication_ingredient_decoder() -> Decoder(MedicationIngredient) {
  use strength <- decode.then(
    none_if_omitted(medication_ingredient_strength_decoder()),
  )
  use is_active <- decode.optional_field(
    "isActive",
    None,
    decode.optional(decode.bool),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationIngredient(
    strength:,
    is_active:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medication_to_json(medication: Medication) -> Json {
  let Medication(
    definition:,
    batch:,
    ingredient:,
    total_volume:,
    dose_form:,
    marketing_authorization_holder:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medication
  let fields = []
  let fields = case definition {
    Some(v) -> [#("definition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case batch {
    Some(v) -> [#("batch", medication_batch_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, medication_ingredient_to_json)),
      ..fields
    ]
  }
  let fields = case total_volume {
    Some(v) -> [#("totalVolume", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dose_form {
    Some(v) -> [#("doseForm", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case marketing_authorization_holder {
    Some(v) -> [
      #("marketingAuthorizationHolder", reference_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.medicationstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medication")), ..fields]
  json.object(fields)
}

pub fn medication_decoder() -> Decoder(Medication) {
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(reference_decoder()),
  )
  use batch <- decode.optional_field(
    "batch",
    None,
    decode.optional(medication_batch_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(medication_ingredient_decoder()),
  )
  use total_volume <- decode.optional_field(
    "totalVolume",
    None,
    decode.optional(quantity_decoder()),
  )
  use dose_form <- decode.optional_field(
    "doseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use marketing_authorization_holder <- decode.optional_field(
    "marketingAuthorizationHolder",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.medicationstatus_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medication",
    decode.failure(medication_new(), "resourceType"),
  )
  decode.success(Medication(
    definition:,
    batch:,
    ingredient:,
    total_volume:,
    dose_form:,
    marketing_authorization_holder:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationAdministration#resource
pub type Medicationadministration {
  Medicationadministration(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Medicationadminstatus,
    status_reason: List(Codeableconcept),
    category: List(Codeableconcept),
    medication: Codeablereference,
    subject: Reference,
    encounter: Option(Reference),
    supporting_information: List(Reference),
    occurence: MedicationadministrationOccurence,
    recorded: Option(String),
    is_sub_potent: Option(Bool),
    sub_potent_reason: List(Codeableconcept),
    performer: List(MedicationadministrationPerformer),
    reason: List(Codeablereference),
    request: Option(Reference),
    device: List(Codeablereference),
    note: List(Annotation),
    dosage: Option(MedicationadministrationDosage),
    event_history: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationOccurence {
  MedicationadministrationOccurenceDatetime(occurence: String)
  MedicationadministrationOccurencePeriod(occurence: Period)
  MedicationadministrationOccurenceTiming(occurence: Timing)
}

pub fn medicationadministration_occurence_to_json(
  elt: MedicationadministrationOccurence,
) -> Json {
  case elt {
    MedicationadministrationOccurenceDatetime(v) -> json.string(v)
    MedicationadministrationOccurencePeriod(v) -> period_to_json(v)
    MedicationadministrationOccurenceTiming(v) -> timing_to_json(v)
  }
}

pub fn medicationadministration_occurence_decoder() -> Decoder(
  MedicationadministrationOccurence,
) {
  decode.one_of(
    decode.field("occurenceDateTime", decode.string, decode.success)
      |> decode.map(MedicationadministrationOccurenceDatetime),
    [
      decode.field("occurencePeriod", period_decoder(), decode.success)
        |> decode.map(MedicationadministrationOccurencePeriod),
      decode.field("occurenceTiming", timing_decoder(), decode.success)
        |> decode.map(MedicationadministrationOccurenceTiming),
    ],
  )
}

pub fn medicationadministration_new(
  occurence occurence: MedicationadministrationOccurence,
  subject subject: Reference,
  medication medication: Codeablereference,
  status status: r5valuesets.Medicationadminstatus,
) -> Medicationadministration {
  Medicationadministration(
    event_history: [],
    dosage: None,
    note: [],
    device: [],
    request: None,
    reason: [],
    performer: [],
    sub_potent_reason: [],
    is_sub_potent: None,
    recorded: None,
    occurence:,
    supporting_information: [],
    encounter: None,
    subject:,
    medication:,
    category: [],
    status_reason: [],
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationPerformer {
  MedicationadministrationPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Codeablereference,
  )
}

pub fn medicationadministration_performer_new(
  actor actor: Codeablereference,
) -> MedicationadministrationPerformer {
  MedicationadministrationPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosage {
  MedicationadministrationDosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    text: Option(String),
    site: Option(Codeableconcept),
    route: Option(Codeableconcept),
    method: Option(Codeableconcept),
    dose: Option(Quantity),
    rate: Option(MedicationadministrationDosageRate),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationAdministration#resource
pub type MedicationadministrationDosageRate {
  MedicationadministrationDosageRateRatio(rate: Ratio)
  MedicationadministrationDosageRateQuantity(rate: Quantity)
}

pub fn medicationadministration_dosage_rate_to_json(
  elt: MedicationadministrationDosageRate,
) -> Json {
  case elt {
    MedicationadministrationDosageRateRatio(v) -> ratio_to_json(v)
    MedicationadministrationDosageRateQuantity(v) -> quantity_to_json(v)
  }
}

pub fn medicationadministration_dosage_rate_decoder() -> Decoder(
  MedicationadministrationDosageRate,
) {
  decode.one_of(
    decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(MedicationadministrationDosageRateRatio),
    [
      decode.field("rateQuantity", quantity_decoder(), decode.success)
      |> decode.map(MedicationadministrationDosageRateQuantity),
    ],
  )
}

pub fn medicationadministration_dosage_new() -> MedicationadministrationDosage {
  MedicationadministrationDosage(
    rate: None,
    dose: None,
    method: None,
    route: None,
    site: None,
    text: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationadministration_dosage_to_json(
  medicationadministration_dosage: MedicationadministrationDosage,
) -> Json {
  let MedicationadministrationDosage(
    rate:,
    dose:,
    method:,
    route:,
    site:,
    text:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationadministration_dosage
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          MedicationadministrationDosageRateRatio(_) -> "Ratio"
          MedicationadministrationDosageRateQuantity(_) -> "Quantity"
        },
        medicationadministration_dosage_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case dose {
    Some(v) -> [#("dose", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    Some(v) -> [#("route", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case site {
    Some(v) -> [#("site", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationadministration_dosage_decoder() -> Decoder(
  MedicationadministrationDosage,
) {
  use rate <- decode.then(
    none_if_omitted(medicationadministration_dosage_rate_decoder()),
  )
  use dose <- decode.optional_field(
    "dose",
    None,
    decode.optional(quantity_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use route <- decode.optional_field(
    "route",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationadministrationDosage(
    rate:,
    dose:,
    method:,
    route:,
    site:,
    text:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationadministration_performer_to_json(
  medicationadministration_performer: MedicationadministrationPerformer,
) -> Json {
  let MedicationadministrationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationadministration_performer
  let fields = [
    #("actor", codeablereference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationadministration_performer_decoder() -> Decoder(
  MedicationadministrationPerformer,
) {
  use actor <- decode.field("actor", codeablereference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationadministrationPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationadministration_to_json(
  medicationadministration: Medicationadministration,
) -> Json {
  let Medicationadministration(
    event_history:,
    dosage:,
    note:,
    device:,
    request:,
    reason:,
    performer:,
    sub_potent_reason:,
    is_sub_potent:,
    recorded:,
    occurence:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationadministration
  let fields = [
    #("occurence", medicationadministration_occurence_to_json(occurence)),
    #("subject", reference_to_json(subject)),
    #("medication", codeablereference_to_json(medication)),
    #("status", r5valuesets.medicationadminstatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case dosage {
    Some(v) -> [
      #("dosage", medicationadministration_dosage_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, codeablereference_to_json)), ..fields]
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, medicationadministration_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case sub_potent_reason {
    [] -> fields
    _ -> [
      #(
        "subPotentReason",
        json.array(sub_potent_reason, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case is_sub_potent {
    Some(v) -> [#("isSubPotent", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Medicationadministration")),
    ..fields
  ]
  json.object(fields)
}

pub fn medicationadministration_decoder() -> Decoder(Medicationadministration) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    None,
    decode.optional(medicationadministration_dosage_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(codeablereference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(medicationadministration_performer_decoder()),
  )
  use sub_potent_reason <- decode.optional_field(
    "subPotentReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use is_sub_potent <- decode.optional_field(
    "isSubPotent",
    None,
    decode.optional(decode.bool),
  )
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use occurence <- decode.then(medicationadministration_occurence_decoder())
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.field("medication", codeablereference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.medicationadminstatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationadministration",
    decode.failure(
      medicationadministration_new(occurence:, subject:, medication:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationadministration(
    event_history:,
    dosage:,
    note:,
    device:,
    request:,
    reason:,
    performer:,
    sub_potent_reason:,
    is_sub_potent:,
    recorded:,
    occurence:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationDispense#resource
pub type Medicationdispense {
  Medicationdispense(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Medicationdispensestatus,
    not_performed_reason: Option(Codeablereference),
    status_changed: Option(String),
    category: List(Codeableconcept),
    medication: Codeablereference,
    subject: Reference,
    encounter: Option(Reference),
    supporting_information: List(Reference),
    performer: List(MedicationdispensePerformer),
    location: Option(Reference),
    authorizing_prescription: List(Reference),
    type_: Option(Codeableconcept),
    quantity: Option(Quantity),
    days_supply: Option(Quantity),
    recorded: Option(String),
    when_prepared: Option(String),
    when_handed_over: Option(String),
    destination: Option(Reference),
    receiver: List(Reference),
    note: List(Annotation),
    rendered_dosage_instruction: Option(String),
    dosage_instruction: List(Dosage),
    substitution: Option(MedicationdispenseSubstitution),
    event_history: List(Reference),
  )
}

pub fn medicationdispense_new(
  subject subject: Reference,
  medication medication: Codeablereference,
  status status: r5valuesets.Medicationdispensestatus,
) -> Medicationdispense {
  Medicationdispense(
    event_history: [],
    substitution: None,
    dosage_instruction: [],
    rendered_dosage_instruction: None,
    note: [],
    receiver: [],
    destination: None,
    when_handed_over: None,
    when_prepared: None,
    recorded: None,
    days_supply: None,
    quantity: None,
    type_: None,
    authorizing_prescription: [],
    location: None,
    performer: [],
    supporting_information: [],
    encounter: None,
    subject:,
    medication:,
    category: [],
    status_changed: None,
    not_performed_reason: None,
    status:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationDispense#resource
pub type MedicationdispensePerformer {
  MedicationdispensePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn medicationdispense_performer_new(
  actor actor: Reference,
) -> MedicationdispensePerformer {
  MedicationdispensePerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationDispense#resource
pub type MedicationdispenseSubstitution {
  MedicationdispenseSubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    was_substituted: Bool,
    type_: Option(Codeableconcept),
    reason: List(Codeableconcept),
    responsible_party: Option(Reference),
  )
}

pub fn medicationdispense_substitution_new(
  was_substituted was_substituted: Bool,
) -> MedicationdispenseSubstitution {
  MedicationdispenseSubstitution(
    responsible_party: None,
    reason: [],
    type_: None,
    was_substituted:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationdispense_substitution_to_json(
  medicationdispense_substitution: MedicationdispenseSubstitution,
) -> Json {
  let MedicationdispenseSubstitution(
    responsible_party:,
    reason:,
    type_:,
    was_substituted:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationdispense_substitution
  let fields = [
    #("wasSubstituted", json.bool(was_substituted)),
  ]
  let fields = case responsible_party {
    Some(v) -> [#("responsibleParty", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationdispense_substitution_decoder() -> Decoder(
  MedicationdispenseSubstitution,
) {
  use responsible_party <- decode.optional_field(
    "responsibleParty",
    None,
    decode.optional(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use was_substituted <- decode.field("wasSubstituted", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationdispenseSubstitution(
    responsible_party:,
    reason:,
    type_:,
    was_substituted:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationdispense_performer_to_json(
  medicationdispense_performer: MedicationdispensePerformer,
) -> Json {
  let MedicationdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationdispense_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationdispense_performer_decoder() -> Decoder(
  MedicationdispensePerformer,
) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationdispensePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationdispense_to_json(
  medicationdispense: Medicationdispense,
) -> Json {
  let Medicationdispense(
    event_history:,
    substitution:,
    dosage_instruction:,
    rendered_dosage_instruction:,
    note:,
    receiver:,
    destination:,
    when_handed_over:,
    when_prepared:,
    recorded:,
    days_supply:,
    quantity:,
    type_:,
    authorizing_prescription:,
    location:,
    performer:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    category:,
    status_changed:,
    not_performed_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationdispense
  let fields = [
    #("subject", reference_to_json(subject)),
    #("medication", codeablereference_to_json(medication)),
    #("status", r5valuesets.medicationdispensestatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case substitution {
    Some(v) -> [
      #("substitution", medicationdispense_substitution_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage_instruction {
    [] -> fields
    _ -> [
      #("dosageInstruction", json.array(dosage_instruction, dosage_to_json)),
      ..fields
    ]
  }
  let fields = case rendered_dosage_instruction {
    Some(v) -> [#("renderedDosageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case receiver {
    [] -> fields
    _ -> [#("receiver", json.array(receiver, reference_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case when_handed_over {
    Some(v) -> [#("whenHandedOver", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case when_prepared {
    Some(v) -> [#("whenPrepared", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case days_supply {
    Some(v) -> [#("daysSupply", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authorizing_prescription {
    [] -> fields
    _ -> [
      #(
        "authorizingPrescription",
        json.array(authorizing_prescription, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #(
        "performer",
        json.array(performer, medicationdispense_performer_to_json),
      ),
      ..fields
    ]
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_changed {
    Some(v) -> [#("statusChanged", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case not_performed_reason {
    Some(v) -> [#("notPerformedReason", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationdispense")), ..fields]
  json.object(fields)
}

pub fn medicationdispense_decoder() -> Decoder(Medicationdispense) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    None,
    decode.optional(medicationdispense_substitution_decoder()),
  )
  use dosage_instruction <- decode.optional_field(
    "dosageInstruction",
    [],
    decode.list(dosage_decoder()),
  )
  use rendered_dosage_instruction <- decode.optional_field(
    "renderedDosageInstruction",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use receiver <- decode.optional_field(
    "receiver",
    [],
    decode.list(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use when_handed_over <- decode.optional_field(
    "whenHandedOver",
    None,
    decode.optional(decode.string),
  )
  use when_prepared <- decode.optional_field(
    "whenPrepared",
    None,
    decode.optional(decode.string),
  )
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use days_supply <- decode.optional_field(
    "daysSupply",
    None,
    decode.optional(quantity_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use authorizing_prescription <- decode.optional_field(
    "authorizingPrescription",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(medicationdispense_performer_decoder()),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.field("medication", codeablereference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_changed <- decode.optional_field(
    "statusChanged",
    None,
    decode.optional(decode.string),
  )
  use not_performed_reason <- decode.optional_field(
    "notPerformedReason",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.medicationdispensestatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationdispense",
    decode.failure(
      medicationdispense_new(subject:, medication:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationdispense(
    event_history:,
    substitution:,
    dosage_instruction:,
    rendered_dosage_instruction:,
    note:,
    receiver:,
    destination:,
    when_handed_over:,
    when_prepared:,
    recorded:,
    days_supply:,
    quantity:,
    type_:,
    authorizing_prescription:,
    location:,
    performer:,
    supporting_information:,
    encounter:,
    subject:,
    medication:,
    category:,
    status_changed:,
    not_performed_reason:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type Medicationknowledge {
  Medicationknowledge(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Option(Codeableconcept),
    status: Option(r5valuesets.Medicationknowledgestatus),
    author: Option(Reference),
    intended_jurisdiction: List(Codeableconcept),
    name: List(String),
    related_medication_knowledge: List(
      MedicationknowledgeRelatedmedicationknowledge,
    ),
    associated_medication: List(Reference),
    product_type: List(Codeableconcept),
    monograph: List(MedicationknowledgeMonograph),
    preparation_instruction: Option(String),
    cost: List(MedicationknowledgeCost),
    monitoring_program: List(MedicationknowledgeMonitoringprogram),
    indication_guideline: List(MedicationknowledgeIndicationguideline),
    medicine_classification: List(MedicationknowledgeMedicineclassification),
    packaging: List(MedicationknowledgePackaging),
    clinical_use_issue: List(Reference),
    storage_guideline: List(MedicationknowledgeStorageguideline),
    regulatory: List(MedicationknowledgeRegulatory),
    definitional: Option(MedicationknowledgeDefinitional),
  )
}

pub fn medicationknowledge_new() -> Medicationknowledge {
  Medicationknowledge(
    definitional: None,
    regulatory: [],
    storage_guideline: [],
    clinical_use_issue: [],
    packaging: [],
    medicine_classification: [],
    indication_guideline: [],
    monitoring_program: [],
    cost: [],
    preparation_instruction: None,
    monograph: [],
    product_type: [],
    associated_medication: [],
    related_medication_knowledge: [],
    name: [],
    intended_jurisdiction: [],
    author: None,
    status: None,
    code: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRelatedmedicationknowledge {
  MedicationknowledgeRelatedmedicationknowledge(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    reference: List(Reference),
  )
}

pub fn medicationknowledge_relatedmedicationknowledge_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeRelatedmedicationknowledge {
  MedicationknowledgeRelatedmedicationknowledge(
    reference: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonograph {
  MedicationknowledgeMonograph(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    source: Option(Reference),
  )
}

pub fn medicationknowledge_monograph_new() -> MedicationknowledgeMonograph {
  MedicationknowledgeMonograph(
    source: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeCost {
  MedicationknowledgeCost(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    effective_date: List(Period),
    type_: Codeableconcept,
    source: Option(String),
    cost: MedicationknowledgeCostCost,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeCostCost {
  MedicationknowledgeCostCostMoney(cost: Money)
  MedicationknowledgeCostCostCodeableconcept(cost: Codeableconcept)
}

pub fn medicationknowledge_cost_cost_to_json(
  elt: MedicationknowledgeCostCost,
) -> Json {
  case elt {
    MedicationknowledgeCostCostMoney(v) -> money_to_json(v)
    MedicationknowledgeCostCostCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn medicationknowledge_cost_cost_decoder() -> Decoder(
  MedicationknowledgeCostCost,
) {
  decode.one_of(
    decode.field("costMoney", money_decoder(), decode.success)
      |> decode.map(MedicationknowledgeCostCostMoney),
    [
      decode.field(
        "costCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(MedicationknowledgeCostCostCodeableconcept),
    ],
  )
}

pub fn medicationknowledge_cost_new(
  cost cost: MedicationknowledgeCostCost,
  type_ type_: Codeableconcept,
) -> MedicationknowledgeCost {
  MedicationknowledgeCost(
    cost:,
    source: None,
    type_:,
    effective_date: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMonitoringprogram {
  MedicationknowledgeMonitoringprogram(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    name: Option(String),
  )
}

pub fn medicationknowledge_monitoringprogram_new() -> MedicationknowledgeMonitoringprogram {
  MedicationknowledgeMonitoringprogram(
    name: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIndicationguideline {
  MedicationknowledgeIndicationguideline(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    indication: List(Codeablereference),
    dosing_guideline: List(
      MedicationknowledgeIndicationguidelineDosingguideline,
    ),
  )
}

pub fn medicationknowledge_indicationguideline_new() -> MedicationknowledgeIndicationguideline {
  MedicationknowledgeIndicationguideline(
    dosing_guideline: [],
    indication: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIndicationguidelineDosingguideline {
  MedicationknowledgeIndicationguidelineDosingguideline(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    treatment_intent: Option(Codeableconcept),
    dosage: List(MedicationknowledgeIndicationguidelineDosingguidelineDosage),
    administration_treatment: Option(Codeableconcept),
    patient_characteristic: List(
      MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic,
    ),
  )
}

pub fn medicationknowledge_indicationguideline_dosingguideline_new() -> MedicationknowledgeIndicationguidelineDosingguideline {
  MedicationknowledgeIndicationguidelineDosingguideline(
    patient_characteristic: [],
    administration_treatment: None,
    dosage: [],
    treatment_intent: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIndicationguidelineDosingguidelineDosage {
  MedicationknowledgeIndicationguidelineDosingguidelineDosage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    dosage: List(Dosage),
  )
}

pub fn medicationknowledge_indicationguideline_dosingguideline_dosage_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeIndicationguidelineDosingguidelineDosage {
  MedicationknowledgeIndicationguidelineDosingguidelineDosage(
    dosage: [],
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic {
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(
      MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValue,
    ),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValue {
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueQuantity(
    value: Quantity,
  )
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueRange(
    value: Range,
  )
}

pub fn medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_value_to_json(
  elt: MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValue,
) -> Json {
  case elt {
    MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueCodeableconcept(
      v,
    ) -> codeableconcept_to_json(v)
    MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueQuantity(
      v,
    ) -> quantity_to_json(v)
    MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueRange(
      v,
    ) -> range_to_json(v)
  }
}

pub fn medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_value_decoder() -> Decoder(
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueCodeableconcept,
      ),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(
          MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueQuantity,
        ),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(
          MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueRange,
        ),
    ],
  )
}

pub fn medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic {
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMedicineclassification {
  MedicationknowledgeMedicineclassification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    source: Option(MedicationknowledgeMedicineclassificationSource),
    classification: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeMedicineclassificationSource {
  MedicationknowledgeMedicineclassificationSourceString(source: String)
  MedicationknowledgeMedicineclassificationSourceUri(source: String)
}

pub fn medicationknowledge_medicineclassification_source_to_json(
  elt: MedicationknowledgeMedicineclassificationSource,
) -> Json {
  case elt {
    MedicationknowledgeMedicineclassificationSourceString(v) -> json.string(v)
    MedicationknowledgeMedicineclassificationSourceUri(v) -> json.string(v)
  }
}

pub fn medicationknowledge_medicineclassification_source_decoder() -> Decoder(
  MedicationknowledgeMedicineclassificationSource,
) {
  decode.one_of(
    decode.field("sourceString", decode.string, decode.success)
      |> decode.map(MedicationknowledgeMedicineclassificationSourceString),
    [
      decode.field("sourceUri", decode.string, decode.success)
      |> decode.map(MedicationknowledgeMedicineclassificationSourceUri),
    ],
  )
}

pub fn medicationknowledge_medicineclassification_new(
  type_ type_: Codeableconcept,
) -> MedicationknowledgeMedicineclassification {
  MedicationknowledgeMedicineclassification(
    classification: [],
    source: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgePackaging {
  MedicationknowledgePackaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    packaged_product: Option(Reference),
  )
}

pub fn medicationknowledge_packaging_new() -> MedicationknowledgePackaging {
  MedicationknowledgePackaging(
    packaged_product: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeStorageguideline {
  MedicationknowledgeStorageguideline(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    reference: Option(String),
    note: List(Annotation),
    stability_duration: Option(Duration),
    environmental_setting: List(
      MedicationknowledgeStorageguidelineEnvironmentalsetting,
    ),
  )
}

pub fn medicationknowledge_storageguideline_new() -> MedicationknowledgeStorageguideline {
  MedicationknowledgeStorageguideline(
    environmental_setting: [],
    stability_duration: None,
    note: [],
    reference: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeStorageguidelineEnvironmentalsetting {
  MedicationknowledgeStorageguidelineEnvironmentalsetting(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: MedicationknowledgeStorageguidelineEnvironmentalsettingValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeStorageguidelineEnvironmentalsettingValue {
  MedicationknowledgeStorageguidelineEnvironmentalsettingValueQuantity(
    value: Quantity,
  )
  MedicationknowledgeStorageguidelineEnvironmentalsettingValueRange(
    value: Range,
  )
  MedicationknowledgeStorageguidelineEnvironmentalsettingValueCodeableconcept(
    value: Codeableconcept,
  )
}

pub fn medicationknowledge_storageguideline_environmentalsetting_value_to_json(
  elt: MedicationknowledgeStorageguidelineEnvironmentalsettingValue,
) -> Json {
  case elt {
    MedicationknowledgeStorageguidelineEnvironmentalsettingValueQuantity(v) ->
      quantity_to_json(v)
    MedicationknowledgeStorageguidelineEnvironmentalsettingValueRange(v) ->
      range_to_json(v)
    MedicationknowledgeStorageguidelineEnvironmentalsettingValueCodeableconcept(
      v,
    ) -> codeableconcept_to_json(v)
  }
}

pub fn medicationknowledge_storageguideline_environmentalsetting_value_decoder() -> Decoder(
  MedicationknowledgeStorageguidelineEnvironmentalsettingValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(
        MedicationknowledgeStorageguidelineEnvironmentalsettingValueQuantity,
      ),
    [
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(
          MedicationknowledgeStorageguidelineEnvironmentalsettingValueRange,
        ),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(
          MedicationknowledgeStorageguidelineEnvironmentalsettingValueCodeableconcept,
        ),
    ],
  )
}

pub fn medicationknowledge_storageguideline_environmentalsetting_new(
  value value: MedicationknowledgeStorageguidelineEnvironmentalsettingValue,
  type_ type_: Codeableconcept,
) -> MedicationknowledgeStorageguidelineEnvironmentalsetting {
  MedicationknowledgeStorageguidelineEnvironmentalsetting(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatory {
  MedicationknowledgeRegulatory(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    regulatory_authority: Reference,
    substitution: List(MedicationknowledgeRegulatorySubstitution),
    schedule: List(Codeableconcept),
    max_dispense: Option(MedicationknowledgeRegulatoryMaxdispense),
  )
}

pub fn medicationknowledge_regulatory_new(
  regulatory_authority regulatory_authority: Reference,
) -> MedicationknowledgeRegulatory {
  MedicationknowledgeRegulatory(
    max_dispense: None,
    schedule: [],
    substitution: [],
    regulatory_authority:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatorySubstitution {
  MedicationknowledgeRegulatorySubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    allowed: Bool,
  )
}

pub fn medicationknowledge_regulatory_substitution_new(
  allowed allowed: Bool,
  type_ type_: Codeableconcept,
) -> MedicationknowledgeRegulatorySubstitution {
  MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeRegulatoryMaxdispense {
  MedicationknowledgeRegulatoryMaxdispense(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Quantity,
    period: Option(Duration),
  )
}

pub fn medicationknowledge_regulatory_maxdispense_new(
  quantity quantity: Quantity,
) -> MedicationknowledgeRegulatoryMaxdispense {
  MedicationknowledgeRegulatoryMaxdispense(
    period: None,
    quantity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDefinitional {
  MedicationknowledgeDefinitional(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    definition: List(Reference),
    dose_form: Option(Codeableconcept),
    intended_route: List(Codeableconcept),
    ingredient: List(MedicationknowledgeDefinitionalIngredient),
    drug_characteristic: List(MedicationknowledgeDefinitionalDrugcharacteristic),
  )
}

pub fn medicationknowledge_definitional_new() -> MedicationknowledgeDefinitional {
  MedicationknowledgeDefinitional(
    drug_characteristic: [],
    ingredient: [],
    intended_route: [],
    dose_form: None,
    definition: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDefinitionalIngredient {
  MedicationknowledgeDefinitionalIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    type_: Option(Codeableconcept),
    strength: Option(MedicationknowledgeDefinitionalIngredientStrength),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDefinitionalIngredientStrength {
  MedicationknowledgeDefinitionalIngredientStrengthRatio(strength: Ratio)
  MedicationknowledgeDefinitionalIngredientStrengthCodeableconcept(
    strength: Codeableconcept,
  )
  MedicationknowledgeDefinitionalIngredientStrengthQuantity(strength: Quantity)
}

pub fn medicationknowledge_definitional_ingredient_strength_to_json(
  elt: MedicationknowledgeDefinitionalIngredientStrength,
) -> Json {
  case elt {
    MedicationknowledgeDefinitionalIngredientStrengthRatio(v) ->
      ratio_to_json(v)
    MedicationknowledgeDefinitionalIngredientStrengthCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationknowledgeDefinitionalIngredientStrengthQuantity(v) ->
      quantity_to_json(v)
  }
}

pub fn medicationknowledge_definitional_ingredient_strength_decoder() -> Decoder(
  MedicationknowledgeDefinitionalIngredientStrength,
) {
  decode.one_of(
    decode.field("strengthRatio", ratio_decoder(), decode.success)
      |> decode.map(MedicationknowledgeDefinitionalIngredientStrengthRatio),
    [
      decode.field(
        "strengthCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(
          MedicationknowledgeDefinitionalIngredientStrengthCodeableconcept,
        ),
      decode.field("strengthQuantity", quantity_decoder(), decode.success)
        |> decode.map(MedicationknowledgeDefinitionalIngredientStrengthQuantity),
    ],
  )
}

pub fn medicationknowledge_definitional_ingredient_new(
  item item: Codeablereference,
) -> MedicationknowledgeDefinitionalIngredient {
  MedicationknowledgeDefinitionalIngredient(
    strength: None,
    type_: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDefinitionalDrugcharacteristic {
  MedicationknowledgeDefinitionalDrugcharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: Option(MedicationknowledgeDefinitionalDrugcharacteristicValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationKnowledge#resource
pub type MedicationknowledgeDefinitionalDrugcharacteristicValue {
  MedicationknowledgeDefinitionalDrugcharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  MedicationknowledgeDefinitionalDrugcharacteristicValueString(value: String)
  MedicationknowledgeDefinitionalDrugcharacteristicValueQuantity(
    value: Quantity,
  )
  MedicationknowledgeDefinitionalDrugcharacteristicValueBase64binary(
    value: String,
  )
  MedicationknowledgeDefinitionalDrugcharacteristicValueAttachment(
    value: Attachment,
  )
}

pub fn medicationknowledge_definitional_drugcharacteristic_value_to_json(
  elt: MedicationknowledgeDefinitionalDrugcharacteristicValue,
) -> Json {
  case elt {
    MedicationknowledgeDefinitionalDrugcharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicationknowledgeDefinitionalDrugcharacteristicValueString(v) ->
      json.string(v)
    MedicationknowledgeDefinitionalDrugcharacteristicValueQuantity(v) ->
      quantity_to_json(v)
    MedicationknowledgeDefinitionalDrugcharacteristicValueBase64binary(v) ->
      json.string(v)
    MedicationknowledgeDefinitionalDrugcharacteristicValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn medicationknowledge_definitional_drugcharacteristic_value_decoder() -> Decoder(
  MedicationknowledgeDefinitionalDrugcharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicationknowledgeDefinitionalDrugcharacteristicValueCodeableconcept,
      ),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(
          MedicationknowledgeDefinitionalDrugcharacteristicValueString,
        ),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(
          MedicationknowledgeDefinitionalDrugcharacteristicValueQuantity,
        ),
      decode.field("valueBase64Binary", decode.string, decode.success)
        |> decode.map(
          MedicationknowledgeDefinitionalDrugcharacteristicValueBase64binary,
        ),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(
          MedicationknowledgeDefinitionalDrugcharacteristicValueAttachment,
        ),
    ],
  )
}

pub fn medicationknowledge_definitional_drugcharacteristic_new() -> MedicationknowledgeDefinitionalDrugcharacteristic {
  MedicationknowledgeDefinitionalDrugcharacteristic(
    value: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationknowledge_definitional_drugcharacteristic_to_json(
  medicationknowledge_definitional_drugcharacteristic: MedicationknowledgeDefinitionalDrugcharacteristic,
) -> Json {
  let MedicationknowledgeDefinitionalDrugcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_definitional_drugcharacteristic
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MedicationknowledgeDefinitionalDrugcharacteristicValueCodeableconcept(
            _,
          ) -> "Codeableconcept"
          MedicationknowledgeDefinitionalDrugcharacteristicValueString(_) ->
            "String"
          MedicationknowledgeDefinitionalDrugcharacteristicValueQuantity(_) ->
            "Quantity"
          MedicationknowledgeDefinitionalDrugcharacteristicValueBase64binary(_) ->
            "Base64binary"
          MedicationknowledgeDefinitionalDrugcharacteristicValueAttachment(_) ->
            "Attachment"
        },
        medicationknowledge_definitional_drugcharacteristic_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_definitional_drugcharacteristic_decoder() -> Decoder(
  MedicationknowledgeDefinitionalDrugcharacteristic,
) {
  use value <- decode.then(
    none_if_omitted(
      medicationknowledge_definitional_drugcharacteristic_value_decoder(),
    ),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeDefinitionalDrugcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_definitional_ingredient_to_json(
  medicationknowledge_definitional_ingredient: MedicationknowledgeDefinitionalIngredient,
) -> Json {
  let MedicationknowledgeDefinitionalIngredient(
    strength:,
    type_:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_definitional_ingredient
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case strength {
    Some(v) -> [
      #(
        "strength"
          <> case v {
          MedicationknowledgeDefinitionalIngredientStrengthRatio(_) -> "Ratio"
          MedicationknowledgeDefinitionalIngredientStrengthCodeableconcept(_) ->
            "Codeableconcept"
          MedicationknowledgeDefinitionalIngredientStrengthQuantity(_) ->
            "Quantity"
        },
        medicationknowledge_definitional_ingredient_strength_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_definitional_ingredient_decoder() -> Decoder(
  MedicationknowledgeDefinitionalIngredient,
) {
  use strength <- decode.then(
    none_if_omitted(
      medicationknowledge_definitional_ingredient_strength_decoder(),
    ),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeDefinitionalIngredient(
    strength:,
    type_:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_definitional_to_json(
  medicationknowledge_definitional: MedicationknowledgeDefinitional,
) -> Json {
  let MedicationknowledgeDefinitional(
    drug_characteristic:,
    ingredient:,
    intended_route:,
    dose_form:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_definitional
  let fields = []
  let fields = case drug_characteristic {
    [] -> fields
    _ -> [
      #(
        "drugCharacteristic",
        json.array(
          drug_characteristic,
          medicationknowledge_definitional_drugcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #(
        "ingredient",
        json.array(
          ingredient,
          medicationknowledge_definitional_ingredient_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case intended_route {
    [] -> fields
    _ -> [
      #("intendedRoute", json.array(intended_route, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case dose_form {
    Some(v) -> [#("doseForm", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    [] -> fields
    _ -> [#("definition", json.array(definition, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_definitional_decoder() -> Decoder(
  MedicationknowledgeDefinitional,
) {
  use drug_characteristic <- decode.optional_field(
    "drugCharacteristic",
    [],
    decode.list(medicationknowledge_definitional_drugcharacteristic_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(medicationknowledge_definitional_ingredient_decoder()),
  )
  use intended_route <- decode.optional_field(
    "intendedRoute",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use dose_form <- decode.optional_field(
    "doseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use definition <- decode.optional_field(
    "definition",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeDefinitional(
    drug_characteristic:,
    ingredient:,
    intended_route:,
    dose_form:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_maxdispense_to_json(
  medicationknowledge_regulatory_maxdispense: MedicationknowledgeRegulatoryMaxdispense,
) -> Json {
  let MedicationknowledgeRegulatoryMaxdispense(
    period:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory_maxdispense
  let fields = [
    #("quantity", quantity_to_json(quantity)),
  ]
  let fields = case period {
    Some(v) -> [#("period", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_maxdispense_decoder() -> Decoder(
  MedicationknowledgeRegulatoryMaxdispense,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.field("quantity", quantity_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatoryMaxdispense(
    period:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_substitution_to_json(
  medicationknowledge_regulatory_substitution: MedicationknowledgeRegulatorySubstitution,
) -> Json {
  let MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory_substitution
  let fields = [
    #("allowed", json.bool(allowed)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_substitution_decoder() -> Decoder(
  MedicationknowledgeRegulatorySubstitution,
) {
  use allowed <- decode.field("allowed", decode.bool)
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatorySubstitution(
    allowed:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_regulatory_to_json(
  medicationknowledge_regulatory: MedicationknowledgeRegulatory,
) -> Json {
  let MedicationknowledgeRegulatory(
    max_dispense:,
    schedule:,
    substitution:,
    regulatory_authority:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_regulatory
  let fields = [
    #("regulatoryAuthority", reference_to_json(regulatory_authority)),
  ]
  let fields = case max_dispense {
    Some(v) -> [
      #("maxDispense", medicationknowledge_regulatory_maxdispense_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case schedule {
    [] -> fields
    _ -> [
      #("schedule", json.array(schedule, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case substitution {
    [] -> fields
    _ -> [
      #(
        "substitution",
        json.array(
          substitution,
          medicationknowledge_regulatory_substitution_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_regulatory_decoder() -> Decoder(
  MedicationknowledgeRegulatory,
) {
  use max_dispense <- decode.optional_field(
    "maxDispense",
    None,
    decode.optional(medicationknowledge_regulatory_maxdispense_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    [],
    decode.list(medicationknowledge_regulatory_substitution_decoder()),
  )
  use regulatory_authority <- decode.field(
    "regulatoryAuthority",
    reference_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRegulatory(
    max_dispense:,
    schedule:,
    substitution:,
    regulatory_authority:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_storageguideline_environmentalsetting_to_json(
  medicationknowledge_storageguideline_environmentalsetting: MedicationknowledgeStorageguidelineEnvironmentalsetting,
) -> Json {
  let MedicationknowledgeStorageguidelineEnvironmentalsetting(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_storageguideline_environmentalsetting
  let fields = [
    #(
      "value",
      medicationknowledge_storageguideline_environmentalsetting_value_to_json(
        value,
      ),
    ),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_storageguideline_environmentalsetting_decoder() -> Decoder(
  MedicationknowledgeStorageguidelineEnvironmentalsetting,
) {
  use value <- decode.then(
    medicationknowledge_storageguideline_environmentalsetting_value_decoder(),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeStorageguidelineEnvironmentalsetting(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_storageguideline_to_json(
  medicationknowledge_storageguideline: MedicationknowledgeStorageguideline,
) -> Json {
  let MedicationknowledgeStorageguideline(
    environmental_setting:,
    stability_duration:,
    note:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_storageguideline
  let fields = []
  let fields = case environmental_setting {
    [] -> fields
    _ -> [
      #(
        "environmentalSetting",
        json.array(
          environmental_setting,
          medicationknowledge_storageguideline_environmentalsetting_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case stability_duration {
    Some(v) -> [#("stabilityDuration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reference {
    Some(v) -> [#("reference", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_storageguideline_decoder() -> Decoder(
  MedicationknowledgeStorageguideline,
) {
  use environmental_setting <- decode.optional_field(
    "environmentalSetting",
    [],
    decode.list(
      medicationknowledge_storageguideline_environmentalsetting_decoder(),
    ),
  )
  use stability_duration <- decode.optional_field(
    "stabilityDuration",
    None,
    decode.optional(duration_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeStorageguideline(
    environmental_setting:,
    stability_duration:,
    note:,
    reference:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_packaging_to_json(
  medicationknowledge_packaging: MedicationknowledgePackaging,
) -> Json {
  let MedicationknowledgePackaging(
    packaged_product:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_packaging
  let fields = []
  let fields = case packaged_product {
    Some(v) -> [#("packagedProduct", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_packaging_decoder() -> Decoder(
  MedicationknowledgePackaging,
) {
  use packaged_product <- decode.optional_field(
    "packagedProduct",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgePackaging(
    packaged_product:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_medicineclassification_to_json(
  medicationknowledge_medicineclassification: MedicationknowledgeMedicineclassification,
) -> Json {
  let MedicationknowledgeMedicineclassification(
    classification:,
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_medicineclassification
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          MedicationknowledgeMedicineclassificationSourceString(_) -> "String"
          MedicationknowledgeMedicineclassificationSourceUri(_) -> "Uri"
        },
        medicationknowledge_medicineclassification_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_medicineclassification_decoder() -> Decoder(
  MedicationknowledgeMedicineclassification,
) {
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use source <- decode.then(
    none_if_omitted(medicationknowledge_medicineclassification_source_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMedicineclassification(
    classification:,
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_to_json(
  medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic: MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic,
) -> Json {
  let MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) =
    medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueCodeableconcept(
            _,
          ) -> "Codeableconcept"
          MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueQuantity(
            _,
          ) -> "Quantity"
          MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristicValueRange(
            _,
          ) -> "Range"
        },
        medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_value_to_json(
          v,
        ),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_decoder() -> Decoder(
  MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic,
) {
  use value <- decode.then(
    none_if_omitted(
      medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_value_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(
    MedicationknowledgeIndicationguidelineDosingguidelinePatientcharacteristic(
      value:,
      type_:,
      modifier_extension:,
      extension:,
      id:,
    ),
  )
}

pub fn medicationknowledge_indicationguideline_dosingguideline_dosage_to_json(
  medicationknowledge_indicationguideline_dosingguideline_dosage: MedicationknowledgeIndicationguidelineDosingguidelineDosage,
) -> Json {
  let MedicationknowledgeIndicationguidelineDosingguidelineDosage(
    dosage:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_indicationguideline_dosingguideline_dosage
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_indicationguideline_dosingguideline_dosage_decoder() -> Decoder(
  MedicationknowledgeIndicationguidelineDosingguidelineDosage,
) {
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeIndicationguidelineDosingguidelineDosage(
    dosage:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_indicationguideline_dosingguideline_to_json(
  medicationknowledge_indicationguideline_dosingguideline: MedicationknowledgeIndicationguidelineDosingguideline,
) -> Json {
  let MedicationknowledgeIndicationguidelineDosingguideline(
    patient_characteristic:,
    administration_treatment:,
    dosage:,
    treatment_intent:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_indicationguideline_dosingguideline
  let fields = []
  let fields = case patient_characteristic {
    [] -> fields
    _ -> [
      #(
        "patientCharacteristic",
        json.array(
          patient_characteristic,
          medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case administration_treatment {
    Some(v) -> [
      #("administrationTreatment", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage {
    [] -> fields
    _ -> [
      #(
        "dosage",
        json.array(
          dosage,
          medicationknowledge_indicationguideline_dosingguideline_dosage_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case treatment_intent {
    Some(v) -> [#("treatmentIntent", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_indicationguideline_dosingguideline_decoder() -> Decoder(
  MedicationknowledgeIndicationguidelineDosingguideline,
) {
  use patient_characteristic <- decode.optional_field(
    "patientCharacteristic",
    [],
    decode.list(
      medicationknowledge_indicationguideline_dosingguideline_patientcharacteristic_decoder(),
    ),
  )
  use administration_treatment <- decode.optional_field(
    "administrationTreatment",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(
      medicationknowledge_indicationguideline_dosingguideline_dosage_decoder(),
    ),
  )
  use treatment_intent <- decode.optional_field(
    "treatmentIntent",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeIndicationguidelineDosingguideline(
    patient_characteristic:,
    administration_treatment:,
    dosage:,
    treatment_intent:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_indicationguideline_to_json(
  medicationknowledge_indicationguideline: MedicationknowledgeIndicationguideline,
) -> Json {
  let MedicationknowledgeIndicationguideline(
    dosing_guideline:,
    indication:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_indicationguideline
  let fields = []
  let fields = case dosing_guideline {
    [] -> fields
    _ -> [
      #(
        "dosingGuideline",
        json.array(
          dosing_guideline,
          medicationknowledge_indicationguideline_dosingguideline_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case indication {
    [] -> fields
    _ -> [
      #("indication", json.array(indication, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_indicationguideline_decoder() -> Decoder(
  MedicationknowledgeIndicationguideline,
) {
  use dosing_guideline <- decode.optional_field(
    "dosingGuideline",
    [],
    decode.list(
      medicationknowledge_indicationguideline_dosingguideline_decoder(),
    ),
  )
  use indication <- decode.optional_field(
    "indication",
    [],
    decode.list(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeIndicationguideline(
    dosing_guideline:,
    indication:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_monitoringprogram_to_json(
  medicationknowledge_monitoringprogram: MedicationknowledgeMonitoringprogram,
) -> Json {
  let MedicationknowledgeMonitoringprogram(
    name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_monitoringprogram
  let fields = []
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_monitoringprogram_decoder() -> Decoder(
  MedicationknowledgeMonitoringprogram,
) {
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMonitoringprogram(
    name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_cost_to_json(
  medicationknowledge_cost: MedicationknowledgeCost,
) -> Json {
  let MedicationknowledgeCost(
    cost:,
    source:,
    type_:,
    effective_date:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_cost
  let fields = [
    #("cost", medicationknowledge_cost_cost_to_json(cost)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case source {
    Some(v) -> [#("source", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective_date {
    [] -> fields
    _ -> [
      #("effectiveDate", json.array(effective_date, period_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_cost_decoder() -> Decoder(MedicationknowledgeCost) {
  use cost <- decode.then(medicationknowledge_cost_cost_decoder())
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use effective_date <- decode.optional_field(
    "effectiveDate",
    [],
    decode.list(period_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeCost(
    cost:,
    source:,
    type_:,
    effective_date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_monograph_to_json(
  medicationknowledge_monograph: MedicationknowledgeMonograph,
) -> Json {
  let MedicationknowledgeMonograph(
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_monograph
  let fields = []
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_monograph_decoder() -> Decoder(
  MedicationknowledgeMonograph,
) {
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeMonograph(
    source:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_relatedmedicationknowledge_to_json(
  medicationknowledge_relatedmedicationknowledge: MedicationknowledgeRelatedmedicationknowledge,
) -> Json {
  let MedicationknowledgeRelatedmedicationknowledge(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationknowledge_relatedmedicationknowledge
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationknowledge_relatedmedicationknowledge_decoder() -> Decoder(
  MedicationknowledgeRelatedmedicationknowledge,
) {
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationknowledgeRelatedmedicationknowledge(
    reference:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationknowledge_to_json(
  medicationknowledge: Medicationknowledge,
) -> Json {
  let Medicationknowledge(
    definitional:,
    regulatory:,
    storage_guideline:,
    clinical_use_issue:,
    packaging:,
    medicine_classification:,
    indication_guideline:,
    monitoring_program:,
    cost:,
    preparation_instruction:,
    monograph:,
    product_type:,
    associated_medication:,
    related_medication_knowledge:,
    name:,
    intended_jurisdiction:,
    author:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationknowledge
  let fields = []
  let fields = case definitional {
    Some(v) -> [
      #("definitional", medicationknowledge_definitional_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case regulatory {
    [] -> fields
    _ -> [
      #(
        "regulatory",
        json.array(regulatory, medicationknowledge_regulatory_to_json),
      ),
      ..fields
    ]
  }
  let fields = case storage_guideline {
    [] -> fields
    _ -> [
      #(
        "storageGuideline",
        json.array(
          storage_guideline,
          medicationknowledge_storageguideline_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case clinical_use_issue {
    [] -> fields
    _ -> [
      #("clinicalUseIssue", json.array(clinical_use_issue, reference_to_json)),
      ..fields
    ]
  }
  let fields = case packaging {
    [] -> fields
    _ -> [
      #(
        "packaging",
        json.array(packaging, medicationknowledge_packaging_to_json),
      ),
      ..fields
    ]
  }
  let fields = case medicine_classification {
    [] -> fields
    _ -> [
      #(
        "medicineClassification",
        json.array(
          medicine_classification,
          medicationknowledge_medicineclassification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case indication_guideline {
    [] -> fields
    _ -> [
      #(
        "indicationGuideline",
        json.array(
          indication_guideline,
          medicationknowledge_indicationguideline_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case monitoring_program {
    [] -> fields
    _ -> [
      #(
        "monitoringProgram",
        json.array(
          monitoring_program,
          medicationknowledge_monitoringprogram_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case cost {
    [] -> fields
    _ -> [
      #("cost", json.array(cost, medicationknowledge_cost_to_json)),
      ..fields
    ]
  }
  let fields = case preparation_instruction {
    Some(v) -> [#("preparationInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case monograph {
    [] -> fields
    _ -> [
      #(
        "monograph",
        json.array(monograph, medicationknowledge_monograph_to_json),
      ),
      ..fields
    ]
  }
  let fields = case product_type {
    [] -> fields
    _ -> [
      #("productType", json.array(product_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case associated_medication {
    [] -> fields
    _ -> [
      #(
        "associatedMedication",
        json.array(associated_medication, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case related_medication_knowledge {
    [] -> fields
    _ -> [
      #(
        "relatedMedicationKnowledge",
        json.array(
          related_medication_knowledge,
          medicationknowledge_relatedmedicationknowledge_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, json.string)), ..fields]
  }
  let fields = case intended_jurisdiction {
    [] -> fields
    _ -> [
      #(
        "intendedJurisdiction",
        json.array(intended_jurisdiction, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.medicationknowledgestatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationknowledge")), ..fields]
  json.object(fields)
}

pub fn medicationknowledge_decoder() -> Decoder(Medicationknowledge) {
  use definitional <- decode.optional_field(
    "definitional",
    None,
    decode.optional(medicationknowledge_definitional_decoder()),
  )
  use regulatory <- decode.optional_field(
    "regulatory",
    [],
    decode.list(medicationknowledge_regulatory_decoder()),
  )
  use storage_guideline <- decode.optional_field(
    "storageGuideline",
    [],
    decode.list(medicationknowledge_storageguideline_decoder()),
  )
  use clinical_use_issue <- decode.optional_field(
    "clinicalUseIssue",
    [],
    decode.list(reference_decoder()),
  )
  use packaging <- decode.optional_field(
    "packaging",
    [],
    decode.list(medicationknowledge_packaging_decoder()),
  )
  use medicine_classification <- decode.optional_field(
    "medicineClassification",
    [],
    decode.list(medicationknowledge_medicineclassification_decoder()),
  )
  use indication_guideline <- decode.optional_field(
    "indicationGuideline",
    [],
    decode.list(medicationknowledge_indicationguideline_decoder()),
  )
  use monitoring_program <- decode.optional_field(
    "monitoringProgram",
    [],
    decode.list(medicationknowledge_monitoringprogram_decoder()),
  )
  use cost <- decode.optional_field(
    "cost",
    [],
    decode.list(medicationknowledge_cost_decoder()),
  )
  use preparation_instruction <- decode.optional_field(
    "preparationInstruction",
    None,
    decode.optional(decode.string),
  )
  use monograph <- decode.optional_field(
    "monograph",
    [],
    decode.list(medicationknowledge_monograph_decoder()),
  )
  use product_type <- decode.optional_field(
    "productType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use associated_medication <- decode.optional_field(
    "associatedMedication",
    [],
    decode.list(reference_decoder()),
  )
  use related_medication_knowledge <- decode.optional_field(
    "relatedMedicationKnowledge",
    [],
    decode.list(medicationknowledge_relatedmedicationknowledge_decoder()),
  )
  use name <- decode.optional_field("name", [], decode.list(decode.string))
  use intended_jurisdiction <- decode.optional_field(
    "intendedJurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.medicationknowledgestatus_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationknowledge",
    decode.failure(medicationknowledge_new(), "resourceType"),
  )
  decode.success(Medicationknowledge(
    definitional:,
    regulatory:,
    storage_guideline:,
    clinical_use_issue:,
    packaging:,
    medicine_classification:,
    indication_guideline:,
    monitoring_program:,
    cost:,
    preparation_instruction:,
    monograph:,
    product_type:,
    associated_medication:,
    related_medication_knowledge:,
    name:,
    intended_jurisdiction:,
    author:,
    status:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationRequest#resource
pub type Medicationrequest {
  Medicationrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    prior_prescription: Option(Reference),
    group_identifier: Option(Identifier),
    status: r5valuesets.Medicationrequeststatus,
    status_reason: Option(Codeableconcept),
    status_changed: Option(String),
    intent: r5valuesets.Medicationrequestintent,
    category: List(Codeableconcept),
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    medication: Codeablereference,
    subject: Reference,
    information_source: List(Reference),
    encounter: Option(Reference),
    supporting_information: List(Reference),
    authored_on: Option(String),
    requester: Option(Reference),
    reported: Option(Bool),
    performer_type: Option(Codeableconcept),
    performer: List(Reference),
    device: List(Codeablereference),
    recorder: Option(Reference),
    reason: List(Codeablereference),
    course_of_therapy_type: Option(Codeableconcept),
    insurance: List(Reference),
    note: List(Annotation),
    rendered_dosage_instruction: Option(String),
    effective_dose_period: Option(Period),
    dosage_instruction: List(Dosage),
    dispense_request: Option(MedicationrequestDispenserequest),
    substitution: Option(MedicationrequestSubstitution),
    event_history: List(Reference),
  )
}

pub fn medicationrequest_new(
  subject subject: Reference,
  medication medication: Codeablereference,
  intent intent: r5valuesets.Medicationrequestintent,
  status status: r5valuesets.Medicationrequeststatus,
) -> Medicationrequest {
  Medicationrequest(
    event_history: [],
    substitution: None,
    dispense_request: None,
    dosage_instruction: [],
    effective_dose_period: None,
    rendered_dosage_instruction: None,
    note: [],
    insurance: [],
    course_of_therapy_type: None,
    reason: [],
    recorder: None,
    device: [],
    performer: [],
    performer_type: None,
    reported: None,
    requester: None,
    authored_on: None,
    supporting_information: [],
    encounter: None,
    information_source: [],
    subject:,
    medication:,
    do_not_perform: None,
    priority: None,
    category: [],
    intent:,
    status_changed: None,
    status_reason: None,
    status:,
    group_identifier: None,
    prior_prescription: None,
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequest {
  MedicationrequestDispenserequest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    initial_fill: Option(MedicationrequestDispenserequestInitialfill),
    dispense_interval: Option(Duration),
    validity_period: Option(Period),
    number_of_repeats_allowed: Option(Int),
    quantity: Option(Quantity),
    expected_supply_duration: Option(Duration),
    dispenser: Option(Reference),
    dispenser_instruction: List(Annotation),
    dose_administration_aid: Option(Codeableconcept),
  )
}

pub fn medicationrequest_dispenserequest_new() -> MedicationrequestDispenserequest {
  MedicationrequestDispenserequest(
    dose_administration_aid: None,
    dispenser_instruction: [],
    dispenser: None,
    expected_supply_duration: None,
    quantity: None,
    number_of_repeats_allowed: None,
    validity_period: None,
    dispense_interval: None,
    initial_fill: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestDispenserequestInitialfill {
  MedicationrequestDispenserequestInitialfill(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    duration: Option(Duration),
  )
}

pub fn medicationrequest_dispenserequest_initialfill_new() -> MedicationrequestDispenserequestInitialfill {
  MedicationrequestDispenserequestInitialfill(
    duration: None,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitution {
  MedicationrequestSubstitution(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    allowed: MedicationrequestSubstitutionAllowed,
    reason: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationRequest#resource
pub type MedicationrequestSubstitutionAllowed {
  MedicationrequestSubstitutionAllowedBoolean(allowed: Bool)
  MedicationrequestSubstitutionAllowedCodeableconcept(allowed: Codeableconcept)
}

pub fn medicationrequest_substitution_allowed_to_json(
  elt: MedicationrequestSubstitutionAllowed,
) -> Json {
  case elt {
    MedicationrequestSubstitutionAllowedBoolean(v) -> json.bool(v)
    MedicationrequestSubstitutionAllowedCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn medicationrequest_substitution_allowed_decoder() -> Decoder(
  MedicationrequestSubstitutionAllowed,
) {
  decode.one_of(
    decode.field("allowedBoolean", decode.bool, decode.success)
      |> decode.map(MedicationrequestSubstitutionAllowedBoolean),
    [
      decode.field(
        "allowedCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(MedicationrequestSubstitutionAllowedCodeableconcept),
    ],
  )
}

pub fn medicationrequest_substitution_new(
  allowed allowed: MedicationrequestSubstitutionAllowed,
) -> MedicationrequestSubstitution {
  MedicationrequestSubstitution(
    reason: None,
    allowed:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationrequest_substitution_to_json(
  medicationrequest_substitution: MedicationrequestSubstitution,
) -> Json {
  let MedicationrequestSubstitution(
    reason:,
    allowed:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_substitution
  let fields = [
    #("allowed", medicationrequest_substitution_allowed_to_json(allowed)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_substitution_decoder() -> Decoder(
  MedicationrequestSubstitution,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use allowed <- decode.then(medicationrequest_substitution_allowed_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestSubstitution(
    reason:,
    allowed:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_dispenserequest_initialfill_to_json(
  medicationrequest_dispenserequest_initialfill: MedicationrequestDispenserequestInitialfill,
) -> Json {
  let MedicationrequestDispenserequestInitialfill(
    duration:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_dispenserequest_initialfill
  let fields = []
  let fields = case duration {
    Some(v) -> [#("duration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_dispenserequest_initialfill_decoder() -> Decoder(
  MedicationrequestDispenserequestInitialfill,
) {
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestDispenserequestInitialfill(
    duration:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_dispenserequest_to_json(
  medicationrequest_dispenserequest: MedicationrequestDispenserequest,
) -> Json {
  let MedicationrequestDispenserequest(
    dose_administration_aid:,
    dispenser_instruction:,
    dispenser:,
    expected_supply_duration:,
    quantity:,
    number_of_repeats_allowed:,
    validity_period:,
    dispense_interval:,
    initial_fill:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationrequest_dispenserequest
  let fields = []
  let fields = case dose_administration_aid {
    Some(v) -> [
      #("doseAdministrationAid", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dispenser_instruction {
    [] -> fields
    _ -> [
      #(
        "dispenserInstruction",
        json.array(dispenser_instruction, annotation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case dispenser {
    Some(v) -> [#("dispenser", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expected_supply_duration {
    Some(v) -> [#("expectedSupplyDuration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_repeats_allowed {
    Some(v) -> [#("numberOfRepeatsAllowed", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case validity_period {
    Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case dispense_interval {
    Some(v) -> [#("dispenseInterval", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case initial_fill {
    Some(v) -> [
      #("initialFill", medicationrequest_dispenserequest_initialfill_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationrequest_dispenserequest_decoder() -> Decoder(
  MedicationrequestDispenserequest,
) {
  use dose_administration_aid <- decode.optional_field(
    "doseAdministrationAid",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use dispenser_instruction <- decode.optional_field(
    "dispenserInstruction",
    [],
    decode.list(annotation_decoder()),
  )
  use dispenser <- decode.optional_field(
    "dispenser",
    None,
    decode.optional(reference_decoder()),
  )
  use expected_supply_duration <- decode.optional_field(
    "expectedSupplyDuration",
    None,
    decode.optional(duration_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use number_of_repeats_allowed <- decode.optional_field(
    "numberOfRepeatsAllowed",
    None,
    decode.optional(decode.int),
  )
  use validity_period <- decode.optional_field(
    "validityPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use dispense_interval <- decode.optional_field(
    "dispenseInterval",
    None,
    decode.optional(duration_decoder()),
  )
  use initial_fill <- decode.optional_field(
    "initialFill",
    None,
    decode.optional(medicationrequest_dispenserequest_initialfill_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationrequestDispenserequest(
    dose_administration_aid:,
    dispenser_instruction:,
    dispenser:,
    expected_supply_duration:,
    quantity:,
    number_of_repeats_allowed:,
    validity_period:,
    dispense_interval:,
    initial_fill:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationrequest_to_json(medicationrequest: Medicationrequest) -> Json {
  let Medicationrequest(
    event_history:,
    substitution:,
    dispense_request:,
    dosage_instruction:,
    effective_dose_period:,
    rendered_dosage_instruction:,
    note:,
    insurance:,
    course_of_therapy_type:,
    reason:,
    recorder:,
    device:,
    performer:,
    performer_type:,
    reported:,
    requester:,
    authored_on:,
    supporting_information:,
    encounter:,
    information_source:,
    subject:,
    medication:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_changed:,
    status_reason:,
    status:,
    group_identifier:,
    prior_prescription:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationrequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("medication", codeablereference_to_json(medication)),
    #("intent", r5valuesets.medicationrequestintent_to_json(intent)),
    #("status", r5valuesets.medicationrequeststatus_to_json(status)),
  ]
  let fields = case event_history {
    [] -> fields
    _ -> [
      #("eventHistory", json.array(event_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case substitution {
    Some(v) -> [
      #("substitution", medicationrequest_substitution_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dispense_request {
    Some(v) -> [
      #("dispenseRequest", medicationrequest_dispenserequest_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage_instruction {
    [] -> fields
    _ -> [
      #("dosageInstruction", json.array(dosage_instruction, dosage_to_json)),
      ..fields
    ]
  }
  let fields = case effective_dose_period {
    Some(v) -> [#("effectiveDosePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case rendered_dosage_instruction {
    Some(v) -> [#("renderedDosageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case course_of_therapy_type {
    Some(v) -> [#("courseOfTherapyType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, codeablereference_to_json)), ..fields]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reported {
    Some(v) -> [#("reported", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case information_source {
    [] -> fields
    _ -> [
      #("informationSource", json.array(information_source, reference_to_json)),
      ..fields
    ]
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_changed {
    Some(v) -> [#("statusChanged", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case prior_prescription {
    Some(v) -> [#("priorPrescription", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationrequest")), ..fields]
  json.object(fields)
}

pub fn medicationrequest_decoder() -> Decoder(Medicationrequest) {
  use event_history <- decode.optional_field(
    "eventHistory",
    [],
    decode.list(reference_decoder()),
  )
  use substitution <- decode.optional_field(
    "substitution",
    None,
    decode.optional(medicationrequest_substitution_decoder()),
  )
  use dispense_request <- decode.optional_field(
    "dispenseRequest",
    None,
    decode.optional(medicationrequest_dispenserequest_decoder()),
  )
  use dosage_instruction <- decode.optional_field(
    "dosageInstruction",
    [],
    decode.list(dosage_decoder()),
  )
  use effective_dose_period <- decode.optional_field(
    "effectiveDosePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use rendered_dosage_instruction <- decode.optional_field(
    "renderedDosageInstruction",
    None,
    decode.optional(decode.string),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use course_of_therapy_type <- decode.optional_field(
    "courseOfTherapyType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use reported <- decode.optional_field(
    "reported",
    None,
    decode.optional(decode.bool),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.field("medication", codeablereference_decoder())
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field(
    "intent",
    r5valuesets.medicationrequestintent_decoder(),
  )
  use status_changed <- decode.optional_field(
    "statusChanged",
    None,
    decode.optional(decode.string),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.medicationrequeststatus_decoder(),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use prior_prescription <- decode.optional_field(
    "priorPrescription",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationrequest",
    decode.failure(
      medicationrequest_new(subject:, medication:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationrequest(
    event_history:,
    substitution:,
    dispense_request:,
    dosage_instruction:,
    effective_dose_period:,
    rendered_dosage_instruction:,
    note:,
    insurance:,
    course_of_therapy_type:,
    reason:,
    recorder:,
    device:,
    performer:,
    performer_type:,
    reported:,
    requester:,
    authored_on:,
    supporting_information:,
    encounter:,
    information_source:,
    subject:,
    medication:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status_changed:,
    status_reason:,
    status:,
    group_identifier:,
    prior_prescription:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationStatement#resource
pub type Medicationstatement {
  Medicationstatement(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    part_of: List(Reference),
    status: r5valuesets.Medicationstatementstatus,
    category: List(Codeableconcept),
    medication: Codeablereference,
    subject: Reference,
    encounter: Option(Reference),
    effective: Option(MedicationstatementEffective),
    date_asserted: Option(String),
    information_source: List(Reference),
    derived_from: List(Reference),
    reason: List(Codeablereference),
    note: List(Annotation),
    related_clinical_information: List(Reference),
    rendered_dosage_instruction: Option(String),
    dosage: List(Dosage),
    adherence: Option(MedicationstatementAdherence),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementEffective {
  MedicationstatementEffectiveDatetime(effective: String)
  MedicationstatementEffectivePeriod(effective: Period)
  MedicationstatementEffectiveTiming(effective: Timing)
}

pub fn medicationstatement_effective_to_json(
  elt: MedicationstatementEffective,
) -> Json {
  case elt {
    MedicationstatementEffectiveDatetime(v) -> json.string(v)
    MedicationstatementEffectivePeriod(v) -> period_to_json(v)
    MedicationstatementEffectiveTiming(v) -> timing_to_json(v)
  }
}

pub fn medicationstatement_effective_decoder() -> Decoder(
  MedicationstatementEffective,
) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(MedicationstatementEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
        |> decode.map(MedicationstatementEffectivePeriod),
      decode.field("effectiveTiming", timing_decoder(), decode.success)
        |> decode.map(MedicationstatementEffectiveTiming),
    ],
  )
}

pub fn medicationstatement_new(
  subject subject: Reference,
  medication medication: Codeablereference,
  status status: r5valuesets.Medicationstatementstatus,
) -> Medicationstatement {
  Medicationstatement(
    adherence: None,
    dosage: [],
    rendered_dosage_instruction: None,
    related_clinical_information: [],
    note: [],
    reason: [],
    derived_from: [],
    information_source: [],
    date_asserted: None,
    effective: None,
    encounter: None,
    subject:,
    medication:,
    category: [],
    status:,
    part_of: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicationStatement#resource
pub type MedicationstatementAdherence {
  MedicationstatementAdherence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    reason: Option(Codeableconcept),
  )
}

pub fn medicationstatement_adherence_new(
  code code: Codeableconcept,
) -> MedicationstatementAdherence {
  MedicationstatementAdherence(
    reason: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicationstatement_adherence_to_json(
  medicationstatement_adherence: MedicationstatementAdherence,
) -> Json {
  let MedicationstatementAdherence(
    reason:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicationstatement_adherence
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicationstatement_adherence_decoder() -> Decoder(
  MedicationstatementAdherence,
) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicationstatementAdherence(
    reason:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicationstatement_to_json(
  medicationstatement: Medicationstatement,
) -> Json {
  let Medicationstatement(
    adherence:,
    dosage:,
    rendered_dosage_instruction:,
    related_clinical_information:,
    note:,
    reason:,
    derived_from:,
    information_source:,
    date_asserted:,
    effective:,
    encounter:,
    subject:,
    medication:,
    category:,
    status:,
    part_of:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicationstatement
  let fields = [
    #("subject", reference_to_json(subject)),
    #("medication", codeablereference_to_json(medication)),
    #("status", r5valuesets.medicationstatementstatus_to_json(status)),
  ]
  let fields = case adherence {
    Some(v) -> [
      #("adherence", medicationstatement_adherence_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case dosage {
    [] -> fields
    _ -> [#("dosage", json.array(dosage, dosage_to_json)), ..fields]
  }
  let fields = case rendered_dosage_instruction {
    Some(v) -> [#("renderedDosageInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_clinical_information {
    [] -> fields
    _ -> [
      #(
        "relatedClinicalInformation",
        json.array(related_clinical_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case information_source {
    [] -> fields
    _ -> [
      #("informationSource", json.array(information_source, reference_to_json)),
      ..fields
    ]
  }
  let fields = case date_asserted {
    Some(v) -> [#("dateAsserted", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          MedicationstatementEffectiveDatetime(_) -> "Datetime"
          MedicationstatementEffectivePeriod(_) -> "Period"
          MedicationstatementEffectiveTiming(_) -> "Timing"
        },
        medicationstatement_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Medicationstatement")), ..fields]
  json.object(fields)
}

pub fn medicationstatement_decoder() -> Decoder(Medicationstatement) {
  use adherence <- decode.optional_field(
    "adherence",
    None,
    decode.optional(medicationstatement_adherence_decoder()),
  )
  use dosage <- decode.optional_field(
    "dosage",
    [],
    decode.list(dosage_decoder()),
  )
  use rendered_dosage_instruction <- decode.optional_field(
    "renderedDosageInstruction",
    None,
    decode.optional(decode.string),
  )
  use related_clinical_information <- decode.optional_field(
    "relatedClinicalInformation",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    [],
    decode.list(reference_decoder()),
  )
  use date_asserted <- decode.optional_field(
    "dateAsserted",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(
    none_if_omitted(medicationstatement_effective_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use medication <- decode.field("medication", codeablereference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.medicationstatementstatus_decoder(),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicationstatement",
    decode.failure(
      medicationstatement_new(subject:, medication:, status:),
      "resourceType",
    ),
  )
  decode.success(Medicationstatement(
    adherence:,
    dosage:,
    rendered_dosage_instruction:,
    related_clinical_information:,
    note:,
    reason:,
    derived_from:,
    information_source:,
    date_asserted:,
    effective:,
    encounter:,
    subject:,
    medication:,
    category:,
    status:,
    part_of:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type Medicinalproductdefinition {
  Medicinalproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    domain: Option(Codeableconcept),
    version: Option(String),
    status: Option(Codeableconcept),
    status_date: Option(String),
    description: Option(String),
    combined_pharmaceutical_dose_form: Option(Codeableconcept),
    route: List(Codeableconcept),
    indication: Option(String),
    legal_status_of_supply: Option(Codeableconcept),
    additional_monitoring_indicator: Option(Codeableconcept),
    special_measures: List(Codeableconcept),
    pediatric_use_indicator: Option(Codeableconcept),
    classification: List(Codeableconcept),
    marketing_status: List(Marketingstatus),
    packaged_medicinal_product: List(Codeableconcept),
    comprised_of: List(Reference),
    ingredient: List(Codeableconcept),
    impurity: List(Codeablereference),
    attached_document: List(Reference),
    master_file: List(Reference),
    contact: List(MedicinalproductdefinitionContact),
    clinical_trial: List(Reference),
    code: List(Coding),
    name: List(MedicinalproductdefinitionName),
    cross_reference: List(MedicinalproductdefinitionCrossreference),
    operation: List(MedicinalproductdefinitionOperation),
    characteristic: List(MedicinalproductdefinitionCharacteristic),
  )
}

pub fn medicinalproductdefinition_new() -> Medicinalproductdefinition {
  Medicinalproductdefinition(
    characteristic: [],
    operation: [],
    cross_reference: [],
    name: [],
    code: [],
    clinical_trial: [],
    contact: [],
    master_file: [],
    attached_document: [],
    impurity: [],
    ingredient: [],
    comprised_of: [],
    packaged_medicinal_product: [],
    marketing_status: [],
    classification: [],
    pediatric_use_indicator: None,
    special_measures: [],
    additional_monitoring_indicator: None,
    legal_status_of_supply: None,
    indication: None,
    route: [],
    combined_pharmaceutical_dose_form: None,
    description: None,
    status_date: None,
    status: None,
    version: None,
    domain: None,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionContact {
  MedicinalproductdefinitionContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    contact: Reference,
  )
}

pub fn medicinalproductdefinition_contact_new(
  contact contact: Reference,
) -> MedicinalproductdefinitionContact {
  MedicinalproductdefinitionContact(
    contact:,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionName {
  MedicinalproductdefinitionName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product_name: String,
    type_: Option(Codeableconcept),
    part: List(MedicinalproductdefinitionNamePart),
    usage: List(MedicinalproductdefinitionNameUsage),
  )
}

pub fn medicinalproductdefinition_name_new(
  product_name product_name: String,
) -> MedicinalproductdefinitionName {
  MedicinalproductdefinitionName(
    usage: [],
    part: [],
    type_: None,
    product_name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionNamePart {
  MedicinalproductdefinitionNamePart(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    part: String,
    type_: Codeableconcept,
  )
}

pub fn medicinalproductdefinition_name_part_new(
  type_ type_: Codeableconcept,
  part part: String,
) -> MedicinalproductdefinitionNamePart {
  MedicinalproductdefinitionNamePart(
    type_:,
    part:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionNameUsage {
  MedicinalproductdefinitionNameUsage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    country: Codeableconcept,
    jurisdiction: Option(Codeableconcept),
    language: Codeableconcept,
  )
}

pub fn medicinalproductdefinition_name_usage_new(
  language language: Codeableconcept,
  country country: Codeableconcept,
) -> MedicinalproductdefinitionNameUsage {
  MedicinalproductdefinitionNameUsage(
    language:,
    jurisdiction: None,
    country:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCrossreference {
  MedicinalproductdefinitionCrossreference(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product: Codeablereference,
    type_: Option(Codeableconcept),
  )
}

pub fn medicinalproductdefinition_crossreference_new(
  product product: Codeablereference,
) -> MedicinalproductdefinitionCrossreference {
  MedicinalproductdefinitionCrossreference(
    type_: None,
    product:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionOperation {
  MedicinalproductdefinitionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeablereference),
    effective_date: Option(Period),
    organization: List(Reference),
    confidentiality_indicator: Option(Codeableconcept),
  )
}

pub fn medicinalproductdefinition_operation_new() -> MedicinalproductdefinitionOperation {
  MedicinalproductdefinitionOperation(
    confidentiality_indicator: None,
    organization: [],
    effective_date: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCharacteristic {
  MedicinalproductdefinitionCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(MedicinalproductdefinitionCharacteristicValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MedicinalProductDefinition#resource
pub type MedicinalproductdefinitionCharacteristicValue {
  MedicinalproductdefinitionCharacteristicValueCodeableconcept(
    value: Codeableconcept,
  )
  MedicinalproductdefinitionCharacteristicValueMarkdown(value: String)
  MedicinalproductdefinitionCharacteristicValueQuantity(value: Quantity)
  MedicinalproductdefinitionCharacteristicValueInteger(value: Int)
  MedicinalproductdefinitionCharacteristicValueDate(value: String)
  MedicinalproductdefinitionCharacteristicValueBoolean(value: Bool)
  MedicinalproductdefinitionCharacteristicValueAttachment(value: Attachment)
}

pub fn medicinalproductdefinition_characteristic_value_to_json(
  elt: MedicinalproductdefinitionCharacteristicValue,
) -> Json {
  case elt {
    MedicinalproductdefinitionCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MedicinalproductdefinitionCharacteristicValueMarkdown(v) -> json.string(v)
    MedicinalproductdefinitionCharacteristicValueQuantity(v) ->
      quantity_to_json(v)
    MedicinalproductdefinitionCharacteristicValueInteger(v) -> json.int(v)
    MedicinalproductdefinitionCharacteristicValueDate(v) -> json.string(v)
    MedicinalproductdefinitionCharacteristicValueBoolean(v) -> json.bool(v)
    MedicinalproductdefinitionCharacteristicValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn medicinalproductdefinition_characteristic_value_decoder() -> Decoder(
  MedicinalproductdefinitionCharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MedicinalproductdefinitionCharacteristicValueCodeableconcept,
      ),
    [
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueMarkdown),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueQuantity),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(MedicinalproductdefinitionCharacteristicValueAttachment),
    ],
  )
}

pub fn medicinalproductdefinition_characteristic_new(
  type_ type_: Codeableconcept,
) -> MedicinalproductdefinitionCharacteristic {
  MedicinalproductdefinitionCharacteristic(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn medicinalproductdefinition_characteristic_to_json(
  medicinalproductdefinition_characteristic: MedicinalproductdefinitionCharacteristic,
) -> Json {
  let MedicinalproductdefinitionCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_characteristic
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          MedicinalproductdefinitionCharacteristicValueCodeableconcept(_) ->
            "Codeableconcept"
          MedicinalproductdefinitionCharacteristicValueMarkdown(_) -> "Markdown"
          MedicinalproductdefinitionCharacteristicValueQuantity(_) -> "Quantity"
          MedicinalproductdefinitionCharacteristicValueInteger(_) -> "Integer"
          MedicinalproductdefinitionCharacteristicValueDate(_) -> "Date"
          MedicinalproductdefinitionCharacteristicValueBoolean(_) -> "Boolean"
          MedicinalproductdefinitionCharacteristicValueAttachment(_) ->
            "Attachment"
        },
        medicinalproductdefinition_characteristic_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_characteristic_decoder() -> Decoder(
  MedicinalproductdefinitionCharacteristic,
) {
  use value <- decode.then(
    none_if_omitted(medicinalproductdefinition_characteristic_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_operation_to_json(
  medicinalproductdefinition_operation: MedicinalproductdefinitionOperation,
) -> Json {
  let MedicinalproductdefinitionOperation(
    confidentiality_indicator:,
    organization:,
    effective_date:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_operation
  let fields = []
  let fields = case confidentiality_indicator {
    Some(v) -> [
      #("confidentialityIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case organization {
    [] -> fields
    _ -> [
      #("organization", json.array(organization, reference_to_json)),
      ..fields
    ]
  }
  let fields = case effective_date {
    Some(v) -> [#("effectiveDate", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_operation_decoder() -> Decoder(
  MedicinalproductdefinitionOperation,
) {
  use confidentiality_indicator <- decode.optional_field(
    "confidentialityIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    [],
    decode.list(reference_decoder()),
  )
  use effective_date <- decode.optional_field(
    "effectiveDate",
    None,
    decode.optional(period_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionOperation(
    confidentiality_indicator:,
    organization:,
    effective_date:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_crossreference_to_json(
  medicinalproductdefinition_crossreference: MedicinalproductdefinitionCrossreference,
) -> Json {
  let MedicinalproductdefinitionCrossreference(
    type_:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_crossreference
  let fields = [
    #("product", codeablereference_to_json(product)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_crossreference_decoder() -> Decoder(
  MedicinalproductdefinitionCrossreference,
) {
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product <- decode.field("product", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionCrossreference(
    type_:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_usage_to_json(
  medicinalproductdefinition_name_usage: MedicinalproductdefinitionNameUsage,
) -> Json {
  let MedicinalproductdefinitionNameUsage(
    language:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name_usage
  let fields = [
    #("language", codeableconcept_to_json(language)),
    #("country", codeableconcept_to_json(country)),
  ]
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_usage_decoder() -> Decoder(
  MedicinalproductdefinitionNameUsage,
) {
  use language <- decode.field("language", codeableconcept_decoder())
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use country <- decode.field("country", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionNameUsage(
    language:,
    jurisdiction:,
    country:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_part_to_json(
  medicinalproductdefinition_name_part: MedicinalproductdefinitionNamePart,
) -> Json {
  let MedicinalproductdefinitionNamePart(
    type_:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name_part
  let fields = [
    #("type", codeableconcept_to_json(type_)),
    #("part", json.string(part)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_part_decoder() -> Decoder(
  MedicinalproductdefinitionNamePart,
) {
  use type_ <- decode.field("type", codeableconcept_decoder())
  use part <- decode.field("part", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionNamePart(
    type_:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_name_to_json(
  medicinalproductdefinition_name: MedicinalproductdefinitionName,
) -> Json {
  let MedicinalproductdefinitionName(
    usage:,
    part:,
    type_:,
    product_name:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_name
  let fields = [
    #("productName", json.string(product_name)),
  ]
  let fields = case usage {
    [] -> fields
    _ -> [
      #(
        "usage",
        json.array(usage, medicinalproductdefinition_name_usage_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part {
    [] -> fields
    _ -> [
      #("part", json.array(part, medicinalproductdefinition_name_part_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_name_decoder() -> Decoder(
  MedicinalproductdefinitionName,
) {
  use usage <- decode.optional_field(
    "usage",
    [],
    decode.list(medicinalproductdefinition_name_usage_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    [],
    decode.list(medicinalproductdefinition_name_part_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use product_name <- decode.field("productName", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionName(
    usage:,
    part:,
    type_:,
    product_name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_contact_to_json(
  medicinalproductdefinition_contact: MedicinalproductdefinitionContact,
) -> Json {
  let MedicinalproductdefinitionContact(
    contact:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = medicinalproductdefinition_contact
  let fields = [
    #("contact", reference_to_json(contact)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn medicinalproductdefinition_contact_decoder() -> Decoder(
  MedicinalproductdefinitionContact,
) {
  use contact <- decode.field("contact", reference_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MedicinalproductdefinitionContact(
    contact:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn medicinalproductdefinition_to_json(
  medicinalproductdefinition: Medicinalproductdefinition,
) -> Json {
  let Medicinalproductdefinition(
    characteristic:,
    operation:,
    cross_reference:,
    name:,
    code:,
    clinical_trial:,
    contact:,
    master_file:,
    attached_document:,
    impurity:,
    ingredient:,
    comprised_of:,
    packaged_medicinal_product:,
    marketing_status:,
    classification:,
    pediatric_use_indicator:,
    special_measures:,
    additional_monitoring_indicator:,
    legal_status_of_supply:,
    indication:,
    route:,
    combined_pharmaceutical_dose_form:,
    description:,
    status_date:,
    status:,
    version:,
    domain:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = medicinalproductdefinition
  let fields = []
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(
          characteristic,
          medicinalproductdefinition_characteristic_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case operation {
    [] -> fields
    _ -> [
      #(
        "operation",
        json.array(operation, medicinalproductdefinition_operation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case cross_reference {
    [] -> fields
    _ -> [
      #(
        "crossReference",
        json.array(
          cross_reference,
          medicinalproductdefinition_crossreference_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [
      #("name", json.array(name, medicinalproductdefinition_name_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case clinical_trial {
    [] -> fields
    _ -> [
      #("clinicalTrial", json.array(clinical_trial, reference_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #(
        "contact",
        json.array(contact, medicinalproductdefinition_contact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case master_file {
    [] -> fields
    _ -> [#("masterFile", json.array(master_file, reference_to_json)), ..fields]
  }
  let fields = case attached_document {
    [] -> fields
    _ -> [
      #("attachedDocument", json.array(attached_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case impurity {
    [] -> fields
    _ -> [
      #("impurity", json.array(impurity, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case comprised_of {
    [] -> fields
    _ -> [
      #("comprisedOf", json.array(comprised_of, reference_to_json)),
      ..fields
    ]
  }
  let fields = case packaged_medicinal_product {
    [] -> fields
    _ -> [
      #(
        "packagedMedicinalProduct",
        json.array(packaged_medicinal_product, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case marketing_status {
    [] -> fields
    _ -> [
      #(
        "marketingStatus",
        json.array(marketing_status, marketingstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case pediatric_use_indicator {
    Some(v) -> [
      #("pediatricUseIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case special_measures {
    [] -> fields
    _ -> [
      #(
        "specialMeasures",
        json.array(special_measures, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case additional_monitoring_indicator {
    Some(v) -> [
      #("additionalMonitoringIndicator", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case legal_status_of_supply {
    Some(v) -> [#("legalStatusOfSupply", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case indication {
    Some(v) -> [#("indication", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case route {
    [] -> fields
    _ -> [#("route", json.array(route, codeableconcept_to_json)), ..fields]
  }
  let fields = case combined_pharmaceutical_dose_form {
    Some(v) -> [
      #("combinedPharmaceuticalDoseForm", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case domain {
    Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Medicinalproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn medicinalproductdefinition_decoder() -> Decoder(
  Medicinalproductdefinition,
) {
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(medicinalproductdefinition_characteristic_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    [],
    decode.list(medicinalproductdefinition_operation_decoder()),
  )
  use cross_reference <- decode.optional_field(
    "crossReference",
    [],
    decode.list(medicinalproductdefinition_crossreference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(medicinalproductdefinition_name_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use clinical_trial <- decode.optional_field(
    "clinicalTrial",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(medicinalproductdefinition_contact_decoder()),
  )
  use master_file <- decode.optional_field(
    "masterFile",
    [],
    decode.list(reference_decoder()),
  )
  use attached_document <- decode.optional_field(
    "attachedDocument",
    [],
    decode.list(reference_decoder()),
  )
  use impurity <- decode.optional_field(
    "impurity",
    [],
    decode.list(codeablereference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use comprised_of <- decode.optional_field(
    "comprisedOf",
    [],
    decode.list(reference_decoder()),
  )
  use packaged_medicinal_product <- decode.optional_field(
    "packagedMedicinalProduct",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use marketing_status <- decode.optional_field(
    "marketingStatus",
    [],
    decode.list(marketingstatus_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use pediatric_use_indicator <- decode.optional_field(
    "pediatricUseIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use special_measures <- decode.optional_field(
    "specialMeasures",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use additional_monitoring_indicator <- decode.optional_field(
    "additionalMonitoringIndicator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use legal_status_of_supply <- decode.optional_field(
    "legalStatusOfSupply",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    None,
    decode.optional(decode.string),
  )
  use route <- decode.optional_field(
    "route",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use combined_pharmaceutical_dose_form <- decode.optional_field(
    "combinedPharmaceuticalDoseForm",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use domain <- decode.optional_field(
    "domain",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Medicinalproductdefinition",
    decode.failure(medicinalproductdefinition_new(), "resourceType"),
  )
  decode.success(Medicinalproductdefinition(
    characteristic:,
    operation:,
    cross_reference:,
    name:,
    code:,
    clinical_trial:,
    contact:,
    master_file:,
    attached_document:,
    impurity:,
    ingredient:,
    comprised_of:,
    packaged_medicinal_product:,
    marketing_status:,
    classification:,
    pediatric_use_indicator:,
    special_measures:,
    additional_monitoring_indicator:,
    legal_status_of_supply:,
    indication:,
    route:,
    combined_pharmaceutical_dose_form:,
    description:,
    status_date:,
    status:,
    version:,
    domain:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageDefinition#resource
pub type Messagedefinition {
  Messagedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(MessagedefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    replaces: List(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    base: Option(String),
    parent: List(String),
    event: MessagedefinitionEvent,
    category: Option(r5valuesets.Messagesignificancecategory),
    focus: List(MessagedefinitionFocus),
    response_required: Option(r5valuesets.Messageheaderresponserequest),
    allowed_response: List(MessagedefinitionAllowedresponse),
    graph: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionVersionalgorithm {
  MessagedefinitionVersionalgorithmString(version_algorithm: String)
  MessagedefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn messagedefinition_versionalgorithm_to_json(
  elt: MessagedefinitionVersionalgorithm,
) -> Json {
  case elt {
    MessagedefinitionVersionalgorithmString(v) -> json.string(v)
    MessagedefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn messagedefinition_versionalgorithm_decoder() -> Decoder(
  MessagedefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(MessagedefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(MessagedefinitionVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionEvent {
  MessagedefinitionEventCoding(event: Coding)
  MessagedefinitionEventUri(event: String)
}

pub fn messagedefinition_event_to_json(elt: MessagedefinitionEvent) -> Json {
  case elt {
    MessagedefinitionEventCoding(v) -> coding_to_json(v)
    MessagedefinitionEventUri(v) -> json.string(v)
  }
}

pub fn messagedefinition_event_decoder() -> Decoder(MessagedefinitionEvent) {
  decode.one_of(
    decode.field("eventCoding", coding_decoder(), decode.success)
      |> decode.map(MessagedefinitionEventCoding),
    [
      decode.field("eventUri", decode.string, decode.success)
      |> decode.map(MessagedefinitionEventUri),
    ],
  )
}

pub fn messagedefinition_new(
  event event: MessagedefinitionEvent,
  date date: String,
  status status: r5valuesets.Publicationstatus,
) -> Messagedefinition {
  Messagedefinition(
    graph: None,
    allowed_response: [],
    response_required: None,
    focus: [],
    category: None,
    event:,
    parent: [],
    base: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    replaces: [],
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionFocus {
  MessagedefinitionFocus(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: r5valuesets.Resourcetypes,
    profile: Option(String),
    min: Int,
    max: Option(String),
  )
}

pub fn messagedefinition_focus_new(
  min min: Int,
  code code: r5valuesets.Resourcetypes,
) -> MessagedefinitionFocus {
  MessagedefinitionFocus(
    max: None,
    min:,
    profile: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageDefinition#resource
pub type MessagedefinitionAllowedresponse {
  MessagedefinitionAllowedresponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    message: String,
    situation: Option(String),
  )
}

pub fn messagedefinition_allowedresponse_new(
  message message: String,
) -> MessagedefinitionAllowedresponse {
  MessagedefinitionAllowedresponse(
    situation: None,
    message:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn messagedefinition_allowedresponse_to_json(
  messagedefinition_allowedresponse: MessagedefinitionAllowedresponse,
) -> Json {
  let MessagedefinitionAllowedresponse(
    situation:,
    message:,
    modifier_extension:,
    extension:,
    id:,
  ) = messagedefinition_allowedresponse
  let fields = [
    #("message", json.string(message)),
  ]
  let fields = case situation {
    Some(v) -> [#("situation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messagedefinition_allowedresponse_decoder() -> Decoder(
  MessagedefinitionAllowedresponse,
) {
  use situation <- decode.optional_field(
    "situation",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.field("message", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessagedefinitionAllowedresponse(
    situation:,
    message:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messagedefinition_focus_to_json(
  messagedefinition_focus: MessagedefinitionFocus,
) -> Json {
  let MessagedefinitionFocus(
    max:,
    min:,
    profile:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = messagedefinition_focus
  let fields = [
    #("min", json.int(min)),
    #("code", r5valuesets.resourcetypes_to_json(code)),
  ]
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case profile {
    Some(v) -> [#("profile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messagedefinition_focus_decoder() -> Decoder(MessagedefinitionFocus) {
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.field("min", decode.int)
  use profile <- decode.optional_field(
    "profile",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", r5valuesets.resourcetypes_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessagedefinitionFocus(
    max:,
    min:,
    profile:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messagedefinition_to_json(messagedefinition: Messagedefinition) -> Json {
  let Messagedefinition(
    graph:,
    allowed_response:,
    response_required:,
    focus:,
    category:,
    event:,
    parent:,
    base:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = messagedefinition
  let fields = [
    #("event", messagedefinition_event_to_json(event)),
    #("date", json.string(date)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case graph {
    Some(v) -> [#("graph", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case allowed_response {
    [] -> fields
    _ -> [
      #(
        "allowedResponse",
        json.array(allowed_response, messagedefinition_allowedresponse_to_json),
      ),
      ..fields
    ]
  }
  let fields = case response_required {
    Some(v) -> [
      #("responseRequired", r5valuesets.messageheaderresponserequest_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [
      #("focus", json.array(focus, messagedefinition_focus_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    Some(v) -> [
      #("category", r5valuesets.messagesignificancecategory_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, json.string)), ..fields]
  }
  let fields = case base {
    Some(v) -> [#("base", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          MessagedefinitionVersionalgorithmString(_) -> "String"
          MessagedefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        messagedefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Messagedefinition")), ..fields]
  json.object(fields)
}

pub fn messagedefinition_decoder() -> Decoder(Messagedefinition) {
  use graph <- decode.optional_field(
    "graph",
    None,
    decode.optional(decode.string),
  )
  use allowed_response <- decode.optional_field(
    "allowedResponse",
    [],
    decode.list(messagedefinition_allowedresponse_decoder()),
  )
  use response_required <- decode.optional_field(
    "responseRequired",
    None,
    decode.optional(r5valuesets.messageheaderresponserequest_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(messagedefinition_focus_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(r5valuesets.messagesignificancecategory_decoder()),
  )
  use event <- decode.then(messagedefinition_event_decoder())
  use parent <- decode.optional_field("parent", [], decode.list(decode.string))
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(messagedefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Messagedefinition",
    decode.failure(
      messagedefinition_new(event:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Messagedefinition(
    graph:,
    allowed_response:,
    response_required:,
    focus:,
    category:,
    event:,
    parent:,
    base:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    replaces:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type Messageheader {
  Messageheader(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event: MessageheaderEvent,
    destination: List(MessageheaderDestination),
    sender: Option(Reference),
    author: Option(Reference),
    source: MessageheaderSource,
    responsible: Option(Reference),
    reason: Option(Codeableconcept),
    response: Option(MessageheaderResponse),
    focus: List(Reference),
    definition: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderEvent {
  MessageheaderEventCoding(event: Coding)
  MessageheaderEventCanonical(event: String)
}

pub fn messageheader_event_to_json(elt: MessageheaderEvent) -> Json {
  case elt {
    MessageheaderEventCoding(v) -> coding_to_json(v)
    MessageheaderEventCanonical(v) -> json.string(v)
  }
}

pub fn messageheader_event_decoder() -> Decoder(MessageheaderEvent) {
  decode.one_of(
    decode.field("eventCoding", coding_decoder(), decode.success)
      |> decode.map(MessageheaderEventCoding),
    [
      decode.field("eventCanonical", decode.string, decode.success)
      |> decode.map(MessageheaderEventCanonical),
    ],
  )
}

pub fn messageheader_new(
  source source: MessageheaderSource,
  event event: MessageheaderEvent,
) -> Messageheader {
  Messageheader(
    definition: None,
    focus: [],
    response: None,
    reason: None,
    responsible: None,
    source:,
    author: None,
    sender: None,
    destination: [],
    event:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderDestination {
  MessageheaderDestination(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    endpoint: Option(MessageheaderDestinationEndpoint),
    name: Option(String),
    target: Option(Reference),
    receiver: Option(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderDestinationEndpoint {
  MessageheaderDestinationEndpointUrl(endpoint: String)
  MessageheaderDestinationEndpointReference(endpoint: Reference)
}

pub fn messageheader_destination_endpoint_to_json(
  elt: MessageheaderDestinationEndpoint,
) -> Json {
  case elt {
    MessageheaderDestinationEndpointUrl(v) -> json.string(v)
    MessageheaderDestinationEndpointReference(v) -> reference_to_json(v)
  }
}

pub fn messageheader_destination_endpoint_decoder() -> Decoder(
  MessageheaderDestinationEndpoint,
) {
  decode.one_of(
    decode.field("endpointUrl", decode.string, decode.success)
      |> decode.map(MessageheaderDestinationEndpointUrl),
    [
      decode.field("endpointReference", reference_decoder(), decode.success)
      |> decode.map(MessageheaderDestinationEndpointReference),
    ],
  )
}

pub fn messageheader_destination_new() -> MessageheaderDestination {
  MessageheaderDestination(
    receiver: None,
    target: None,
    name: None,
    endpoint: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderSource {
  MessageheaderSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    endpoint: Option(MessageheaderSourceEndpoint),
    name: Option(String),
    software: Option(String),
    version: Option(String),
    contact: Option(Contactpoint),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderSourceEndpoint {
  MessageheaderSourceEndpointUrl(endpoint: String)
  MessageheaderSourceEndpointReference(endpoint: Reference)
}

pub fn messageheader_source_endpoint_to_json(
  elt: MessageheaderSourceEndpoint,
) -> Json {
  case elt {
    MessageheaderSourceEndpointUrl(v) -> json.string(v)
    MessageheaderSourceEndpointReference(v) -> reference_to_json(v)
  }
}

pub fn messageheader_source_endpoint_decoder() -> Decoder(
  MessageheaderSourceEndpoint,
) {
  decode.one_of(
    decode.field("endpointUrl", decode.string, decode.success)
      |> decode.map(MessageheaderSourceEndpointUrl),
    [
      decode.field("endpointReference", reference_decoder(), decode.success)
      |> decode.map(MessageheaderSourceEndpointReference),
    ],
  )
}

pub fn messageheader_source_new() -> MessageheaderSource {
  MessageheaderSource(
    contact: None,
    version: None,
    software: None,
    name: None,
    endpoint: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MessageHeader#resource
pub type MessageheaderResponse {
  MessageheaderResponse(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Identifier,
    code: r5valuesets.Responsecode,
    details: Option(Reference),
  )
}

pub fn messageheader_response_new(
  code code: r5valuesets.Responsecode,
  identifier identifier: Identifier,
) -> MessageheaderResponse {
  MessageheaderResponse(
    details: None,
    code:,
    identifier:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn messageheader_response_to_json(
  messageheader_response: MessageheaderResponse,
) -> Json {
  let MessageheaderResponse(
    details:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_response
  let fields = [
    #("code", r5valuesets.responsecode_to_json(code)),
    #("identifier", identifier_to_json(identifier)),
  ]
  let fields = case details {
    Some(v) -> [#("details", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_response_decoder() -> Decoder(MessageheaderResponse) {
  use details <- decode.optional_field(
    "details",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", r5valuesets.responsecode_decoder())
  use identifier <- decode.field("identifier", identifier_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderResponse(
    details:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_source_to_json(
  messageheader_source: MessageheaderSource,
) -> Json {
  let MessageheaderSource(
    contact:,
    version:,
    software:,
    name:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_source
  let fields = []
  let fields = case contact {
    Some(v) -> [#("contact", contactpoint_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [#("software", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    Some(v) -> [
      #(
        "endpoint"
          <> case v {
          MessageheaderSourceEndpointUrl(_) -> "Url"
          MessageheaderSourceEndpointReference(_) -> "Reference"
        },
        messageheader_source_endpoint_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_source_decoder() -> Decoder(MessageheaderSource) {
  use contact <- decode.optional_field(
    "contact",
    None,
    decode.optional(contactpoint_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use endpoint <- decode.then(
    none_if_omitted(messageheader_source_endpoint_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderSource(
    contact:,
    version:,
    software:,
    name:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_destination_to_json(
  messageheader_destination: MessageheaderDestination,
) -> Json {
  let MessageheaderDestination(
    receiver:,
    target:,
    name:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ) = messageheader_destination
  let fields = []
  let fields = case receiver {
    Some(v) -> [#("receiver", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    Some(v) -> [#("target", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case endpoint {
    Some(v) -> [
      #(
        "endpoint"
          <> case v {
          MessageheaderDestinationEndpointUrl(_) -> "Url"
          MessageheaderDestinationEndpointReference(_) -> "Reference"
        },
        messageheader_destination_endpoint_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn messageheader_destination_decoder() -> Decoder(MessageheaderDestination) {
  use receiver <- decode.optional_field(
    "receiver",
    None,
    decode.optional(reference_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use endpoint <- decode.then(
    none_if_omitted(messageheader_destination_endpoint_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MessageheaderDestination(
    receiver:,
    target:,
    name:,
    endpoint:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn messageheader_to_json(messageheader: Messageheader) -> Json {
  let Messageheader(
    definition:,
    focus:,
    response:,
    reason:,
    responsible:,
    source:,
    author:,
    sender:,
    destination:,
    event:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = messageheader
  let fields = [
    #("source", messageheader_source_to_json(source)),
    #("event", messageheader_event_to_json(event)),
  ]
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case response {
    Some(v) -> [#("response", messageheader_response_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sender {
    Some(v) -> [#("sender", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    [] -> fields
    _ -> [
      #(
        "destination",
        json.array(destination, messageheader_destination_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Messageheader")), ..fields]
  json.object(fields)
}

pub fn messageheader_decoder() -> Decoder(Messageheader) {
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(messageheader_response_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use source <- decode.field("source", messageheader_source_decoder())
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use sender <- decode.optional_field(
    "sender",
    None,
    decode.optional(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    [],
    decode.list(messageheader_destination_decoder()),
  )
  use event <- decode.then(messageheader_event_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Messageheader",
    decode.failure(messageheader_new(source:, event:), "resourceType"),
  )
  decode.success(Messageheader(
    definition:,
    focus:,
    response:,
    reason:,
    responsible:,
    source:,
    author:,
    sender:,
    destination:,
    event:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MetadataResource#resource
pub type Metadataresource {
  Metadataresource(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(MetadataresourceVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MetadataResource#resource
pub type MetadataresourceVersionalgorithm {
  MetadataresourceVersionalgorithmString(version_algorithm: String)
  MetadataresourceVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn metadataresource_versionalgorithm_to_json(
  elt: MetadataresourceVersionalgorithm,
) -> Json {
  case elt {
    MetadataresourceVersionalgorithmString(v) -> json.string(v)
    MetadataresourceVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn metadataresource_versionalgorithm_decoder() -> Decoder(
  MetadataresourceVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(MetadataresourceVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(MetadataresourceVersionalgorithmCoding),
    ],
  )
}

pub fn metadataresource_new(
  status status: r5valuesets.Publicationstatus,
) -> Metadataresource {
  Metadataresource(
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn metadataresource_to_json(metadataresource: Metadataresource) -> Json {
  let Metadataresource(
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = metadataresource
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          MetadataresourceVersionalgorithmString(_) -> "String"
          MetadataresourceVersionalgorithmCoding(_) -> "Coding"
        },
        metadataresource_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Metadataresource")), ..fields]
  json.object(fields)
}

pub fn metadataresource_decoder() -> Decoder(Metadataresource) {
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(metadataresource_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Metadataresource",
    decode.failure(metadataresource_new(status:), "resourceType"),
  )
  decode.success(Metadataresource(
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/MolecularSequence#resource
pub type Molecularsequence {
  Molecularsequence(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(r5valuesets.Sequencetype),
    subject: Option(Reference),
    focus: List(Reference),
    specimen: Option(Reference),
    device: Option(Reference),
    performer: Option(Reference),
    literal: Option(String),
    formatted: List(Attachment),
    relative: List(MolecularsequenceRelative),
  )
}

pub fn molecularsequence_new() -> Molecularsequence {
  Molecularsequence(
    relative: [],
    formatted: [],
    literal: None,
    performer: None,
    device: None,
    specimen: None,
    focus: [],
    subject: None,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRelative {
  MolecularsequenceRelative(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    coordinate_system: Codeableconcept,
    ordinal_position: Option(Int),
    sequence_range: Option(Range),
    starting_sequence: Option(MolecularsequenceRelativeStartingsequence),
    edit: List(MolecularsequenceRelativeEdit),
  )
}

pub fn molecularsequence_relative_new(
  coordinate_system coordinate_system: Codeableconcept,
) -> MolecularsequenceRelative {
  MolecularsequenceRelative(
    edit: [],
    starting_sequence: None,
    sequence_range: None,
    ordinal_position: None,
    coordinate_system:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRelativeStartingsequence {
  MolecularsequenceRelativeStartingsequence(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    genome_assembly: Option(Codeableconcept),
    chromosome: Option(Codeableconcept),
    sequence: Option(MolecularsequenceRelativeStartingsequenceSequence),
    window_start: Option(Int),
    window_end: Option(Int),
    orientation: Option(r5valuesets.Orientationtype),
    strand: Option(r5valuesets.Strandtype),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRelativeStartingsequenceSequence {
  MolecularsequenceRelativeStartingsequenceSequenceCodeableconcept(
    sequence: Codeableconcept,
  )
  MolecularsequenceRelativeStartingsequenceSequenceString(sequence: String)
  MolecularsequenceRelativeStartingsequenceSequenceReference(
    sequence: Reference,
  )
}

pub fn molecularsequence_relative_startingsequence_sequence_to_json(
  elt: MolecularsequenceRelativeStartingsequenceSequence,
) -> Json {
  case elt {
    MolecularsequenceRelativeStartingsequenceSequenceCodeableconcept(v) ->
      codeableconcept_to_json(v)
    MolecularsequenceRelativeStartingsequenceSequenceString(v) -> json.string(v)
    MolecularsequenceRelativeStartingsequenceSequenceReference(v) ->
      reference_to_json(v)
  }
}

pub fn molecularsequence_relative_startingsequence_sequence_decoder() -> Decoder(
  MolecularsequenceRelativeStartingsequenceSequence,
) {
  decode.one_of(
    decode.field(
      "sequenceCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        MolecularsequenceRelativeStartingsequenceSequenceCodeableconcept,
      ),
    [
      decode.field("sequenceString", decode.string, decode.success)
        |> decode.map(MolecularsequenceRelativeStartingsequenceSequenceString),
      decode.field("sequenceReference", reference_decoder(), decode.success)
        |> decode.map(
          MolecularsequenceRelativeStartingsequenceSequenceReference,
        ),
    ],
  )
}

pub fn molecularsequence_relative_startingsequence_new() -> MolecularsequenceRelativeStartingsequence {
  MolecularsequenceRelativeStartingsequence(
    strand: None,
    orientation: None,
    window_end: None,
    window_start: None,
    sequence: None,
    chromosome: None,
    genome_assembly: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/MolecularSequence#resource
pub type MolecularsequenceRelativeEdit {
  MolecularsequenceRelativeEdit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    start: Option(Int),
    end: Option(Int),
    replacement_sequence: Option(String),
    replaced_sequence: Option(String),
  )
}

pub fn molecularsequence_relative_edit_new() -> MolecularsequenceRelativeEdit {
  MolecularsequenceRelativeEdit(
    replaced_sequence: None,
    replacement_sequence: None,
    end: None,
    start: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn molecularsequence_relative_edit_to_json(
  molecularsequence_relative_edit: MolecularsequenceRelativeEdit,
) -> Json {
  let MolecularsequenceRelativeEdit(
    replaced_sequence:,
    replacement_sequence:,
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_relative_edit
  let fields = []
  let fields = case replaced_sequence {
    Some(v) -> [#("replacedSequence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case replacement_sequence {
    Some(v) -> [#("replacementSequence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case start {
    Some(v) -> [#("start", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_relative_edit_decoder() -> Decoder(
  MolecularsequenceRelativeEdit,
) {
  use replaced_sequence <- decode.optional_field(
    "replacedSequence",
    None,
    decode.optional(decode.string),
  )
  use replacement_sequence <- decode.optional_field(
    "replacementSequence",
    None,
    decode.optional(decode.string),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.int))
  use start <- decode.optional_field("start", None, decode.optional(decode.int))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceRelativeEdit(
    replaced_sequence:,
    replacement_sequence:,
    end:,
    start:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_relative_startingsequence_to_json(
  molecularsequence_relative_startingsequence: MolecularsequenceRelativeStartingsequence,
) -> Json {
  let MolecularsequenceRelativeStartingsequence(
    strand:,
    orientation:,
    window_end:,
    window_start:,
    sequence:,
    chromosome:,
    genome_assembly:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_relative_startingsequence
  let fields = []
  let fields = case strand {
    Some(v) -> [#("strand", r5valuesets.strandtype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case orientation {
    Some(v) -> [
      #("orientation", r5valuesets.orientationtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case window_end {
    Some(v) -> [#("windowEnd", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case window_start {
    Some(v) -> [#("windowStart", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [
      #(
        "sequence"
          <> case v {
          MolecularsequenceRelativeStartingsequenceSequenceCodeableconcept(_) ->
            "Codeableconcept"
          MolecularsequenceRelativeStartingsequenceSequenceString(_) -> "String"
          MolecularsequenceRelativeStartingsequenceSequenceReference(_) ->
            "Reference"
        },
        molecularsequence_relative_startingsequence_sequence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case chromosome {
    Some(v) -> [#("chromosome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case genome_assembly {
    Some(v) -> [#("genomeAssembly", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_relative_startingsequence_decoder() -> Decoder(
  MolecularsequenceRelativeStartingsequence,
) {
  use strand <- decode.optional_field(
    "strand",
    None,
    decode.optional(r5valuesets.strandtype_decoder()),
  )
  use orientation <- decode.optional_field(
    "orientation",
    None,
    decode.optional(r5valuesets.orientationtype_decoder()),
  )
  use window_end <- decode.optional_field(
    "windowEnd",
    None,
    decode.optional(decode.int),
  )
  use window_start <- decode.optional_field(
    "windowStart",
    None,
    decode.optional(decode.int),
  )
  use sequence <- decode.then(
    none_if_omitted(
      molecularsequence_relative_startingsequence_sequence_decoder(),
    ),
  )
  use chromosome <- decode.optional_field(
    "chromosome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use genome_assembly <- decode.optional_field(
    "genomeAssembly",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceRelativeStartingsequence(
    strand:,
    orientation:,
    window_end:,
    window_start:,
    sequence:,
    chromosome:,
    genome_assembly:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_relative_to_json(
  molecularsequence_relative: MolecularsequenceRelative,
) -> Json {
  let MolecularsequenceRelative(
    edit:,
    starting_sequence:,
    sequence_range:,
    ordinal_position:,
    coordinate_system:,
    modifier_extension:,
    extension:,
    id:,
  ) = molecularsequence_relative
  let fields = [
    #("coordinateSystem", codeableconcept_to_json(coordinate_system)),
  ]
  let fields = case edit {
    [] -> fields
    _ -> [
      #("edit", json.array(edit, molecularsequence_relative_edit_to_json)),
      ..fields
    ]
  }
  let fields = case starting_sequence {
    Some(v) -> [
      #(
        "startingSequence",
        molecularsequence_relative_startingsequence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case sequence_range {
    Some(v) -> [#("sequenceRange", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ordinal_position {
    Some(v) -> [#("ordinalPosition", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn molecularsequence_relative_decoder() -> Decoder(
  MolecularsequenceRelative,
) {
  use edit <- decode.optional_field(
    "edit",
    [],
    decode.list(molecularsequence_relative_edit_decoder()),
  )
  use starting_sequence <- decode.optional_field(
    "startingSequence",
    None,
    decode.optional(molecularsequence_relative_startingsequence_decoder()),
  )
  use sequence_range <- decode.optional_field(
    "sequenceRange",
    None,
    decode.optional(range_decoder()),
  )
  use ordinal_position <- decode.optional_field(
    "ordinalPosition",
    None,
    decode.optional(decode.int),
  )
  use coordinate_system <- decode.field(
    "coordinateSystem",
    codeableconcept_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(MolecularsequenceRelative(
    edit:,
    starting_sequence:,
    sequence_range:,
    ordinal_position:,
    coordinate_system:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn molecularsequence_to_json(molecularsequence: Molecularsequence) -> Json {
  let Molecularsequence(
    relative:,
    formatted:,
    literal:,
    performer:,
    device:,
    specimen:,
    focus:,
    subject:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = molecularsequence
  let fields = []
  let fields = case relative {
    [] -> fields
    _ -> [
      #("relative", json.array(relative, molecularsequence_relative_to_json)),
      ..fields
    ]
  }
  let fields = case formatted {
    [] -> fields
    _ -> [#("formatted", json.array(formatted, attachment_to_json)), ..fields]
  }
  let fields = case literal {
    Some(v) -> [#("literal", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r5valuesets.sequencetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Molecularsequence")), ..fields]
  json.object(fields)
}

pub fn molecularsequence_decoder() -> Decoder(Molecularsequence) {
  use relative <- decode.optional_field(
    "relative",
    [],
    decode.list(molecularsequence_relative_decoder()),
  )
  use formatted <- decode.optional_field(
    "formatted",
    [],
    decode.list(attachment_decoder()),
  )
  use literal <- decode.optional_field(
    "literal",
    None,
    decode.optional(decode.string),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.sequencetype_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Molecularsequence",
    decode.failure(molecularsequence_new(), "resourceType"),
  )
  decode.success(Molecularsequence(
    relative:,
    formatted:,
    literal:,
    performer:,
    device:,
    specimen:,
    focus:,
    subject:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/NamingSystem#resource
pub type Namingsystem {
  Namingsystem(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(NamingsystemVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    kind: r5valuesets.Namingsystemtype,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    responsible: Option(String),
    type_: Option(Codeableconcept),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    usage: Option(String),
    unique_id: List(NamingsystemUniqueid),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NamingSystem#resource
pub type NamingsystemVersionalgorithm {
  NamingsystemVersionalgorithmString(version_algorithm: String)
  NamingsystemVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn namingsystem_versionalgorithm_to_json(
  elt: NamingsystemVersionalgorithm,
) -> Json {
  case elt {
    NamingsystemVersionalgorithmString(v) -> json.string(v)
    NamingsystemVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn namingsystem_versionalgorithm_decoder() -> Decoder(
  NamingsystemVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(NamingsystemVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(NamingsystemVersionalgorithmCoding),
    ],
  )
}

pub fn namingsystem_new(
  date date: String,
  kind kind: r5valuesets.Namingsystemtype,
  status status: r5valuesets.Publicationstatus,
  name name: String,
) -> Namingsystem {
  Namingsystem(
    unique_id: [],
    usage: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    type_: None,
    responsible: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    kind:,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NamingSystem#resource
pub type NamingsystemUniqueid {
  NamingsystemUniqueid(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Namingsystemidentifiertype,
    value: String,
    preferred: Option(Bool),
    comment: Option(String),
    period: Option(Period),
    authoritative: Option(Bool),
  )
}

pub fn namingsystem_uniqueid_new(
  value value: String,
  type_ type_: r5valuesets.Namingsystemidentifiertype,
) -> NamingsystemUniqueid {
  NamingsystemUniqueid(
    authoritative: None,
    period: None,
    comment: None,
    preferred: None,
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn namingsystem_uniqueid_to_json(
  namingsystem_uniqueid: NamingsystemUniqueid,
) -> Json {
  let NamingsystemUniqueid(
    authoritative:,
    period:,
    comment:,
    preferred:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = namingsystem_uniqueid
  let fields = [
    #("value", json.string(value)),
    #("type", r5valuesets.namingsystemidentifiertype_to_json(type_)),
  ]
  let fields = case authoritative {
    Some(v) -> [#("authoritative", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn namingsystem_uniqueid_decoder() -> Decoder(NamingsystemUniqueid) {
  use authoritative <- decode.optional_field(
    "authoritative",
    None,
    decode.optional(decode.bool),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.field("value", decode.string)
  use type_ <- decode.field(
    "type",
    r5valuesets.namingsystemidentifiertype_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NamingsystemUniqueid(
    authoritative:,
    period:,
    comment:,
    preferred:,
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn namingsystem_to_json(namingsystem: Namingsystem) -> Json {
  let Namingsystem(
    unique_id:,
    usage:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    type_:,
    responsible:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = namingsystem
  let fields = [
    #("date", json.string(date)),
    #("kind", r5valuesets.namingsystemtype_to_json(kind)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case unique_id {
    [] -> fields
    _ -> [
      #("uniqueId", json.array(unique_id, namingsystem_uniqueid_to_json)),
      ..fields
    ]
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          NamingsystemVersionalgorithmString(_) -> "String"
          NamingsystemVersionalgorithmCoding(_) -> "Coding"
        },
        namingsystem_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Namingsystem")), ..fields]
  json.object(fields)
}

pub fn namingsystem_decoder() -> Decoder(Namingsystem) {
  use unique_id <- decode.optional_field(
    "uniqueId",
    [],
    decode.list(namingsystem_uniqueid_decoder()),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use kind <- decode.field("kind", r5valuesets.namingsystemtype_decoder())
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(namingsystem_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Namingsystem",
    decode.failure(
      namingsystem_new(date:, kind:, status:, name:),
      "resourceType",
    ),
  )
  decode.success(Namingsystem(
    unique_id:,
    usage:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    type_:,
    responsible:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type Nutritionintake {
  Nutritionintake(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Eventstatus,
    status_reason: List(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(NutritionintakeOccurrence),
    recorded: Option(String),
    reported: Option(NutritionintakeReported),
    consumed_item: List(NutritionintakeConsumeditem),
    ingredient_label: List(NutritionintakeIngredientlabel),
    performer: List(NutritionintakePerformer),
    location: Option(Reference),
    derived_from: List(Reference),
    reason: List(Codeablereference),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type NutritionintakeOccurrence {
  NutritionintakeOccurrenceDatetime(occurrence: String)
  NutritionintakeOccurrencePeriod(occurrence: Period)
}

pub fn nutritionintake_occurrence_to_json(
  elt: NutritionintakeOccurrence,
) -> Json {
  case elt {
    NutritionintakeOccurrenceDatetime(v) -> json.string(v)
    NutritionintakeOccurrencePeriod(v) -> period_to_json(v)
  }
}

pub fn nutritionintake_occurrence_decoder() -> Decoder(
  NutritionintakeOccurrence,
) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(NutritionintakeOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
      |> decode.map(NutritionintakeOccurrencePeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type NutritionintakeReported {
  NutritionintakeReportedBoolean(reported: Bool)
  NutritionintakeReportedReference(reported: Reference)
}

pub fn nutritionintake_reported_to_json(elt: NutritionintakeReported) -> Json {
  case elt {
    NutritionintakeReportedBoolean(v) -> json.bool(v)
    NutritionintakeReportedReference(v) -> reference_to_json(v)
  }
}

pub fn nutritionintake_reported_decoder() -> Decoder(NutritionintakeReported) {
  decode.one_of(
    decode.field("reportedBoolean", decode.bool, decode.success)
      |> decode.map(NutritionintakeReportedBoolean),
    [
      decode.field("reportedReference", reference_decoder(), decode.success)
      |> decode.map(NutritionintakeReportedReference),
    ],
  )
}

pub fn nutritionintake_new(
  subject subject: Reference,
  status status: r5valuesets.Eventstatus,
) -> Nutritionintake {
  Nutritionintake(
    note: [],
    reason: [],
    derived_from: [],
    location: None,
    performer: [],
    ingredient_label: [],
    consumed_item: [],
    reported: None,
    recorded: None,
    occurrence: None,
    encounter: None,
    subject:,
    code: None,
    status_reason: [],
    status:,
    part_of: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type NutritionintakeConsumeditem {
  NutritionintakeConsumeditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    nutrition_product: Codeablereference,
    schedule: Option(Timing),
    amount: Option(Quantity),
    rate: Option(Quantity),
    not_consumed: Option(Bool),
    not_consumed_reason: Option(Codeableconcept),
  )
}

pub fn nutritionintake_consumeditem_new(
  nutrition_product nutrition_product: Codeablereference,
  type_ type_: Codeableconcept,
) -> NutritionintakeConsumeditem {
  NutritionintakeConsumeditem(
    not_consumed_reason: None,
    not_consumed: None,
    rate: None,
    amount: None,
    schedule: None,
    nutrition_product:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type NutritionintakeIngredientlabel {
  NutritionintakeIngredientlabel(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    nutrient: Codeablereference,
    amount: Quantity,
  )
}

pub fn nutritionintake_ingredientlabel_new(
  amount amount: Quantity,
  nutrient nutrient: Codeablereference,
) -> NutritionintakeIngredientlabel {
  NutritionintakeIngredientlabel(
    amount:,
    nutrient:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionIntake#resource
pub type NutritionintakePerformer {
  NutritionintakePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn nutritionintake_performer_new(
  actor actor: Reference,
) -> NutritionintakePerformer {
  NutritionintakePerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn nutritionintake_performer_to_json(
  nutritionintake_performer: NutritionintakePerformer,
) -> Json {
  let NutritionintakePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionintake_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionintake_performer_decoder() -> Decoder(NutritionintakePerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionintakePerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionintake_ingredientlabel_to_json(
  nutritionintake_ingredientlabel: NutritionintakeIngredientlabel,
) -> Json {
  let NutritionintakeIngredientlabel(
    amount:,
    nutrient:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionintake_ingredientlabel
  let fields = [
    #("amount", quantity_to_json(amount)),
    #("nutrient", codeablereference_to_json(nutrient)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionintake_ingredientlabel_decoder() -> Decoder(
  NutritionintakeIngredientlabel,
) {
  use amount <- decode.field("amount", quantity_decoder())
  use nutrient <- decode.field("nutrient", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionintakeIngredientlabel(
    amount:,
    nutrient:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionintake_consumeditem_to_json(
  nutritionintake_consumeditem: NutritionintakeConsumeditem,
) -> Json {
  let NutritionintakeConsumeditem(
    not_consumed_reason:,
    not_consumed:,
    rate:,
    amount:,
    schedule:,
    nutrition_product:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionintake_consumeditem
  let fields = [
    #("nutritionProduct", codeablereference_to_json(nutrition_product)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case not_consumed_reason {
    Some(v) -> [#("notConsumedReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case not_consumed {
    Some(v) -> [#("notConsumed", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case rate {
    Some(v) -> [#("rate", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case schedule {
    Some(v) -> [#("schedule", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionintake_consumeditem_decoder() -> Decoder(
  NutritionintakeConsumeditem,
) {
  use not_consumed_reason <- decode.optional_field(
    "notConsumedReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use not_consumed <- decode.optional_field(
    "notConsumed",
    None,
    decode.optional(decode.bool),
  )
  use rate <- decode.optional_field(
    "rate",
    None,
    decode.optional(quantity_decoder()),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    None,
    decode.optional(timing_decoder()),
  )
  use nutrition_product <- decode.field(
    "nutritionProduct",
    codeablereference_decoder(),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionintakeConsumeditem(
    not_consumed_reason:,
    not_consumed:,
    rate:,
    amount:,
    schedule:,
    nutrition_product:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionintake_to_json(nutritionintake: Nutritionintake) -> Json {
  let Nutritionintake(
    note:,
    reason:,
    derived_from:,
    location:,
    performer:,
    ingredient_label:,
    consumed_item:,
    reported:,
    recorded:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = nutritionintake
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.eventstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, nutritionintake_performer_to_json)),
      ..fields
    ]
  }
  let fields = case ingredient_label {
    [] -> fields
    _ -> [
      #(
        "ingredientLabel",
        json.array(ingredient_label, nutritionintake_ingredientlabel_to_json),
      ),
      ..fields
    ]
  }
  let fields = case consumed_item {
    [] -> fields
    _ -> [
      #(
        "consumedItem",
        json.array(consumed_item, nutritionintake_consumeditem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case reported {
    Some(v) -> [
      #(
        "reported"
          <> case v {
          NutritionintakeReportedBoolean(_) -> "Boolean"
          NutritionintakeReportedReference(_) -> "Reference"
        },
        nutritionintake_reported_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          NutritionintakeOccurrenceDatetime(_) -> "Datetime"
          NutritionintakeOccurrencePeriod(_) -> "Period"
        },
        nutritionintake_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    [] -> fields
    _ -> [
      #("statusReason", json.array(status_reason, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Nutritionintake")), ..fields]
  json.object(fields)
}

pub fn nutritionintake_decoder() -> Decoder(Nutritionintake) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(nutritionintake_performer_decoder()),
  )
  use ingredient_label <- decode.optional_field(
    "ingredientLabel",
    [],
    decode.list(nutritionintake_ingredientlabel_decoder()),
  )
  use consumed_item <- decode.optional_field(
    "consumedItem",
    [],
    decode.list(nutritionintake_consumeditem_decoder()),
  )
  use reported <- decode.then(
    none_if_omitted(nutritionintake_reported_decoder()),
  )
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(nutritionintake_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.eventstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Nutritionintake",
    decode.failure(nutritionintake_new(subject:, status:), "resourceType"),
  )
  decode.success(Nutritionintake(
    note:,
    reason:,
    derived_from:,
    location:,
    performer:,
    ingredient_label:,
    consumed_item:,
    reported:,
    recorded:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type Nutritionorder {
  Nutritionorder(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    instantiates: List(String),
    based_on: List(Reference),
    group_identifier: Option(Identifier),
    status: r5valuesets.Requeststatus,
    intent: r5valuesets.Requestintent,
    priority: Option(r5valuesets.Requestpriority),
    subject: Reference,
    encounter: Option(Reference),
    supporting_information: List(Reference),
    date_time: String,
    orderer: Option(Reference),
    performer: List(Codeablereference),
    allergy_intolerance: List(Reference),
    food_preference_modifier: List(Codeableconcept),
    exclude_food_modifier: List(Codeableconcept),
    outside_food_allowed: Option(Bool),
    oral_diet: Option(NutritionorderOraldiet),
    supplement: List(NutritionorderSupplement),
    enteral_formula: Option(NutritionorderEnteralformula),
    note: List(Annotation),
  )
}

pub fn nutritionorder_new(
  date_time date_time: String,
  subject subject: Reference,
  intent intent: r5valuesets.Requestintent,
  status status: r5valuesets.Requeststatus,
) -> Nutritionorder {
  Nutritionorder(
    note: [],
    enteral_formula: None,
    supplement: [],
    oral_diet: None,
    outside_food_allowed: None,
    exclude_food_modifier: [],
    food_preference_modifier: [],
    allergy_intolerance: [],
    performer: [],
    orderer: None,
    date_time:,
    supporting_information: [],
    encounter: None,
    subject:,
    priority: None,
    intent:,
    status:,
    group_identifier: None,
    based_on: [],
    instantiates: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldiet {
  NutritionorderOraldiet(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    schedule: Option(NutritionorderOraldietSchedule),
    nutrient: List(NutritionorderOraldietNutrient),
    texture: List(NutritionorderOraldietTexture),
    fluid_consistency_type: List(Codeableconcept),
    instruction: Option(String),
  )
}

pub fn nutritionorder_oraldiet_new() -> NutritionorderOraldiet {
  NutritionorderOraldiet(
    instruction: None,
    fluid_consistency_type: [],
    texture: [],
    nutrient: [],
    schedule: None,
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietSchedule {
  NutritionorderOraldietSchedule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    timing: List(Timing),
    as_needed: Option(Bool),
    as_needed_for: Option(Codeableconcept),
  )
}

pub fn nutritionorder_oraldiet_schedule_new() -> NutritionorderOraldietSchedule {
  NutritionorderOraldietSchedule(
    as_needed_for: None,
    as_needed: None,
    timing: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietNutrient {
  NutritionorderOraldietNutrient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    modifier: Option(Codeableconcept),
    amount: Option(Quantity),
  )
}

pub fn nutritionorder_oraldiet_nutrient_new() -> NutritionorderOraldietNutrient {
  NutritionorderOraldietNutrient(
    amount: None,
    modifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderOraldietTexture {
  NutritionorderOraldietTexture(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    modifier: Option(Codeableconcept),
    food_type: Option(Codeableconcept),
  )
}

pub fn nutritionorder_oraldiet_texture_new() -> NutritionorderOraldietTexture {
  NutritionorderOraldietTexture(
    food_type: None,
    modifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderSupplement {
  NutritionorderSupplement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeablereference),
    product_name: Option(String),
    schedule: Option(NutritionorderSupplementSchedule),
    quantity: Option(Quantity),
    instruction: Option(String),
  )
}

pub fn nutritionorder_supplement_new() -> NutritionorderSupplement {
  NutritionorderSupplement(
    instruction: None,
    quantity: None,
    schedule: None,
    product_name: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderSupplementSchedule {
  NutritionorderSupplementSchedule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    timing: List(Timing),
    as_needed: Option(Bool),
    as_needed_for: Option(Codeableconcept),
  )
}

pub fn nutritionorder_supplement_schedule_new() -> NutritionorderSupplementSchedule {
  NutritionorderSupplementSchedule(
    as_needed_for: None,
    as_needed: None,
    timing: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformula {
  NutritionorderEnteralformula(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    base_formula_type: Option(Codeablereference),
    base_formula_product_name: Option(String),
    delivery_device: List(Codeablereference),
    additive: List(NutritionorderEnteralformulaAdditive),
    caloric_density: Option(Quantity),
    route_of_administration: Option(Codeableconcept),
    administration: List(NutritionorderEnteralformulaAdministration),
    max_volume_to_deliver: Option(Quantity),
    administration_instruction: Option(String),
  )
}

pub fn nutritionorder_enteralformula_new() -> NutritionorderEnteralformula {
  NutritionorderEnteralformula(
    administration_instruction: None,
    max_volume_to_deliver: None,
    administration: [],
    route_of_administration: None,
    caloric_density: None,
    additive: [],
    delivery_device: [],
    base_formula_product_name: None,
    base_formula_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdditive {
  NutritionorderEnteralformulaAdditive(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeablereference),
    product_name: Option(String),
    quantity: Option(Quantity),
  )
}

pub fn nutritionorder_enteralformula_additive_new() -> NutritionorderEnteralformulaAdditive {
  NutritionorderEnteralformulaAdditive(
    quantity: None,
    product_name: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministration {
  NutritionorderEnteralformulaAdministration(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    schedule: Option(NutritionorderEnteralformulaAdministrationSchedule),
    quantity: Option(Quantity),
    rate: Option(NutritionorderEnteralformulaAdministrationRate),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministrationRate {
  NutritionorderEnteralformulaAdministrationRateQuantity(rate: Quantity)
  NutritionorderEnteralformulaAdministrationRateRatio(rate: Ratio)
}

pub fn nutritionorder_enteralformula_administration_rate_to_json(
  elt: NutritionorderEnteralformulaAdministrationRate,
) -> Json {
  case elt {
    NutritionorderEnteralformulaAdministrationRateQuantity(v) ->
      quantity_to_json(v)
    NutritionorderEnteralformulaAdministrationRateRatio(v) -> ratio_to_json(v)
  }
}

pub fn nutritionorder_enteralformula_administration_rate_decoder() -> Decoder(
  NutritionorderEnteralformulaAdministrationRate,
) {
  decode.one_of(
    decode.field("rateQuantity", quantity_decoder(), decode.success)
      |> decode.map(NutritionorderEnteralformulaAdministrationRateQuantity),
    [
      decode.field("rateRatio", ratio_decoder(), decode.success)
      |> decode.map(NutritionorderEnteralformulaAdministrationRateRatio),
    ],
  )
}

pub fn nutritionorder_enteralformula_administration_new() -> NutritionorderEnteralformulaAdministration {
  NutritionorderEnteralformulaAdministration(
    rate: None,
    quantity: None,
    schedule: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionOrder#resource
pub type NutritionorderEnteralformulaAdministrationSchedule {
  NutritionorderEnteralformulaAdministrationSchedule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    timing: List(Timing),
    as_needed: Option(Bool),
    as_needed_for: Option(Codeableconcept),
  )
}

pub fn nutritionorder_enteralformula_administration_schedule_new() -> NutritionorderEnteralformulaAdministrationSchedule {
  NutritionorderEnteralformulaAdministrationSchedule(
    as_needed_for: None,
    as_needed: None,
    timing: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn nutritionorder_enteralformula_administration_schedule_to_json(
  nutritionorder_enteralformula_administration_schedule: NutritionorderEnteralformulaAdministrationSchedule,
) -> Json {
  let NutritionorderEnteralformulaAdministrationSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula_administration_schedule
  let fields = []
  let fields = case as_needed_for {
    Some(v) -> [#("asNeededFor", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [#("asNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    [] -> fields
    _ -> [#("timing", json.array(timing, timing_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_administration_schedule_decoder() -> Decoder(
  NutritionorderEnteralformulaAdministrationSchedule,
) {
  use as_needed_for <- decode.optional_field(
    "asNeededFor",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed <- decode.optional_field(
    "asNeeded",
    None,
    decode.optional(decode.bool),
  )
  use timing <- decode.optional_field(
    "timing",
    [],
    decode.list(timing_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformulaAdministrationSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_enteralformula_administration_to_json(
  nutritionorder_enteralformula_administration: NutritionorderEnteralformulaAdministration,
) -> Json {
  let NutritionorderEnteralformulaAdministration(
    rate:,
    quantity:,
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula_administration
  let fields = []
  let fields = case rate {
    Some(v) -> [
      #(
        "rate"
          <> case v {
          NutritionorderEnteralformulaAdministrationRateQuantity(_) ->
            "Quantity"
          NutritionorderEnteralformulaAdministrationRateRatio(_) -> "Ratio"
        },
        nutritionorder_enteralformula_administration_rate_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case schedule {
    Some(v) -> [
      #(
        "schedule",
        nutritionorder_enteralformula_administration_schedule_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_administration_decoder() -> Decoder(
  NutritionorderEnteralformulaAdministration,
) {
  use rate <- decode.then(
    none_if_omitted(nutritionorder_enteralformula_administration_rate_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    None,
    decode.optional(
      nutritionorder_enteralformula_administration_schedule_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformulaAdministration(
    rate:,
    quantity:,
    schedule:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_enteralformula_additive_to_json(
  nutritionorder_enteralformula_additive: NutritionorderEnteralformulaAdditive,
) -> Json {
  let NutritionorderEnteralformulaAdditive(
    quantity:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula_additive
  let fields = []
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case product_name {
    Some(v) -> [#("productName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_additive_decoder() -> Decoder(
  NutritionorderEnteralformulaAdditive,
) {
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use product_name <- decode.optional_field(
    "productName",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformulaAdditive(
    quantity:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_enteralformula_to_json(
  nutritionorder_enteralformula: NutritionorderEnteralformula,
) -> Json {
  let NutritionorderEnteralformula(
    administration_instruction:,
    max_volume_to_deliver:,
    administration:,
    route_of_administration:,
    caloric_density:,
    additive:,
    delivery_device:,
    base_formula_product_name:,
    base_formula_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_enteralformula
  let fields = []
  let fields = case administration_instruction {
    Some(v) -> [#("administrationInstruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_volume_to_deliver {
    Some(v) -> [#("maxVolumeToDeliver", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case administration {
    [] -> fields
    _ -> [
      #(
        "administration",
        json.array(
          administration,
          nutritionorder_enteralformula_administration_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case route_of_administration {
    Some(v) -> [
      #("routeOfAdministration", codeableconcept_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case caloric_density {
    Some(v) -> [#("caloricDensity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case additive {
    [] -> fields
    _ -> [
      #(
        "additive",
        json.array(additive, nutritionorder_enteralformula_additive_to_json),
      ),
      ..fields
    ]
  }
  let fields = case delivery_device {
    [] -> fields
    _ -> [
      #(
        "deliveryDevice",
        json.array(delivery_device, codeablereference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case base_formula_product_name {
    Some(v) -> [#("baseFormulaProductName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base_formula_type {
    Some(v) -> [#("baseFormulaType", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_enteralformula_decoder() -> Decoder(
  NutritionorderEnteralformula,
) {
  use administration_instruction <- decode.optional_field(
    "administrationInstruction",
    None,
    decode.optional(decode.string),
  )
  use max_volume_to_deliver <- decode.optional_field(
    "maxVolumeToDeliver",
    None,
    decode.optional(quantity_decoder()),
  )
  use administration <- decode.optional_field(
    "administration",
    [],
    decode.list(nutritionorder_enteralformula_administration_decoder()),
  )
  use route_of_administration <- decode.optional_field(
    "routeOfAdministration",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use caloric_density <- decode.optional_field(
    "caloricDensity",
    None,
    decode.optional(quantity_decoder()),
  )
  use additive <- decode.optional_field(
    "additive",
    [],
    decode.list(nutritionorder_enteralformula_additive_decoder()),
  )
  use delivery_device <- decode.optional_field(
    "deliveryDevice",
    [],
    decode.list(codeablereference_decoder()),
  )
  use base_formula_product_name <- decode.optional_field(
    "baseFormulaProductName",
    None,
    decode.optional(decode.string),
  )
  use base_formula_type <- decode.optional_field(
    "baseFormulaType",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderEnteralformula(
    administration_instruction:,
    max_volume_to_deliver:,
    administration:,
    route_of_administration:,
    caloric_density:,
    additive:,
    delivery_device:,
    base_formula_product_name:,
    base_formula_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_supplement_schedule_to_json(
  nutritionorder_supplement_schedule: NutritionorderSupplementSchedule,
) -> Json {
  let NutritionorderSupplementSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_supplement_schedule
  let fields = []
  let fields = case as_needed_for {
    Some(v) -> [#("asNeededFor", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [#("asNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    [] -> fields
    _ -> [#("timing", json.array(timing, timing_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_supplement_schedule_decoder() -> Decoder(
  NutritionorderSupplementSchedule,
) {
  use as_needed_for <- decode.optional_field(
    "asNeededFor",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed <- decode.optional_field(
    "asNeeded",
    None,
    decode.optional(decode.bool),
  )
  use timing <- decode.optional_field(
    "timing",
    [],
    decode.list(timing_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderSupplementSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_supplement_to_json(
  nutritionorder_supplement: NutritionorderSupplement,
) -> Json {
  let NutritionorderSupplement(
    instruction:,
    quantity:,
    schedule:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_supplement
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case schedule {
    Some(v) -> [
      #("schedule", nutritionorder_supplement_schedule_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case product_name {
    Some(v) -> [#("productName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_supplement_decoder() -> Decoder(NutritionorderSupplement) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    None,
    decode.optional(nutritionorder_supplement_schedule_decoder()),
  )
  use product_name <- decode.optional_field(
    "productName",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderSupplement(
    instruction:,
    quantity:,
    schedule:,
    product_name:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_texture_to_json(
  nutritionorder_oraldiet_texture: NutritionorderOraldietTexture,
) -> Json {
  let NutritionorderOraldietTexture(
    food_type:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet_texture
  let fields = []
  let fields = case food_type {
    Some(v) -> [#("foodType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_texture_decoder() -> Decoder(
  NutritionorderOraldietTexture,
) {
  use food_type <- decode.optional_field(
    "foodType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldietTexture(
    food_type:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_nutrient_to_json(
  nutritionorder_oraldiet_nutrient: NutritionorderOraldietNutrient,
) -> Json {
  let NutritionorderOraldietNutrient(
    amount:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet_nutrient
  let fields = []
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier {
    Some(v) -> [#("modifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_nutrient_decoder() -> Decoder(
  NutritionorderOraldietNutrient,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier <- decode.optional_field(
    "modifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldietNutrient(
    amount:,
    modifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_schedule_to_json(
  nutritionorder_oraldiet_schedule: NutritionorderOraldietSchedule,
) -> Json {
  let NutritionorderOraldietSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet_schedule
  let fields = []
  let fields = case as_needed_for {
    Some(v) -> [#("asNeededFor", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [#("asNeeded", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    [] -> fields
    _ -> [#("timing", json.array(timing, timing_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_schedule_decoder() -> Decoder(
  NutritionorderOraldietSchedule,
) {
  use as_needed_for <- decode.optional_field(
    "asNeededFor",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use as_needed <- decode.optional_field(
    "asNeeded",
    None,
    decode.optional(decode.bool),
  )
  use timing <- decode.optional_field(
    "timing",
    [],
    decode.list(timing_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldietSchedule(
    as_needed_for:,
    as_needed:,
    timing:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_oraldiet_to_json(
  nutritionorder_oraldiet: NutritionorderOraldiet,
) -> Json {
  let NutritionorderOraldiet(
    instruction:,
    fluid_consistency_type:,
    texture:,
    nutrient:,
    schedule:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionorder_oraldiet
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case fluid_consistency_type {
    [] -> fields
    _ -> [
      #(
        "fluidConsistencyType",
        json.array(fluid_consistency_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case texture {
    [] -> fields
    _ -> [
      #("texture", json.array(texture, nutritionorder_oraldiet_texture_to_json)),
      ..fields
    ]
  }
  let fields = case nutrient {
    [] -> fields
    _ -> [
      #(
        "nutrient",
        json.array(nutrient, nutritionorder_oraldiet_nutrient_to_json),
      ),
      ..fields
    ]
  }
  let fields = case schedule {
    Some(v) -> [
      #("schedule", nutritionorder_oraldiet_schedule_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionorder_oraldiet_decoder() -> Decoder(NutritionorderOraldiet) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use fluid_consistency_type <- decode.optional_field(
    "fluidConsistencyType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use texture <- decode.optional_field(
    "texture",
    [],
    decode.list(nutritionorder_oraldiet_texture_decoder()),
  )
  use nutrient <- decode.optional_field(
    "nutrient",
    [],
    decode.list(nutritionorder_oraldiet_nutrient_decoder()),
  )
  use schedule <- decode.optional_field(
    "schedule",
    None,
    decode.optional(nutritionorder_oraldiet_schedule_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionorderOraldiet(
    instruction:,
    fluid_consistency_type:,
    texture:,
    nutrient:,
    schedule:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionorder_to_json(nutritionorder: Nutritionorder) -> Json {
  let Nutritionorder(
    note:,
    enteral_formula:,
    supplement:,
    oral_diet:,
    outside_food_allowed:,
    exclude_food_modifier:,
    food_preference_modifier:,
    allergy_intolerance:,
    performer:,
    orderer:,
    date_time:,
    supporting_information:,
    encounter:,
    subject:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    based_on:,
    instantiates:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = nutritionorder
  let fields = [
    #("dateTime", json.string(date_time)),
    #("subject", reference_to_json(subject)),
    #("intent", r5valuesets.requestintent_to_json(intent)),
    #("status", r5valuesets.requeststatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case enteral_formula {
    Some(v) -> [
      #("enteralFormula", nutritionorder_enteralformula_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case supplement {
    [] -> fields
    _ -> [
      #("supplement", json.array(supplement, nutritionorder_supplement_to_json)),
      ..fields
    ]
  }
  let fields = case oral_diet {
    Some(v) -> [#("oralDiet", nutritionorder_oraldiet_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case outside_food_allowed {
    Some(v) -> [#("outsideFoodAllowed", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case exclude_food_modifier {
    [] -> fields
    _ -> [
      #(
        "excludeFoodModifier",
        json.array(exclude_food_modifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case food_preference_modifier {
    [] -> fields
    _ -> [
      #(
        "foodPreferenceModifier",
        json.array(food_preference_modifier, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case allergy_intolerance {
    [] -> fields
    _ -> [
      #(
        "allergyIntolerance",
        json.array(allergy_intolerance, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case orderer {
    Some(v) -> [#("orderer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supporting_information {
    [] -> fields
    _ -> [
      #(
        "supportingInformation",
        json.array(supporting_information, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates {
    [] -> fields
    _ -> [#("instantiates", json.array(instantiates, json.string)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Nutritionorder")), ..fields]
  json.object(fields)
}

pub fn nutritionorder_decoder() -> Decoder(Nutritionorder) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use enteral_formula <- decode.optional_field(
    "enteralFormula",
    None,
    decode.optional(nutritionorder_enteralformula_decoder()),
  )
  use supplement <- decode.optional_field(
    "supplement",
    [],
    decode.list(nutritionorder_supplement_decoder()),
  )
  use oral_diet <- decode.optional_field(
    "oralDiet",
    None,
    decode.optional(nutritionorder_oraldiet_decoder()),
  )
  use outside_food_allowed <- decode.optional_field(
    "outsideFoodAllowed",
    None,
    decode.optional(decode.bool),
  )
  use exclude_food_modifier <- decode.optional_field(
    "excludeFoodModifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use food_preference_modifier <- decode.optional_field(
    "foodPreferenceModifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use allergy_intolerance <- decode.optional_field(
    "allergyIntolerance",
    [],
    decode.list(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(codeablereference_decoder()),
  )
  use orderer <- decode.optional_field(
    "orderer",
    None,
    decode.optional(reference_decoder()),
  )
  use date_time <- decode.field("dateTime", decode.string)
  use supporting_information <- decode.optional_field(
    "supportingInformation",
    [],
    decode.list(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.requestintent_decoder())
  use status <- decode.field("status", r5valuesets.requeststatus_decoder())
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates <- decode.optional_field(
    "instantiates",
    [],
    decode.list(decode.string),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Nutritionorder",
    decode.failure(
      nutritionorder_new(date_time:, subject:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Nutritionorder(
    note:,
    enteral_formula:,
    supplement:,
    oral_diet:,
    outside_food_allowed:,
    exclude_food_modifier:,
    food_preference_modifier:,
    allergy_intolerance:,
    performer:,
    orderer:,
    date_time:,
    supporting_information:,
    encounter:,
    subject:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    based_on:,
    instantiates:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type Nutritionproduct {
  Nutritionproduct(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    status: r5valuesets.Nutritionproductstatus,
    category: List(Codeableconcept),
    manufacturer: List(Reference),
    nutrient: List(NutritionproductNutrient),
    ingredient: List(NutritionproductIngredient),
    known_allergen: List(Codeablereference),
    characteristic: List(NutritionproductCharacteristic),
    instance: List(NutritionproductInstance),
    note: List(Annotation),
  )
}

pub fn nutritionproduct_new(
  status status: r5valuesets.Nutritionproductstatus,
) -> Nutritionproduct {
  Nutritionproduct(
    note: [],
    instance: [],
    characteristic: [],
    known_allergen: [],
    ingredient: [],
    nutrient: [],
    manufacturer: [],
    category: [],
    status:,
    code: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type NutritionproductNutrient {
  NutritionproductNutrient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Option(Codeablereference),
    amount: List(Ratio),
  )
}

pub fn nutritionproduct_nutrient_new() -> NutritionproductNutrient {
  NutritionproductNutrient(
    amount: [],
    item: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type NutritionproductIngredient {
  NutritionproductIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    amount: List(Ratio),
  )
}

pub fn nutritionproduct_ingredient_new(
  item item: Codeablereference,
) -> NutritionproductIngredient {
  NutritionproductIngredient(
    amount: [],
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type NutritionproductCharacteristic {
  NutritionproductCharacteristic(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: NutritionproductCharacteristicValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type NutritionproductCharacteristicValue {
  NutritionproductCharacteristicValueCodeableconcept(value: Codeableconcept)
  NutritionproductCharacteristicValueString(value: String)
  NutritionproductCharacteristicValueQuantity(value: Quantity)
  NutritionproductCharacteristicValueBase64binary(value: String)
  NutritionproductCharacteristicValueAttachment(value: Attachment)
  NutritionproductCharacteristicValueBoolean(value: Bool)
}

pub fn nutritionproduct_characteristic_value_to_json(
  elt: NutritionproductCharacteristicValue,
) -> Json {
  case elt {
    NutritionproductCharacteristicValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    NutritionproductCharacteristicValueString(v) -> json.string(v)
    NutritionproductCharacteristicValueQuantity(v) -> quantity_to_json(v)
    NutritionproductCharacteristicValueBase64binary(v) -> json.string(v)
    NutritionproductCharacteristicValueAttachment(v) -> attachment_to_json(v)
    NutritionproductCharacteristicValueBoolean(v) -> json.bool(v)
  }
}

pub fn nutritionproduct_characteristic_value_decoder() -> Decoder(
  NutritionproductCharacteristicValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(NutritionproductCharacteristicValueCodeableconcept),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(NutritionproductCharacteristicValueString),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(NutritionproductCharacteristicValueQuantity),
      decode.field("valueBase64Binary", decode.string, decode.success)
        |> decode.map(NutritionproductCharacteristicValueBase64binary),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(NutritionproductCharacteristicValueAttachment),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(NutritionproductCharacteristicValueBoolean),
    ],
  )
}

pub fn nutritionproduct_characteristic_new(
  value value: NutritionproductCharacteristicValue,
  type_ type_: Codeableconcept,
) -> NutritionproductCharacteristic {
  NutritionproductCharacteristic(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/NutritionProduct#resource
pub type NutritionproductInstance {
  NutritionproductInstance(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    identifier: List(Identifier),
    name: Option(String),
    lot_number: Option(String),
    expiry: Option(String),
    use_by: Option(String),
    biological_source_event: Option(Identifier),
  )
}

pub fn nutritionproduct_instance_new() -> NutritionproductInstance {
  NutritionproductInstance(
    biological_source_event: None,
    use_by: None,
    expiry: None,
    lot_number: None,
    name: None,
    identifier: [],
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn nutritionproduct_instance_to_json(
  nutritionproduct_instance: NutritionproductInstance,
) -> Json {
  let NutritionproductInstance(
    biological_source_event:,
    use_by:,
    expiry:,
    lot_number:,
    name:,
    identifier:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_instance
  let fields = []
  let fields = case biological_source_event {
    Some(v) -> [#("biologicalSourceEvent", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case use_by {
    Some(v) -> [#("useBy", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expiry {
    Some(v) -> [#("expiry", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case lot_number {
    Some(v) -> [#("lotNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_instance_decoder() -> Decoder(NutritionproductInstance) {
  use biological_source_event <- decode.optional_field(
    "biologicalSourceEvent",
    None,
    decode.optional(identifier_decoder()),
  )
  use use_by <- decode.optional_field(
    "useBy",
    None,
    decode.optional(decode.string),
  )
  use expiry <- decode.optional_field(
    "expiry",
    None,
    decode.optional(decode.string),
  )
  use lot_number <- decode.optional_field(
    "lotNumber",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductInstance(
    biological_source_event:,
    use_by:,
    expiry:,
    lot_number:,
    name:,
    identifier:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_characteristic_to_json(
  nutritionproduct_characteristic: NutritionproductCharacteristic,
) -> Json {
  let NutritionproductCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_characteristic
  let fields = [
    #("value", nutritionproduct_characteristic_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_characteristic_decoder() -> Decoder(
  NutritionproductCharacteristic,
) {
  use value <- decode.then(nutritionproduct_characteristic_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductCharacteristic(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_ingredient_to_json(
  nutritionproduct_ingredient: NutritionproductIngredient,
) -> Json {
  let NutritionproductIngredient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_ingredient
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, ratio_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_ingredient_decoder() -> Decoder(
  NutritionproductIngredient,
) {
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(ratio_decoder()),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductIngredient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_nutrient_to_json(
  nutritionproduct_nutrient: NutritionproductNutrient,
) -> Json {
  let NutritionproductNutrient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = nutritionproduct_nutrient
  let fields = []
  let fields = case amount {
    [] -> fields
    _ -> [#("amount", json.array(amount, ratio_to_json)), ..fields]
  }
  let fields = case item {
    Some(v) -> [#("item", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn nutritionproduct_nutrient_decoder() -> Decoder(NutritionproductNutrient) {
  use amount <- decode.optional_field(
    "amount",
    [],
    decode.list(ratio_decoder()),
  )
  use item <- decode.optional_field(
    "item",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(NutritionproductNutrient(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn nutritionproduct_to_json(nutritionproduct: Nutritionproduct) -> Json {
  let Nutritionproduct(
    note:,
    instance:,
    characteristic:,
    known_allergen:,
    ingredient:,
    nutrient:,
    manufacturer:,
    category:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = nutritionproduct
  let fields = [
    #("status", r5valuesets.nutritionproductstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case instance {
    [] -> fields
    _ -> [
      #("instance", json.array(instance, nutritionproduct_instance_to_json)),
      ..fields
    ]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #(
        "characteristic",
        json.array(characteristic, nutritionproduct_characteristic_to_json),
      ),
      ..fields
    ]
  }
  let fields = case known_allergen {
    [] -> fields
    _ -> [
      #("knownAllergen", json.array(known_allergen, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #(
        "ingredient",
        json.array(ingredient, nutritionproduct_ingredient_to_json),
      ),
      ..fields
    ]
  }
  let fields = case nutrient {
    [] -> fields
    _ -> [
      #("nutrient", json.array(nutrient, nutritionproduct_nutrient_to_json)),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Nutritionproduct")), ..fields]
  json.object(fields)
}

pub fn nutritionproduct_decoder() -> Decoder(Nutritionproduct) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use instance <- decode.optional_field(
    "instance",
    [],
    decode.list(nutritionproduct_instance_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(nutritionproduct_characteristic_decoder()),
  )
  use known_allergen <- decode.optional_field(
    "knownAllergen",
    [],
    decode.list(codeablereference_decoder()),
  )
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(nutritionproduct_ingredient_decoder()),
  )
  use nutrient <- decode.optional_field(
    "nutrient",
    [],
    decode.list(nutritionproduct_nutrient_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.nutritionproductstatus_decoder(),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Nutritionproduct",
    decode.failure(nutritionproduct_new(status:), "resourceType"),
  )
  decode.success(Nutritionproduct(
    note:,
    instance:,
    characteristic:,
    known_allergen:,
    ingredient:,
    nutrient:,
    manufacturer:,
    category:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type Observation {
  Observation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates: Option(ObservationInstantiates),
    based_on: List(Reference),
    triggered_by: List(ObservationTriggeredby),
    part_of: List(Reference),
    status: r5valuesets.Observationstatus,
    category: List(Codeableconcept),
    code: Codeableconcept,
    subject: Option(Reference),
    focus: List(Reference),
    encounter: Option(Reference),
    effective: Option(ObservationEffective),
    issued: Option(String),
    performer: List(Reference),
    value: Option(ObservationValue),
    data_absent_reason: Option(Codeableconcept),
    interpretation: List(Codeableconcept),
    note: List(Annotation),
    body_site: Option(Codeableconcept),
    body_structure: Option(Reference),
    method: Option(Codeableconcept),
    specimen: Option(Reference),
    device: Option(Reference),
    reference_range: List(ObservationReferencerange),
    has_member: List(Reference),
    derived_from: List(Reference),
    component: List(ObservationComponent),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationInstantiates {
  ObservationInstantiatesCanonical(instantiates: String)
  ObservationInstantiatesReference(instantiates: Reference)
}

pub fn observation_instantiates_to_json(elt: ObservationInstantiates) -> Json {
  case elt {
    ObservationInstantiatesCanonical(v) -> json.string(v)
    ObservationInstantiatesReference(v) -> reference_to_json(v)
  }
}

pub fn observation_instantiates_decoder() -> Decoder(ObservationInstantiates) {
  decode.one_of(
    decode.field("instantiatesCanonical", decode.string, decode.success)
      |> decode.map(ObservationInstantiatesCanonical),
    [
      decode.field("instantiatesReference", reference_decoder(), decode.success)
      |> decode.map(ObservationInstantiatesReference),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationEffective {
  ObservationEffectiveDatetime(effective: String)
  ObservationEffectivePeriod(effective: Period)
  ObservationEffectiveTiming(effective: Timing)
  ObservationEffectiveInstant(effective: String)
}

pub fn observation_effective_to_json(elt: ObservationEffective) -> Json {
  case elt {
    ObservationEffectiveDatetime(v) -> json.string(v)
    ObservationEffectivePeriod(v) -> period_to_json(v)
    ObservationEffectiveTiming(v) -> timing_to_json(v)
    ObservationEffectiveInstant(v) -> json.string(v)
  }
}

pub fn observation_effective_decoder() -> Decoder(ObservationEffective) {
  decode.one_of(
    decode.field("effectiveDateTime", decode.string, decode.success)
      |> decode.map(ObservationEffectiveDatetime),
    [
      decode.field("effectivePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationEffectivePeriod),
      decode.field("effectiveTiming", timing_decoder(), decode.success)
        |> decode.map(ObservationEffectiveTiming),
      decode.field("effectiveInstant", decode.string, decode.success)
        |> decode.map(ObservationEffectiveInstant),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationValue {
  ObservationValueQuantity(value: Quantity)
  ObservationValueCodeableconcept(value: Codeableconcept)
  ObservationValueString(value: String)
  ObservationValueBoolean(value: Bool)
  ObservationValueInteger(value: Int)
  ObservationValueRange(value: Range)
  ObservationValueRatio(value: Ratio)
  ObservationValueSampleddata(value: Sampleddata)
  ObservationValueTime(value: String)
  ObservationValueDatetime(value: String)
  ObservationValuePeriod(value: Period)
  ObservationValueAttachment(value: Attachment)
  ObservationValueReference(value: Reference)
}

pub fn observation_value_to_json(elt: ObservationValue) -> Json {
  case elt {
    ObservationValueQuantity(v) -> quantity_to_json(v)
    ObservationValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ObservationValueString(v) -> json.string(v)
    ObservationValueBoolean(v) -> json.bool(v)
    ObservationValueInteger(v) -> json.int(v)
    ObservationValueRange(v) -> range_to_json(v)
    ObservationValueRatio(v) -> ratio_to_json(v)
    ObservationValueSampleddata(v) -> sampleddata_to_json(v)
    ObservationValueTime(v) -> json.string(v)
    ObservationValueDatetime(v) -> json.string(v)
    ObservationValuePeriod(v) -> period_to_json(v)
    ObservationValueAttachment(v) -> attachment_to_json(v)
    ObservationValueReference(v) -> reference_to_json(v)
  }
}

pub fn observation_value_decoder() -> Decoder(ObservationValue) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ObservationValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ObservationValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ObservationValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ObservationValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ObservationValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ObservationValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ObservationValueRatio),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ObservationValueSampleddata),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ObservationValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ObservationValueDatetime),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationValuePeriod),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ObservationValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ObservationValueReference),
    ],
  )
}

pub fn observation_new(
  code code: Codeableconcept,
  status status: r5valuesets.Observationstatus,
) -> Observation {
  Observation(
    component: [],
    derived_from: [],
    has_member: [],
    reference_range: [],
    device: None,
    specimen: None,
    method: None,
    body_structure: None,
    body_site: None,
    note: [],
    interpretation: [],
    data_absent_reason: None,
    value: None,
    performer: [],
    issued: None,
    effective: None,
    encounter: None,
    focus: [],
    subject: None,
    code:,
    category: [],
    status:,
    part_of: [],
    triggered_by: [],
    based_on: [],
    instantiates: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationTriggeredby {
  ObservationTriggeredby(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    observation: Reference,
    type_: r5valuesets.Observationtriggeredbytype,
    reason: Option(String),
  )
}

pub fn observation_triggeredby_new(
  type_ type_: r5valuesets.Observationtriggeredbytype,
  observation observation: Reference,
) -> ObservationTriggeredby {
  ObservationTriggeredby(
    reason: None,
    type_:,
    observation:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationReferencerange {
  ObservationReferencerange(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    low: Option(Quantity),
    high: Option(Quantity),
    normal_value: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    applies_to: List(Codeableconcept),
    age: Option(Range),
    text: Option(String),
  )
}

pub fn observation_referencerange_new() -> ObservationReferencerange {
  ObservationReferencerange(
    text: None,
    age: None,
    applies_to: [],
    type_: None,
    normal_value: None,
    high: None,
    low: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationComponent {
  ObservationComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: Option(ObservationComponentValue),
    data_absent_reason: Option(Codeableconcept),
    interpretation: List(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Observation#resource
pub type ObservationComponentValue {
  ObservationComponentValueQuantity(value: Quantity)
  ObservationComponentValueCodeableconcept(value: Codeableconcept)
  ObservationComponentValueString(value: String)
  ObservationComponentValueBoolean(value: Bool)
  ObservationComponentValueInteger(value: Int)
  ObservationComponentValueRange(value: Range)
  ObservationComponentValueRatio(value: Ratio)
  ObservationComponentValueSampleddata(value: Sampleddata)
  ObservationComponentValueTime(value: String)
  ObservationComponentValueDatetime(value: String)
  ObservationComponentValuePeriod(value: Period)
  ObservationComponentValueAttachment(value: Attachment)
  ObservationComponentValueReference(value: Reference)
}

pub fn observation_component_value_to_json(
  elt: ObservationComponentValue,
) -> Json {
  case elt {
    ObservationComponentValueQuantity(v) -> quantity_to_json(v)
    ObservationComponentValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ObservationComponentValueString(v) -> json.string(v)
    ObservationComponentValueBoolean(v) -> json.bool(v)
    ObservationComponentValueInteger(v) -> json.int(v)
    ObservationComponentValueRange(v) -> range_to_json(v)
    ObservationComponentValueRatio(v) -> ratio_to_json(v)
    ObservationComponentValueSampleddata(v) -> sampleddata_to_json(v)
    ObservationComponentValueTime(v) -> json.string(v)
    ObservationComponentValueDatetime(v) -> json.string(v)
    ObservationComponentValuePeriod(v) -> period_to_json(v)
    ObservationComponentValueAttachment(v) -> attachment_to_json(v)
    ObservationComponentValueReference(v) -> reference_to_json(v)
  }
}

pub fn observation_component_value_decoder() -> Decoder(
  ObservationComponentValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ObservationComponentValueQuantity),
    [
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ObservationComponentValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ObservationComponentValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ObservationComponentValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ObservationComponentValueInteger),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ObservationComponentValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ObservationComponentValueRatio),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ObservationComponentValueSampleddata),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ObservationComponentValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ObservationComponentValueDatetime),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ObservationComponentValuePeriod),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ObservationComponentValueAttachment),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ObservationComponentValueReference),
    ],
  )
}

pub fn observation_component_new(
  code code: Codeableconcept,
) -> ObservationComponent {
  ObservationComponent(
    interpretation: [],
    data_absent_reason: None,
    value: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn observation_component_to_json(
  observation_component: ObservationComponent,
) -> Json {
  let ObservationComponent(
    interpretation:,
    data_absent_reason:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = observation_component
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case interpretation {
    [] -> fields
    _ -> [
      #("interpretation", json.array(interpretation, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ObservationComponentValueQuantity(_) -> "Quantity"
          ObservationComponentValueCodeableconcept(_) -> "Codeableconcept"
          ObservationComponentValueString(_) -> "String"
          ObservationComponentValueBoolean(_) -> "Boolean"
          ObservationComponentValueInteger(_) -> "Integer"
          ObservationComponentValueRange(_) -> "Range"
          ObservationComponentValueRatio(_) -> "Ratio"
          ObservationComponentValueSampleddata(_) -> "Sampleddata"
          ObservationComponentValueTime(_) -> "Time"
          ObservationComponentValueDatetime(_) -> "Datetime"
          ObservationComponentValuePeriod(_) -> "Period"
          ObservationComponentValueAttachment(_) -> "Attachment"
          ObservationComponentValueReference(_) -> "Reference"
        },
        observation_component_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observation_component_decoder() -> Decoder(ObservationComponent) {
  use interpretation <- decode.optional_field(
    "interpretation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(observation_component_value_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationComponent(
    interpretation:,
    data_absent_reason:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observation_referencerange_to_json(
  observation_referencerange: ObservationReferencerange,
) -> Json {
  let ObservationReferencerange(
    text:,
    age:,
    applies_to:,
    type_:,
    normal_value:,
    high:,
    low:,
    modifier_extension:,
    extension:,
    id:,
  ) = observation_referencerange
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [#("age", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case applies_to {
    [] -> fields
    _ -> [
      #("appliesTo", json.array(applies_to, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case normal_value {
    Some(v) -> [#("normalValue", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case high {
    Some(v) -> [#("high", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case low {
    Some(v) -> [#("low", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observation_referencerange_decoder() -> Decoder(
  ObservationReferencerange,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use age <- decode.optional_field(
    "age",
    None,
    decode.optional(range_decoder()),
  )
  use applies_to <- decode.optional_field(
    "appliesTo",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use normal_value <- decode.optional_field(
    "normalValue",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use high <- decode.optional_field(
    "high",
    None,
    decode.optional(quantity_decoder()),
  )
  use low <- decode.optional_field(
    "low",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationReferencerange(
    text:,
    age:,
    applies_to:,
    type_:,
    normal_value:,
    high:,
    low:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observation_triggeredby_to_json(
  observation_triggeredby: ObservationTriggeredby,
) -> Json {
  let ObservationTriggeredby(
    reason:,
    type_:,
    observation:,
    modifier_extension:,
    extension:,
    id:,
  ) = observation_triggeredby
  let fields = [
    #("type", r5valuesets.observationtriggeredbytype_to_json(type_)),
    #("observation", reference_to_json(observation)),
  ]
  let fields = case reason {
    Some(v) -> [#("reason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observation_triggeredby_decoder() -> Decoder(ObservationTriggeredby) {
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.observationtriggeredbytype_decoder(),
  )
  use observation <- decode.field("observation", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationTriggeredby(
    reason:,
    type_:,
    observation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observation_to_json(observation: Observation) -> Json {
  let Observation(
    component:,
    derived_from:,
    has_member:,
    reference_range:,
    device:,
    specimen:,
    method:,
    body_structure:,
    body_site:,
    note:,
    interpretation:,
    data_absent_reason:,
    value:,
    performer:,
    issued:,
    effective:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status:,
    part_of:,
    triggered_by:,
    based_on:,
    instantiates:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = observation
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.observationstatus_to_json(status)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #("component", json.array(component, observation_component_to_json)),
      ..fields
    ]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [
      #("derivedFrom", json.array(derived_from, reference_to_json)),
      ..fields
    ]
  }
  let fields = case has_member {
    [] -> fields
    _ -> [#("hasMember", json.array(has_member, reference_to_json)), ..fields]
  }
  let fields = case reference_range {
    [] -> fields
    _ -> [
      #(
        "referenceRange",
        json.array(reference_range, observation_referencerange_to_json),
      ),
      ..fields
    ]
  }
  let fields = case device {
    Some(v) -> [#("device", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case specimen {
    Some(v) -> [#("specimen", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_structure {
    Some(v) -> [#("bodyStructure", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case interpretation {
    [] -> fields
    _ -> [
      #("interpretation", json.array(interpretation, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case data_absent_reason {
    Some(v) -> [#("dataAbsentReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ObservationValueQuantity(_) -> "Quantity"
          ObservationValueCodeableconcept(_) -> "Codeableconcept"
          ObservationValueString(_) -> "String"
          ObservationValueBoolean(_) -> "Boolean"
          ObservationValueInteger(_) -> "Integer"
          ObservationValueRange(_) -> "Range"
          ObservationValueRatio(_) -> "Ratio"
          ObservationValueSampleddata(_) -> "Sampleddata"
          ObservationValueTime(_) -> "Time"
          ObservationValueDatetime(_) -> "Datetime"
          ObservationValuePeriod(_) -> "Period"
          ObservationValueAttachment(_) -> "Attachment"
          ObservationValueReference(_) -> "Reference"
        },
        observation_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case effective {
    Some(v) -> [
      #(
        "effective"
          <> case v {
          ObservationEffectiveDatetime(_) -> "Datetime"
          ObservationEffectivePeriod(_) -> "Period"
          ObservationEffectiveTiming(_) -> "Timing"
          ObservationEffectiveInstant(_) -> "Instant"
        },
        observation_effective_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case triggered_by {
    [] -> fields
    _ -> [
      #(
        "triggeredBy",
        json.array(triggered_by, observation_triggeredby_to_json),
      ),
      ..fields
    ]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates {
    Some(v) -> [
      #(
        "instantiates"
          <> case v {
          ObservationInstantiatesCanonical(_) -> "Canonical"
          ObservationInstantiatesReference(_) -> "Reference"
        },
        observation_instantiates_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Observation")), ..fields]
  json.object(fields)
}

pub fn observation_decoder() -> Decoder(Observation) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(observation_component_decoder()),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(reference_decoder()),
  )
  use has_member <- decode.optional_field(
    "hasMember",
    [],
    decode.list(reference_decoder()),
  )
  use reference_range <- decode.optional_field(
    "referenceRange",
    [],
    decode.list(observation_referencerange_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    None,
    decode.optional(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_structure <- decode.optional_field(
    "bodyStructure",
    None,
    decode.optional(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use interpretation <- decode.optional_field(
    "interpretation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use data_absent_reason <- decode.optional_field(
    "dataAbsentReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use value <- decode.then(none_if_omitted(observation_value_decoder()))
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use effective <- decode.then(none_if_omitted(observation_effective_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.observationstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use triggered_by <- decode.optional_field(
    "triggeredBy",
    [],
    decode.list(observation_triggeredby_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates <- decode.then(
    none_if_omitted(observation_instantiates_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Observation",
    decode.failure(observation_new(code:, status:), "resourceType"),
  )
  decode.success(Observation(
    component:,
    derived_from:,
    has_member:,
    reference_range:,
    device:,
    specimen:,
    method:,
    body_structure:,
    body_site:,
    note:,
    interpretation:,
    data_absent_reason:,
    value:,
    performer:,
    issued:,
    effective:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status:,
    part_of:,
    triggered_by:,
    based_on:,
    instantiates:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ObservationDefinition#resource
pub type Observationdefinition {
  Observationdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: Option(Identifier),
    version: Option(String),
    version_algorithm: Option(ObservationdefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    derived_from_canonical: List(String),
    derived_from_uri: List(String),
    subject: List(Codeableconcept),
    performer_type: Option(Codeableconcept),
    category: List(Codeableconcept),
    code: Codeableconcept,
    permitted_data_type: List(r5valuesets.Permitteddatatype),
    multiple_results_allowed: Option(Bool),
    body_site: Option(Codeableconcept),
    method: Option(Codeableconcept),
    specimen: List(Reference),
    device: List(Reference),
    preferred_report_name: Option(String),
    permitted_unit: List(Coding),
    qualified_value: List(ObservationdefinitionQualifiedvalue),
    has_member: List(Reference),
    component: List(ObservationdefinitionComponent),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionVersionalgorithm {
  ObservationdefinitionVersionalgorithmString(version_algorithm: String)
  ObservationdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn observationdefinition_versionalgorithm_to_json(
  elt: ObservationdefinitionVersionalgorithm,
) -> Json {
  case elt {
    ObservationdefinitionVersionalgorithmString(v) -> json.string(v)
    ObservationdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn observationdefinition_versionalgorithm_decoder() -> Decoder(
  ObservationdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ObservationdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ObservationdefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn observationdefinition_new(
  code code: Codeableconcept,
  status status: r5valuesets.Publicationstatus,
) -> Observationdefinition {
  Observationdefinition(
    component: [],
    has_member: [],
    qualified_value: [],
    permitted_unit: [],
    preferred_report_name: None,
    device: [],
    specimen: [],
    method: None,
    body_site: None,
    multiple_results_allowed: None,
    permitted_data_type: [],
    code:,
    category: [],
    performer_type: None,
    subject: [],
    derived_from_uri: [],
    derived_from_canonical: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionQualifiedvalue {
  ObservationdefinitionQualifiedvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    context: Option(Codeableconcept),
    applies_to: List(Codeableconcept),
    gender: Option(r5valuesets.Administrativegender),
    age: Option(Range),
    gestational_age: Option(Range),
    condition: Option(String),
    range_category: Option(r5valuesets.Observationrangecategory),
    range: Option(Range),
    valid_coded_value_set: Option(String),
    normal_coded_value_set: Option(String),
    abnormal_coded_value_set: Option(String),
    critical_coded_value_set: Option(String),
  )
}

pub fn observationdefinition_qualifiedvalue_new() -> ObservationdefinitionQualifiedvalue {
  ObservationdefinitionQualifiedvalue(
    critical_coded_value_set: None,
    abnormal_coded_value_set: None,
    normal_coded_value_set: None,
    valid_coded_value_set: None,
    range: None,
    range_category: None,
    condition: None,
    gestational_age: None,
    age: None,
    gender: None,
    applies_to: [],
    context: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ObservationDefinition#resource
pub type ObservationdefinitionComponent {
  ObservationdefinitionComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    permitted_data_type: List(r5valuesets.Permitteddatatype),
    permitted_unit: List(Coding),
  )
}

pub fn observationdefinition_component_new(
  code code: Codeableconcept,
) -> ObservationdefinitionComponent {
  ObservationdefinitionComponent(
    permitted_unit: [],
    permitted_data_type: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn observationdefinition_component_to_json(
  observationdefinition_component: ObservationdefinitionComponent,
) -> Json {
  let ObservationdefinitionComponent(
    permitted_unit:,
    permitted_data_type:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = observationdefinition_component
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case permitted_unit {
    [] -> fields
    _ -> [
      #("permittedUnit", json.array(permitted_unit, coding_to_json)),
      ..fields
    ]
  }
  let fields = case permitted_data_type {
    [] -> fields
    _ -> [
      #(
        "permittedDataType",
        json.array(permitted_data_type, r5valuesets.permitteddatatype_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observationdefinition_component_decoder() -> Decoder(
  ObservationdefinitionComponent,
) {
  use permitted_unit <- decode.optional_field(
    "permittedUnit",
    [],
    decode.list(coding_decoder()),
  )
  use permitted_data_type <- decode.optional_field(
    "permittedDataType",
    [],
    decode.list(r5valuesets.permitteddatatype_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationdefinitionComponent(
    permitted_unit:,
    permitted_data_type:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observationdefinition_qualifiedvalue_to_json(
  observationdefinition_qualifiedvalue: ObservationdefinitionQualifiedvalue,
) -> Json {
  let ObservationdefinitionQualifiedvalue(
    critical_coded_value_set:,
    abnormal_coded_value_set:,
    normal_coded_value_set:,
    valid_coded_value_set:,
    range:,
    range_category:,
    condition:,
    gestational_age:,
    age:,
    gender:,
    applies_to:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ) = observationdefinition_qualifiedvalue
  let fields = []
  let fields = case critical_coded_value_set {
    Some(v) -> [#("criticalCodedValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case abnormal_coded_value_set {
    Some(v) -> [#("abnormalCodedValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case normal_coded_value_set {
    Some(v) -> [#("normalCodedValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case valid_coded_value_set {
    Some(v) -> [#("validCodedValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case range {
    Some(v) -> [#("range", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case range_category {
    Some(v) -> [
      #("rangeCategory", r5valuesets.observationrangecategory_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gestational_age {
    Some(v) -> [#("gestationalAge", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case age {
    Some(v) -> [#("age", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case applies_to {
    [] -> fields
    _ -> [
      #("appliesTo", json.array(applies_to, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case context {
    Some(v) -> [#("context", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn observationdefinition_qualifiedvalue_decoder() -> Decoder(
  ObservationdefinitionQualifiedvalue,
) {
  use critical_coded_value_set <- decode.optional_field(
    "criticalCodedValueSet",
    None,
    decode.optional(decode.string),
  )
  use abnormal_coded_value_set <- decode.optional_field(
    "abnormalCodedValueSet",
    None,
    decode.optional(decode.string),
  )
  use normal_coded_value_set <- decode.optional_field(
    "normalCodedValueSet",
    None,
    decode.optional(decode.string),
  )
  use valid_coded_value_set <- decode.optional_field(
    "validCodedValueSet",
    None,
    decode.optional(decode.string),
  )
  use range <- decode.optional_field(
    "range",
    None,
    decode.optional(range_decoder()),
  )
  use range_category <- decode.optional_field(
    "rangeCategory",
    None,
    decode.optional(r5valuesets.observationrangecategory_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use gestational_age <- decode.optional_field(
    "gestationalAge",
    None,
    decode.optional(range_decoder()),
  )
  use age <- decode.optional_field(
    "age",
    None,
    decode.optional(range_decoder()),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use applies_to <- decode.optional_field(
    "appliesTo",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ObservationdefinitionQualifiedvalue(
    critical_coded_value_set:,
    abnormal_coded_value_set:,
    normal_coded_value_set:,
    valid_coded_value_set:,
    range:,
    range_category:,
    condition:,
    gestational_age:,
    age:,
    gender:,
    applies_to:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn observationdefinition_to_json(
  observationdefinition: Observationdefinition,
) -> Json {
  let Observationdefinition(
    component:,
    has_member:,
    qualified_value:,
    permitted_unit:,
    preferred_report_name:,
    device:,
    specimen:,
    method:,
    body_site:,
    multiple_results_allowed:,
    permitted_data_type:,
    code:,
    category:,
    performer_type:,
    subject:,
    derived_from_uri:,
    derived_from_canonical:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = observationdefinition
  let fields = [
    #("code", codeableconcept_to_json(code)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #(
        "component",
        json.array(component, observationdefinition_component_to_json),
      ),
      ..fields
    ]
  }
  let fields = case has_member {
    [] -> fields
    _ -> [#("hasMember", json.array(has_member, reference_to_json)), ..fields]
  }
  let fields = case qualified_value {
    [] -> fields
    _ -> [
      #(
        "qualifiedValue",
        json.array(
          qualified_value,
          observationdefinition_qualifiedvalue_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case permitted_unit {
    [] -> fields
    _ -> [
      #("permittedUnit", json.array(permitted_unit, coding_to_json)),
      ..fields
    ]
  }
  let fields = case preferred_report_name {
    Some(v) -> [#("preferredReportName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    [] -> fields
    _ -> [#("device", json.array(device, reference_to_json)), ..fields]
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case multiple_results_allowed {
    Some(v) -> [#("multipleResultsAllowed", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case permitted_data_type {
    [] -> fields
    _ -> [
      #(
        "permittedDataType",
        json.array(permitted_data_type, r5valuesets.permitteddatatype_to_json),
      ),
      ..fields
    ]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, codeableconcept_to_json)), ..fields]
  }
  let fields = case derived_from_uri {
    [] -> fields
    _ -> [
      #("derivedFromUri", json.array(derived_from_uri, json.string)),
      ..fields
    ]
  }
  let fields = case derived_from_canonical {
    [] -> fields
    _ -> [
      #("derivedFromCanonical", json.array(derived_from_canonical, json.string)),
      ..fields
    ]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ObservationdefinitionVersionalgorithmString(_) -> "String"
          ObservationdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        observationdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Observationdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn observationdefinition_decoder() -> Decoder(Observationdefinition) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(observationdefinition_component_decoder()),
  )
  use has_member <- decode.optional_field(
    "hasMember",
    [],
    decode.list(reference_decoder()),
  )
  use qualified_value <- decode.optional_field(
    "qualifiedValue",
    [],
    decode.list(observationdefinition_qualifiedvalue_decoder()),
  )
  use permitted_unit <- decode.optional_field(
    "permittedUnit",
    [],
    decode.list(coding_decoder()),
  )
  use preferred_report_name <- decode.optional_field(
    "preferredReportName",
    None,
    decode.optional(decode.string),
  )
  use device <- decode.optional_field(
    "device",
    [],
    decode.list(reference_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use multiple_results_allowed <- decode.optional_field(
    "multipleResultsAllowed",
    None,
    decode.optional(decode.bool),
  )
  use permitted_data_type <- decode.optional_field(
    "permittedDataType",
    [],
    decode.list(r5valuesets.permitteddatatype_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use derived_from_uri <- decode.optional_field(
    "derivedFromUri",
    [],
    decode.list(decode.string),
  )
  use derived_from_canonical <- decode.optional_field(
    "derivedFromCanonical",
    [],
    decode.list(decode.string),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(observationdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Observationdefinition",
    decode.failure(observationdefinition_new(code:, status:), "resourceType"),
  )
  decode.success(Observationdefinition(
    component:,
    has_member:,
    qualified_value:,
    permitted_unit:,
    preferred_report_name:,
    device:,
    specimen:,
    method:,
    body_site:,
    multiple_results_allowed:,
    permitted_data_type:,
    code:,
    category:,
    performer_type:,
    subject:,
    derived_from_uri:,
    derived_from_canonical:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type Operationdefinition {
  Operationdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(OperationdefinitionVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    kind: r5valuesets.Operationkind,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    affects_state: Option(Bool),
    code: String,
    comment: Option(String),
    base: Option(String),
    resource: List(r5valuesets.Versionindependentallresourcetypes),
    system: Bool,
    type_: Bool,
    instance: Bool,
    input_profile: Option(String),
    output_profile: Option(String),
    parameter: List(OperationdefinitionParameter),
    overload: List(OperationdefinitionOverload),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionVersionalgorithm {
  OperationdefinitionVersionalgorithmString(version_algorithm: String)
  OperationdefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn operationdefinition_versionalgorithm_to_json(
  elt: OperationdefinitionVersionalgorithm,
) -> Json {
  case elt {
    OperationdefinitionVersionalgorithmString(v) -> json.string(v)
    OperationdefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn operationdefinition_versionalgorithm_decoder() -> Decoder(
  OperationdefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(OperationdefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(OperationdefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn operationdefinition_new(
  instance instance: Bool,
  type_ type_: Bool,
  system system: Bool,
  code code: String,
  kind kind: r5valuesets.Operationkind,
  status status: r5valuesets.Publicationstatus,
  name name: String,
) -> Operationdefinition {
  Operationdefinition(
    overload: [],
    parameter: [],
    output_profile: None,
    input_profile: None,
    instance:,
    type_:,
    system:,
    resource: [],
    base: None,
    comment: None,
    code:,
    affects_state: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    kind:,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameter {
  OperationdefinitionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    use_: r5valuesets.Operationparameteruse,
    scope: List(r5valuesets.Operationparameterscope),
    min: Int,
    max: String,
    documentation: Option(String),
    type_: Option(r5valuesets.Fhirtypes),
    allowed_type: List(r5valuesets.Fhirtypes),
    target_profile: List(String),
    search_type: Option(r5valuesets.Searchparamtype),
    binding: Option(OperationdefinitionParameterBinding),
    referenced_from: List(OperationdefinitionParameterReferencedfrom),
  )
}

pub fn operationdefinition_parameter_new(
  max max: String,
  min min: Int,
  use_ use_: r5valuesets.Operationparameteruse,
  name name: String,
) -> OperationdefinitionParameter {
  OperationdefinitionParameter(
    referenced_from: [],
    binding: None,
    search_type: None,
    target_profile: [],
    allowed_type: [],
    type_: None,
    documentation: None,
    max:,
    min:,
    scope: [],
    use_:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterBinding {
  OperationdefinitionParameterBinding(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    strength: r5valuesets.Bindingstrength,
    value_set: String,
  )
}

pub fn operationdefinition_parameter_binding_new(
  value_set value_set: String,
  strength strength: r5valuesets.Bindingstrength,
) -> OperationdefinitionParameterBinding {
  OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionParameterReferencedfrom {
  OperationdefinitionParameterReferencedfrom(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source: String,
    source_id: Option(String),
  )
}

pub fn operationdefinition_parameter_referencedfrom_new(
  source source: String,
) -> OperationdefinitionParameterReferencedfrom {
  OperationdefinitionParameterReferencedfrom(
    source_id: None,
    source:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationDefinition#resource
pub type OperationdefinitionOverload {
  OperationdefinitionOverload(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    parameter_name: List(String),
    comment: Option(String),
  )
}

pub fn operationdefinition_overload_new() -> OperationdefinitionOverload {
  OperationdefinitionOverload(
    comment: None,
    parameter_name: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn operationdefinition_overload_to_json(
  operationdefinition_overload: OperationdefinitionOverload,
) -> Json {
  let OperationdefinitionOverload(
    comment:,
    parameter_name:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_overload
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case parameter_name {
    [] -> fields
    _ -> [#("parameterName", json.array(parameter_name, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_overload_decoder() -> Decoder(
  OperationdefinitionOverload,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use parameter_name <- decode.optional_field(
    "parameterName",
    [],
    decode.list(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionOverload(
    comment:,
    parameter_name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_referencedfrom_to_json(
  operationdefinition_parameter_referencedfrom: OperationdefinitionParameterReferencedfrom,
) -> Json {
  let OperationdefinitionParameterReferencedfrom(
    source_id:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter_referencedfrom
  let fields = [
    #("source", json.string(source)),
  ]
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_referencedfrom_decoder() -> Decoder(
  OperationdefinitionParameterReferencedfrom,
) {
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use source <- decode.field("source", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameterReferencedfrom(
    source_id:,
    source:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_binding_to_json(
  operationdefinition_parameter_binding: OperationdefinitionParameterBinding,
) -> Json {
  let OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter_binding
  let fields = [
    #("valueSet", json.string(value_set)),
    #("strength", r5valuesets.bindingstrength_to_json(strength)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_binding_decoder() -> Decoder(
  OperationdefinitionParameterBinding,
) {
  use value_set <- decode.field("valueSet", decode.string)
  use strength <- decode.field(
    "strength",
    r5valuesets.bindingstrength_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameterBinding(
    value_set:,
    strength:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_parameter_to_json(
  operationdefinition_parameter: OperationdefinitionParameter,
) -> Json {
  let OperationdefinitionParameter(
    referenced_from:,
    binding:,
    search_type:,
    target_profile:,
    allowed_type:,
    type_:,
    documentation:,
    max:,
    min:,
    scope:,
    use_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationdefinition_parameter
  let fields = [
    #("max", json.string(max)),
    #("min", json.int(min)),
    #("use", r5valuesets.operationparameteruse_to_json(use_)),
    #("name", json.string(name)),
  ]
  let fields = case referenced_from {
    [] -> fields
    _ -> [
      #(
        "referencedFrom",
        json.array(
          referenced_from,
          operationdefinition_parameter_referencedfrom_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case binding {
    Some(v) -> [
      #("binding", operationdefinition_parameter_binding_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case search_type {
    Some(v) -> [
      #("searchType", r5valuesets.searchparamtype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case target_profile {
    [] -> fields
    _ -> [#("targetProfile", json.array(target_profile, json.string)), ..fields]
  }
  let fields = case allowed_type {
    [] -> fields
    _ -> [
      #("allowedType", json.array(allowed_type, r5valuesets.fhirtypes_to_json)),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", r5valuesets.fhirtypes_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case scope {
    [] -> fields
    _ -> [
      #("scope", json.array(scope, r5valuesets.operationparameterscope_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationdefinition_parameter_decoder() -> Decoder(
  OperationdefinitionParameter,
) {
  use referenced_from <- decode.optional_field(
    "referencedFrom",
    [],
    decode.list(operationdefinition_parameter_referencedfrom_decoder()),
  )
  use binding <- decode.optional_field(
    "binding",
    None,
    decode.optional(operationdefinition_parameter_binding_decoder()),
  )
  use search_type <- decode.optional_field(
    "searchType",
    None,
    decode.optional(r5valuesets.searchparamtype_decoder()),
  )
  use target_profile <- decode.optional_field(
    "targetProfile",
    [],
    decode.list(decode.string),
  )
  use allowed_type <- decode.optional_field(
    "allowedType",
    [],
    decode.list(r5valuesets.fhirtypes_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.fhirtypes_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.field("max", decode.string)
  use min <- decode.field("min", decode.int)
  use scope <- decode.optional_field(
    "scope",
    [],
    decode.list(r5valuesets.operationparameterscope_decoder()),
  )
  use use_ <- decode.field("use", r5valuesets.operationparameteruse_decoder())
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationdefinitionParameter(
    referenced_from:,
    binding:,
    search_type:,
    target_profile:,
    allowed_type:,
    type_:,
    documentation:,
    max:,
    min:,
    scope:,
    use_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationdefinition_to_json(
  operationdefinition: Operationdefinition,
) -> Json {
  let Operationdefinition(
    overload:,
    parameter:,
    output_profile:,
    input_profile:,
    instance:,
    type_:,
    system:,
    resource:,
    base:,
    comment:,
    code:,
    affects_state:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = operationdefinition
  let fields = [
    #("instance", json.bool(instance)),
    #("type", json.bool(type_)),
    #("system", json.bool(system)),
    #("code", json.string(code)),
    #("kind", r5valuesets.operationkind_to_json(kind)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case overload {
    [] -> fields
    _ -> [
      #("overload", json.array(overload, operationdefinition_overload_to_json)),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, operationdefinition_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case output_profile {
    Some(v) -> [#("outputProfile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case input_profile {
    Some(v) -> [#("inputProfile", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #(
        "resource",
        json.array(
          resource,
          r5valuesets.versionindependentallresourcetypes_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case base {
    Some(v) -> [#("base", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case affects_state {
    Some(v) -> [#("affectsState", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          OperationdefinitionVersionalgorithmString(_) -> "String"
          OperationdefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        operationdefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Operationdefinition")), ..fields]
  json.object(fields)
}

pub fn operationdefinition_decoder() -> Decoder(Operationdefinition) {
  use overload <- decode.optional_field(
    "overload",
    [],
    decode.list(operationdefinition_overload_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(operationdefinition_parameter_decoder()),
  )
  use output_profile <- decode.optional_field(
    "outputProfile",
    None,
    decode.optional(decode.string),
  )
  use input_profile <- decode.optional_field(
    "inputProfile",
    None,
    decode.optional(decode.string),
  )
  use instance <- decode.field("instance", decode.bool)
  use type_ <- decode.field("type", decode.bool)
  use system <- decode.field("system", decode.bool)
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(r5valuesets.versionindependentallresourcetypes_decoder()),
  )
  use base <- decode.optional_field(
    "base",
    None,
    decode.optional(decode.string),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use affects_state <- decode.optional_field(
    "affectsState",
    None,
    decode.optional(decode.bool),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use kind <- decode.field("kind", r5valuesets.operationkind_decoder())
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(operationdefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Operationdefinition",
    decode.failure(
      operationdefinition_new(
        instance:,
        type_:,
        system:,
        code:,
        kind:,
        status:,
        name:,
      ),
      "resourceType",
    ),
  )
  decode.success(Operationdefinition(
    overload:,
    parameter:,
    output_profile:,
    input_profile:,
    instance:,
    type_:,
    system:,
    resource:,
    base:,
    comment:,
    code:,
    affects_state:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    kind:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationOutcome#resource
pub type Operationoutcome {
  Operationoutcome(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    issue: List(OperationoutcomeIssue),
  )
}

pub fn operationoutcome_new() -> Operationoutcome {
  Operationoutcome(
    issue: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/OperationOutcome#resource
pub type OperationoutcomeIssue {
  OperationoutcomeIssue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    severity: r5valuesets.Issueseverity,
    code: r5valuesets.Issuetype,
    details: Option(Codeableconcept),
    diagnostics: Option(String),
    location: List(String),
    expression: List(String),
  )
}

pub fn operationoutcome_issue_new(
  code code: r5valuesets.Issuetype,
  severity severity: r5valuesets.Issueseverity,
) -> OperationoutcomeIssue {
  OperationoutcomeIssue(
    expression: [],
    location: [],
    diagnostics: None,
    details: None,
    code:,
    severity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn operationoutcome_issue_to_json(
  operationoutcome_issue: OperationoutcomeIssue,
) -> Json {
  let OperationoutcomeIssue(
    expression:,
    location:,
    diagnostics:,
    details:,
    code:,
    severity:,
    modifier_extension:,
    extension:,
    id:,
  ) = operationoutcome_issue
  let fields = [
    #("code", r5valuesets.issuetype_to_json(code)),
    #("severity", r5valuesets.issueseverity_to_json(severity)),
  ]
  let fields = case expression {
    [] -> fields
    _ -> [#("expression", json.array(expression, json.string)), ..fields]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, json.string)), ..fields]
  }
  let fields = case diagnostics {
    Some(v) -> [#("diagnostics", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case details {
    Some(v) -> [#("details", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn operationoutcome_issue_decoder() -> Decoder(OperationoutcomeIssue) {
  use expression <- decode.optional_field(
    "expression",
    [],
    decode.list(decode.string),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(decode.string),
  )
  use diagnostics <- decode.optional_field(
    "diagnostics",
    None,
    decode.optional(decode.string),
  )
  use details <- decode.optional_field(
    "details",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.field("code", r5valuesets.issuetype_decoder())
  use severity <- decode.field("severity", r5valuesets.issueseverity_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OperationoutcomeIssue(
    expression:,
    location:,
    diagnostics:,
    details:,
    code:,
    severity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn operationoutcome_to_json(operationoutcome: Operationoutcome) -> Json {
  let Operationoutcome(
    issue:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = operationoutcome
  let fields = []
  let fields = case issue {
    [] -> fields
    _ -> [
      #("issue", json.array(issue, operationoutcome_issue_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Operationoutcome")), ..fields]
  json.object(fields)
}

pub fn operationoutcome_decoder() -> Decoder(Operationoutcome) {
  use issue <- decode.optional_field(
    "issue",
    [],
    decode.list(operationoutcome_issue_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Operationoutcome",
    decode.failure(operationoutcome_new(), "resourceType"),
  )
  decode.success(Operationoutcome(
    issue:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Organization#resource
pub type Organization {
  Organization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    type_: List(Codeableconcept),
    name: Option(String),
    alias: List(String),
    description: Option(String),
    contact: List(Extendedcontactdetail),
    part_of: Option(Reference),
    endpoint: List(Reference),
    qualification: List(OrganizationQualification),
  )
}

pub fn organization_new() -> Organization {
  Organization(
    qualification: [],
    endpoint: [],
    part_of: None,
    contact: [],
    description: None,
    alias: [],
    name: None,
    type_: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Organization#resource
pub type OrganizationQualification {
  OrganizationQualification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Codeableconcept,
    period: Option(Period),
    issuer: Option(Reference),
  )
}

pub fn organization_qualification_new(
  code code: Codeableconcept,
) -> OrganizationQualification {
  OrganizationQualification(
    issuer: None,
    period: None,
    code:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn organization_qualification_to_json(
  organization_qualification: OrganizationQualification,
) -> Json {
  let OrganizationQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = organization_qualification
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case issuer {
    Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn organization_qualification_decoder() -> Decoder(
  OrganizationQualification,
) {
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(OrganizationQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn organization_to_json(organization: Organization) -> Json {
  let Organization(
    qualification:,
    endpoint:,
    part_of:,
    contact:,
    description:,
    alias:,
    name:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = organization
  let fields = []
  let fields = case qualification {
    [] -> fields
    _ -> [
      #(
        "qualification",
        json.array(qualification, organization_qualification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case part_of {
    Some(v) -> [#("partOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    [] -> fields
    _ -> [#("alias", json.array(alias, json.string)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Organization")), ..fields]
  json.object(fields)
}

pub fn organization_decoder() -> Decoder(Organization) {
  use qualification <- decode.optional_field(
    "qualification",
    [],
    decode.list(organization_qualification_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    None,
    decode.optional(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use alias <- decode.optional_field("alias", [], decode.list(decode.string))
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Organization",
    decode.failure(organization_new(), "resourceType"),
  )
  decode.success(Organization(
    qualification:,
    endpoint:,
    part_of:,
    contact:,
    description:,
    alias:,
    name:,
    type_:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/OrganizationAffiliation#resource
pub type Organizationaffiliation {
  Organizationaffiliation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    period: Option(Period),
    organization: Option(Reference),
    participating_organization: Option(Reference),
    network: List(Reference),
    code: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    healthcare_service: List(Reference),
    contact: List(Extendedcontactdetail),
    endpoint: List(Reference),
  )
}

pub fn organizationaffiliation_new() -> Organizationaffiliation {
  Organizationaffiliation(
    endpoint: [],
    contact: [],
    healthcare_service: [],
    location: [],
    specialty: [],
    code: [],
    network: [],
    participating_organization: None,
    organization: None,
    period: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn organizationaffiliation_to_json(
  organizationaffiliation: Organizationaffiliation,
) -> Json {
  let Organizationaffiliation(
    endpoint:,
    contact:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    network:,
    participating_organization:,
    organization:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = organizationaffiliation
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case healthcare_service {
    [] -> fields
    _ -> [
      #("healthcareService", json.array(healthcare_service, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case network {
    [] -> fields
    _ -> [#("network", json.array(network, reference_to_json)), ..fields]
  }
  let fields = case participating_organization {
    Some(v) -> [#("participatingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Organizationaffiliation")),
    ..fields
  ]
  json.object(fields)
}

pub fn organizationaffiliation_decoder() -> Decoder(Organizationaffiliation) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use healthcare_service <- decode.optional_field(
    "healthcareService",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use network <- decode.optional_field(
    "network",
    [],
    decode.list(reference_decoder()),
  )
  use participating_organization <- decode.optional_field(
    "participatingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Organizationaffiliation",
    decode.failure(organizationaffiliation_new(), "resourceType"),
  )
  decode.success(Organizationaffiliation(
    endpoint:,
    contact:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    network:,
    participating_organization:,
    organization:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type Packagedproductdefinition {
  Packagedproductdefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    name: Option(String),
    type_: Option(Codeableconcept),
    package_for: List(Reference),
    status: Option(Codeableconcept),
    status_date: Option(String),
    contained_item_quantity: List(Quantity),
    description: Option(String),
    legal_status_of_supply: List(PackagedproductdefinitionLegalstatusofsupply),
    marketing_status: List(Marketingstatus),
    copackaged_indicator: Option(Bool),
    manufacturer: List(Reference),
    attached_document: List(Reference),
    packaging: Option(PackagedproductdefinitionPackaging),
  )
}

pub fn packagedproductdefinition_new() -> Packagedproductdefinition {
  Packagedproductdefinition(
    packaging: None,
    attached_document: [],
    manufacturer: [],
    copackaged_indicator: None,
    marketing_status: [],
    legal_status_of_supply: [],
    description: None,
    contained_item_quantity: [],
    status_date: None,
    status: None,
    package_for: [],
    type_: None,
    name: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionLegalstatusofsupply {
  PackagedproductdefinitionLegalstatusofsupply(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    jurisdiction: Option(Codeableconcept),
  )
}

pub fn packagedproductdefinition_legalstatusofsupply_new() -> PackagedproductdefinitionLegalstatusofsupply {
  PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackaging {
  PackagedproductdefinitionPackaging(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Option(Codeableconcept),
    component_part: Option(Bool),
    quantity: Option(Int),
    material: List(Codeableconcept),
    alternate_material: List(Codeableconcept),
    shelf_life_storage: List(Productshelflife),
    manufacturer: List(Reference),
    property: List(PackagedproductdefinitionPackagingProperty),
    contained_item: List(PackagedproductdefinitionPackagingContaineditem),
  )
}

pub fn packagedproductdefinition_packaging_new() -> PackagedproductdefinitionPackaging {
  PackagedproductdefinitionPackaging(
    contained_item: [],
    property: [],
    manufacturer: [],
    shelf_life_storage: [],
    alternate_material: [],
    material: [],
    quantity: None,
    component_part: None,
    type_: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackagingProperty {
  PackagedproductdefinitionPackagingProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(PackagedproductdefinitionPackagingPropertyValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackagingPropertyValue {
  PackagedproductdefinitionPackagingPropertyValueCodeableconcept(
    value: Codeableconcept,
  )
  PackagedproductdefinitionPackagingPropertyValueQuantity(value: Quantity)
  PackagedproductdefinitionPackagingPropertyValueDate(value: String)
  PackagedproductdefinitionPackagingPropertyValueBoolean(value: Bool)
  PackagedproductdefinitionPackagingPropertyValueAttachment(value: Attachment)
}

pub fn packagedproductdefinition_packaging_property_value_to_json(
  elt: PackagedproductdefinitionPackagingPropertyValue,
) -> Json {
  case elt {
    PackagedproductdefinitionPackagingPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    PackagedproductdefinitionPackagingPropertyValueQuantity(v) ->
      quantity_to_json(v)
    PackagedproductdefinitionPackagingPropertyValueDate(v) -> json.string(v)
    PackagedproductdefinitionPackagingPropertyValueBoolean(v) -> json.bool(v)
    PackagedproductdefinitionPackagingPropertyValueAttachment(v) ->
      attachment_to_json(v)
  }
}

pub fn packagedproductdefinition_packaging_property_value_decoder() -> Decoder(
  PackagedproductdefinitionPackagingPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        PackagedproductdefinitionPackagingPropertyValueCodeableconcept,
      ),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(PackagedproductdefinitionPackagingPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(PackagedproductdefinitionPackagingPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(PackagedproductdefinitionPackagingPropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(PackagedproductdefinitionPackagingPropertyValueAttachment),
    ],
  )
}

pub fn packagedproductdefinition_packaging_property_new(
  type_ type_: Codeableconcept,
) -> PackagedproductdefinitionPackagingProperty {
  PackagedproductdefinitionPackagingProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PackagedProductDefinition#resource
pub type PackagedproductdefinitionPackagingContaineditem {
  PackagedproductdefinitionPackagingContaineditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    item: Codeablereference,
    amount: Option(Quantity),
  )
}

pub fn packagedproductdefinition_packaging_containeditem_new(
  item item: Codeablereference,
) -> PackagedproductdefinitionPackagingContaineditem {
  PackagedproductdefinitionPackagingContaineditem(
    amount: None,
    item:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn packagedproductdefinition_packaging_containeditem_to_json(
  packagedproductdefinition_packaging_containeditem: PackagedproductdefinitionPackagingContaineditem,
) -> Json {
  let PackagedproductdefinitionPackagingContaineditem(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_packaging_containeditem
  let fields = [
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_packaging_containeditem_decoder() -> Decoder(
  PackagedproductdefinitionPackagingContaineditem,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use item <- decode.field("item", codeablereference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackagingContaineditem(
    amount:,
    item:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_packaging_property_to_json(
  packagedproductdefinition_packaging_property: PackagedproductdefinitionPackagingProperty,
) -> Json {
  let PackagedproductdefinitionPackagingProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_packaging_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          PackagedproductdefinitionPackagingPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          PackagedproductdefinitionPackagingPropertyValueQuantity(_) ->
            "Quantity"
          PackagedproductdefinitionPackagingPropertyValueDate(_) -> "Date"
          PackagedproductdefinitionPackagingPropertyValueBoolean(_) -> "Boolean"
          PackagedproductdefinitionPackagingPropertyValueAttachment(_) ->
            "Attachment"
        },
        packagedproductdefinition_packaging_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_packaging_property_decoder() -> Decoder(
  PackagedproductdefinitionPackagingProperty,
) {
  use value <- decode.then(
    none_if_omitted(
      packagedproductdefinition_packaging_property_value_decoder(),
    ),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackagingProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_packaging_to_json(
  packagedproductdefinition_packaging: PackagedproductdefinitionPackaging,
) -> Json {
  let PackagedproductdefinitionPackaging(
    contained_item:,
    property:,
    manufacturer:,
    shelf_life_storage:,
    alternate_material:,
    material:,
    quantity:,
    component_part:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_packaging
  let fields = []
  let fields = case contained_item {
    [] -> fields
    _ -> [
      #(
        "containedItem",
        json.array(
          contained_item,
          packagedproductdefinition_packaging_containeditem_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(
          property,
          packagedproductdefinition_packaging_property_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case shelf_life_storage {
    [] -> fields
    _ -> [
      #(
        "shelfLifeStorage",
        json.array(shelf_life_storage, productshelflife_to_json),
      ),
      ..fields
    ]
  }
  let fields = case alternate_material {
    [] -> fields
    _ -> [
      #(
        "alternateMaterial",
        json.array(alternate_material, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case material {
    [] -> fields
    _ -> [
      #("material", json.array(material, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case component_part {
    Some(v) -> [#("componentPart", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_packaging_decoder() -> Decoder(
  PackagedproductdefinitionPackaging,
) {
  use contained_item <- decode.optional_field(
    "containedItem",
    [],
    decode.list(packagedproductdefinition_packaging_containeditem_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(packagedproductdefinition_packaging_property_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use shelf_life_storage <- decode.optional_field(
    "shelfLifeStorage",
    [],
    decode.list(productshelflife_decoder()),
  )
  use alternate_material <- decode.optional_field(
    "alternateMaterial",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use material <- decode.optional_field(
    "material",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(decode.int),
  )
  use component_part <- decode.optional_field(
    "componentPart",
    None,
    decode.optional(decode.bool),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionPackaging(
    contained_item:,
    property:,
    manufacturer:,
    shelf_life_storage:,
    alternate_material:,
    material:,
    quantity:,
    component_part:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_legalstatusofsupply_to_json(
  packagedproductdefinition_legalstatusofsupply: PackagedproductdefinitionLegalstatusofsupply,
) -> Json {
  let PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = packagedproductdefinition_legalstatusofsupply
  let fields = []
  let fields = case jurisdiction {
    Some(v) -> [#("jurisdiction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn packagedproductdefinition_legalstatusofsupply_decoder() -> Decoder(
  PackagedproductdefinitionLegalstatusofsupply,
) {
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PackagedproductdefinitionLegalstatusofsupply(
    jurisdiction:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn packagedproductdefinition_to_json(
  packagedproductdefinition: Packagedproductdefinition,
) -> Json {
  let Packagedproductdefinition(
    packaging:,
    attached_document:,
    manufacturer:,
    copackaged_indicator:,
    marketing_status:,
    legal_status_of_supply:,
    description:,
    contained_item_quantity:,
    status_date:,
    status:,
    package_for:,
    type_:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = packagedproductdefinition
  let fields = []
  let fields = case packaging {
    Some(v) -> [
      #("packaging", packagedproductdefinition_packaging_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case attached_document {
    [] -> fields
    _ -> [
      #("attachedDocument", json.array(attached_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case copackaged_indicator {
    Some(v) -> [#("copackagedIndicator", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case marketing_status {
    [] -> fields
    _ -> [
      #(
        "marketingStatus",
        json.array(marketing_status, marketingstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case legal_status_of_supply {
    [] -> fields
    _ -> [
      #(
        "legalStatusOfSupply",
        json.array(
          legal_status_of_supply,
          packagedproductdefinition_legalstatusofsupply_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contained_item_quantity {
    [] -> fields
    _ -> [
      #(
        "containedItemQuantity",
        json.array(contained_item_quantity, quantity_to_json),
      ),
      ..fields
    ]
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case package_for {
    [] -> fields
    _ -> [#("packageFor", json.array(package_for, reference_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Packagedproductdefinition")),
    ..fields
  ]
  json.object(fields)
}

pub fn packagedproductdefinition_decoder() -> Decoder(Packagedproductdefinition) {
  use packaging <- decode.optional_field(
    "packaging",
    None,
    decode.optional(packagedproductdefinition_packaging_decoder()),
  )
  use attached_document <- decode.optional_field(
    "attachedDocument",
    [],
    decode.list(reference_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use copackaged_indicator <- decode.optional_field(
    "copackagedIndicator",
    None,
    decode.optional(decode.bool),
  )
  use marketing_status <- decode.optional_field(
    "marketingStatus",
    [],
    decode.list(marketingstatus_decoder()),
  )
  use legal_status_of_supply <- decode.optional_field(
    "legalStatusOfSupply",
    [],
    decode.list(packagedproductdefinition_legalstatusofsupply_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contained_item_quantity <- decode.optional_field(
    "containedItemQuantity",
    [],
    decode.list(quantity_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use package_for <- decode.optional_field(
    "packageFor",
    [],
    decode.list(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Packagedproductdefinition",
    decode.failure(packagedproductdefinition_new(), "resourceType"),
  )
  decode.success(Packagedproductdefinition(
    packaging:,
    attached_document:,
    manufacturer:,
    copackaged_indicator:,
    marketing_status:,
    legal_status_of_supply:,
    description:,
    contained_item_quantity:,
    status_date:,
    status:,
    package_for:,
    type_:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Parameters#resource
pub type Parameters {
  Parameters(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    parameter: List(ParametersParameter),
  )
}

pub fn parameters_new() -> Parameters {
  Parameters(
    parameter: [],
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Parameters#resource
pub type ParametersParameter {
  ParametersParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    value: Option(ParametersParameterValue),
    resource: Option(Resource),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Parameters#resource
pub type ParametersParameterValue {
  ParametersParameterValueBase64binary(value: String)
  ParametersParameterValueBoolean(value: Bool)
  ParametersParameterValueCanonical(value: String)
  ParametersParameterValueCode(value: String)
  ParametersParameterValueDate(value: String)
  ParametersParameterValueDatetime(value: String)
  ParametersParameterValueDecimal(value: Float)
  ParametersParameterValueId(value: String)
  ParametersParameterValueInstant(value: String)
  ParametersParameterValueInteger(value: Int)
  ParametersParameterValueInteger64(value: Int)
  ParametersParameterValueMarkdown(value: String)
  ParametersParameterValueOid(value: String)
  ParametersParameterValuePositiveint(value: Int)
  ParametersParameterValueString(value: String)
  ParametersParameterValueTime(value: String)
  ParametersParameterValueUnsignedint(value: Int)
  ParametersParameterValueUri(value: String)
  ParametersParameterValueUrl(value: String)
  ParametersParameterValueUuid(value: String)
  ParametersParameterValueAddress(value: Address)
  ParametersParameterValueAge(value: Age)
  ParametersParameterValueAnnotation(value: Annotation)
  ParametersParameterValueAttachment(value: Attachment)
  ParametersParameterValueCodeableconcept(value: Codeableconcept)
  ParametersParameterValueCodeablereference(value: Codeablereference)
  ParametersParameterValueCoding(value: Coding)
  ParametersParameterValueContactpoint(value: Contactpoint)
  ParametersParameterValueCount(value: Count)
  ParametersParameterValueDistance(value: Distance)
  ParametersParameterValueDuration(value: Duration)
  ParametersParameterValueHumanname(value: Humanname)
  ParametersParameterValueIdentifier(value: Identifier)
  ParametersParameterValueMoney(value: Money)
  ParametersParameterValuePeriod(value: Period)
  ParametersParameterValueQuantity(value: Quantity)
  ParametersParameterValueRange(value: Range)
  ParametersParameterValueRatio(value: Ratio)
  ParametersParameterValueRatiorange(value: Ratiorange)
  ParametersParameterValueReference(value: Reference)
  ParametersParameterValueSampleddata(value: Sampleddata)
  ParametersParameterValueSignature(value: Signature)
  ParametersParameterValueTiming(value: Timing)
  ParametersParameterValueContactdetail(value: Contactdetail)
  ParametersParameterValueDatarequirement(value: Datarequirement)
  ParametersParameterValueExpression(value: Expression)
  ParametersParameterValueParameterdefinition(value: Parameterdefinition)
  ParametersParameterValueRelatedartifact(value: Relatedartifact)
  ParametersParameterValueTriggerdefinition(value: Triggerdefinition)
  ParametersParameterValueUsagecontext(value: Usagecontext)
  ParametersParameterValueAvailability(value: Availability)
  ParametersParameterValueExtendedcontactdetail(value: Extendedcontactdetail)
  ParametersParameterValueDosage(value: Dosage)
  ParametersParameterValueMeta(value: Meta)
}

pub fn parameters_parameter_value_to_json(elt: ParametersParameterValue) -> Json {
  case elt {
    ParametersParameterValueBase64binary(v) -> json.string(v)
    ParametersParameterValueBoolean(v) -> json.bool(v)
    ParametersParameterValueCanonical(v) -> json.string(v)
    ParametersParameterValueCode(v) -> json.string(v)
    ParametersParameterValueDate(v) -> json.string(v)
    ParametersParameterValueDatetime(v) -> json.string(v)
    ParametersParameterValueDecimal(v) -> json.float(v)
    ParametersParameterValueId(v) -> json.string(v)
    ParametersParameterValueInstant(v) -> json.string(v)
    ParametersParameterValueInteger(v) -> json.int(v)
    ParametersParameterValueInteger64(v) -> json.int(v)
    ParametersParameterValueMarkdown(v) -> json.string(v)
    ParametersParameterValueOid(v) -> json.string(v)
    ParametersParameterValuePositiveint(v) -> json.int(v)
    ParametersParameterValueString(v) -> json.string(v)
    ParametersParameterValueTime(v) -> json.string(v)
    ParametersParameterValueUnsignedint(v) -> json.int(v)
    ParametersParameterValueUri(v) -> json.string(v)
    ParametersParameterValueUrl(v) -> json.string(v)
    ParametersParameterValueUuid(v) -> json.string(v)
    ParametersParameterValueAddress(v) -> address_to_json(v)
    ParametersParameterValueAge(v) -> age_to_json(v)
    ParametersParameterValueAnnotation(v) -> annotation_to_json(v)
    ParametersParameterValueAttachment(v) -> attachment_to_json(v)
    ParametersParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    ParametersParameterValueCodeablereference(v) -> codeablereference_to_json(v)
    ParametersParameterValueCoding(v) -> coding_to_json(v)
    ParametersParameterValueContactpoint(v) -> contactpoint_to_json(v)
    ParametersParameterValueCount(v) -> count_to_json(v)
    ParametersParameterValueDistance(v) -> distance_to_json(v)
    ParametersParameterValueDuration(v) -> duration_to_json(v)
    ParametersParameterValueHumanname(v) -> humanname_to_json(v)
    ParametersParameterValueIdentifier(v) -> identifier_to_json(v)
    ParametersParameterValueMoney(v) -> money_to_json(v)
    ParametersParameterValuePeriod(v) -> period_to_json(v)
    ParametersParameterValueQuantity(v) -> quantity_to_json(v)
    ParametersParameterValueRange(v) -> range_to_json(v)
    ParametersParameterValueRatio(v) -> ratio_to_json(v)
    ParametersParameterValueRatiorange(v) -> ratiorange_to_json(v)
    ParametersParameterValueReference(v) -> reference_to_json(v)
    ParametersParameterValueSampleddata(v) -> sampleddata_to_json(v)
    ParametersParameterValueSignature(v) -> signature_to_json(v)
    ParametersParameterValueTiming(v) -> timing_to_json(v)
    ParametersParameterValueContactdetail(v) -> contactdetail_to_json(v)
    ParametersParameterValueDatarequirement(v) -> datarequirement_to_json(v)
    ParametersParameterValueExpression(v) -> expression_to_json(v)
    ParametersParameterValueParameterdefinition(v) ->
      parameterdefinition_to_json(v)
    ParametersParameterValueRelatedartifact(v) -> relatedartifact_to_json(v)
    ParametersParameterValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    ParametersParameterValueUsagecontext(v) -> usagecontext_to_json(v)
    ParametersParameterValueAvailability(v) -> availability_to_json(v)
    ParametersParameterValueExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    ParametersParameterValueDosage(v) -> dosage_to_json(v)
    ParametersParameterValueMeta(v) -> meta_to_json(v)
  }
}

pub fn parameters_parameter_value_decoder() -> Decoder(ParametersParameterValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(ParametersParameterValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ParametersParameterValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(ParametersParameterValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ParametersParameterValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(ParametersParameterValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ParametersParameterValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ParametersParameterValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(ParametersParameterValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(ParametersParameterValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ParametersParameterValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(ParametersParameterValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(ParametersParameterValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(ParametersParameterValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(ParametersParameterValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ParametersParameterValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(ParametersParameterValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(ParametersParameterValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(ParametersParameterValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ParametersParameterValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(ParametersParameterValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(ParametersParameterValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(ParametersParameterValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(ParametersParameterValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(ParametersParameterValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ParametersParameterValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(ParametersParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ParametersParameterValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ParametersParameterValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(ParametersParameterValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(ParametersParameterValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(ParametersParameterValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(ParametersParameterValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(ParametersParameterValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(ParametersParameterValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(ParametersParameterValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(ParametersParameterValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(ParametersParameterValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(ParametersParameterValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(ParametersParameterValueMeta),
    ],
  )
}

pub fn parameters_parameter_new(name name: String) -> ParametersParameter {
  ParametersParameter(
    resource: None,
    value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn parameters_parameter_to_json(
  parameters_parameter: ParametersParameter,
) -> Json {
  let ParametersParameter(
    resource:,
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = parameters_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case resource {
    Some(v) -> [#("resource", resource_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ParametersParameterValueBase64binary(_) -> "Base64binary"
          ParametersParameterValueBoolean(_) -> "Boolean"
          ParametersParameterValueCanonical(_) -> "Canonical"
          ParametersParameterValueCode(_) -> "Code"
          ParametersParameterValueDate(_) -> "Date"
          ParametersParameterValueDatetime(_) -> "Datetime"
          ParametersParameterValueDecimal(_) -> "Decimal"
          ParametersParameterValueId(_) -> "Id"
          ParametersParameterValueInstant(_) -> "Instant"
          ParametersParameterValueInteger(_) -> "Integer"
          ParametersParameterValueInteger64(_) -> "Integer64"
          ParametersParameterValueMarkdown(_) -> "Markdown"
          ParametersParameterValueOid(_) -> "Oid"
          ParametersParameterValuePositiveint(_) -> "Positiveint"
          ParametersParameterValueString(_) -> "String"
          ParametersParameterValueTime(_) -> "Time"
          ParametersParameterValueUnsignedint(_) -> "Unsignedint"
          ParametersParameterValueUri(_) -> "Uri"
          ParametersParameterValueUrl(_) -> "Url"
          ParametersParameterValueUuid(_) -> "Uuid"
          ParametersParameterValueAddress(_) -> "Address"
          ParametersParameterValueAge(_) -> "Age"
          ParametersParameterValueAnnotation(_) -> "Annotation"
          ParametersParameterValueAttachment(_) -> "Attachment"
          ParametersParameterValueCodeableconcept(_) -> "Codeableconcept"
          ParametersParameterValueCodeablereference(_) -> "Codeablereference"
          ParametersParameterValueCoding(_) -> "Coding"
          ParametersParameterValueContactpoint(_) -> "Contactpoint"
          ParametersParameterValueCount(_) -> "Count"
          ParametersParameterValueDistance(_) -> "Distance"
          ParametersParameterValueDuration(_) -> "Duration"
          ParametersParameterValueHumanname(_) -> "Humanname"
          ParametersParameterValueIdentifier(_) -> "Identifier"
          ParametersParameterValueMoney(_) -> "Money"
          ParametersParameterValuePeriod(_) -> "Period"
          ParametersParameterValueQuantity(_) -> "Quantity"
          ParametersParameterValueRange(_) -> "Range"
          ParametersParameterValueRatio(_) -> "Ratio"
          ParametersParameterValueRatiorange(_) -> "Ratiorange"
          ParametersParameterValueReference(_) -> "Reference"
          ParametersParameterValueSampleddata(_) -> "Sampleddata"
          ParametersParameterValueSignature(_) -> "Signature"
          ParametersParameterValueTiming(_) -> "Timing"
          ParametersParameterValueContactdetail(_) -> "Contactdetail"
          ParametersParameterValueDatarequirement(_) -> "Datarequirement"
          ParametersParameterValueExpression(_) -> "Expression"
          ParametersParameterValueParameterdefinition(_) ->
            "Parameterdefinition"
          ParametersParameterValueRelatedartifact(_) -> "Relatedartifact"
          ParametersParameterValueTriggerdefinition(_) -> "Triggerdefinition"
          ParametersParameterValueUsagecontext(_) -> "Usagecontext"
          ParametersParameterValueAvailability(_) -> "Availability"
          ParametersParameterValueExtendedcontactdetail(_) ->
            "Extendedcontactdetail"
          ParametersParameterValueDosage(_) -> "Dosage"
          ParametersParameterValueMeta(_) -> "Meta"
        },
        parameters_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn parameters_parameter_decoder() -> Decoder(ParametersParameter) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(resource_decoder()),
  )
  use value <- decode.then(
    none_if_omitted(parameters_parameter_value_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ParametersParameter(
    resource:,
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn parameters_to_json(parameters: Parameters) -> Json {
  let Parameters(parameter:, language:, implicit_rules:, meta:, id:) =
    parameters
  let fields = []
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, parameters_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Parameters")), ..fields]
  json.object(fields)
}

pub fn parameters_decoder() -> Decoder(Parameters) {
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(parameters_parameter_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Parameters",
    decode.failure(parameters_new(), "resourceType"),
  )
  decode.success(Parameters(parameter:, language:, implicit_rules:, meta:, id:))
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type Patient {
  Patient(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r5valuesets.Administrativegender),
    birth_date: Option(String),
    deceased: Option(PatientDeceased),
    address: List(Address),
    marital_status: Option(Codeableconcept),
    multiple_birth: Option(PatientMultiplebirth),
    photo: List(Attachment),
    contact: List(PatientContact),
    communication: List(PatientCommunication),
    general_practitioner: List(Reference),
    managing_organization: Option(Reference),
    link: List(PatientLink),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type PatientDeceased {
  PatientDeceasedBoolean(deceased: Bool)
  PatientDeceasedDatetime(deceased: String)
}

pub fn patient_deceased_to_json(elt: PatientDeceased) -> Json {
  case elt {
    PatientDeceasedBoolean(v) -> json.bool(v)
    PatientDeceasedDatetime(v) -> json.string(v)
  }
}

pub fn patient_deceased_decoder() -> Decoder(PatientDeceased) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(PatientDeceasedBoolean),
    [
      decode.field("deceasedDateTime", decode.string, decode.success)
      |> decode.map(PatientDeceasedDatetime),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type PatientMultiplebirth {
  PatientMultiplebirthBoolean(multiple_birth: Bool)
  PatientMultiplebirthInteger(multiple_birth: Int)
}

pub fn patient_multiplebirth_to_json(elt: PatientMultiplebirth) -> Json {
  case elt {
    PatientMultiplebirthBoolean(v) -> json.bool(v)
    PatientMultiplebirthInteger(v) -> json.int(v)
  }
}

pub fn patient_multiplebirth_decoder() -> Decoder(PatientMultiplebirth) {
  decode.one_of(
    decode.field("multipleBirthBoolean", decode.bool, decode.success)
      |> decode.map(PatientMultiplebirthBoolean),
    [
      decode.field("multipleBirthInteger", decode.int, decode.success)
      |> decode.map(PatientMultiplebirthInteger),
    ],
  )
}

pub fn patient_new() -> Patient {
  Patient(
    link: [],
    managing_organization: None,
    general_practitioner: [],
    communication: [],
    contact: [],
    photo: [],
    multiple_birth: None,
    marital_status: None,
    address: [],
    deceased: None,
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type PatientContact {
  PatientContact(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    relationship: List(Codeableconcept),
    name: Option(Humanname),
    telecom: List(Contactpoint),
    address: Option(Address),
    gender: Option(r5valuesets.Administrativegender),
    organization: Option(Reference),
    period: Option(Period),
  )
}

pub fn patient_contact_new() -> PatientContact {
  PatientContact(
    period: None,
    organization: None,
    gender: None,
    address: None,
    telecom: [],
    name: None,
    relationship: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type PatientCommunication {
  PatientCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn patient_communication_new(
  language language: Codeableconcept,
) -> PatientCommunication {
  PatientCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Patient#resource
pub type PatientLink {
  PatientLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    other: Reference,
    type_: r5valuesets.Linktype,
  )
}

pub fn patient_link_new(
  type_ type_: r5valuesets.Linktype,
  other other: Reference,
) -> PatientLink {
  PatientLink(type_:, other:, modifier_extension: [], extension: [], id: None)
}

pub fn patient_link_to_json(patient_link: PatientLink) -> Json {
  let PatientLink(type_:, other:, modifier_extension:, extension:, id:) =
    patient_link
  let fields = [
    #("type", r5valuesets.linktype_to_json(type_)),
    #("other", reference_to_json(other)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_link_decoder() -> Decoder(PatientLink) {
  use type_ <- decode.field("type", r5valuesets.linktype_decoder())
  use other <- decode.field("other", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientLink(
    type_:,
    other:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_communication_to_json(
  patient_communication: PatientCommunication,
) -> Json {
  let PatientCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = patient_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_communication_decoder() -> Decoder(PatientCommunication) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_contact_to_json(patient_contact: PatientContact) -> Json {
  let PatientContact(
    period:,
    organization:,
    gender:,
    address:,
    telecom:,
    name:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ) = patient_contact
  let fields = []
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case address {
    Some(v) -> [#("address", address_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", humanname_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #("relationship", json.array(relationship, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn patient_contact_decoder() -> Decoder(PatientContact) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    None,
    decode.optional(address_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(humanname_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PatientContact(
    period:,
    organization:,
    gender:,
    address:,
    telecom:,
    name:,
    relationship:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn patient_to_json(patient: Patient) -> Json {
  let Patient(
    link:,
    managing_organization:,
    general_practitioner:,
    communication:,
    contact:,
    photo:,
    multiple_birth:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = patient
  let fields = []
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, patient_link_to_json)), ..fields]
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case general_practitioner {
    [] -> fields
    _ -> [
      #(
        "generalPractitioner",
        json.array(general_practitioner, reference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, patient_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, patient_contact_to_json)), ..fields]
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case multiple_birth {
    Some(v) -> [
      #(
        "multipleBirth"
          <> case v {
          PatientMultiplebirthBoolean(_) -> "Boolean"
          PatientMultiplebirthInteger(_) -> "Integer"
        },
        patient_multiplebirth_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case marital_status {
    Some(v) -> [#("maritalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          PatientDeceasedBoolean(_) -> "Boolean"
          PatientDeceasedDatetime(_) -> "Datetime"
        },
        patient_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Patient")), ..fields]
  json.object(fields)
}

pub fn patient_decoder() -> Decoder(Patient) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(patient_link_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use general_practitioner <- decode.optional_field(
    "generalPractitioner",
    [],
    decode.list(reference_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(patient_communication_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(patient_contact_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use multiple_birth <- decode.then(
    none_if_omitted(patient_multiplebirth_decoder()),
  )
  use marital_status <- decode.optional_field(
    "maritalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use deceased <- decode.then(none_if_omitted(patient_deceased_decoder()))
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Patient",
    decode.failure(patient_new(), "resourceType"),
  )
  decode.success(Patient(
    link:,
    managing_organization:,
    general_practitioner:,
    communication:,
    contact:,
    photo:,
    multiple_birth:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/PaymentNotice#resource
pub type Paymentnotice {
  Paymentnotice(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Fmstatus,
    request: Option(Reference),
    response: Option(Reference),
    created: String,
    reporter: Option(Reference),
    payment: Option(Reference),
    payment_date: Option(String),
    payee: Option(Reference),
    recipient: Reference,
    amount: Money,
    payment_status: Option(Codeableconcept),
  )
}

pub fn paymentnotice_new(
  amount amount: Money,
  recipient recipient: Reference,
  created created: String,
  status status: r5valuesets.Fmstatus,
) -> Paymentnotice {
  Paymentnotice(
    payment_status: None,
    amount:,
    recipient:,
    payee: None,
    payment_date: None,
    payment: None,
    reporter: None,
    created:,
    response: None,
    request: None,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn paymentnotice_to_json(paymentnotice: Paymentnotice) -> Json {
  let Paymentnotice(
    payment_status:,
    amount:,
    recipient:,
    payee:,
    payment_date:,
    payment:,
    reporter:,
    created:,
    response:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = paymentnotice
  let fields = [
    #("amount", money_to_json(amount)),
    #("recipient", reference_to_json(recipient)),
    #("created", json.string(created)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case payment_status {
    Some(v) -> [#("paymentStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_date {
    Some(v) -> [#("paymentDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case payment {
    Some(v) -> [#("payment", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reporter {
    Some(v) -> [#("reporter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [#("response", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Paymentnotice")), ..fields]
  json.object(fields)
}

pub fn paymentnotice_decoder() -> Decoder(Paymentnotice) {
  use payment_status <- decode.optional_field(
    "paymentStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use amount <- decode.field("amount", money_decoder())
  use recipient <- decode.field("recipient", reference_decoder())
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_date <- decode.optional_field(
    "paymentDate",
    None,
    decode.optional(decode.string),
  )
  use payment <- decode.optional_field(
    "payment",
    None,
    decode.optional(reference_decoder()),
  )
  use reporter <- decode.optional_field(
    "reporter",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Paymentnotice",
    decode.failure(
      paymentnotice_new(amount:, recipient:, created:, status:),
      "resourceType",
    ),
  )
  decode.success(Paymentnotice(
    payment_status:,
    amount:,
    recipient:,
    payee:,
    payment_date:,
    payment:,
    reporter:,
    created:,
    response:,
    request:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/PaymentReconciliation#resource
pub type Paymentreconciliation {
  Paymentreconciliation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    type_: Codeableconcept,
    status: r5valuesets.Fmstatus,
    kind: Option(Codeableconcept),
    period: Option(Period),
    created: String,
    enterer: Option(Reference),
    issuer_type: Option(Codeableconcept),
    payment_issuer: Option(Reference),
    request: Option(Reference),
    requestor: Option(Reference),
    outcome: Option(r5valuesets.Paymentoutcome),
    disposition: Option(String),
    date: String,
    location: Option(Reference),
    method: Option(Codeableconcept),
    card_brand: Option(String),
    account_number: Option(String),
    expiration_date: Option(String),
    processor: Option(String),
    reference_number: Option(String),
    authorization: Option(String),
    tendered_amount: Option(Money),
    returned_amount: Option(Money),
    amount: Money,
    payment_identifier: Option(Identifier),
    allocation: List(PaymentreconciliationAllocation),
    form_code: Option(Codeableconcept),
    process_note: List(PaymentreconciliationProcessnote),
  )
}

pub fn paymentreconciliation_new(
  amount amount: Money,
  date date: String,
  created created: String,
  status status: r5valuesets.Fmstatus,
  type_ type_: Codeableconcept,
) -> Paymentreconciliation {
  Paymentreconciliation(
    process_note: [],
    form_code: None,
    allocation: [],
    payment_identifier: None,
    amount:,
    returned_amount: None,
    tendered_amount: None,
    authorization: None,
    reference_number: None,
    processor: None,
    expiration_date: None,
    account_number: None,
    card_brand: None,
    method: None,
    location: None,
    date:,
    disposition: None,
    outcome: None,
    requestor: None,
    request: None,
    payment_issuer: None,
    issuer_type: None,
    enterer: None,
    created:,
    period: None,
    kind: None,
    status:,
    type_:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationAllocation {
  PaymentreconciliationAllocation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    predecessor: Option(Identifier),
    target: Option(Reference),
    target_item: Option(PaymentreconciliationAllocationTargetitem),
    encounter: Option(Reference),
    account: Option(Reference),
    type_: Option(Codeableconcept),
    submitter: Option(Reference),
    response: Option(Reference),
    date: Option(String),
    responsible: Option(Reference),
    payee: Option(Reference),
    amount: Option(Money),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationAllocationTargetitem {
  PaymentreconciliationAllocationTargetitemString(target_item: String)
  PaymentreconciliationAllocationTargetitemIdentifier(target_item: Identifier)
  PaymentreconciliationAllocationTargetitemPositiveint(target_item: Int)
}

pub fn paymentreconciliation_allocation_targetitem_to_json(
  elt: PaymentreconciliationAllocationTargetitem,
) -> Json {
  case elt {
    PaymentreconciliationAllocationTargetitemString(v) -> json.string(v)
    PaymentreconciliationAllocationTargetitemIdentifier(v) ->
      identifier_to_json(v)
    PaymentreconciliationAllocationTargetitemPositiveint(v) -> json.int(v)
  }
}

pub fn paymentreconciliation_allocation_targetitem_decoder() -> Decoder(
  PaymentreconciliationAllocationTargetitem,
) {
  decode.one_of(
    decode.field("targetItemString", decode.string, decode.success)
      |> decode.map(PaymentreconciliationAllocationTargetitemString),
    [
      decode.field("targetItemIdentifier", identifier_decoder(), decode.success)
        |> decode.map(PaymentreconciliationAllocationTargetitemIdentifier),
      decode.field("targetItemPositiveInt", decode.int, decode.success)
        |> decode.map(PaymentreconciliationAllocationTargetitemPositiveint),
    ],
  )
}

pub fn paymentreconciliation_allocation_new() -> PaymentreconciliationAllocation {
  PaymentreconciliationAllocation(
    amount: None,
    payee: None,
    responsible: None,
    date: None,
    response: None,
    submitter: None,
    type_: None,
    account: None,
    encounter: None,
    target_item: None,
    target: None,
    predecessor: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PaymentReconciliation#resource
pub type PaymentreconciliationProcessnote {
  PaymentreconciliationProcessnote(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Notetype),
    text: Option(String),
  )
}

pub fn paymentreconciliation_processnote_new() -> PaymentreconciliationProcessnote {
  PaymentreconciliationProcessnote(
    text: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn paymentreconciliation_processnote_to_json(
  paymentreconciliation_processnote: PaymentreconciliationProcessnote,
) -> Json {
  let PaymentreconciliationProcessnote(
    text:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = paymentreconciliation_processnote
  let fields = []
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", r5valuesets.notetype_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn paymentreconciliation_processnote_decoder() -> Decoder(
  PaymentreconciliationProcessnote,
) {
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.notetype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PaymentreconciliationProcessnote(
    text:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn paymentreconciliation_allocation_to_json(
  paymentreconciliation_allocation: PaymentreconciliationAllocation,
) -> Json {
  let PaymentreconciliationAllocation(
    amount:,
    payee:,
    responsible:,
    date:,
    response:,
    submitter:,
    type_:,
    account:,
    encounter:,
    target_item:,
    target:,
    predecessor:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = paymentreconciliation_allocation
  let fields = []
  let fields = case amount {
    Some(v) -> [#("amount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payee {
    Some(v) -> [#("payee", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case responsible {
    Some(v) -> [#("responsible", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [#("response", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case submitter {
    Some(v) -> [#("submitter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case account {
    Some(v) -> [#("account", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target_item {
    Some(v) -> [
      #(
        "targetItem"
          <> case v {
          PaymentreconciliationAllocationTargetitemString(_) -> "String"
          PaymentreconciliationAllocationTargetitemIdentifier(_) -> "Identifier"
          PaymentreconciliationAllocationTargetitemPositiveint(_) ->
            "Positiveint"
        },
        paymentreconciliation_allocation_targetitem_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case target {
    Some(v) -> [#("target", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case predecessor {
    Some(v) -> [#("predecessor", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn paymentreconciliation_allocation_decoder() -> Decoder(
  PaymentreconciliationAllocation,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(money_decoder()),
  )
  use payee <- decode.optional_field(
    "payee",
    None,
    decode.optional(reference_decoder()),
  )
  use responsible <- decode.optional_field(
    "responsible",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(reference_decoder()),
  )
  use submitter <- decode.optional_field(
    "submitter",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use account <- decode.optional_field(
    "account",
    None,
    decode.optional(reference_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use target_item <- decode.then(
    none_if_omitted(paymentreconciliation_allocation_targetitem_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(reference_decoder()),
  )
  use predecessor <- decode.optional_field(
    "predecessor",
    None,
    decode.optional(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PaymentreconciliationAllocation(
    amount:,
    payee:,
    responsible:,
    date:,
    response:,
    submitter:,
    type_:,
    account:,
    encounter:,
    target_item:,
    target:,
    predecessor:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn paymentreconciliation_to_json(
  paymentreconciliation: Paymentreconciliation,
) -> Json {
  let Paymentreconciliation(
    process_note:,
    form_code:,
    allocation:,
    payment_identifier:,
    amount:,
    returned_amount:,
    tendered_amount:,
    authorization:,
    reference_number:,
    processor:,
    expiration_date:,
    account_number:,
    card_brand:,
    method:,
    location:,
    date:,
    disposition:,
    outcome:,
    requestor:,
    request:,
    payment_issuer:,
    issuer_type:,
    enterer:,
    created:,
    period:,
    kind:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = paymentreconciliation
  let fields = [
    #("amount", money_to_json(amount)),
    #("date", json.string(date)),
    #("created", json.string(created)),
    #("status", r5valuesets.fmstatus_to_json(status)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case process_note {
    [] -> fields
    _ -> [
      #(
        "processNote",
        json.array(process_note, paymentreconciliation_processnote_to_json),
      ),
      ..fields
    ]
  }
  let fields = case form_code {
    Some(v) -> [#("formCode", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case allocation {
    [] -> fields
    _ -> [
      #(
        "allocation",
        json.array(allocation, paymentreconciliation_allocation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case payment_identifier {
    Some(v) -> [#("paymentIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case returned_amount {
    Some(v) -> [#("returnedAmount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case tendered_amount {
    Some(v) -> [#("tenderedAmount", money_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authorization {
    Some(v) -> [#("authorization", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reference_number {
    Some(v) -> [#("referenceNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case processor {
    Some(v) -> [#("processor", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expiration_date {
    Some(v) -> [#("expirationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case account_number {
    Some(v) -> [#("accountNumber", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case card_brand {
    Some(v) -> [#("cardBrand", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case disposition {
    Some(v) -> [#("disposition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", r5valuesets.paymentoutcome_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requestor {
    Some(v) -> [#("requestor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case request {
    Some(v) -> [#("request", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case payment_issuer {
    Some(v) -> [#("paymentIssuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case issuer_type {
    Some(v) -> [#("issuerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case enterer {
    Some(v) -> [#("enterer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case kind {
    Some(v) -> [#("kind", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Paymentreconciliation")),
    ..fields
  ]
  json.object(fields)
}

pub fn paymentreconciliation_decoder() -> Decoder(Paymentreconciliation) {
  use process_note <- decode.optional_field(
    "processNote",
    [],
    decode.list(paymentreconciliation_processnote_decoder()),
  )
  use form_code <- decode.optional_field(
    "formCode",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use allocation <- decode.optional_field(
    "allocation",
    [],
    decode.list(paymentreconciliation_allocation_decoder()),
  )
  use payment_identifier <- decode.optional_field(
    "paymentIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use amount <- decode.field("amount", money_decoder())
  use returned_amount <- decode.optional_field(
    "returnedAmount",
    None,
    decode.optional(money_decoder()),
  )
  use tendered_amount <- decode.optional_field(
    "tenderedAmount",
    None,
    decode.optional(money_decoder()),
  )
  use authorization <- decode.optional_field(
    "authorization",
    None,
    decode.optional(decode.string),
  )
  use reference_number <- decode.optional_field(
    "referenceNumber",
    None,
    decode.optional(decode.string),
  )
  use processor <- decode.optional_field(
    "processor",
    None,
    decode.optional(decode.string),
  )
  use expiration_date <- decode.optional_field(
    "expirationDate",
    None,
    decode.optional(decode.string),
  )
  use account_number <- decode.optional_field(
    "accountNumber",
    None,
    decode.optional(decode.string),
  )
  use card_brand <- decode.optional_field(
    "cardBrand",
    None,
    decode.optional(decode.string),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use date <- decode.field("date", decode.string)
  use disposition <- decode.optional_field(
    "disposition",
    None,
    decode.optional(decode.string),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(r5valuesets.paymentoutcome_decoder()),
  )
  use requestor <- decode.optional_field(
    "requestor",
    None,
    decode.optional(reference_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    None,
    decode.optional(reference_decoder()),
  )
  use payment_issuer <- decode.optional_field(
    "paymentIssuer",
    None,
    decode.optional(reference_decoder()),
  )
  use issuer_type <- decode.optional_field(
    "issuerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use enterer <- decode.optional_field(
    "enterer",
    None,
    decode.optional(reference_decoder()),
  )
  use created <- decode.field("created", decode.string)
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use kind <- decode.optional_field(
    "kind",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Paymentreconciliation",
    decode.failure(
      paymentreconciliation_new(amount:, date:, created:, status:, type_:),
      "resourceType",
    ),
  )
  decode.success(Paymentreconciliation(
    process_note:,
    form_code:,
    allocation:,
    payment_identifier:,
    amount:,
    returned_amount:,
    tendered_amount:,
    authorization:,
    reference_number:,
    processor:,
    expiration_date:,
    account_number:,
    card_brand:,
    method:,
    location:,
    date:,
    disposition:,
    outcome:,
    requestor:,
    request:,
    payment_issuer:,
    issuer_type:,
    enterer:,
    created:,
    period:,
    kind:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type Permission {
  Permission(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: r5valuesets.Permissionstatus,
    asserter: Option(Reference),
    date: List(String),
    validity: Option(Period),
    justification: Option(PermissionJustification),
    combining: r5valuesets.Permissionrulecombining,
    rule: List(PermissionRule),
  )
}

pub fn permission_new(
  combining combining: r5valuesets.Permissionrulecombining,
  status status: r5valuesets.Permissionstatus,
) -> Permission {
  Permission(
    rule: [],
    combining:,
    justification: None,
    validity: None,
    date: [],
    asserter: None,
    status:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type PermissionJustification {
  PermissionJustification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    basis: List(Codeableconcept),
    evidence: List(Reference),
  )
}

pub fn permission_justification_new() -> PermissionJustification {
  PermissionJustification(
    evidence: [],
    basis: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type PermissionRule {
  PermissionRule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Consentprovisiontype),
    data: List(PermissionRuleData),
    activity: List(PermissionRuleActivity),
    limit: List(Codeableconcept),
  )
}

pub fn permission_rule_new() -> PermissionRule {
  PermissionRule(
    limit: [],
    activity: [],
    data: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type PermissionRuleData {
  PermissionRuleData(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource: List(PermissionRuleDataResource),
    security: List(Coding),
    period: List(Period),
    expression: Option(Expression),
  )
}

pub fn permission_rule_data_new() -> PermissionRuleData {
  PermissionRuleData(
    expression: None,
    period: [],
    security: [],
    resource: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type PermissionRuleDataResource {
  PermissionRuleDataResource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    meaning: r5valuesets.Consentdatameaning,
    reference: Reference,
  )
}

pub fn permission_rule_data_resource_new(
  reference reference: Reference,
  meaning meaning: r5valuesets.Consentdatameaning,
) -> PermissionRuleDataResource {
  PermissionRuleDataResource(
    reference:,
    meaning:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Permission#resource
pub type PermissionRuleActivity {
  PermissionRuleActivity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    actor: List(Reference),
    action: List(Codeableconcept),
    purpose: List(Codeableconcept),
  )
}

pub fn permission_rule_activity_new() -> PermissionRuleActivity {
  PermissionRuleActivity(
    purpose: [],
    action: [],
    actor: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn permission_rule_activity_to_json(
  permission_rule_activity: PermissionRuleActivity,
) -> Json {
  let PermissionRuleActivity(
    purpose:,
    action:,
    actor:,
    modifier_extension:,
    extension:,
    id:,
  ) = permission_rule_activity
  let fields = []
  let fields = case purpose {
    [] -> fields
    _ -> [#("purpose", json.array(purpose, codeableconcept_to_json)), ..fields]
  }
  let fields = case action {
    [] -> fields
    _ -> [#("action", json.array(action, codeableconcept_to_json)), ..fields]
  }
  let fields = case actor {
    [] -> fields
    _ -> [#("actor", json.array(actor, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn permission_rule_activity_decoder() -> Decoder(PermissionRuleActivity) {
  use purpose <- decode.optional_field(
    "purpose",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PermissionRuleActivity(
    purpose:,
    action:,
    actor:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn permission_rule_data_resource_to_json(
  permission_rule_data_resource: PermissionRuleDataResource,
) -> Json {
  let PermissionRuleDataResource(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ) = permission_rule_data_resource
  let fields = [
    #("reference", reference_to_json(reference)),
    #("meaning", r5valuesets.consentdatameaning_to_json(meaning)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn permission_rule_data_resource_decoder() -> Decoder(
  PermissionRuleDataResource,
) {
  use reference <- decode.field("reference", reference_decoder())
  use meaning <- decode.field(
    "meaning",
    r5valuesets.consentdatameaning_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PermissionRuleDataResource(
    reference:,
    meaning:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn permission_rule_data_to_json(
  permission_rule_data: PermissionRuleData,
) -> Json {
  let PermissionRuleData(
    expression:,
    period:,
    security:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ) = permission_rule_data
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    [] -> fields
    _ -> [#("period", json.array(period, period_to_json)), ..fields]
  }
  let fields = case security {
    [] -> fields
    _ -> [#("security", json.array(security, coding_to_json)), ..fields]
  }
  let fields = case resource {
    [] -> fields
    _ -> [
      #("resource", json.array(resource, permission_rule_data_resource_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn permission_rule_data_decoder() -> Decoder(PermissionRuleData) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    [],
    decode.list(period_decoder()),
  )
  use security <- decode.optional_field(
    "security",
    [],
    decode.list(coding_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    [],
    decode.list(permission_rule_data_resource_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PermissionRuleData(
    expression:,
    period:,
    security:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn permission_rule_to_json(permission_rule: PermissionRule) -> Json {
  let PermissionRule(
    limit:,
    activity:,
    data:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = permission_rule
  let fields = []
  let fields = case limit {
    [] -> fields
    _ -> [#("limit", json.array(limit, codeableconcept_to_json)), ..fields]
  }
  let fields = case activity {
    [] -> fields
    _ -> [
      #("activity", json.array(activity, permission_rule_activity_to_json)),
      ..fields
    ]
  }
  let fields = case data {
    [] -> fields
    _ -> [#("data", json.array(data, permission_rule_data_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.consentprovisiontype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn permission_rule_decoder() -> Decoder(PermissionRule) {
  use limit <- decode.optional_field(
    "limit",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use activity <- decode.optional_field(
    "activity",
    [],
    decode.list(permission_rule_activity_decoder()),
  )
  use data <- decode.optional_field(
    "data",
    [],
    decode.list(permission_rule_data_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.consentprovisiontype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PermissionRule(
    limit:,
    activity:,
    data:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn permission_justification_to_json(
  permission_justification: PermissionJustification,
) -> Json {
  let PermissionJustification(
    evidence:,
    basis:,
    modifier_extension:,
    extension:,
    id:,
  ) = permission_justification
  let fields = []
  let fields = case evidence {
    [] -> fields
    _ -> [#("evidence", json.array(evidence, reference_to_json)), ..fields]
  }
  let fields = case basis {
    [] -> fields
    _ -> [#("basis", json.array(basis, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn permission_justification_decoder() -> Decoder(PermissionJustification) {
  use evidence <- decode.optional_field(
    "evidence",
    [],
    decode.list(reference_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PermissionJustification(
    evidence:,
    basis:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn permission_to_json(permission: Permission) -> Json {
  let Permission(
    rule:,
    combining:,
    justification:,
    validity:,
    date:,
    asserter:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = permission
  let fields = [
    #("combining", r5valuesets.permissionrulecombining_to_json(combining)),
    #("status", r5valuesets.permissionstatus_to_json(status)),
  ]
  let fields = case rule {
    [] -> fields
    _ -> [#("rule", json.array(rule, permission_rule_to_json)), ..fields]
  }
  let fields = case justification {
    Some(v) -> [
      #("justification", permission_justification_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case validity {
    Some(v) -> [#("validity", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    [] -> fields
    _ -> [#("date", json.array(date, json.string)), ..fields]
  }
  let fields = case asserter {
    Some(v) -> [#("asserter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Permission")), ..fields]
  json.object(fields)
}

pub fn permission_decoder() -> Decoder(Permission) {
  use rule <- decode.optional_field(
    "rule",
    [],
    decode.list(permission_rule_decoder()),
  )
  use combining <- decode.field(
    "combining",
    r5valuesets.permissionrulecombining_decoder(),
  )
  use justification <- decode.optional_field(
    "justification",
    None,
    decode.optional(permission_justification_decoder()),
  )
  use validity <- decode.optional_field(
    "validity",
    None,
    decode.optional(period_decoder()),
  )
  use date <- decode.optional_field("date", [], decode.list(decode.string))
  use asserter <- decode.optional_field(
    "asserter",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field("status", r5valuesets.permissionstatus_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Permission",
    decode.failure(permission_new(combining:, status:), "resourceType"),
  )
  decode.success(Permission(
    rule:,
    combining:,
    justification:,
    validity:,
    date:,
    asserter:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Person#resource
pub type Person {
  Person(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r5valuesets.Administrativegender),
    birth_date: Option(String),
    deceased: Option(PersonDeceased),
    address: List(Address),
    marital_status: Option(Codeableconcept),
    photo: List(Attachment),
    communication: List(PersonCommunication),
    managing_organization: Option(Reference),
    link: List(PersonLink),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Person#resource
pub type PersonDeceased {
  PersonDeceasedBoolean(deceased: Bool)
  PersonDeceasedDatetime(deceased: String)
}

pub fn person_deceased_to_json(elt: PersonDeceased) -> Json {
  case elt {
    PersonDeceasedBoolean(v) -> json.bool(v)
    PersonDeceasedDatetime(v) -> json.string(v)
  }
}

pub fn person_deceased_decoder() -> Decoder(PersonDeceased) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(PersonDeceasedBoolean),
    [
      decode.field("deceasedDateTime", decode.string, decode.success)
      |> decode.map(PersonDeceasedDatetime),
    ],
  )
}

pub fn person_new() -> Person {
  Person(
    link: [],
    managing_organization: None,
    communication: [],
    photo: [],
    marital_status: None,
    address: [],
    deceased: None,
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Person#resource
pub type PersonCommunication {
  PersonCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn person_communication_new(
  language language: Codeableconcept,
) -> PersonCommunication {
  PersonCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Person#resource
pub type PersonLink {
  PersonLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: Reference,
    assurance: Option(r5valuesets.Identityassurancelevel),
  )
}

pub fn person_link_new(target target: Reference) -> PersonLink {
  PersonLink(
    assurance: None,
    target:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn person_link_to_json(person_link: PersonLink) -> Json {
  let PersonLink(assurance:, target:, modifier_extension:, extension:, id:) =
    person_link
  let fields = [
    #("target", reference_to_json(target)),
  ]
  let fields = case assurance {
    Some(v) -> [
      #("assurance", r5valuesets.identityassurancelevel_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn person_link_decoder() -> Decoder(PersonLink) {
  use assurance <- decode.optional_field(
    "assurance",
    None,
    decode.optional(r5valuesets.identityassurancelevel_decoder()),
  )
  use target <- decode.field("target", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PersonLink(
    assurance:,
    target:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn person_communication_to_json(
  person_communication: PersonCommunication,
) -> Json {
  let PersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = person_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn person_communication_decoder() -> Decoder(PersonCommunication) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn person_to_json(person: Person) -> Json {
  let Person(
    link:,
    managing_organization:,
    communication:,
    photo:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = person
  let fields = []
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, person_link_to_json)), ..fields]
  }
  let fields = case managing_organization {
    Some(v) -> [#("managingOrganization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, person_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case marital_status {
    Some(v) -> [#("maritalStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          PersonDeceasedBoolean(_) -> "Boolean"
          PersonDeceasedDatetime(_) -> "Datetime"
        },
        person_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Person")), ..fields]
  json.object(fields)
}

pub fn person_decoder() -> Decoder(Person) {
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(person_link_decoder()),
  )
  use managing_organization <- decode.optional_field(
    "managingOrganization",
    None,
    decode.optional(reference_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(person_communication_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use marital_status <- decode.optional_field(
    "maritalStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use deceased <- decode.then(none_if_omitted(person_deceased_decoder()))
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Person",
    decode.failure(person_new(), "resourceType"),
  )
  decode.success(Person(
    link:,
    managing_organization:,
    communication:,
    photo:,
    marital_status:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type Plandefinition {
  Plandefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(PlandefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    subtitle: Option(String),
    type_: Option(Codeableconcept),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(PlandefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    usage: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    library: List(String),
    goal: List(PlandefinitionGoal),
    actor: List(PlandefinitionActor),
    action: List(PlandefinitionAction),
    as_needed: Option(PlandefinitionAsneeded),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionVersionalgorithm {
  PlandefinitionVersionalgorithmString(version_algorithm: String)
  PlandefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn plandefinition_versionalgorithm_to_json(
  elt: PlandefinitionVersionalgorithm,
) -> Json {
  case elt {
    PlandefinitionVersionalgorithmString(v) -> json.string(v)
    PlandefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn plandefinition_versionalgorithm_decoder() -> Decoder(
  PlandefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(PlandefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(PlandefinitionVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionSubject {
  PlandefinitionSubjectCodeableconcept(subject: Codeableconcept)
  PlandefinitionSubjectReference(subject: Reference)
  PlandefinitionSubjectCanonical(subject: String)
}

pub fn plandefinition_subject_to_json(elt: PlandefinitionSubject) -> Json {
  case elt {
    PlandefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    PlandefinitionSubjectReference(v) -> reference_to_json(v)
    PlandefinitionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn plandefinition_subject_decoder() -> Decoder(PlandefinitionSubject) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(PlandefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(PlandefinitionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(PlandefinitionSubjectCanonical),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionAsneeded {
  PlandefinitionAsneededBoolean(as_needed: Bool)
  PlandefinitionAsneededCodeableconcept(as_needed: Codeableconcept)
}

pub fn plandefinition_asneeded_to_json(elt: PlandefinitionAsneeded) -> Json {
  case elt {
    PlandefinitionAsneededBoolean(v) -> json.bool(v)
    PlandefinitionAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn plandefinition_asneeded_decoder() -> Decoder(PlandefinitionAsneeded) {
  decode.one_of(
    decode.field("asNeededBoolean", decode.bool, decode.success)
      |> decode.map(PlandefinitionAsneededBoolean),
    [
      decode.field(
        "asNeededCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(PlandefinitionAsneededCodeableconcept),
    ],
  )
}

pub fn plandefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Plandefinition {
  Plandefinition(
    as_needed: None,
    action: [],
    actor: [],
    goal: [],
    library: [],
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    usage: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    type_: None,
    subtitle: None,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoal {
  PlandefinitionGoal(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    category: Option(Codeableconcept),
    description: Codeableconcept,
    priority: Option(Codeableconcept),
    start: Option(Codeableconcept),
    addresses: List(Codeableconcept),
    documentation: List(Relatedartifact),
    target: List(PlandefinitionGoalTarget),
  )
}

pub fn plandefinition_goal_new(
  description description: Codeableconcept,
) -> PlandefinitionGoal {
  PlandefinitionGoal(
    target: [],
    documentation: [],
    addresses: [],
    start: None,
    priority: None,
    description:,
    category: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTarget {
  PlandefinitionGoalTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    measure: Option(Codeableconcept),
    detail: Option(PlandefinitionGoalTargetDetail),
    due: Option(Duration),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionGoalTargetDetail {
  PlandefinitionGoalTargetDetailQuantity(detail: Quantity)
  PlandefinitionGoalTargetDetailRange(detail: Range)
  PlandefinitionGoalTargetDetailCodeableconcept(detail: Codeableconcept)
  PlandefinitionGoalTargetDetailString(detail: String)
  PlandefinitionGoalTargetDetailBoolean(detail: Bool)
  PlandefinitionGoalTargetDetailInteger(detail: Int)
  PlandefinitionGoalTargetDetailRatio(detail: Ratio)
}

pub fn plandefinition_goal_target_detail_to_json(
  elt: PlandefinitionGoalTargetDetail,
) -> Json {
  case elt {
    PlandefinitionGoalTargetDetailQuantity(v) -> quantity_to_json(v)
    PlandefinitionGoalTargetDetailRange(v) -> range_to_json(v)
    PlandefinitionGoalTargetDetailCodeableconcept(v) ->
      codeableconcept_to_json(v)
    PlandefinitionGoalTargetDetailString(v) -> json.string(v)
    PlandefinitionGoalTargetDetailBoolean(v) -> json.bool(v)
    PlandefinitionGoalTargetDetailInteger(v) -> json.int(v)
    PlandefinitionGoalTargetDetailRatio(v) -> ratio_to_json(v)
  }
}

pub fn plandefinition_goal_target_detail_decoder() -> Decoder(
  PlandefinitionGoalTargetDetail,
) {
  decode.one_of(
    decode.field("detailQuantity", quantity_decoder(), decode.success)
      |> decode.map(PlandefinitionGoalTargetDetailQuantity),
    [
      decode.field("detailRange", range_decoder(), decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailRange),
      decode.field(
        "detailCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(PlandefinitionGoalTargetDetailCodeableconcept),
      decode.field("detailString", decode.string, decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailString),
      decode.field("detailBoolean", decode.bool, decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailBoolean),
      decode.field("detailInteger", decode.int, decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailInteger),
      decode.field("detailRatio", ratio_decoder(), decode.success)
        |> decode.map(PlandefinitionGoalTargetDetailRatio),
    ],
  )
}

pub fn plandefinition_goal_target_new() -> PlandefinitionGoalTarget {
  PlandefinitionGoalTarget(
    due: None,
    detail: None,
    measure: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActor {
  PlandefinitionActor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    description: Option(String),
    option: List(PlandefinitionActorOption),
  )
}

pub fn plandefinition_actor_new() -> PlandefinitionActor {
  PlandefinitionActor(
    option: [],
    description: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActorOption {
  PlandefinitionActorOption(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Actionparticipanttype),
    type_canonical: Option(String),
    type_reference: Option(Reference),
    role: Option(Codeableconcept),
  )
}

pub fn plandefinition_actor_option_new() -> PlandefinitionActorOption {
  PlandefinitionActorOption(
    role: None,
    type_reference: None,
    type_canonical: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionAction {
  PlandefinitionAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    prefix: Option(String),
    title: Option(String),
    description: Option(String),
    text_equivalent: Option(String),
    priority: Option(r5valuesets.Requestpriority),
    code: Option(Codeableconcept),
    reason: List(Codeableconcept),
    documentation: List(Relatedartifact),
    goal_id: List(String),
    subject: Option(PlandefinitionActionSubject),
    trigger: List(Triggerdefinition),
    condition: List(PlandefinitionActionCondition),
    input: List(PlandefinitionActionInput),
    output: List(PlandefinitionActionOutput),
    related_action: List(PlandefinitionActionRelatedaction),
    timing: Option(PlandefinitionActionTiming),
    location: Option(Codeablereference),
    participant: List(PlandefinitionActionParticipant),
    type_: Option(Codeableconcept),
    grouping_behavior: Option(r5valuesets.Actiongroupingbehavior),
    selection_behavior: Option(r5valuesets.Actionselectionbehavior),
    required_behavior: Option(r5valuesets.Actionrequiredbehavior),
    precheck_behavior: Option(r5valuesets.Actionprecheckbehavior),
    cardinality_behavior: Option(r5valuesets.Actioncardinalitybehavior),
    definition: Option(PlandefinitionActionDefinition),
    transform: Option(String),
    dynamic_value: List(PlandefinitionActionDynamicvalue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionSubject {
  PlandefinitionActionSubjectCodeableconcept(subject: Codeableconcept)
  PlandefinitionActionSubjectReference(subject: Reference)
  PlandefinitionActionSubjectCanonical(subject: String)
}

pub fn plandefinition_action_subject_to_json(
  elt: PlandefinitionActionSubject,
) -> Json {
  case elt {
    PlandefinitionActionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    PlandefinitionActionSubjectReference(v) -> reference_to_json(v)
    PlandefinitionActionSubjectCanonical(v) -> json.string(v)
  }
}

pub fn plandefinition_action_subject_decoder() -> Decoder(
  PlandefinitionActionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(PlandefinitionActionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
        |> decode.map(PlandefinitionActionSubjectReference),
      decode.field("subjectCanonical", decode.string, decode.success)
        |> decode.map(PlandefinitionActionSubjectCanonical),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionTiming {
  PlandefinitionActionTimingAge(timing: Age)
  PlandefinitionActionTimingDuration(timing: Duration)
  PlandefinitionActionTimingRange(timing: Range)
  PlandefinitionActionTimingTiming(timing: Timing)
}

pub fn plandefinition_action_timing_to_json(
  elt: PlandefinitionActionTiming,
) -> Json {
  case elt {
    PlandefinitionActionTimingAge(v) -> age_to_json(v)
    PlandefinitionActionTimingDuration(v) -> duration_to_json(v)
    PlandefinitionActionTimingRange(v) -> range_to_json(v)
    PlandefinitionActionTimingTiming(v) -> timing_to_json(v)
  }
}

pub fn plandefinition_action_timing_decoder() -> Decoder(
  PlandefinitionActionTiming,
) {
  decode.one_of(
    decode.field("timingAge", age_decoder(), decode.success)
      |> decode.map(PlandefinitionActionTimingAge),
    [
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingDuration),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingRange),
      decode.field("timingTiming", timing_decoder(), decode.success)
        |> decode.map(PlandefinitionActionTimingTiming),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDefinition {
  PlandefinitionActionDefinitionCanonical(definition: String)
  PlandefinitionActionDefinitionUri(definition: String)
}

pub fn plandefinition_action_definition_to_json(
  elt: PlandefinitionActionDefinition,
) -> Json {
  case elt {
    PlandefinitionActionDefinitionCanonical(v) -> json.string(v)
    PlandefinitionActionDefinitionUri(v) -> json.string(v)
  }
}

pub fn plandefinition_action_definition_decoder() -> Decoder(
  PlandefinitionActionDefinition,
) {
  decode.one_of(
    decode.field("definitionCanonical", decode.string, decode.success)
      |> decode.map(PlandefinitionActionDefinitionCanonical),
    [
      decode.field("definitionUri", decode.string, decode.success)
      |> decode.map(PlandefinitionActionDefinitionUri),
    ],
  )
}

pub fn plandefinition_action_new() -> PlandefinitionAction {
  PlandefinitionAction(
    dynamic_value: [],
    transform: None,
    definition: None,
    cardinality_behavior: None,
    precheck_behavior: None,
    required_behavior: None,
    selection_behavior: None,
    grouping_behavior: None,
    type_: None,
    participant: [],
    location: None,
    timing: None,
    related_action: [],
    output: [],
    input: [],
    condition: [],
    trigger: [],
    subject: None,
    goal_id: [],
    documentation: [],
    reason: [],
    code: None,
    priority: None,
    text_equivalent: None,
    description: None,
    title: None,
    prefix: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionCondition {
  PlandefinitionActionCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kind: r5valuesets.Actionconditionkind,
    expression: Option(Expression),
  )
}

pub fn plandefinition_action_condition_new(
  kind kind: r5valuesets.Actionconditionkind,
) -> PlandefinitionActionCondition {
  PlandefinitionActionCondition(
    expression: None,
    kind:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionInput {
  PlandefinitionActionInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    requirement: Option(Datarequirement),
    related_data: Option(String),
  )
}

pub fn plandefinition_action_input_new() -> PlandefinitionActionInput {
  PlandefinitionActionInput(
    related_data: None,
    requirement: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionOutput {
  PlandefinitionActionOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    requirement: Option(Datarequirement),
    related_data: Option(String),
  )
}

pub fn plandefinition_action_output_new() -> PlandefinitionActionOutput {
  PlandefinitionActionOutput(
    related_data: None,
    requirement: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedaction {
  PlandefinitionActionRelatedaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target_id: String,
    relationship: r5valuesets.Actionrelationshiptype,
    end_relationship: Option(r5valuesets.Actionrelationshiptype),
    offset: Option(PlandefinitionActionRelatedactionOffset),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionRelatedactionOffset {
  PlandefinitionActionRelatedactionOffsetDuration(offset: Duration)
  PlandefinitionActionRelatedactionOffsetRange(offset: Range)
}

pub fn plandefinition_action_relatedaction_offset_to_json(
  elt: PlandefinitionActionRelatedactionOffset,
) -> Json {
  case elt {
    PlandefinitionActionRelatedactionOffsetDuration(v) -> duration_to_json(v)
    PlandefinitionActionRelatedactionOffsetRange(v) -> range_to_json(v)
  }
}

pub fn plandefinition_action_relatedaction_offset_decoder() -> Decoder(
  PlandefinitionActionRelatedactionOffset,
) {
  decode.one_of(
    decode.field("offsetDuration", duration_decoder(), decode.success)
      |> decode.map(PlandefinitionActionRelatedactionOffsetDuration),
    [
      decode.field("offsetRange", range_decoder(), decode.success)
      |> decode.map(PlandefinitionActionRelatedactionOffsetRange),
    ],
  )
}

pub fn plandefinition_action_relatedaction_new(
  relationship relationship: r5valuesets.Actionrelationshiptype,
  target_id target_id: String,
) -> PlandefinitionActionRelatedaction {
  PlandefinitionActionRelatedaction(
    offset: None,
    end_relationship: None,
    relationship:,
    target_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionParticipant {
  PlandefinitionActionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    actor_id: Option(String),
    type_: Option(r5valuesets.Actionparticipanttype),
    type_canonical: Option(String),
    type_reference: Option(Reference),
    role: Option(Codeableconcept),
    function: Option(Codeableconcept),
  )
}

pub fn plandefinition_action_participant_new() -> PlandefinitionActionParticipant {
  PlandefinitionActionParticipant(
    function: None,
    role: None,
    type_reference: None,
    type_canonical: None,
    type_: None,
    actor_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/PlanDefinition#resource
pub type PlandefinitionActionDynamicvalue {
  PlandefinitionActionDynamicvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: Option(String),
    expression: Option(Expression),
  )
}

pub fn plandefinition_action_dynamicvalue_new() -> PlandefinitionActionDynamicvalue {
  PlandefinitionActionDynamicvalue(
    expression: None,
    path: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn plandefinition_action_dynamicvalue_to_json(
  plandefinition_action_dynamicvalue: PlandefinitionActionDynamicvalue,
) -> Json {
  let PlandefinitionActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_dynamicvalue
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_dynamicvalue_decoder() -> Decoder(
  PlandefinitionActionDynamicvalue,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_participant_to_json(
  plandefinition_action_participant: PlandefinitionActionParticipant,
) -> Json {
  let PlandefinitionActionParticipant(
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    actor_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_participant
  let fields = []
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_reference {
    Some(v) -> [#("typeReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_canonical {
    Some(v) -> [#("typeCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.actionparticipanttype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case actor_id {
    Some(v) -> [#("actorId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_participant_decoder() -> Decoder(
  PlandefinitionActionParticipant,
) {
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    None,
    decode.optional(reference_decoder()),
  )
  use type_canonical <- decode.optional_field(
    "typeCanonical",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.actionparticipanttype_decoder()),
  )
  use actor_id <- decode.optional_field(
    "actorId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionParticipant(
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    actor_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_relatedaction_to_json(
  plandefinition_action_relatedaction: PlandefinitionActionRelatedaction,
) -> Json {
  let PlandefinitionActionRelatedaction(
    offset:,
    end_relationship:,
    relationship:,
    target_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_relatedaction
  let fields = [
    #("relationship", r5valuesets.actionrelationshiptype_to_json(relationship)),
    #("targetId", json.string(target_id)),
  ]
  let fields = case offset {
    Some(v) -> [
      #(
        "offset"
          <> case v {
          PlandefinitionActionRelatedactionOffsetDuration(_) -> "Duration"
          PlandefinitionActionRelatedactionOffsetRange(_) -> "Range"
        },
        plandefinition_action_relatedaction_offset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case end_relationship {
    Some(v) -> [
      #("endRelationship", r5valuesets.actionrelationshiptype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_relatedaction_decoder() -> Decoder(
  PlandefinitionActionRelatedaction,
) {
  use offset <- decode.then(
    none_if_omitted(plandefinition_action_relatedaction_offset_decoder()),
  )
  use end_relationship <- decode.optional_field(
    "endRelationship",
    None,
    decode.optional(r5valuesets.actionrelationshiptype_decoder()),
  )
  use relationship <- decode.field(
    "relationship",
    r5valuesets.actionrelationshiptype_decoder(),
  )
  use target_id <- decode.field("targetId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionRelatedaction(
    offset:,
    end_relationship:,
    relationship:,
    target_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_output_to_json(
  plandefinition_action_output: PlandefinitionActionOutput,
) -> Json {
  let PlandefinitionActionOutput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_output
  let fields = []
  let fields = case related_data {
    Some(v) -> [#("relatedData", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", datarequirement_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_output_decoder() -> Decoder(
  PlandefinitionActionOutput,
) {
  use related_data <- decode.optional_field(
    "relatedData",
    None,
    decode.optional(decode.string),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(datarequirement_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionOutput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_input_to_json(
  plandefinition_action_input: PlandefinitionActionInput,
) -> Json {
  let PlandefinitionActionInput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_input
  let fields = []
  let fields = case related_data {
    Some(v) -> [#("relatedData", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", datarequirement_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_input_decoder() -> Decoder(
  PlandefinitionActionInput,
) {
  use related_data <- decode.optional_field(
    "relatedData",
    None,
    decode.optional(decode.string),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(datarequirement_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionInput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_condition_to_json(
  plandefinition_action_condition: PlandefinitionActionCondition,
) -> Json {
  let PlandefinitionActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action_condition
  let fields = [
    #("kind", r5valuesets.actionconditionkind_to_json(kind)),
  ]
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_condition_decoder() -> Decoder(
  PlandefinitionActionCondition,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use kind <- decode.field("kind", r5valuesets.actionconditionkind_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_action_to_json(
  plandefinition_action: PlandefinitionAction,
) -> Json {
  let PlandefinitionAction(
    dynamic_value:,
    transform:,
    definition:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    location:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    trigger:,
    subject:,
    goal_id:,
    documentation:,
    reason:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_action
  let fields = []
  let fields = case dynamic_value {
    [] -> fields
    _ -> [
      #(
        "dynamicValue",
        json.array(dynamic_value, plandefinition_action_dynamicvalue_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [
      #(
        "definition"
          <> case v {
          PlandefinitionActionDefinitionCanonical(_) -> "Canonical"
          PlandefinitionActionDefinitionUri(_) -> "Uri"
        },
        plandefinition_action_definition_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case cardinality_behavior {
    Some(v) -> [
      #("cardinalityBehavior", r5valuesets.actioncardinalitybehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case precheck_behavior {
    Some(v) -> [
      #("precheckBehavior", r5valuesets.actionprecheckbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case required_behavior {
    Some(v) -> [
      #("requiredBehavior", r5valuesets.actionrequiredbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case selection_behavior {
    Some(v) -> [
      #("selectionBehavior", r5valuesets.actionselectionbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case grouping_behavior {
    Some(v) -> [
      #("groupingBehavior", r5valuesets.actiongroupingbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, plandefinition_action_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          PlandefinitionActionTimingAge(_) -> "Age"
          PlandefinitionActionTimingDuration(_) -> "Duration"
          PlandefinitionActionTimingRange(_) -> "Range"
          PlandefinitionActionTimingTiming(_) -> "Timing"
        },
        plandefinition_action_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_action {
    [] -> fields
    _ -> [
      #(
        "relatedAction",
        json.array(related_action, plandefinition_action_relatedaction_to_json),
      ),
      ..fields
    ]
  }
  let fields = case output {
    [] -> fields
    _ -> [
      #("output", json.array(output, plandefinition_action_output_to_json)),
      ..fields
    ]
  }
  let fields = case input {
    [] -> fields
    _ -> [
      #("input", json.array(input, plandefinition_action_input_to_json)),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, plandefinition_action_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case trigger {
    [] -> fields
    _ -> [
      #("trigger", json.array(trigger, triggerdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          PlandefinitionActionSubjectCodeableconcept(_) -> "Codeableconcept"
          PlandefinitionActionSubjectReference(_) -> "Reference"
          PlandefinitionActionSubjectCanonical(_) -> "Canonical"
        },
        plandefinition_action_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case goal_id {
    [] -> fields
    _ -> [#("goalId", json.array(goal_id, json.string)), ..fields]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeableconcept_to_json)), ..fields]
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text_equivalent {
    Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_action_decoder() -> Decoder(PlandefinitionAction) {
  use dynamic_value <- decode.optional_field(
    "dynamicValue",
    [],
    decode.list(plandefinition_action_dynamicvalue_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.then(
    none_if_omitted(plandefinition_action_definition_decoder()),
  )
  use cardinality_behavior <- decode.optional_field(
    "cardinalityBehavior",
    None,
    decode.optional(r5valuesets.actioncardinalitybehavior_decoder()),
  )
  use precheck_behavior <- decode.optional_field(
    "precheckBehavior",
    None,
    decode.optional(r5valuesets.actionprecheckbehavior_decoder()),
  )
  use required_behavior <- decode.optional_field(
    "requiredBehavior",
    None,
    decode.optional(r5valuesets.actionrequiredbehavior_decoder()),
  )
  use selection_behavior <- decode.optional_field(
    "selectionBehavior",
    None,
    decode.optional(r5valuesets.actionselectionbehavior_decoder()),
  )
  use grouping_behavior <- decode.optional_field(
    "groupingBehavior",
    None,
    decode.optional(r5valuesets.actiongroupingbehavior_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(plandefinition_action_participant_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(plandefinition_action_timing_decoder()),
  )
  use related_action <- decode.optional_field(
    "relatedAction",
    [],
    decode.list(plandefinition_action_relatedaction_decoder()),
  )
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(plandefinition_action_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(plandefinition_action_input_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(plandefinition_action_condition_decoder()),
  )
  use trigger <- decode.optional_field(
    "trigger",
    [],
    decode.list(triggerdefinition_decoder()),
  )
  use subject <- decode.then(
    none_if_omitted(plandefinition_action_subject_decoder()),
  )
  use goal_id <- decode.optional_field("goalId", [], decode.list(decode.string))
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use text_equivalent <- decode.optional_field(
    "textEquivalent",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionAction(
    dynamic_value:,
    transform:,
    definition:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    location:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    trigger:,
    subject:,
    goal_id:,
    documentation:,
    reason:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_actor_option_to_json(
  plandefinition_actor_option: PlandefinitionActorOption,
) -> Json {
  let PlandefinitionActorOption(
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_actor_option
  let fields = []
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_reference {
    Some(v) -> [#("typeReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_canonical {
    Some(v) -> [#("typeCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.actionparticipanttype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_actor_option_decoder() -> Decoder(
  PlandefinitionActorOption,
) {
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    None,
    decode.optional(reference_decoder()),
  )
  use type_canonical <- decode.optional_field(
    "typeCanonical",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.actionparticipanttype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActorOption(
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_actor_to_json(
  plandefinition_actor: PlandefinitionActor,
) -> Json {
  let PlandefinitionActor(
    option:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_actor
  let fields = []
  let fields = case option {
    [] -> fields
    _ -> [
      #("option", json.array(option, plandefinition_actor_option_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_actor_decoder() -> Decoder(PlandefinitionActor) {
  use option <- decode.optional_field(
    "option",
    [],
    decode.list(plandefinition_actor_option_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionActor(
    option:,
    description:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_goal_target_to_json(
  plandefinition_goal_target: PlandefinitionGoalTarget,
) -> Json {
  let PlandefinitionGoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_goal_target
  let fields = []
  let fields = case due {
    Some(v) -> [#("due", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case detail {
    Some(v) -> [
      #(
        "detail"
          <> case v {
          PlandefinitionGoalTargetDetailQuantity(_) -> "Quantity"
          PlandefinitionGoalTargetDetailRange(_) -> "Range"
          PlandefinitionGoalTargetDetailCodeableconcept(_) -> "Codeableconcept"
          PlandefinitionGoalTargetDetailString(_) -> "String"
          PlandefinitionGoalTargetDetailBoolean(_) -> "Boolean"
          PlandefinitionGoalTargetDetailInteger(_) -> "Integer"
          PlandefinitionGoalTargetDetailRatio(_) -> "Ratio"
        },
        plandefinition_goal_target_detail_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case measure {
    Some(v) -> [#("measure", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_goal_target_decoder() -> Decoder(PlandefinitionGoalTarget) {
  use due <- decode.optional_field(
    "due",
    None,
    decode.optional(duration_decoder()),
  )
  use detail <- decode.then(
    none_if_omitted(plandefinition_goal_target_detail_decoder()),
  )
  use measure <- decode.optional_field(
    "measure",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionGoalTarget(
    due:,
    detail:,
    measure:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_goal_to_json(
  plandefinition_goal: PlandefinitionGoal,
) -> Json {
  let PlandefinitionGoal(
    target:,
    documentation:,
    addresses:,
    start:,
    priority:,
    description:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ) = plandefinition_goal
  let fields = [
    #("description", codeableconcept_to_json(description)),
  ]
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, plandefinition_goal_target_to_json)),
      ..fields
    ]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case addresses {
    [] -> fields
    _ -> [
      #("addresses", json.array(addresses, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case start {
    Some(v) -> [#("start", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn plandefinition_goal_decoder() -> Decoder(PlandefinitionGoal) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(plandefinition_goal_target_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use addresses <- decode.optional_field(
    "addresses",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use start <- decode.optional_field(
    "start",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.field("description", codeableconcept_decoder())
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PlandefinitionGoal(
    target:,
    documentation:,
    addresses:,
    start:,
    priority:,
    description:,
    category:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn plandefinition_to_json(plandefinition: Plandefinition) -> Json {
  let Plandefinition(
    as_needed:,
    action:,
    actor:,
    goal:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    type_:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = plandefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case as_needed {
    Some(v) -> [
      #(
        "asNeeded"
          <> case v {
          PlandefinitionAsneededBoolean(_) -> "Boolean"
          PlandefinitionAsneededCodeableconcept(_) -> "Codeableconcept"
        },
        plandefinition_asneeded_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, plandefinition_action_to_json)),
      ..fields
    ]
  }
  let fields = case actor {
    [] -> fields
    _ -> [#("actor", json.array(actor, plandefinition_actor_to_json)), ..fields]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, plandefinition_goal_to_json)), ..fields]
  }
  let fields = case library {
    [] -> fields
    _ -> [#("library", json.array(library, json.string)), ..fields]
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case usage {
    Some(v) -> [#("usage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          PlandefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          PlandefinitionSubjectReference(_) -> "Reference"
          PlandefinitionSubjectCanonical(_) -> "Canonical"
        },
        plandefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subtitle {
    Some(v) -> [#("subtitle", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          PlandefinitionVersionalgorithmString(_) -> "String"
          PlandefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        plandefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Plandefinition")), ..fields]
  json.object(fields)
}

pub fn plandefinition_decoder() -> Decoder(Plandefinition) {
  use as_needed <- decode.then(
    none_if_omitted(plandefinition_asneeded_decoder()),
  )
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(plandefinition_action_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(plandefinition_actor_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(plandefinition_goal_decoder()),
  )
  use library <- decode.optional_field(
    "library",
    [],
    decode.list(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use usage <- decode.optional_field(
    "usage",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(none_if_omitted(plandefinition_subject_decoder()))
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subtitle <- decode.optional_field(
    "subtitle",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(plandefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Plandefinition",
    decode.failure(plandefinition_new(status:), "resourceType"),
  )
  decode.success(Plandefinition(
    as_needed:,
    action:,
    actor:,
    goal:,
    library:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    usage:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    type_:,
    subtitle:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Practitioner#resource
pub type Practitioner {
  Practitioner(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r5valuesets.Administrativegender),
    birth_date: Option(String),
    deceased: Option(PractitionerDeceased),
    address: List(Address),
    photo: List(Attachment),
    qualification: List(PractitionerQualification),
    communication: List(PractitionerCommunication),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Practitioner#resource
pub type PractitionerDeceased {
  PractitionerDeceasedBoolean(deceased: Bool)
  PractitionerDeceasedDatetime(deceased: String)
}

pub fn practitioner_deceased_to_json(elt: PractitionerDeceased) -> Json {
  case elt {
    PractitionerDeceasedBoolean(v) -> json.bool(v)
    PractitionerDeceasedDatetime(v) -> json.string(v)
  }
}

pub fn practitioner_deceased_decoder() -> Decoder(PractitionerDeceased) {
  decode.one_of(
    decode.field("deceasedBoolean", decode.bool, decode.success)
      |> decode.map(PractitionerDeceasedBoolean),
    [
      decode.field("deceasedDateTime", decode.string, decode.success)
      |> decode.map(PractitionerDeceasedDatetime),
    ],
  )
}

pub fn practitioner_new() -> Practitioner {
  Practitioner(
    communication: [],
    qualification: [],
    photo: [],
    address: [],
    deceased: None,
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Practitioner#resource
pub type PractitionerQualification {
  PractitionerQualification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    code: Codeableconcept,
    period: Option(Period),
    issuer: Option(Reference),
  )
}

pub fn practitioner_qualification_new(
  code code: Codeableconcept,
) -> PractitionerQualification {
  PractitionerQualification(
    issuer: None,
    period: None,
    code:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Practitioner#resource
pub type PractitionerCommunication {
  PractitionerCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn practitioner_communication_new(
  language language: Codeableconcept,
) -> PractitionerCommunication {
  PractitionerCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn practitioner_communication_to_json(
  practitioner_communication: PractitionerCommunication,
) -> Json {
  let PractitionerCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = practitioner_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn practitioner_communication_decoder() -> Decoder(
  PractitionerCommunication,
) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PractitionerCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn practitioner_qualification_to_json(
  practitioner_qualification: PractitionerQualification,
) -> Json {
  let PractitionerQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = practitioner_qualification
  let fields = [
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case issuer {
    Some(v) -> [#("issuer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn practitioner_qualification_decoder() -> Decoder(
  PractitionerQualification,
) {
  use issuer <- decode.optional_field(
    "issuer",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use code <- decode.field("code", codeableconcept_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(PractitionerQualification(
    issuer:,
    period:,
    code:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn practitioner_to_json(practitioner: Practitioner) -> Json {
  let Practitioner(
    communication:,
    qualification:,
    photo:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = practitioner
  let fields = []
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, practitioner_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case qualification {
    [] -> fields
    _ -> [
      #(
        "qualification",
        json.array(qualification, practitioner_qualification_to_json),
      ),
      ..fields
    ]
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case deceased {
    Some(v) -> [
      #(
        "deceased"
          <> case v {
          PractitionerDeceasedBoolean(_) -> "Boolean"
          PractitionerDeceasedDatetime(_) -> "Datetime"
        },
        practitioner_deceased_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Practitioner")), ..fields]
  json.object(fields)
}

pub fn practitioner_decoder() -> Decoder(Practitioner) {
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(practitioner_communication_decoder()),
  )
  use qualification <- decode.optional_field(
    "qualification",
    [],
    decode.list(practitioner_qualification_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use deceased <- decode.then(none_if_omitted(practitioner_deceased_decoder()))
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Practitioner",
    decode.failure(practitioner_new(), "resourceType"),
  )
  decode.success(Practitioner(
    communication:,
    qualification:,
    photo:,
    address:,
    deceased:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/PractitionerRole#resource
pub type Practitionerrole {
  Practitionerrole(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    period: Option(Period),
    practitioner: Option(Reference),
    organization: Option(Reference),
    code: List(Codeableconcept),
    specialty: List(Codeableconcept),
    location: List(Reference),
    healthcare_service: List(Reference),
    contact: List(Extendedcontactdetail),
    characteristic: List(Codeableconcept),
    communication: List(Codeableconcept),
    availability: List(Availability),
    endpoint: List(Reference),
  )
}

pub fn practitionerrole_new() -> Practitionerrole {
  Practitionerrole(
    endpoint: [],
    availability: [],
    communication: [],
    characteristic: [],
    contact: [],
    healthcare_service: [],
    location: [],
    specialty: [],
    code: [],
    organization: None,
    practitioner: None,
    period: None,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn practitionerrole_to_json(practitionerrole: Practitionerrole) -> Json {
  let Practitionerrole(
    endpoint:,
    availability:,
    communication:,
    characteristic:,
    contact:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    organization:,
    practitioner:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = practitionerrole
  let fields = []
  let fields = case endpoint {
    [] -> fields
    _ -> [#("endpoint", json.array(endpoint, reference_to_json)), ..fields]
  }
  let fields = case availability {
    [] -> fields
    _ -> [
      #("availability", json.array(availability, availability_to_json)),
      ..fields
    ]
  }
  let fields = case communication {
    [] -> fields
    _ -> [
      #("communication", json.array(communication, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case characteristic {
    [] -> fields
    _ -> [
      #("characteristic", json.array(characteristic, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [
      #("contact", json.array(contact, extendedcontactdetail_to_json)),
      ..fields
    ]
  }
  let fields = case healthcare_service {
    [] -> fields
    _ -> [
      #("healthcareService", json.array(healthcare_service, reference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    [] -> fields
    _ -> [#("location", json.array(location, reference_to_json)), ..fields]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case organization {
    Some(v) -> [#("organization", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case practitioner {
    Some(v) -> [#("practitioner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Practitionerrole")), ..fields]
  json.object(fields)
}

pub fn practitionerrole_decoder() -> Decoder(Practitionerrole) {
  use endpoint <- decode.optional_field(
    "endpoint",
    [],
    decode.list(reference_decoder()),
  )
  use availability <- decode.optional_field(
    "availability",
    [],
    decode.list(availability_decoder()),
  )
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use characteristic <- decode.optional_field(
    "characteristic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(extendedcontactdetail_decoder()),
  )
  use healthcare_service <- decode.optional_field(
    "healthcareService",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(reference_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use organization <- decode.optional_field(
    "organization",
    None,
    decode.optional(reference_decoder()),
  )
  use practitioner <- decode.optional_field(
    "practitioner",
    None,
    decode.optional(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Practitionerrole",
    decode.failure(practitionerrole_new(), "resourceType"),
  )
  decode.success(Practitionerrole(
    endpoint:,
    availability:,
    communication:,
    characteristic:,
    contact:,
    healthcare_service:,
    location:,
    specialty:,
    code:,
    organization:,
    practitioner:,
    period:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Procedure#resource
pub type Procedure {
  Procedure(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    part_of: List(Reference),
    status: r5valuesets.Eventstatus,
    status_reason: Option(Codeableconcept),
    category: List(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    focus: Option(Reference),
    encounter: Option(Reference),
    occurrence: Option(ProcedureOccurrence),
    recorded: Option(String),
    recorder: Option(Reference),
    reported: Option(ProcedureReported),
    performer: List(ProcedurePerformer),
    location: Option(Reference),
    reason: List(Codeablereference),
    body_site: List(Codeableconcept),
    outcome: Option(Codeableconcept),
    report: List(Reference),
    complication: List(Codeablereference),
    follow_up: List(Codeableconcept),
    note: List(Annotation),
    focal_device: List(ProcedureFocaldevice),
    used: List(Codeablereference),
    supporting_info: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Procedure#resource
pub type ProcedureOccurrence {
  ProcedureOccurrenceDatetime(occurrence: String)
  ProcedureOccurrencePeriod(occurrence: Period)
  ProcedureOccurrenceString(occurrence: String)
  ProcedureOccurrenceAge(occurrence: Age)
  ProcedureOccurrenceRange(occurrence: Range)
  ProcedureOccurrenceTiming(occurrence: Timing)
}

pub fn procedure_occurrence_to_json(elt: ProcedureOccurrence) -> Json {
  case elt {
    ProcedureOccurrenceDatetime(v) -> json.string(v)
    ProcedureOccurrencePeriod(v) -> period_to_json(v)
    ProcedureOccurrenceString(v) -> json.string(v)
    ProcedureOccurrenceAge(v) -> age_to_json(v)
    ProcedureOccurrenceRange(v) -> range_to_json(v)
    ProcedureOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn procedure_occurrence_decoder() -> Decoder(ProcedureOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ProcedureOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ProcedureOccurrencePeriod),
      decode.field("occurrenceString", decode.string, decode.success)
        |> decode.map(ProcedureOccurrenceString),
      decode.field("occurrenceAge", age_decoder(), decode.success)
        |> decode.map(ProcedureOccurrenceAge),
      decode.field("occurrenceRange", range_decoder(), decode.success)
        |> decode.map(ProcedureOccurrenceRange),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ProcedureOccurrenceTiming),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Procedure#resource
pub type ProcedureReported {
  ProcedureReportedBoolean(reported: Bool)
  ProcedureReportedReference(reported: Reference)
}

pub fn procedure_reported_to_json(elt: ProcedureReported) -> Json {
  case elt {
    ProcedureReportedBoolean(v) -> json.bool(v)
    ProcedureReportedReference(v) -> reference_to_json(v)
  }
}

pub fn procedure_reported_decoder() -> Decoder(ProcedureReported) {
  decode.one_of(
    decode.field("reportedBoolean", decode.bool, decode.success)
      |> decode.map(ProcedureReportedBoolean),
    [
      decode.field("reportedReference", reference_decoder(), decode.success)
      |> decode.map(ProcedureReportedReference),
    ],
  )
}

pub fn procedure_new(
  subject subject: Reference,
  status status: r5valuesets.Eventstatus,
) -> Procedure {
  Procedure(
    supporting_info: [],
    used: [],
    focal_device: [],
    note: [],
    follow_up: [],
    complication: [],
    report: [],
    outcome: None,
    body_site: [],
    reason: [],
    location: None,
    performer: [],
    reported: None,
    recorder: None,
    recorded: None,
    occurrence: None,
    encounter: None,
    focus: None,
    subject:,
    code: None,
    category: [],
    status_reason: None,
    status:,
    part_of: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Procedure#resource
pub type ProcedurePerformer {
  ProcedurePerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
    on_behalf_of: Option(Reference),
    period: Option(Period),
  )
}

pub fn procedure_performer_new(actor actor: Reference) -> ProcedurePerformer {
  ProcedurePerformer(
    period: None,
    on_behalf_of: None,
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Procedure#resource
pub type ProcedureFocaldevice {
  ProcedureFocaldevice(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: Option(Codeableconcept),
    manipulated: Reference,
  )
}

pub fn procedure_focaldevice_new(
  manipulated manipulated: Reference,
) -> ProcedureFocaldevice {
  ProcedureFocaldevice(
    manipulated:,
    action: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn procedure_focaldevice_to_json(
  procedure_focaldevice: ProcedureFocaldevice,
) -> Json {
  let ProcedureFocaldevice(
    manipulated:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ) = procedure_focaldevice
  let fields = [
    #("manipulated", reference_to_json(manipulated)),
  ]
  let fields = case action {
    Some(v) -> [#("action", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn procedure_focaldevice_decoder() -> Decoder(ProcedureFocaldevice) {
  use manipulated <- decode.field("manipulated", reference_decoder())
  use action <- decode.optional_field(
    "action",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProcedureFocaldevice(
    manipulated:,
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn procedure_performer_to_json(
  procedure_performer: ProcedurePerformer,
) -> Json {
  let ProcedurePerformer(
    period:,
    on_behalf_of:,
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ) = procedure_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn procedure_performer_decoder() -> Decoder(ProcedurePerformer) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProcedurePerformer(
    period:,
    on_behalf_of:,
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn procedure_to_json(procedure: Procedure) -> Json {
  let Procedure(
    supporting_info:,
    used:,
    focal_device:,
    note:,
    follow_up:,
    complication:,
    report:,
    outcome:,
    body_site:,
    reason:,
    location:,
    performer:,
    reported:,
    recorder:,
    recorded:,
    occurrence:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = procedure
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.eventstatus_to_json(status)),
  ]
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #("supportingInfo", json.array(supporting_info, reference_to_json)),
      ..fields
    ]
  }
  let fields = case used {
    [] -> fields
    _ -> [#("used", json.array(used, codeablereference_to_json)), ..fields]
  }
  let fields = case focal_device {
    [] -> fields
    _ -> [
      #("focalDevice", json.array(focal_device, procedure_focaldevice_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case follow_up {
    [] -> fields
    _ -> [
      #("followUp", json.array(follow_up, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case complication {
    [] -> fields
    _ -> [
      #("complication", json.array(complication, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case report {
    [] -> fields
    _ -> [#("report", json.array(report, reference_to_json)), ..fields]
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, procedure_performer_to_json)),
      ..fields
    ]
  }
  let fields = case reported {
    Some(v) -> [
      #(
        "reported"
          <> case v {
          ProcedureReportedBoolean(_) -> "Boolean"
          ProcedureReportedReference(_) -> "Reference"
        },
        procedure_reported_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case recorder {
    Some(v) -> [#("recorder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ProcedureOccurrenceDatetime(_) -> "Datetime"
          ProcedureOccurrencePeriod(_) -> "Period"
          ProcedureOccurrenceString(_) -> "String"
          ProcedureOccurrenceAge(_) -> "Age"
          ProcedureOccurrenceRange(_) -> "Range"
          ProcedureOccurrenceTiming(_) -> "Timing"
        },
        procedure_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Procedure")), ..fields]
  json.object(fields)
}

pub fn procedure_decoder() -> Decoder(Procedure) {
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(reference_decoder()),
  )
  use used <- decode.optional_field(
    "used",
    [],
    decode.list(codeablereference_decoder()),
  )
  use focal_device <- decode.optional_field(
    "focalDevice",
    [],
    decode.list(procedure_focaldevice_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use follow_up <- decode.optional_field(
    "followUp",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use complication <- decode.optional_field(
    "complication",
    [],
    decode.list(codeablereference_decoder()),
  )
  use report <- decode.optional_field(
    "report",
    [],
    decode.list(reference_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(procedure_performer_decoder()),
  )
  use reported <- decode.then(none_if_omitted(procedure_reported_decoder()))
  use recorder <- decode.optional_field(
    "recorder",
    None,
    decode.optional(reference_decoder()),
  )
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(none_if_omitted(procedure_occurrence_decoder()))
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.eventstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Procedure",
    decode.failure(procedure_new(subject:, status:), "resourceType"),
  )
  decode.success(Procedure(
    supporting_info:,
    used:,
    focal_device:,
    note:,
    follow_up:,
    complication:,
    report:,
    outcome:,
    body_site:,
    reason:,
    location:,
    performer:,
    reported:,
    recorder:,
    recorded:,
    occurrence:,
    encounter:,
    focus:,
    subject:,
    code:,
    category:,
    status_reason:,
    status:,
    part_of:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Provenance#resource
pub type Provenance {
  Provenance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: List(Reference),
    occurred: Option(ProvenanceOccurred),
    recorded: Option(String),
    policy: List(String),
    location: Option(Reference),
    authorization: List(Codeablereference),
    activity: Option(Codeableconcept),
    based_on: List(Reference),
    patient: Option(Reference),
    encounter: Option(Reference),
    agent: List(ProvenanceAgent),
    entity: List(ProvenanceEntity),
    signature: List(Signature),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Provenance#resource
pub type ProvenanceOccurred {
  ProvenanceOccurredPeriod(occurred: Period)
  ProvenanceOccurredDatetime(occurred: String)
}

pub fn provenance_occurred_to_json(elt: ProvenanceOccurred) -> Json {
  case elt {
    ProvenanceOccurredPeriod(v) -> period_to_json(v)
    ProvenanceOccurredDatetime(v) -> json.string(v)
  }
}

pub fn provenance_occurred_decoder() -> Decoder(ProvenanceOccurred) {
  decode.one_of(
    decode.field("occurredPeriod", period_decoder(), decode.success)
      |> decode.map(ProvenanceOccurredPeriod),
    [
      decode.field("occurredDateTime", decode.string, decode.success)
      |> decode.map(ProvenanceOccurredDatetime),
    ],
  )
}

pub fn provenance_new() -> Provenance {
  Provenance(
    signature: [],
    entity: [],
    agent: [],
    encounter: None,
    patient: None,
    based_on: [],
    activity: None,
    authorization: [],
    location: None,
    policy: [],
    recorded: None,
    occurred: None,
    target: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Provenance#resource
pub type ProvenanceAgent {
  ProvenanceAgent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    role: List(Codeableconcept),
    who: Reference,
    on_behalf_of: Option(Reference),
  )
}

pub fn provenance_agent_new(who who: Reference) -> ProvenanceAgent {
  ProvenanceAgent(
    on_behalf_of: None,
    who:,
    role: [],
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Provenance#resource
pub type ProvenanceEntity {
  ProvenanceEntity(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: r5valuesets.Provenanceentityrole,
    what: Reference,
  )
}

pub fn provenance_entity_new(
  what what: Reference,
  role role: r5valuesets.Provenanceentityrole,
) -> ProvenanceEntity {
  ProvenanceEntity(
    what:,
    role:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn provenance_entity_to_json(provenance_entity: ProvenanceEntity) -> Json {
  let ProvenanceEntity(what:, role:, modifier_extension:, extension:, id:) =
    provenance_entity
  let fields = [
    #("what", reference_to_json(what)),
    #("role", r5valuesets.provenanceentityrole_to_json(role)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn provenance_entity_decoder() -> Decoder(ProvenanceEntity) {
  use what <- decode.field("what", reference_decoder())
  use role <- decode.field("role", r5valuesets.provenanceentityrole_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProvenanceEntity(
    what:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn provenance_agent_to_json(provenance_agent: ProvenanceAgent) -> Json {
  let ProvenanceAgent(
    on_behalf_of:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = provenance_agent
  let fields = [
    #("who", reference_to_json(who)),
  ]
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn provenance_agent_decoder() -> Decoder(ProvenanceAgent) {
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.field("who", reference_decoder())
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ProvenanceAgent(
    on_behalf_of:,
    who:,
    role:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn provenance_to_json(provenance: Provenance) -> Json {
  let Provenance(
    signature:,
    entity:,
    agent:,
    encounter:,
    patient:,
    based_on:,
    activity:,
    authorization:,
    location:,
    policy:,
    recorded:,
    occurred:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = provenance
  let fields = []
  let fields = case signature {
    [] -> fields
    _ -> [#("signature", json.array(signature, signature_to_json)), ..fields]
  }
  let fields = case entity {
    [] -> fields
    _ -> [#("entity", json.array(entity, provenance_entity_to_json)), ..fields]
  }
  let fields = case agent {
    [] -> fields
    _ -> [#("agent", json.array(agent, provenance_agent_to_json)), ..fields]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case activity {
    Some(v) -> [#("activity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authorization {
    [] -> fields
    _ -> [
      #("authorization", json.array(authorization, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case policy {
    [] -> fields
    _ -> [#("policy", json.array(policy, json.string)), ..fields]
  }
  let fields = case recorded {
    Some(v) -> [#("recorded", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurred {
    Some(v) -> [
      #(
        "occurred"
          <> case v {
          ProvenanceOccurredPeriod(_) -> "Period"
          ProvenanceOccurredDatetime(_) -> "Datetime"
        },
        provenance_occurred_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Provenance")), ..fields]
  json.object(fields)
}

pub fn provenance_decoder() -> Decoder(Provenance) {
  use signature <- decode.optional_field(
    "signature",
    [],
    decode.list(signature_decoder()),
  )
  use entity <- decode.optional_field(
    "entity",
    [],
    decode.list(provenance_entity_decoder()),
  )
  use agent <- decode.optional_field(
    "agent",
    [],
    decode.list(provenance_agent_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use activity <- decode.optional_field(
    "activity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use authorization <- decode.optional_field(
    "authorization",
    [],
    decode.list(codeablereference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use policy <- decode.optional_field("policy", [], decode.list(decode.string))
  use recorded <- decode.optional_field(
    "recorded",
    None,
    decode.optional(decode.string),
  )
  use occurred <- decode.then(none_if_omitted(provenance_occurred_decoder()))
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Provenance",
    decode.failure(provenance_new(), "resourceType"),
  )
  decode.success(Provenance(
    signature:,
    entity:,
    agent:,
    encounter:,
    patient:,
    based_on:,
    activity:,
    authorization:,
    location:,
    policy:,
    recorded:,
    occurred:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type Questionnaire {
  Questionnaire(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(QuestionnaireVersionalgorithm),
    name: Option(String),
    title: Option(String),
    derived_from: List(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject_type: List(r5valuesets.Resourcetypes),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    code: List(Coding),
    item: List(QuestionnaireItem),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireVersionalgorithm {
  QuestionnaireVersionalgorithmString(version_algorithm: String)
  QuestionnaireVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn questionnaire_versionalgorithm_to_json(
  elt: QuestionnaireVersionalgorithm,
) -> Json {
  case elt {
    QuestionnaireVersionalgorithmString(v) -> json.string(v)
    QuestionnaireVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn questionnaire_versionalgorithm_decoder() -> Decoder(
  QuestionnaireVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(QuestionnaireVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(QuestionnaireVersionalgorithmCoding),
    ],
  )
}

pub fn questionnaire_new(
  status status: r5valuesets.Publicationstatus,
) -> Questionnaire {
  Questionnaire(
    item: [],
    code: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject_type: [],
    experimental: None,
    status:,
    derived_from: [],
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItem {
  QuestionnaireItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: String,
    definition: Option(String),
    code: List(Coding),
    prefix: Option(String),
    text: Option(String),
    type_: r5valuesets.Itemtype,
    enable_when: List(QuestionnaireItemEnablewhen),
    enable_behavior: Option(r5valuesets.Questionnaireenablebehavior),
    disabled_display: Option(r5valuesets.Questionnairedisableddisplay),
    required: Option(Bool),
    repeats: Option(Bool),
    read_only: Option(Bool),
    max_length: Option(Int),
    answer_constraint: Option(r5valuesets.Questionnaireanswerconstraint),
    answer_value_set: Option(String),
    answer_option: List(QuestionnaireItemAnsweroption),
    initial: List(QuestionnaireItemInitial),
  )
}

pub fn questionnaire_item_new(
  type_ type_: r5valuesets.Itemtype,
  link_id link_id: String,
) -> QuestionnaireItem {
  QuestionnaireItem(
    initial: [],
    answer_option: [],
    answer_value_set: None,
    answer_constraint: None,
    max_length: None,
    read_only: None,
    repeats: None,
    required: None,
    disabled_display: None,
    enable_behavior: None,
    enable_when: [],
    type_:,
    text: None,
    prefix: None,
    code: [],
    definition: None,
    link_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhen {
  QuestionnaireItemEnablewhen(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    question: String,
    operator: r5valuesets.Questionnaireenableoperator,
    answer: QuestionnaireItemEnablewhenAnswer,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemEnablewhenAnswer {
  QuestionnaireItemEnablewhenAnswerBoolean(answer: Bool)
  QuestionnaireItemEnablewhenAnswerDecimal(answer: Float)
  QuestionnaireItemEnablewhenAnswerInteger(answer: Int)
  QuestionnaireItemEnablewhenAnswerDate(answer: String)
  QuestionnaireItemEnablewhenAnswerDatetime(answer: String)
  QuestionnaireItemEnablewhenAnswerTime(answer: String)
  QuestionnaireItemEnablewhenAnswerString(answer: String)
  QuestionnaireItemEnablewhenAnswerCoding(answer: Coding)
  QuestionnaireItemEnablewhenAnswerQuantity(answer: Quantity)
  QuestionnaireItemEnablewhenAnswerReference(answer: Reference)
}

pub fn questionnaire_item_enablewhen_answer_to_json(
  elt: QuestionnaireItemEnablewhenAnswer,
) -> Json {
  case elt {
    QuestionnaireItemEnablewhenAnswerBoolean(v) -> json.bool(v)
    QuestionnaireItemEnablewhenAnswerDecimal(v) -> json.float(v)
    QuestionnaireItemEnablewhenAnswerInteger(v) -> json.int(v)
    QuestionnaireItemEnablewhenAnswerDate(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerDatetime(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerTime(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerString(v) -> json.string(v)
    QuestionnaireItemEnablewhenAnswerCoding(v) -> coding_to_json(v)
    QuestionnaireItemEnablewhenAnswerQuantity(v) -> quantity_to_json(v)
    QuestionnaireItemEnablewhenAnswerReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_enablewhen_answer_decoder() -> Decoder(
  QuestionnaireItemEnablewhenAnswer,
) {
  decode.one_of(
    decode.field("answerBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireItemEnablewhenAnswerBoolean),
    [
      decode.field("answerDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDecimal),
      decode.field("answerInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerInteger),
      decode.field("answerDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDate),
      decode.field("answerDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerDatetime),
      decode.field("answerTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerTime),
      decode.field("answerString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerString),
      decode.field("answerCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerCoding),
      decode.field("answerQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerQuantity),
      decode.field("answerReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemEnablewhenAnswerReference),
    ],
  )
}

pub fn questionnaire_item_enablewhen_new(
  answer answer: QuestionnaireItemEnablewhenAnswer,
  operator operator: r5valuesets.Questionnaireenableoperator,
  question question: String,
) -> QuestionnaireItemEnablewhen {
  QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroption {
  QuestionnaireItemAnsweroption(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: QuestionnaireItemAnsweroptionValue,
    initial_selected: Option(Bool),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemAnsweroptionValue {
  QuestionnaireItemAnsweroptionValueInteger(value: Int)
  QuestionnaireItemAnsweroptionValueDate(value: String)
  QuestionnaireItemAnsweroptionValueTime(value: String)
  QuestionnaireItemAnsweroptionValueString(value: String)
  QuestionnaireItemAnsweroptionValueCoding(value: Coding)
  QuestionnaireItemAnsweroptionValueReference(value: Reference)
}

pub fn questionnaire_item_answeroption_value_to_json(
  elt: QuestionnaireItemAnsweroptionValue,
) -> Json {
  case elt {
    QuestionnaireItemAnsweroptionValueInteger(v) -> json.int(v)
    QuestionnaireItemAnsweroptionValueDate(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueTime(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueString(v) -> json.string(v)
    QuestionnaireItemAnsweroptionValueCoding(v) -> coding_to_json(v)
    QuestionnaireItemAnsweroptionValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_answeroption_value_decoder() -> Decoder(
  QuestionnaireItemAnsweroptionValue,
) {
  decode.one_of(
    decode.field("valueInteger", decode.int, decode.success)
      |> decode.map(QuestionnaireItemAnsweroptionValueInteger),
    [
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueDate),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueString),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueCoding),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemAnsweroptionValueReference),
    ],
  )
}

pub fn questionnaire_item_answeroption_new(
  value value: QuestionnaireItemAnsweroptionValue,
) -> QuestionnaireItemAnsweroption {
  QuestionnaireItemAnsweroption(
    initial_selected: None,
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitial {
  QuestionnaireItemInitial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: QuestionnaireItemInitialValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Questionnaire#resource
pub type QuestionnaireItemInitialValue {
  QuestionnaireItemInitialValueBoolean(value: Bool)
  QuestionnaireItemInitialValueDecimal(value: Float)
  QuestionnaireItemInitialValueInteger(value: Int)
  QuestionnaireItemInitialValueDate(value: String)
  QuestionnaireItemInitialValueDatetime(value: String)
  QuestionnaireItemInitialValueTime(value: String)
  QuestionnaireItemInitialValueString(value: String)
  QuestionnaireItemInitialValueUri(value: String)
  QuestionnaireItemInitialValueAttachment(value: Attachment)
  QuestionnaireItemInitialValueCoding(value: Coding)
  QuestionnaireItemInitialValueQuantity(value: Quantity)
  QuestionnaireItemInitialValueReference(value: Reference)
}

pub fn questionnaire_item_initial_value_to_json(
  elt: QuestionnaireItemInitialValue,
) -> Json {
  case elt {
    QuestionnaireItemInitialValueBoolean(v) -> json.bool(v)
    QuestionnaireItemInitialValueDecimal(v) -> json.float(v)
    QuestionnaireItemInitialValueInteger(v) -> json.int(v)
    QuestionnaireItemInitialValueDate(v) -> json.string(v)
    QuestionnaireItemInitialValueDatetime(v) -> json.string(v)
    QuestionnaireItemInitialValueTime(v) -> json.string(v)
    QuestionnaireItemInitialValueString(v) -> json.string(v)
    QuestionnaireItemInitialValueUri(v) -> json.string(v)
    QuestionnaireItemInitialValueAttachment(v) -> attachment_to_json(v)
    QuestionnaireItemInitialValueCoding(v) -> coding_to_json(v)
    QuestionnaireItemInitialValueQuantity(v) -> quantity_to_json(v)
    QuestionnaireItemInitialValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaire_item_initial_value_decoder() -> Decoder(
  QuestionnaireItemInitialValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireItemInitialValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireItemInitialValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(QuestionnaireItemInitialValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireItemInitialValueReference),
    ],
  )
}

pub fn questionnaire_item_initial_new(
  value value: QuestionnaireItemInitialValue,
) -> QuestionnaireItemInitial {
  QuestionnaireItemInitial(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn questionnaire_item_initial_to_json(
  questionnaire_item_initial: QuestionnaireItemInitial,
) -> Json {
  let QuestionnaireItemInitial(value:, modifier_extension:, extension:, id:) =
    questionnaire_item_initial
  let fields = [
    #("value", questionnaire_item_initial_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_initial_decoder() -> Decoder(QuestionnaireItemInitial) {
  use value <- decode.then(questionnaire_item_initial_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemInitial(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_answeroption_to_json(
  questionnaire_item_answeroption: QuestionnaireItemAnsweroption,
) -> Json {
  let QuestionnaireItemAnsweroption(
    initial_selected:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item_answeroption
  let fields = [
    #("value", questionnaire_item_answeroption_value_to_json(value)),
  ]
  let fields = case initial_selected {
    Some(v) -> [#("initialSelected", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_answeroption_decoder() -> Decoder(
  QuestionnaireItemAnsweroption,
) {
  use initial_selected <- decode.optional_field(
    "initialSelected",
    None,
    decode.optional(decode.bool),
  )
  use value <- decode.then(questionnaire_item_answeroption_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemAnsweroption(
    initial_selected:,
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_enablewhen_to_json(
  questionnaire_item_enablewhen: QuestionnaireItemEnablewhen,
) -> Json {
  let QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item_enablewhen
  let fields = [
    #("answer", questionnaire_item_enablewhen_answer_to_json(answer)),
    #("operator", r5valuesets.questionnaireenableoperator_to_json(operator)),
    #("question", json.string(question)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_enablewhen_decoder() -> Decoder(
  QuestionnaireItemEnablewhen,
) {
  use answer <- decode.then(questionnaire_item_enablewhen_answer_decoder())
  use operator <- decode.field(
    "operator",
    r5valuesets.questionnaireenableoperator_decoder(),
  )
  use question <- decode.field("question", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItemEnablewhen(
    answer:,
    operator:,
    question:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_item_to_json(questionnaire_item: QuestionnaireItem) -> Json {
  let QuestionnaireItem(
    initial:,
    answer_option:,
    answer_value_set:,
    answer_constraint:,
    max_length:,
    read_only:,
    repeats:,
    required:,
    disabled_display:,
    enable_behavior:,
    enable_when:,
    type_:,
    text:,
    prefix:,
    code:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaire_item
  let fields = [
    #("type", r5valuesets.itemtype_to_json(type_)),
    #("linkId", json.string(link_id)),
  ]
  let fields = case initial {
    [] -> fields
    _ -> [
      #("initial", json.array(initial, questionnaire_item_initial_to_json)),
      ..fields
    ]
  }
  let fields = case answer_option {
    [] -> fields
    _ -> [
      #(
        "answerOption",
        json.array(answer_option, questionnaire_item_answeroption_to_json),
      ),
      ..fields
    ]
  }
  let fields = case answer_value_set {
    Some(v) -> [#("answerValueSet", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case answer_constraint {
    Some(v) -> [
      #(
        "answerConstraint",
        r5valuesets.questionnaireanswerconstraint_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case max_length {
    Some(v) -> [#("maxLength", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case read_only {
    Some(v) -> [#("readOnly", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case repeats {
    Some(v) -> [#("repeats", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case required {
    Some(v) -> [#("required", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case disabled_display {
    Some(v) -> [
      #("disabledDisplay", r5valuesets.questionnairedisableddisplay_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case enable_behavior {
    Some(v) -> [
      #("enableBehavior", r5valuesets.questionnaireenablebehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case enable_when {
    [] -> fields
    _ -> [
      #(
        "enableWhen",
        json.array(enable_when, questionnaire_item_enablewhen_to_json),
      ),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaire_item_decoder() -> Decoder(QuestionnaireItem) {
  use initial <- decode.optional_field(
    "initial",
    [],
    decode.list(questionnaire_item_initial_decoder()),
  )
  use answer_option <- decode.optional_field(
    "answerOption",
    [],
    decode.list(questionnaire_item_answeroption_decoder()),
  )
  use answer_value_set <- decode.optional_field(
    "answerValueSet",
    None,
    decode.optional(decode.string),
  )
  use answer_constraint <- decode.optional_field(
    "answerConstraint",
    None,
    decode.optional(r5valuesets.questionnaireanswerconstraint_decoder()),
  )
  use max_length <- decode.optional_field(
    "maxLength",
    None,
    decode.optional(decode.int),
  )
  use read_only <- decode.optional_field(
    "readOnly",
    None,
    decode.optional(decode.bool),
  )
  use repeats <- decode.optional_field(
    "repeats",
    None,
    decode.optional(decode.bool),
  )
  use required <- decode.optional_field(
    "required",
    None,
    decode.optional(decode.bool),
  )
  use disabled_display <- decode.optional_field(
    "disabledDisplay",
    None,
    decode.optional(r5valuesets.questionnairedisableddisplay_decoder()),
  )
  use enable_behavior <- decode.optional_field(
    "enableBehavior",
    None,
    decode.optional(r5valuesets.questionnaireenablebehavior_decoder()),
  )
  use enable_when <- decode.optional_field(
    "enableWhen",
    [],
    decode.list(questionnaire_item_enablewhen_decoder()),
  )
  use type_ <- decode.field("type", r5valuesets.itemtype_decoder())
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.field("linkId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireItem(
    initial:,
    answer_option:,
    answer_value_set:,
    answer_constraint:,
    max_length:,
    read_only:,
    repeats:,
    required:,
    disabled_display:,
    enable_behavior:,
    enable_when:,
    type_:,
    text:,
    prefix:,
    code:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaire_to_json(questionnaire: Questionnaire) -> Json {
  let Questionnaire(
    item:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject_type:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = questionnaire
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [#("item", json.array(item, questionnaire_item_to_json)), ..fields]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, coding_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject_type {
    [] -> fields
    _ -> [
      #(
        "subjectType",
        json.array(subject_type, r5valuesets.resourcetypes_to_json),
      ),
      ..fields
    ]
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          QuestionnaireVersionalgorithmString(_) -> "String"
          QuestionnaireVersionalgorithmCoding(_) -> "Coding"
        },
        questionnaire_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Questionnaire")), ..fields]
  json.object(fields)
}

pub fn questionnaire_decoder() -> Decoder(Questionnaire) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(questionnaire_item_decoder()),
  )
  use code <- decode.optional_field("code", [], decode.list(coding_decoder()))
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject_type <- decode.optional_field(
    "subjectType",
    [],
    decode.list(r5valuesets.resourcetypes_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(questionnaire_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Questionnaire",
    decode.failure(questionnaire_new(status:), "resourceType"),
  )
  decode.success(Questionnaire(
    item:,
    code:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject_type:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/QuestionnaireResponse#resource
pub type Questionnaireresponse {
  Questionnaireresponse(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    questionnaire: String,
    status: r5valuesets.Questionnaireanswersstatus,
    subject: Option(Reference),
    encounter: Option(Reference),
    authored: Option(String),
    author: Option(Reference),
    source: Option(Reference),
    item: List(QuestionnaireresponseItem),
  )
}

pub fn questionnaireresponse_new(
  status status: r5valuesets.Questionnaireanswersstatus,
  questionnaire questionnaire: String,
) -> Questionnaireresponse {
  Questionnaireresponse(
    item: [],
    source: None,
    author: None,
    authored: None,
    encounter: None,
    subject: None,
    status:,
    questionnaire:,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItem {
  QuestionnaireresponseItem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: String,
    definition: Option(String),
    text: Option(String),
    answer: List(QuestionnaireresponseItemAnswer),
  )
}

pub fn questionnaireresponse_item_new(
  link_id link_id: String,
) -> QuestionnaireresponseItem {
  QuestionnaireresponseItem(
    answer: [],
    text: None,
    definition: None,
    link_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswer {
  QuestionnaireresponseItemAnswer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: QuestionnaireresponseItemAnswerValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/QuestionnaireResponse#resource
pub type QuestionnaireresponseItemAnswerValue {
  QuestionnaireresponseItemAnswerValueBoolean(value: Bool)
  QuestionnaireresponseItemAnswerValueDecimal(value: Float)
  QuestionnaireresponseItemAnswerValueInteger(value: Int)
  QuestionnaireresponseItemAnswerValueDate(value: String)
  QuestionnaireresponseItemAnswerValueDatetime(value: String)
  QuestionnaireresponseItemAnswerValueTime(value: String)
  QuestionnaireresponseItemAnswerValueString(value: String)
  QuestionnaireresponseItemAnswerValueUri(value: String)
  QuestionnaireresponseItemAnswerValueAttachment(value: Attachment)
  QuestionnaireresponseItemAnswerValueCoding(value: Coding)
  QuestionnaireresponseItemAnswerValueQuantity(value: Quantity)
  QuestionnaireresponseItemAnswerValueReference(value: Reference)
}

pub fn questionnaireresponse_item_answer_value_to_json(
  elt: QuestionnaireresponseItemAnswerValue,
) -> Json {
  case elt {
    QuestionnaireresponseItemAnswerValueBoolean(v) -> json.bool(v)
    QuestionnaireresponseItemAnswerValueDecimal(v) -> json.float(v)
    QuestionnaireresponseItemAnswerValueInteger(v) -> json.int(v)
    QuestionnaireresponseItemAnswerValueDate(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueDatetime(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueTime(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueString(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueUri(v) -> json.string(v)
    QuestionnaireresponseItemAnswerValueAttachment(v) -> attachment_to_json(v)
    QuestionnaireresponseItemAnswerValueCoding(v) -> coding_to_json(v)
    QuestionnaireresponseItemAnswerValueQuantity(v) -> quantity_to_json(v)
    QuestionnaireresponseItemAnswerValueReference(v) -> reference_to_json(v)
  }
}

pub fn questionnaireresponse_item_answer_value_decoder() -> Decoder(
  QuestionnaireresponseItemAnswerValue,
) {
  decode.one_of(
    decode.field("valueBoolean", decode.bool, decode.success)
      |> decode.map(QuestionnaireresponseItemAnswerValueBoolean),
    [
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDecimal),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueInteger),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueDatetime),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueTime),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueString),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueUri),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueAttachment),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueCoding),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueQuantity),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(QuestionnaireresponseItemAnswerValueReference),
    ],
  )
}

pub fn questionnaireresponse_item_answer_new(
  value value: QuestionnaireresponseItemAnswerValue,
) -> QuestionnaireresponseItemAnswer {
  QuestionnaireresponseItemAnswer(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn questionnaireresponse_item_answer_to_json(
  questionnaireresponse_item_answer: QuestionnaireresponseItemAnswer,
) -> Json {
  let QuestionnaireresponseItemAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaireresponse_item_answer
  let fields = [
    #("value", questionnaireresponse_item_answer_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaireresponse_item_answer_decoder() -> Decoder(
  QuestionnaireresponseItemAnswer,
) {
  use value <- decode.then(questionnaireresponse_item_answer_value_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireresponseItemAnswer(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaireresponse_item_to_json(
  questionnaireresponse_item: QuestionnaireresponseItem,
) -> Json {
  let QuestionnaireresponseItem(
    answer:,
    text:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = questionnaireresponse_item
  let fields = [
    #("linkId", json.string(link_id)),
  ]
  let fields = case answer {
    [] -> fields
    _ -> [
      #("answer", json.array(answer, questionnaireresponse_item_answer_to_json)),
      ..fields
    ]
  }
  let fields = case text {
    Some(v) -> [#("text", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [#("definition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn questionnaireresponse_item_decoder() -> Decoder(
  QuestionnaireresponseItem,
) {
  use answer <- decode.optional_field(
    "answer",
    [],
    decode.list(questionnaireresponse_item_answer_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.optional_field(
    "definition",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.field("linkId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(QuestionnaireresponseItem(
    answer:,
    text:,
    definition:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn questionnaireresponse_to_json(
  questionnaireresponse: Questionnaireresponse,
) -> Json {
  let Questionnaireresponse(
    item:,
    source:,
    author:,
    authored:,
    encounter:,
    subject:,
    status:,
    questionnaire:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = questionnaireresponse
  let fields = [
    #("status", r5valuesets.questionnaireanswersstatus_to_json(status)),
    #("questionnaire", json.string(questionnaire)),
  ]
  let fields = case item {
    [] -> fields
    _ -> [
      #("item", json.array(item, questionnaireresponse_item_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    Some(v) -> [#("source", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored {
    Some(v) -> [#("authored", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Questionnaireresponse")),
    ..fields
  ]
  json.object(fields)
}

pub fn questionnaireresponse_decoder() -> Decoder(Questionnaireresponse) {
  use item <- decode.optional_field(
    "item",
    [],
    decode.list(questionnaireresponse_item_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    None,
    decode.optional(reference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use authored <- decode.optional_field(
    "authored",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.field(
    "status",
    r5valuesets.questionnaireanswersstatus_decoder(),
  )
  use questionnaire <- decode.field("questionnaire", decode.string)
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Questionnaireresponse",
    decode.failure(
      questionnaireresponse_new(status:, questionnaire:),
      "resourceType",
    ),
  )
  decode.success(Questionnaireresponse(
    item:,
    source:,
    author:,
    authored:,
    encounter:,
    subject:,
    status:,
    questionnaire:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/RegulatedAuthorization#resource
pub type Regulatedauthorization {
  Regulatedauthorization(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    subject: List(Reference),
    type_: Option(Codeableconcept),
    description: Option(String),
    region: List(Codeableconcept),
    status: Option(Codeableconcept),
    status_date: Option(String),
    validity_period: Option(Period),
    indication: List(Codeablereference),
    intended_use: Option(Codeableconcept),
    basis: List(Codeableconcept),
    holder: Option(Reference),
    regulator: Option(Reference),
    attached_document: List(Reference),
    case_: Option(RegulatedauthorizationCase),
  )
}

pub fn regulatedauthorization_new() -> Regulatedauthorization {
  Regulatedauthorization(
    case_: None,
    attached_document: [],
    regulator: None,
    holder: None,
    basis: [],
    intended_use: None,
    indication: [],
    validity_period: None,
    status_date: None,
    status: None,
    region: [],
    description: None,
    type_: None,
    subject: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RegulatedAuthorization#resource
pub type RegulatedauthorizationCase {
  RegulatedauthorizationCase(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    type_: Option(Codeableconcept),
    status: Option(Codeableconcept),
    date: Option(RegulatedauthorizationCaseDate),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RegulatedAuthorization#resource
pub type RegulatedauthorizationCaseDate {
  RegulatedauthorizationCaseDatePeriod(date: Period)
  RegulatedauthorizationCaseDateDatetime(date: String)
}

pub fn regulatedauthorization_case_date_to_json(
  elt: RegulatedauthorizationCaseDate,
) -> Json {
  case elt {
    RegulatedauthorizationCaseDatePeriod(v) -> period_to_json(v)
    RegulatedauthorizationCaseDateDatetime(v) -> json.string(v)
  }
}

pub fn regulatedauthorization_case_date_decoder() -> Decoder(
  RegulatedauthorizationCaseDate,
) {
  decode.one_of(
    decode.field("datePeriod", period_decoder(), decode.success)
      |> decode.map(RegulatedauthorizationCaseDatePeriod),
    [
      decode.field("dateDateTime", decode.string, decode.success)
      |> decode.map(RegulatedauthorizationCaseDateDatetime),
    ],
  )
}

pub fn regulatedauthorization_case_new() -> RegulatedauthorizationCase {
  RegulatedauthorizationCase(
    date: None,
    status: None,
    type_: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn regulatedauthorization_case_to_json(
  regulatedauthorization_case: RegulatedauthorizationCase,
) -> Json {
  let RegulatedauthorizationCase(
    date:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = regulatedauthorization_case
  let fields = []
  let fields = case date {
    Some(v) -> [
      #(
        "date"
          <> case v {
          RegulatedauthorizationCaseDatePeriod(_) -> "Period"
          RegulatedauthorizationCaseDateDatetime(_) -> "Datetime"
        },
        regulatedauthorization_case_date_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn regulatedauthorization_case_decoder() -> Decoder(
  RegulatedauthorizationCase,
) {
  use date <- decode.then(
    none_if_omitted(regulatedauthorization_case_date_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RegulatedauthorizationCase(
    date:,
    status:,
    type_:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn regulatedauthorization_to_json(
  regulatedauthorization: Regulatedauthorization,
) -> Json {
  let Regulatedauthorization(
    case_:,
    attached_document:,
    regulator:,
    holder:,
    basis:,
    intended_use:,
    indication:,
    validity_period:,
    status_date:,
    status:,
    region:,
    description:,
    type_:,
    subject:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = regulatedauthorization
  let fields = []
  let fields = case case_ {
    Some(v) -> [#("case", regulatedauthorization_case_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case attached_document {
    [] -> fields
    _ -> [
      #("attachedDocument", json.array(attached_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case regulator {
    Some(v) -> [#("regulator", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case holder {
    Some(v) -> [#("holder", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case basis {
    [] -> fields
    _ -> [#("basis", json.array(basis, codeableconcept_to_json)), ..fields]
  }
  let fields = case intended_use {
    Some(v) -> [#("intendedUse", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case indication {
    [] -> fields
    _ -> [
      #("indication", json.array(indication, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case validity_period {
    Some(v) -> [#("validityPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case region {
    [] -> fields
    _ -> [#("region", json.array(region, codeableconcept_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    [] -> fields
    _ -> [#("subject", json.array(subject, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Regulatedauthorization")),
    ..fields
  ]
  json.object(fields)
}

pub fn regulatedauthorization_decoder() -> Decoder(Regulatedauthorization) {
  use case_ <- decode.optional_field(
    "case",
    None,
    decode.optional(regulatedauthorization_case_decoder()),
  )
  use attached_document <- decode.optional_field(
    "attachedDocument",
    [],
    decode.list(reference_decoder()),
  )
  use regulator <- decode.optional_field(
    "regulator",
    None,
    decode.optional(reference_decoder()),
  )
  use holder <- decode.optional_field(
    "holder",
    None,
    decode.optional(reference_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intended_use <- decode.optional_field(
    "intendedUse",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use indication <- decode.optional_field(
    "indication",
    [],
    decode.list(codeablereference_decoder()),
  )
  use validity_period <- decode.optional_field(
    "validityPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use region <- decode.optional_field(
    "region",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Regulatedauthorization",
    decode.failure(regulatedauthorization_new(), "resourceType"),
  )
  decode.success(Regulatedauthorization(
    case_:,
    attached_document:,
    regulator:,
    holder:,
    basis:,
    intended_use:,
    indication:,
    validity_period:,
    status_date:,
    status:,
    region:,
    description:,
    type_:,
    subject:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/RelatedPerson#resource
pub type Relatedperson {
  Relatedperson(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    patient: Reference,
    relationship: List(Codeableconcept),
    name: List(Humanname),
    telecom: List(Contactpoint),
    gender: Option(r5valuesets.Administrativegender),
    birth_date: Option(String),
    address: List(Address),
    photo: List(Attachment),
    period: Option(Period),
    communication: List(RelatedpersonCommunication),
  )
}

pub fn relatedperson_new(patient patient: Reference) -> Relatedperson {
  Relatedperson(
    communication: [],
    period: None,
    photo: [],
    address: [],
    birth_date: None,
    gender: None,
    telecom: [],
    name: [],
    relationship: [],
    patient:,
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RelatedPerson#resource
pub type RelatedpersonCommunication {
  RelatedpersonCommunication(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Codeableconcept,
    preferred: Option(Bool),
  )
}

pub fn relatedperson_communication_new(
  language language: Codeableconcept,
) -> RelatedpersonCommunication {
  RelatedpersonCommunication(
    preferred: None,
    language:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn relatedperson_communication_to_json(
  relatedperson_communication: RelatedpersonCommunication,
) -> Json {
  let RelatedpersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = relatedperson_communication
  let fields = [
    #("language", codeableconcept_to_json(language)),
  ]
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn relatedperson_communication_decoder() -> Decoder(
  RelatedpersonCommunication,
) {
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use language <- decode.field("language", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RelatedpersonCommunication(
    preferred:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn relatedperson_to_json(relatedperson: Relatedperson) -> Json {
  let Relatedperson(
    communication:,
    period:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    relationship:,
    patient:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = relatedperson
  let fields = [
    #("patient", reference_to_json(patient)),
  ]
  let fields = case communication {
    [] -> fields
    _ -> [
      #(
        "communication",
        json.array(communication, relatedperson_communication_to_json),
      ),
      ..fields
    ]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case photo {
    [] -> fields
    _ -> [#("photo", json.array(photo, attachment_to_json)), ..fields]
  }
  let fields = case address {
    [] -> fields
    _ -> [#("address", json.array(address, address_to_json)), ..fields]
  }
  let fields = case birth_date {
    Some(v) -> [#("birthDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case gender {
    Some(v) -> [
      #("gender", r5valuesets.administrativegender_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case telecom {
    [] -> fields
    _ -> [#("telecom", json.array(telecom, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    [] -> fields
    _ -> [#("name", json.array(name, humanname_to_json)), ..fields]
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #("relationship", json.array(relationship, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Relatedperson")), ..fields]
  json.object(fields)
}

pub fn relatedperson_decoder() -> Decoder(Relatedperson) {
  use communication <- decode.optional_field(
    "communication",
    [],
    decode.list(relatedperson_communication_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use photo <- decode.optional_field(
    "photo",
    [],
    decode.list(attachment_decoder()),
  )
  use address <- decode.optional_field(
    "address",
    [],
    decode.list(address_decoder()),
  )
  use birth_date <- decode.optional_field(
    "birthDate",
    None,
    decode.optional(decode.string),
  )
  use gender <- decode.optional_field(
    "gender",
    None,
    decode.optional(r5valuesets.administrativegender_decoder()),
  )
  use telecom <- decode.optional_field(
    "telecom",
    [],
    decode.list(contactpoint_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(humanname_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Relatedperson",
    decode.failure(relatedperson_new(patient:), "resourceType"),
  )
  decode.success(Relatedperson(
    communication:,
    period:,
    photo:,
    address:,
    birth_date:,
    gender:,
    telecom:,
    name:,
    relationship:,
    patient:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type Requestorchestration {
  Requestorchestration(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    group_identifier: Option(Identifier),
    status: r5valuesets.Requeststatus,
    intent: r5valuesets.Requestintent,
    priority: Option(r5valuesets.Requestpriority),
    code: Option(Codeableconcept),
    subject: Option(Reference),
    encounter: Option(Reference),
    authored_on: Option(String),
    author: Option(Reference),
    reason: List(Codeablereference),
    goal: List(Reference),
    note: List(Annotation),
    action: List(RequestorchestrationAction),
  )
}

pub fn requestorchestration_new(
  intent intent: r5valuesets.Requestintent,
  status status: r5valuesets.Requeststatus,
) -> Requestorchestration {
  Requestorchestration(
    action: [],
    note: [],
    goal: [],
    reason: [],
    author: None,
    authored_on: None,
    encounter: None,
    subject: None,
    code: None,
    priority: None,
    intent:,
    status:,
    group_identifier: None,
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationAction {
  RequestorchestrationAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    prefix: Option(String),
    title: Option(String),
    description: Option(String),
    text_equivalent: Option(String),
    priority: Option(r5valuesets.Requestpriority),
    code: List(Codeableconcept),
    documentation: List(Relatedartifact),
    goal: List(Reference),
    condition: List(RequestorchestrationActionCondition),
    input: List(RequestorchestrationActionInput),
    output: List(RequestorchestrationActionOutput),
    related_action: List(RequestorchestrationActionRelatedaction),
    timing: Option(RequestorchestrationActionTiming),
    location: Option(Codeablereference),
    participant: List(RequestorchestrationActionParticipant),
    type_: Option(Codeableconcept),
    grouping_behavior: Option(r5valuesets.Actiongroupingbehavior),
    selection_behavior: Option(r5valuesets.Actionselectionbehavior),
    required_behavior: Option(r5valuesets.Actionrequiredbehavior),
    precheck_behavior: Option(r5valuesets.Actionprecheckbehavior),
    cardinality_behavior: Option(r5valuesets.Actioncardinalitybehavior),
    resource: Option(Reference),
    definition: Option(RequestorchestrationActionDefinition),
    transform: Option(String),
    dynamic_value: List(RequestorchestrationActionDynamicvalue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionTiming {
  RequestorchestrationActionTimingDatetime(timing: String)
  RequestorchestrationActionTimingAge(timing: Age)
  RequestorchestrationActionTimingPeriod(timing: Period)
  RequestorchestrationActionTimingDuration(timing: Duration)
  RequestorchestrationActionTimingRange(timing: Range)
  RequestorchestrationActionTimingTiming(timing: Timing)
}

pub fn requestorchestration_action_timing_to_json(
  elt: RequestorchestrationActionTiming,
) -> Json {
  case elt {
    RequestorchestrationActionTimingDatetime(v) -> json.string(v)
    RequestorchestrationActionTimingAge(v) -> age_to_json(v)
    RequestorchestrationActionTimingPeriod(v) -> period_to_json(v)
    RequestorchestrationActionTimingDuration(v) -> duration_to_json(v)
    RequestorchestrationActionTimingRange(v) -> range_to_json(v)
    RequestorchestrationActionTimingTiming(v) -> timing_to_json(v)
  }
}

pub fn requestorchestration_action_timing_decoder() -> Decoder(
  RequestorchestrationActionTiming,
) {
  decode.one_of(
    decode.field("timingDateTime", decode.string, decode.success)
      |> decode.map(RequestorchestrationActionTimingDatetime),
    [
      decode.field("timingAge", age_decoder(), decode.success)
        |> decode.map(RequestorchestrationActionTimingAge),
      decode.field("timingPeriod", period_decoder(), decode.success)
        |> decode.map(RequestorchestrationActionTimingPeriod),
      decode.field("timingDuration", duration_decoder(), decode.success)
        |> decode.map(RequestorchestrationActionTimingDuration),
      decode.field("timingRange", range_decoder(), decode.success)
        |> decode.map(RequestorchestrationActionTimingRange),
      decode.field("timingTiming", timing_decoder(), decode.success)
        |> decode.map(RequestorchestrationActionTimingTiming),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionDefinition {
  RequestorchestrationActionDefinitionCanonical(definition: String)
  RequestorchestrationActionDefinitionUri(definition: String)
}

pub fn requestorchestration_action_definition_to_json(
  elt: RequestorchestrationActionDefinition,
) -> Json {
  case elt {
    RequestorchestrationActionDefinitionCanonical(v) -> json.string(v)
    RequestorchestrationActionDefinitionUri(v) -> json.string(v)
  }
}

pub fn requestorchestration_action_definition_decoder() -> Decoder(
  RequestorchestrationActionDefinition,
) {
  decode.one_of(
    decode.field("definitionCanonical", decode.string, decode.success)
      |> decode.map(RequestorchestrationActionDefinitionCanonical),
    [
      decode.field("definitionUri", decode.string, decode.success)
      |> decode.map(RequestorchestrationActionDefinitionUri),
    ],
  )
}

pub fn requestorchestration_action_new() -> RequestorchestrationAction {
  RequestorchestrationAction(
    dynamic_value: [],
    transform: None,
    definition: None,
    resource: None,
    cardinality_behavior: None,
    precheck_behavior: None,
    required_behavior: None,
    selection_behavior: None,
    grouping_behavior: None,
    type_: None,
    participant: [],
    location: None,
    timing: None,
    related_action: [],
    output: [],
    input: [],
    condition: [],
    goal: [],
    documentation: [],
    code: [],
    priority: None,
    text_equivalent: None,
    description: None,
    title: None,
    prefix: None,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionCondition {
  RequestorchestrationActionCondition(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kind: r5valuesets.Actionconditionkind,
    expression: Option(Expression),
  )
}

pub fn requestorchestration_action_condition_new(
  kind kind: r5valuesets.Actionconditionkind,
) -> RequestorchestrationActionCondition {
  RequestorchestrationActionCondition(
    expression: None,
    kind:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionInput {
  RequestorchestrationActionInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    requirement: Option(Datarequirement),
    related_data: Option(String),
  )
}

pub fn requestorchestration_action_input_new() -> RequestorchestrationActionInput {
  RequestorchestrationActionInput(
    related_data: None,
    requirement: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionOutput {
  RequestorchestrationActionOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    title: Option(String),
    requirement: Option(Datarequirement),
    related_data: Option(String),
  )
}

pub fn requestorchestration_action_output_new() -> RequestorchestrationActionOutput {
  RequestorchestrationActionOutput(
    related_data: None,
    requirement: None,
    title: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionRelatedaction {
  RequestorchestrationActionRelatedaction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target_id: String,
    relationship: r5valuesets.Actionrelationshiptype,
    end_relationship: Option(r5valuesets.Actionrelationshiptype),
    offset: Option(RequestorchestrationActionRelatedactionOffset),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionRelatedactionOffset {
  RequestorchestrationActionRelatedactionOffsetDuration(offset: Duration)
  RequestorchestrationActionRelatedactionOffsetRange(offset: Range)
}

pub fn requestorchestration_action_relatedaction_offset_to_json(
  elt: RequestorchestrationActionRelatedactionOffset,
) -> Json {
  case elt {
    RequestorchestrationActionRelatedactionOffsetDuration(v) ->
      duration_to_json(v)
    RequestorchestrationActionRelatedactionOffsetRange(v) -> range_to_json(v)
  }
}

pub fn requestorchestration_action_relatedaction_offset_decoder() -> Decoder(
  RequestorchestrationActionRelatedactionOffset,
) {
  decode.one_of(
    decode.field("offsetDuration", duration_decoder(), decode.success)
      |> decode.map(RequestorchestrationActionRelatedactionOffsetDuration),
    [
      decode.field("offsetRange", range_decoder(), decode.success)
      |> decode.map(RequestorchestrationActionRelatedactionOffsetRange),
    ],
  )
}

pub fn requestorchestration_action_relatedaction_new(
  relationship relationship: r5valuesets.Actionrelationshiptype,
  target_id target_id: String,
) -> RequestorchestrationActionRelatedaction {
  RequestorchestrationActionRelatedaction(
    offset: None,
    end_relationship: None,
    relationship:,
    target_id:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionParticipant {
  RequestorchestrationActionParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(r5valuesets.Actionparticipanttype),
    type_canonical: Option(String),
    type_reference: Option(Reference),
    role: Option(Codeableconcept),
    function: Option(Codeableconcept),
    actor: Option(RequestorchestrationActionParticipantActor),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionParticipantActor {
  RequestorchestrationActionParticipantActorCanonical(actor: String)
  RequestorchestrationActionParticipantActorReference(actor: Reference)
}

pub fn requestorchestration_action_participant_actor_to_json(
  elt: RequestorchestrationActionParticipantActor,
) -> Json {
  case elt {
    RequestorchestrationActionParticipantActorCanonical(v) -> json.string(v)
    RequestorchestrationActionParticipantActorReference(v) ->
      reference_to_json(v)
  }
}

pub fn requestorchestration_action_participant_actor_decoder() -> Decoder(
  RequestorchestrationActionParticipantActor,
) {
  decode.one_of(
    decode.field("actorCanonical", decode.string, decode.success)
      |> decode.map(RequestorchestrationActionParticipantActorCanonical),
    [
      decode.field("actorReference", reference_decoder(), decode.success)
      |> decode.map(RequestorchestrationActionParticipantActorReference),
    ],
  )
}

pub fn requestorchestration_action_participant_new() -> RequestorchestrationActionParticipant {
  RequestorchestrationActionParticipant(
    actor: None,
    function: None,
    role: None,
    type_reference: None,
    type_canonical: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RequestOrchestration#resource
pub type RequestorchestrationActionDynamicvalue {
  RequestorchestrationActionDynamicvalue(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    path: Option(String),
    expression: Option(Expression),
  )
}

pub fn requestorchestration_action_dynamicvalue_new() -> RequestorchestrationActionDynamicvalue {
  RequestorchestrationActionDynamicvalue(
    expression: None,
    path: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn requestorchestration_action_dynamicvalue_to_json(
  requestorchestration_action_dynamicvalue: RequestorchestrationActionDynamicvalue,
) -> Json {
  let RequestorchestrationActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_dynamicvalue
  let fields = []
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_dynamicvalue_decoder() -> Decoder(
  RequestorchestrationActionDynamicvalue,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionDynamicvalue(
    expression:,
    path:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_participant_to_json(
  requestorchestration_action_participant: RequestorchestrationActionParticipant,
) -> Json {
  let RequestorchestrationActionParticipant(
    actor:,
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_participant
  let fields = []
  let fields = case actor {
    Some(v) -> [
      #(
        "actor"
          <> case v {
          RequestorchestrationActionParticipantActorCanonical(_) -> "Canonical"
          RequestorchestrationActionParticipantActorReference(_) -> "Reference"
        },
        requestorchestration_action_participant_actor_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_reference {
    Some(v) -> [#("typeReference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_canonical {
    Some(v) -> [#("typeCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [
      #("type", r5valuesets.actionparticipanttype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_participant_decoder() -> Decoder(
  RequestorchestrationActionParticipant,
) {
  use actor <- decode.then(
    none_if_omitted(requestorchestration_action_participant_actor_decoder()),
  )
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_reference <- decode.optional_field(
    "typeReference",
    None,
    decode.optional(reference_decoder()),
  )
  use type_canonical <- decode.optional_field(
    "typeCanonical",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(r5valuesets.actionparticipanttype_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionParticipant(
    actor:,
    function:,
    role:,
    type_reference:,
    type_canonical:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_relatedaction_to_json(
  requestorchestration_action_relatedaction: RequestorchestrationActionRelatedaction,
) -> Json {
  let RequestorchestrationActionRelatedaction(
    offset:,
    end_relationship:,
    relationship:,
    target_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_relatedaction
  let fields = [
    #("relationship", r5valuesets.actionrelationshiptype_to_json(relationship)),
    #("targetId", json.string(target_id)),
  ]
  let fields = case offset {
    Some(v) -> [
      #(
        "offset"
          <> case v {
          RequestorchestrationActionRelatedactionOffsetDuration(_) -> "Duration"
          RequestorchestrationActionRelatedactionOffsetRange(_) -> "Range"
        },
        requestorchestration_action_relatedaction_offset_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case end_relationship {
    Some(v) -> [
      #("endRelationship", r5valuesets.actionrelationshiptype_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_relatedaction_decoder() -> Decoder(
  RequestorchestrationActionRelatedaction,
) {
  use offset <- decode.then(
    none_if_omitted(requestorchestration_action_relatedaction_offset_decoder()),
  )
  use end_relationship <- decode.optional_field(
    "endRelationship",
    None,
    decode.optional(r5valuesets.actionrelationshiptype_decoder()),
  )
  use relationship <- decode.field(
    "relationship",
    r5valuesets.actionrelationshiptype_decoder(),
  )
  use target_id <- decode.field("targetId", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionRelatedaction(
    offset:,
    end_relationship:,
    relationship:,
    target_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_output_to_json(
  requestorchestration_action_output: RequestorchestrationActionOutput,
) -> Json {
  let RequestorchestrationActionOutput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_output
  let fields = []
  let fields = case related_data {
    Some(v) -> [#("relatedData", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", datarequirement_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_output_decoder() -> Decoder(
  RequestorchestrationActionOutput,
) {
  use related_data <- decode.optional_field(
    "relatedData",
    None,
    decode.optional(decode.string),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(datarequirement_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionOutput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_input_to_json(
  requestorchestration_action_input: RequestorchestrationActionInput,
) -> Json {
  let RequestorchestrationActionInput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_input
  let fields = []
  let fields = case related_data {
    Some(v) -> [#("relatedData", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", datarequirement_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_input_decoder() -> Decoder(
  RequestorchestrationActionInput,
) {
  use related_data <- decode.optional_field(
    "relatedData",
    None,
    decode.optional(decode.string),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(datarequirement_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionInput(
    related_data:,
    requirement:,
    title:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_condition_to_json(
  requestorchestration_action_condition: RequestorchestrationActionCondition,
) -> Json {
  let RequestorchestrationActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action_condition
  let fields = [
    #("kind", r5valuesets.actionconditionkind_to_json(kind)),
  ]
  let fields = case expression {
    Some(v) -> [#("expression", expression_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_condition_decoder() -> Decoder(
  RequestorchestrationActionCondition,
) {
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(expression_decoder()),
  )
  use kind <- decode.field("kind", r5valuesets.actionconditionkind_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationActionCondition(
    expression:,
    kind:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_action_to_json(
  requestorchestration_action: RequestorchestrationAction,
) -> Json {
  let RequestorchestrationAction(
    dynamic_value:,
    transform:,
    definition:,
    resource:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    location:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    goal:,
    documentation:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = requestorchestration_action
  let fields = []
  let fields = case dynamic_value {
    [] -> fields
    _ -> [
      #(
        "dynamicValue",
        json.array(
          dynamic_value,
          requestorchestration_action_dynamicvalue_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case definition {
    Some(v) -> [
      #(
        "definition"
          <> case v {
          RequestorchestrationActionDefinitionCanonical(_) -> "Canonical"
          RequestorchestrationActionDefinitionUri(_) -> "Uri"
        },
        requestorchestration_action_definition_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case cardinality_behavior {
    Some(v) -> [
      #("cardinalityBehavior", r5valuesets.actioncardinalitybehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case precheck_behavior {
    Some(v) -> [
      #("precheckBehavior", r5valuesets.actionprecheckbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case required_behavior {
    Some(v) -> [
      #("requiredBehavior", r5valuesets.actionrequiredbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case selection_behavior {
    Some(v) -> [
      #("selectionBehavior", r5valuesets.actionselectionbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case grouping_behavior {
    Some(v) -> [
      #("groupingBehavior", r5valuesets.actiongroupingbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #(
        "participant",
        json.array(participant, requestorchestration_action_participant_to_json),
      ),
      ..fields
    ]
  }
  let fields = case location {
    Some(v) -> [#("location", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case timing {
    Some(v) -> [
      #(
        "timing"
          <> case v {
          RequestorchestrationActionTimingDatetime(_) -> "Datetime"
          RequestorchestrationActionTimingAge(_) -> "Age"
          RequestorchestrationActionTimingPeriod(_) -> "Period"
          RequestorchestrationActionTimingDuration(_) -> "Duration"
          RequestorchestrationActionTimingRange(_) -> "Range"
          RequestorchestrationActionTimingTiming(_) -> "Timing"
        },
        requestorchestration_action_timing_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case related_action {
    [] -> fields
    _ -> [
      #(
        "relatedAction",
        json.array(
          related_action,
          requestorchestration_action_relatedaction_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case output {
    [] -> fields
    _ -> [
      #(
        "output",
        json.array(output, requestorchestration_action_output_to_json),
      ),
      ..fields
    ]
  }
  let fields = case input {
    [] -> fields
    _ -> [
      #("input", json.array(input, requestorchestration_action_input_to_json)),
      ..fields
    ]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #(
        "condition",
        json.array(condition, requestorchestration_action_condition_to_json),
      ),
      ..fields
    ]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, reference_to_json)), ..fields]
  }
  let fields = case documentation {
    [] -> fields
    _ -> [
      #("documentation", json.array(documentation, relatedartifact_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [#("code", json.array(code, codeableconcept_to_json)), ..fields]
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case text_equivalent {
    Some(v) -> [#("textEquivalent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prefix {
    Some(v) -> [#("prefix", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requestorchestration_action_decoder() -> Decoder(
  RequestorchestrationAction,
) {
  use dynamic_value <- decode.optional_field(
    "dynamicValue",
    [],
    decode.list(requestorchestration_action_dynamicvalue_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(decode.string),
  )
  use definition <- decode.then(
    none_if_omitted(requestorchestration_action_definition_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(reference_decoder()),
  )
  use cardinality_behavior <- decode.optional_field(
    "cardinalityBehavior",
    None,
    decode.optional(r5valuesets.actioncardinalitybehavior_decoder()),
  )
  use precheck_behavior <- decode.optional_field(
    "precheckBehavior",
    None,
    decode.optional(r5valuesets.actionprecheckbehavior_decoder()),
  )
  use required_behavior <- decode.optional_field(
    "requiredBehavior",
    None,
    decode.optional(r5valuesets.actionrequiredbehavior_decoder()),
  )
  use selection_behavior <- decode.optional_field(
    "selectionBehavior",
    None,
    decode.optional(r5valuesets.actionselectionbehavior_decoder()),
  )
  use grouping_behavior <- decode.optional_field(
    "groupingBehavior",
    None,
    decode.optional(r5valuesets.actiongroupingbehavior_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(requestorchestration_action_participant_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use timing <- decode.then(
    none_if_omitted(requestorchestration_action_timing_decoder()),
  )
  use related_action <- decode.optional_field(
    "relatedAction",
    [],
    decode.list(requestorchestration_action_relatedaction_decoder()),
  )
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(requestorchestration_action_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(requestorchestration_action_input_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(requestorchestration_action_condition_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(reference_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use text_equivalent <- decode.optional_field(
    "textEquivalent",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use prefix <- decode.optional_field(
    "prefix",
    None,
    decode.optional(decode.string),
  )
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequestorchestrationAction(
    dynamic_value:,
    transform:,
    definition:,
    resource:,
    cardinality_behavior:,
    precheck_behavior:,
    required_behavior:,
    selection_behavior:,
    grouping_behavior:,
    type_:,
    participant:,
    location:,
    timing:,
    related_action:,
    output:,
    input:,
    condition:,
    goal:,
    documentation:,
    code:,
    priority:,
    text_equivalent:,
    description:,
    title:,
    prefix:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requestorchestration_to_json(
  requestorchestration: Requestorchestration,
) -> Json {
  let Requestorchestration(
    action:,
    note:,
    goal:,
    reason:,
    author:,
    authored_on:,
    encounter:,
    subject:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = requestorchestration
  let fields = [
    #("intent", r5valuesets.requestintent_to_json(intent)),
    #("status", r5valuesets.requeststatus_to_json(status)),
  ]
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, requestorchestration_action_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case goal {
    [] -> fields
    _ -> [#("goal", json.array(goal, reference_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case author {
    Some(v) -> [#("author", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Requestorchestration")),
    ..fields
  ]
  json.object(fields)
}

pub fn requestorchestration_decoder() -> Decoder(Requestorchestration) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(requestorchestration_action_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use goal <- decode.optional_field(
    "goal",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.requestintent_decoder())
  use status <- decode.field("status", r5valuesets.requeststatus_decoder())
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Requestorchestration",
    decode.failure(requestorchestration_new(intent:, status:), "resourceType"),
  )
  decode.success(Requestorchestration(
    action:,
    note:,
    goal:,
    reason:,
    author:,
    authored_on:,
    encounter:,
    subject:,
    code:,
    priority:,
    intent:,
    status:,
    group_identifier:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Requirements#resource
pub type Requirements {
  Requirements(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(RequirementsVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    derived_from: List(String),
    reference: List(String),
    actor: List(String),
    statement: List(RequirementsStatement),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Requirements#resource
pub type RequirementsVersionalgorithm {
  RequirementsVersionalgorithmString(version_algorithm: String)
  RequirementsVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn requirements_versionalgorithm_to_json(
  elt: RequirementsVersionalgorithm,
) -> Json {
  case elt {
    RequirementsVersionalgorithmString(v) -> json.string(v)
    RequirementsVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn requirements_versionalgorithm_decoder() -> Decoder(
  RequirementsVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(RequirementsVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(RequirementsVersionalgorithmCoding),
    ],
  )
}

pub fn requirements_new(
  status status: r5valuesets.Publicationstatus,
) -> Requirements {
  Requirements(
    statement: [],
    actor: [],
    reference: [],
    derived_from: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Requirements#resource
pub type RequirementsStatement {
  RequirementsStatement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    key: String,
    label: Option(String),
    conformance: List(r5valuesets.Conformanceexpectation),
    conditionality: Option(Bool),
    requirement: String,
    derived_from: Option(String),
    parent: Option(String),
    satisfied_by: List(String),
    reference: List(String),
    source: List(Reference),
  )
}

pub fn requirements_statement_new(
  requirement requirement: String,
  key key: String,
) -> RequirementsStatement {
  RequirementsStatement(
    source: [],
    reference: [],
    satisfied_by: [],
    parent: None,
    derived_from: None,
    requirement:,
    conditionality: None,
    conformance: [],
    label: None,
    key:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn requirements_statement_to_json(
  requirements_statement: RequirementsStatement,
) -> Json {
  let RequirementsStatement(
    source:,
    reference:,
    satisfied_by:,
    parent:,
    derived_from:,
    requirement:,
    conditionality:,
    conformance:,
    label:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ) = requirements_statement
  let fields = [
    #("requirement", json.string(requirement)),
    #("key", json.string(key)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, json.string)), ..fields]
  }
  let fields = case satisfied_by {
    [] -> fields
    _ -> [#("satisfiedBy", json.array(satisfied_by, json.string)), ..fields]
  }
  let fields = case parent {
    Some(v) -> [#("parent", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    Some(v) -> [#("derivedFrom", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case conditionality {
    Some(v) -> [#("conditionality", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case conformance {
    [] -> fields
    _ -> [
      #(
        "conformance",
        json.array(conformance, r5valuesets.conformanceexpectation_to_json),
      ),
      ..fields
    ]
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn requirements_statement_decoder() -> Decoder(RequirementsStatement) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(decode.string),
  )
  use satisfied_by <- decode.optional_field(
    "satisfiedBy",
    [],
    decode.list(decode.string),
  )
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(decode.string),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    None,
    decode.optional(decode.string),
  )
  use requirement <- decode.field("requirement", decode.string)
  use conditionality <- decode.optional_field(
    "conditionality",
    None,
    decode.optional(decode.bool),
  )
  use conformance <- decode.optional_field(
    "conformance",
    [],
    decode.list(r5valuesets.conformanceexpectation_decoder()),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use key <- decode.field("key", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RequirementsStatement(
    source:,
    reference:,
    satisfied_by:,
    parent:,
    derived_from:,
    requirement:,
    conditionality:,
    conformance:,
    label:,
    key:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn requirements_to_json(requirements: Requirements) -> Json {
  let Requirements(
    statement:,
    actor:,
    reference:,
    derived_from:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = requirements
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case statement {
    [] -> fields
    _ -> [
      #("statement", json.array(statement, requirements_statement_to_json)),
      ..fields
    ]
  }
  let fields = case actor {
    [] -> fields
    _ -> [#("actor", json.array(actor, json.string)), ..fields]
  }
  let fields = case reference {
    [] -> fields
    _ -> [#("reference", json.array(reference, json.string)), ..fields]
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          RequirementsVersionalgorithmString(_) -> "String"
          RequirementsVersionalgorithmCoding(_) -> "Coding"
        },
        requirements_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Requirements")), ..fields]
  json.object(fields)
}

pub fn requirements_decoder() -> Decoder(Requirements) {
  use statement <- decode.optional_field(
    "statement",
    [],
    decode.list(requirements_statement_decoder()),
  )
  use actor <- decode.optional_field("actor", [], decode.list(decode.string))
  use reference <- decode.optional_field(
    "reference",
    [],
    decode.list(decode.string),
  )
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(requirements_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Requirements",
    decode.failure(requirements_new(status:), "resourceType"),
  )
  decode.success(Requirements(
    statement:,
    actor:,
    reference:,
    derived_from:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type Researchstudy {
  Researchstudy(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    name: Option(String),
    title: Option(String),
    label: List(ResearchstudyLabel),
    protocol: List(Reference),
    part_of: List(Reference),
    related_artifact: List(Relatedartifact),
    date: Option(String),
    status: r5valuesets.Publicationstatus,
    primary_purpose_type: Option(Codeableconcept),
    phase: Option(Codeableconcept),
    study_design: List(Codeableconcept),
    focus: List(Codeablereference),
    condition: List(Codeableconcept),
    keyword: List(Codeableconcept),
    region: List(Codeableconcept),
    description_summary: Option(String),
    description: Option(String),
    period: Option(Period),
    site: List(Reference),
    note: List(Annotation),
    classifier: List(Codeableconcept),
    associated_party: List(ResearchstudyAssociatedparty),
    progress_status: List(ResearchstudyProgressstatus),
    why_stopped: Option(Codeableconcept),
    recruitment: Option(ResearchstudyRecruitment),
    comparison_group: List(ResearchstudyComparisongroup),
    objective: List(ResearchstudyObjective),
    outcome_measure: List(ResearchstudyOutcomemeasure),
    result: List(Reference),
  )
}

pub fn researchstudy_new(
  status status: r5valuesets.Publicationstatus,
) -> Researchstudy {
  Researchstudy(
    result: [],
    outcome_measure: [],
    objective: [],
    comparison_group: [],
    recruitment: None,
    why_stopped: None,
    progress_status: [],
    associated_party: [],
    classifier: [],
    note: [],
    site: [],
    period: None,
    description: None,
    description_summary: None,
    region: [],
    keyword: [],
    condition: [],
    focus: [],
    study_design: [],
    phase: None,
    primary_purpose_type: None,
    status:,
    date: None,
    related_artifact: [],
    part_of: [],
    protocol: [],
    label: [],
    title: None,
    name: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyLabel {
  ResearchstudyLabel(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    value: Option(String),
  )
}

pub fn researchstudy_label_new() -> ResearchstudyLabel {
  ResearchstudyLabel(
    value: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyAssociatedparty {
  ResearchstudyAssociatedparty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    role: Codeableconcept,
    period: List(Period),
    classifier: List(Codeableconcept),
    party: Option(Reference),
  )
}

pub fn researchstudy_associatedparty_new(
  role role: Codeableconcept,
) -> ResearchstudyAssociatedparty {
  ResearchstudyAssociatedparty(
    party: None,
    classifier: [],
    period: [],
    role:,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyProgressstatus {
  ResearchstudyProgressstatus(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    state: Codeableconcept,
    actual: Option(Bool),
    period: Option(Period),
  )
}

pub fn researchstudy_progressstatus_new(
  state state: Codeableconcept,
) -> ResearchstudyProgressstatus {
  ResearchstudyProgressstatus(
    period: None,
    actual: None,
    state:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyRecruitment {
  ResearchstudyRecruitment(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target_number: Option(Int),
    actual_number: Option(Int),
    eligibility: Option(Reference),
    actual_group: Option(Reference),
  )
}

pub fn researchstudy_recruitment_new() -> ResearchstudyRecruitment {
  ResearchstudyRecruitment(
    actual_group: None,
    eligibility: None,
    actual_number: None,
    target_number: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyComparisongroup {
  ResearchstudyComparisongroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link_id: Option(String),
    name: String,
    type_: Option(Codeableconcept),
    description: Option(String),
    intended_exposure: List(Reference),
    observed_group: Option(Reference),
  )
}

pub fn researchstudy_comparisongroup_new(
  name name: String,
) -> ResearchstudyComparisongroup {
  ResearchstudyComparisongroup(
    observed_group: None,
    intended_exposure: [],
    description: None,
    type_: None,
    name:,
    link_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyObjective {
  ResearchstudyObjective(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    type_: Option(Codeableconcept),
    description: Option(String),
  )
}

pub fn researchstudy_objective_new() -> ResearchstudyObjective {
  ResearchstudyObjective(
    description: None,
    type_: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchStudy#resource
pub type ResearchstudyOutcomemeasure {
  ResearchstudyOutcomemeasure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    type_: List(Codeableconcept),
    description: Option(String),
    reference: Option(Reference),
  )
}

pub fn researchstudy_outcomemeasure_new() -> ResearchstudyOutcomemeasure {
  ResearchstudyOutcomemeasure(
    reference: None,
    description: None,
    type_: [],
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn researchstudy_outcomemeasure_to_json(
  researchstudy_outcomemeasure: ResearchstudyOutcomemeasure,
) -> Json {
  let ResearchstudyOutcomemeasure(
    reference:,
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_outcomemeasure
  let fields = []
  let fields = case reference {
    Some(v) -> [#("reference", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_outcomemeasure_decoder() -> Decoder(
  ResearchstudyOutcomemeasure,
) {
  use reference <- decode.optional_field(
    "reference",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyOutcomemeasure(
    reference:,
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_objective_to_json(
  researchstudy_objective: ResearchstudyObjective,
) -> Json {
  let ResearchstudyObjective(
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_objective
  let fields = []
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_objective_decoder() -> Decoder(ResearchstudyObjective) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyObjective(
    description:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_comparisongroup_to_json(
  researchstudy_comparisongroup: ResearchstudyComparisongroup,
) -> Json {
  let ResearchstudyComparisongroup(
    observed_group:,
    intended_exposure:,
    description:,
    type_:,
    name:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_comparisongroup
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case observed_group {
    Some(v) -> [#("observedGroup", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case intended_exposure {
    [] -> fields
    _ -> [
      #("intendedExposure", json.array(intended_exposure, reference_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case link_id {
    Some(v) -> [#("linkId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_comparisongroup_decoder() -> Decoder(
  ResearchstudyComparisongroup,
) {
  use observed_group <- decode.optional_field(
    "observedGroup",
    None,
    decode.optional(reference_decoder()),
  )
  use intended_exposure <- decode.optional_field(
    "intendedExposure",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use link_id <- decode.optional_field(
    "linkId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyComparisongroup(
    observed_group:,
    intended_exposure:,
    description:,
    type_:,
    name:,
    link_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_recruitment_to_json(
  researchstudy_recruitment: ResearchstudyRecruitment,
) -> Json {
  let ResearchstudyRecruitment(
    actual_group:,
    eligibility:,
    actual_number:,
    target_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_recruitment
  let fields = []
  let fields = case actual_group {
    Some(v) -> [#("actualGroup", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case eligibility {
    Some(v) -> [#("eligibility", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actual_number {
    Some(v) -> [#("actualNumber", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case target_number {
    Some(v) -> [#("targetNumber", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_recruitment_decoder() -> Decoder(ResearchstudyRecruitment) {
  use actual_group <- decode.optional_field(
    "actualGroup",
    None,
    decode.optional(reference_decoder()),
  )
  use eligibility <- decode.optional_field(
    "eligibility",
    None,
    decode.optional(reference_decoder()),
  )
  use actual_number <- decode.optional_field(
    "actualNumber",
    None,
    decode.optional(decode.int),
  )
  use target_number <- decode.optional_field(
    "targetNumber",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyRecruitment(
    actual_group:,
    eligibility:,
    actual_number:,
    target_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_progressstatus_to_json(
  researchstudy_progressstatus: ResearchstudyProgressstatus,
) -> Json {
  let ResearchstudyProgressstatus(
    period:,
    actual:,
    state:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_progressstatus
  let fields = [
    #("state", codeableconcept_to_json(state)),
  ]
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actual {
    Some(v) -> [#("actual", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_progressstatus_decoder() -> Decoder(
  ResearchstudyProgressstatus,
) {
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use actual <- decode.optional_field(
    "actual",
    None,
    decode.optional(decode.bool),
  )
  use state <- decode.field("state", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyProgressstatus(
    period:,
    actual:,
    state:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_associatedparty_to_json(
  researchstudy_associatedparty: ResearchstudyAssociatedparty,
) -> Json {
  let ResearchstudyAssociatedparty(
    party:,
    classifier:,
    period:,
    role:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchstudy_associatedparty
  let fields = [
    #("role", codeableconcept_to_json(role)),
  ]
  let fields = case party {
    Some(v) -> [#("party", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case period {
    [] -> fields
    _ -> [#("period", json.array(period, period_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_associatedparty_decoder() -> Decoder(
  ResearchstudyAssociatedparty,
) {
  use party <- decode.optional_field(
    "party",
    None,
    decode.optional(reference_decoder()),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    [],
    decode.list(period_decoder()),
  )
  use role <- decode.field("role", codeableconcept_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyAssociatedparty(
    party:,
    classifier:,
    period:,
    role:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_label_to_json(
  researchstudy_label: ResearchstudyLabel,
) -> Json {
  let ResearchstudyLabel(value:, type_:, modifier_extension:, extension:, id:) =
    researchstudy_label
  let fields = []
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchstudy_label_decoder() -> Decoder(ResearchstudyLabel) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchstudyLabel(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchstudy_to_json(researchstudy: Researchstudy) -> Json {
  let Researchstudy(
    result:,
    outcome_measure:,
    objective:,
    comparison_group:,
    recruitment:,
    why_stopped:,
    progress_status:,
    associated_party:,
    classifier:,
    note:,
    site:,
    period:,
    description:,
    description_summary:,
    region:,
    keyword:,
    condition:,
    focus:,
    study_design:,
    phase:,
    primary_purpose_type:,
    status:,
    date:,
    related_artifact:,
    part_of:,
    protocol:,
    label:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchstudy
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case result {
    [] -> fields
    _ -> [#("result", json.array(result, reference_to_json)), ..fields]
  }
  let fields = case outcome_measure {
    [] -> fields
    _ -> [
      #(
        "outcomeMeasure",
        json.array(outcome_measure, researchstudy_outcomemeasure_to_json),
      ),
      ..fields
    ]
  }
  let fields = case objective {
    [] -> fields
    _ -> [
      #("objective", json.array(objective, researchstudy_objective_to_json)),
      ..fields
    ]
  }
  let fields = case comparison_group {
    [] -> fields
    _ -> [
      #(
        "comparisonGroup",
        json.array(comparison_group, researchstudy_comparisongroup_to_json),
      ),
      ..fields
    ]
  }
  let fields = case recruitment {
    Some(v) -> [
      #("recruitment", researchstudy_recruitment_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case why_stopped {
    Some(v) -> [#("whyStopped", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case progress_status {
    [] -> fields
    _ -> [
      #(
        "progressStatus",
        json.array(progress_status, researchstudy_progressstatus_to_json),
      ),
      ..fields
    ]
  }
  let fields = case associated_party {
    [] -> fields
    _ -> [
      #(
        "associatedParty",
        json.array(associated_party, researchstudy_associatedparty_to_json),
      ),
      ..fields
    ]
  }
  let fields = case classifier {
    [] -> fields
    _ -> [
      #("classifier", json.array(classifier, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case site {
    [] -> fields
    _ -> [#("site", json.array(site, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description_summary {
    Some(v) -> [#("descriptionSummary", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case region {
    [] -> fields
    _ -> [#("region", json.array(region, codeableconcept_to_json)), ..fields]
  }
  let fields = case keyword {
    [] -> fields
    _ -> [#("keyword", json.array(keyword, codeableconcept_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, codeablereference_to_json)), ..fields]
  }
  let fields = case study_design {
    [] -> fields
    _ -> [
      #("studyDesign", json.array(study_design, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case phase {
    Some(v) -> [#("phase", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case primary_purpose_type {
    Some(v) -> [#("primaryPurposeType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case protocol {
    [] -> fields
    _ -> [#("protocol", json.array(protocol, reference_to_json)), ..fields]
  }
  let fields = case label {
    [] -> fields
    _ -> [#("label", json.array(label, researchstudy_label_to_json)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Researchstudy")), ..fields]
  json.object(fields)
}

pub fn researchstudy_decoder() -> Decoder(Researchstudy) {
  use result <- decode.optional_field(
    "result",
    [],
    decode.list(reference_decoder()),
  )
  use outcome_measure <- decode.optional_field(
    "outcomeMeasure",
    [],
    decode.list(researchstudy_outcomemeasure_decoder()),
  )
  use objective <- decode.optional_field(
    "objective",
    [],
    decode.list(researchstudy_objective_decoder()),
  )
  use comparison_group <- decode.optional_field(
    "comparisonGroup",
    [],
    decode.list(researchstudy_comparisongroup_decoder()),
  )
  use recruitment <- decode.optional_field(
    "recruitment",
    None,
    decode.optional(researchstudy_recruitment_decoder()),
  )
  use why_stopped <- decode.optional_field(
    "whyStopped",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use progress_status <- decode.optional_field(
    "progressStatus",
    [],
    decode.list(researchstudy_progressstatus_decoder()),
  )
  use associated_party <- decode.optional_field(
    "associatedParty",
    [],
    decode.list(researchstudy_associatedparty_decoder()),
  )
  use classifier <- decode.optional_field(
    "classifier",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use site <- decode.optional_field(
    "site",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use description_summary <- decode.optional_field(
    "descriptionSummary",
    None,
    decode.optional(decode.string),
  )
  use region <- decode.optional_field(
    "region",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use keyword <- decode.optional_field(
    "keyword",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(codeablereference_decoder()),
  )
  use study_design <- decode.optional_field(
    "studyDesign",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use phase <- decode.optional_field(
    "phase",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use primary_purpose_type <- decode.optional_field(
    "primaryPurposeType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use protocol <- decode.optional_field(
    "protocol",
    [],
    decode.list(reference_decoder()),
  )
  use label <- decode.optional_field(
    "label",
    [],
    decode.list(researchstudy_label_decoder()),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchstudy",
    decode.failure(researchstudy_new(status:), "resourceType"),
  )
  decode.success(Researchstudy(
    result:,
    outcome_measure:,
    objective:,
    comparison_group:,
    recruitment:,
    why_stopped:,
    progress_status:,
    associated_party:,
    classifier:,
    note:,
    site:,
    period:,
    description:,
    description_summary:,
    region:,
    keyword:,
    condition:,
    focus:,
    study_design:,
    phase:,
    primary_purpose_type:,
    status:,
    date:,
    related_artifact:,
    part_of:,
    protocol:,
    label:,
    title:,
    name:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchSubject#resource
pub type Researchsubject {
  Researchsubject(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Publicationstatus,
    progress: List(ResearchsubjectProgress),
    period: Option(Period),
    study: Reference,
    subject: Reference,
    assigned_comparison_group: Option(String),
    actual_comparison_group: Option(String),
    consent: List(Reference),
  )
}

pub fn researchsubject_new(
  subject subject: Reference,
  study study: Reference,
  status status: r5valuesets.Publicationstatus,
) -> Researchsubject {
  Researchsubject(
    consent: [],
    actual_comparison_group: None,
    assigned_comparison_group: None,
    subject:,
    study:,
    period: None,
    progress: [],
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ResearchSubject#resource
pub type ResearchsubjectProgress {
  ResearchsubjectProgress(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    subject_state: Option(Codeableconcept),
    milestone: Option(Codeableconcept),
    reason: Option(Codeableconcept),
    start_date: Option(String),
    end_date: Option(String),
  )
}

pub fn researchsubject_progress_new() -> ResearchsubjectProgress {
  ResearchsubjectProgress(
    end_date: None,
    start_date: None,
    reason: None,
    milestone: None,
    subject_state: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn researchsubject_progress_to_json(
  researchsubject_progress: ResearchsubjectProgress,
) -> Json {
  let ResearchsubjectProgress(
    end_date:,
    start_date:,
    reason:,
    milestone:,
    subject_state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = researchsubject_progress
  let fields = []
  let fields = case end_date {
    Some(v) -> [#("endDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case start_date {
    Some(v) -> [#("startDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case milestone {
    Some(v) -> [#("milestone", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case subject_state {
    Some(v) -> [#("subjectState", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn researchsubject_progress_decoder() -> Decoder(ResearchsubjectProgress) {
  use end_date <- decode.optional_field(
    "endDate",
    None,
    decode.optional(decode.string),
  )
  use start_date <- decode.optional_field(
    "startDate",
    None,
    decode.optional(decode.string),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use milestone <- decode.optional_field(
    "milestone",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use subject_state <- decode.optional_field(
    "subjectState",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ResearchsubjectProgress(
    end_date:,
    start_date:,
    reason:,
    milestone:,
    subject_state:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn researchsubject_to_json(researchsubject: Researchsubject) -> Json {
  let Researchsubject(
    consent:,
    actual_comparison_group:,
    assigned_comparison_group:,
    subject:,
    study:,
    period:,
    progress:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = researchsubject
  let fields = [
    #("subject", reference_to_json(subject)),
    #("study", reference_to_json(study)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case consent {
    [] -> fields
    _ -> [#("consent", json.array(consent, reference_to_json)), ..fields]
  }
  let fields = case actual_comparison_group {
    Some(v) -> [#("actualComparisonGroup", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case assigned_comparison_group {
    Some(v) -> [#("assignedComparisonGroup", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case progress {
    [] -> fields
    _ -> [
      #("progress", json.array(progress, researchsubject_progress_to_json)),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Researchsubject")), ..fields]
  json.object(fields)
}

pub fn researchsubject_decoder() -> Decoder(Researchsubject) {
  use consent <- decode.optional_field(
    "consent",
    [],
    decode.list(reference_decoder()),
  )
  use actual_comparison_group <- decode.optional_field(
    "actualComparisonGroup",
    None,
    decode.optional(decode.string),
  )
  use assigned_comparison_group <- decode.optional_field(
    "assignedComparisonGroup",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.field("subject", reference_decoder())
  use study <- decode.field("study", reference_decoder())
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use progress <- decode.optional_field(
    "progress",
    [],
    decode.list(researchsubject_progress_decoder()),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Researchsubject",
    decode.failure(
      researchsubject_new(subject:, study:, status:),
      "resourceType",
    ),
  )
  decode.success(Researchsubject(
    consent:,
    actual_comparison_group:,
    assigned_comparison_group:,
    subject:,
    study:,
    period:,
    progress:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/RiskAssessment#resource
pub type Riskassessment {
  Riskassessment(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: Option(Reference),
    parent: Option(Reference),
    status: r5valuesets.Observationstatus,
    method: Option(Codeableconcept),
    code: Option(Codeableconcept),
    subject: Reference,
    encounter: Option(Reference),
    occurrence: Option(RiskassessmentOccurrence),
    condition: Option(Reference),
    performer: Option(Reference),
    reason: List(Codeablereference),
    basis: List(Reference),
    prediction: List(RiskassessmentPrediction),
    mitigation: Option(String),
    note: List(Annotation),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentOccurrence {
  RiskassessmentOccurrenceDatetime(occurrence: String)
  RiskassessmentOccurrencePeriod(occurrence: Period)
}

pub fn riskassessment_occurrence_to_json(elt: RiskassessmentOccurrence) -> Json {
  case elt {
    RiskassessmentOccurrenceDatetime(v) -> json.string(v)
    RiskassessmentOccurrencePeriod(v) -> period_to_json(v)
  }
}

pub fn riskassessment_occurrence_decoder() -> Decoder(RiskassessmentOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(RiskassessmentOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
      |> decode.map(RiskassessmentOccurrencePeriod),
    ],
  )
}

pub fn riskassessment_new(
  subject subject: Reference,
  status status: r5valuesets.Observationstatus,
) -> Riskassessment {
  Riskassessment(
    note: [],
    mitigation: None,
    prediction: [],
    basis: [],
    reason: [],
    performer: None,
    condition: None,
    occurrence: None,
    encounter: None,
    subject:,
    code: None,
    method: None,
    status:,
    parent: None,
    based_on: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPrediction {
  RiskassessmentPrediction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    outcome: Option(Codeableconcept),
    probability: Option(RiskassessmentPredictionProbability),
    qualitative_risk: Option(Codeableconcept),
    relative_risk: Option(Float),
    when: Option(RiskassessmentPredictionWhen),
    rationale: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionProbability {
  RiskassessmentPredictionProbabilityDecimal(probability: Float)
  RiskassessmentPredictionProbabilityRange(probability: Range)
}

pub fn riskassessment_prediction_probability_to_json(
  elt: RiskassessmentPredictionProbability,
) -> Json {
  case elt {
    RiskassessmentPredictionProbabilityDecimal(v) -> json.float(v)
    RiskassessmentPredictionProbabilityRange(v) -> range_to_json(v)
  }
}

pub fn riskassessment_prediction_probability_decoder() -> Decoder(
  RiskassessmentPredictionProbability,
) {
  decode.one_of(
    decode.field("probabilityDecimal", decode.float, decode.success)
      |> decode.map(RiskassessmentPredictionProbabilityDecimal),
    [
      decode.field("probabilityRange", range_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionProbabilityRange),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/RiskAssessment#resource
pub type RiskassessmentPredictionWhen {
  RiskassessmentPredictionWhenPeriod(when: Period)
  RiskassessmentPredictionWhenRange(when: Range)
}

pub fn riskassessment_prediction_when_to_json(
  elt: RiskassessmentPredictionWhen,
) -> Json {
  case elt {
    RiskassessmentPredictionWhenPeriod(v) -> period_to_json(v)
    RiskassessmentPredictionWhenRange(v) -> range_to_json(v)
  }
}

pub fn riskassessment_prediction_when_decoder() -> Decoder(
  RiskassessmentPredictionWhen,
) {
  decode.one_of(
    decode.field("whenPeriod", period_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionWhenPeriod),
    [
      decode.field("whenRange", range_decoder(), decode.success)
      |> decode.map(RiskassessmentPredictionWhenRange),
    ],
  )
}

pub fn riskassessment_prediction_new() -> RiskassessmentPrediction {
  RiskassessmentPrediction(
    rationale: None,
    when: None,
    relative_risk: None,
    qualitative_risk: None,
    probability: None,
    outcome: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn riskassessment_prediction_to_json(
  riskassessment_prediction: RiskassessmentPrediction,
) -> Json {
  let RiskassessmentPrediction(
    rationale:,
    when:,
    relative_risk:,
    qualitative_risk:,
    probability:,
    outcome:,
    modifier_extension:,
    extension:,
    id:,
  ) = riskassessment_prediction
  let fields = []
  let fields = case rationale {
    Some(v) -> [#("rationale", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case when {
    Some(v) -> [
      #(
        "when"
          <> case v {
          RiskassessmentPredictionWhenPeriod(_) -> "Period"
          RiskassessmentPredictionWhenRange(_) -> "Range"
        },
        riskassessment_prediction_when_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case relative_risk {
    Some(v) -> [#("relativeRisk", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case qualitative_risk {
    Some(v) -> [#("qualitativeRisk", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case probability {
    Some(v) -> [
      #(
        "probability"
          <> case v {
          RiskassessmentPredictionProbabilityDecimal(_) -> "Decimal"
          RiskassessmentPredictionProbabilityRange(_) -> "Range"
        },
        riskassessment_prediction_probability_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case outcome {
    Some(v) -> [#("outcome", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn riskassessment_prediction_decoder() -> Decoder(RiskassessmentPrediction) {
  use rationale <- decode.optional_field(
    "rationale",
    None,
    decode.optional(decode.string),
  )
  use when <- decode.then(
    none_if_omitted(riskassessment_prediction_when_decoder()),
  )
  use relative_risk <- decode.optional_field(
    "relativeRisk",
    None,
    decode.optional(decode.float),
  )
  use qualitative_risk <- decode.optional_field(
    "qualitativeRisk",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use probability <- decode.then(
    none_if_omitted(riskassessment_prediction_probability_decoder()),
  )
  use outcome <- decode.optional_field(
    "outcome",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(RiskassessmentPrediction(
    rationale:,
    when:,
    relative_risk:,
    qualitative_risk:,
    probability:,
    outcome:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn riskassessment_to_json(riskassessment: Riskassessment) -> Json {
  let Riskassessment(
    note:,
    mitigation:,
    prediction:,
    basis:,
    reason:,
    performer:,
    condition:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    method:,
    status:,
    parent:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = riskassessment
  let fields = [
    #("subject", reference_to_json(subject)),
    #("status", r5valuesets.observationstatus_to_json(status)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case mitigation {
    Some(v) -> [#("mitigation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case prediction {
    [] -> fields
    _ -> [
      #("prediction", json.array(prediction, riskassessment_prediction_to_json)),
      ..fields
    ]
  }
  let fields = case basis {
    [] -> fields
    _ -> [#("basis", json.array(basis, reference_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case performer {
    Some(v) -> [#("performer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          RiskassessmentOccurrenceDatetime(_) -> "Datetime"
          RiskassessmentOccurrencePeriod(_) -> "Period"
        },
        riskassessment_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case parent {
    Some(v) -> [#("parent", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    Some(v) -> [#("basedOn", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Riskassessment")), ..fields]
  json.object(fields)
}

pub fn riskassessment_decoder() -> Decoder(Riskassessment) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use mitigation <- decode.optional_field(
    "mitigation",
    None,
    decode.optional(decode.string),
  )
  use prediction <- decode.optional_field(
    "prediction",
    [],
    decode.list(riskassessment_prediction_decoder()),
  )
  use basis <- decode.optional_field(
    "basis",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    None,
    decode.optional(reference_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(riskassessment_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.field("status", r5valuesets.observationstatus_decoder())
  use parent <- decode.optional_field(
    "parent",
    None,
    decode.optional(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    None,
    decode.optional(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Riskassessment",
    decode.failure(riskassessment_new(subject:, status:), "resourceType"),
  )
  decode.success(Riskassessment(
    note:,
    mitigation:,
    prediction:,
    basis:,
    reason:,
    performer:,
    condition:,
    occurrence:,
    encounter:,
    subject:,
    code:,
    method:,
    status:,
    parent:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Schedule#resource
pub type Schedule {
  Schedule(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    active: Option(Bool),
    service_category: List(Codeableconcept),
    service_type: List(Codeablereference),
    specialty: List(Codeableconcept),
    name: Option(String),
    actor: List(Reference),
    planning_horizon: Option(Period),
    comment: Option(String),
  )
}

pub fn schedule_new() -> Schedule {
  Schedule(
    comment: None,
    planning_horizon: None,
    actor: [],
    name: None,
    specialty: [],
    service_type: [],
    service_category: [],
    active: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn schedule_to_json(schedule: Schedule) -> Json {
  let Schedule(
    comment:,
    planning_horizon:,
    actor:,
    name:,
    specialty:,
    service_type:,
    service_category:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = schedule
  let fields = []
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case planning_horizon {
    Some(v) -> [#("planningHorizon", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case actor {
    [] -> fields
    _ -> [#("actor", json.array(actor, reference_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case active {
    Some(v) -> [#("active", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Schedule")), ..fields]
  json.object(fields)
}

pub fn schedule_decoder() -> Decoder(Schedule) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use planning_horizon <- decode.optional_field(
    "planningHorizon",
    None,
    decode.optional(period_decoder()),
  )
  use actor <- decode.optional_field(
    "actor",
    [],
    decode.list(reference_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeablereference_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use active <- decode.optional_field(
    "active",
    None,
    decode.optional(decode.bool),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Schedule",
    decode.failure(schedule_new(), "resourceType"),
  )
  decode.success(Schedule(
    comment:,
    planning_horizon:,
    actor:,
    name:,
    specialty:,
    service_type:,
    service_category:,
    active:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SearchParameter#resource
pub type Searchparameter {
  Searchparameter(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(SearchparameterVersionalgorithm),
    name: String,
    title: Option(String),
    derived_from: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: String,
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    code: String,
    base: List(r5valuesets.Versionindependentallresourcetypes),
    type_: r5valuesets.Searchparamtype,
    expression: Option(String),
    processing_mode: Option(r5valuesets.Searchprocessingmode),
    constraint: Option(String),
    target: List(r5valuesets.Versionindependentallresourcetypes),
    multiple_or: Option(Bool),
    multiple_and: Option(Bool),
    comparator: List(r5valuesets.Searchcomparator),
    modifier: List(r5valuesets.Searchmodifiercode),
    chain: List(String),
    component: List(SearchparameterComponent),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SearchParameter#resource
pub type SearchparameterVersionalgorithm {
  SearchparameterVersionalgorithmString(version_algorithm: String)
  SearchparameterVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn searchparameter_versionalgorithm_to_json(
  elt: SearchparameterVersionalgorithm,
) -> Json {
  case elt {
    SearchparameterVersionalgorithmString(v) -> json.string(v)
    SearchparameterVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn searchparameter_versionalgorithm_decoder() -> Decoder(
  SearchparameterVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(SearchparameterVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(SearchparameterVersionalgorithmCoding),
    ],
  )
}

pub fn searchparameter_new(
  type_ type_: r5valuesets.Searchparamtype,
  code code: String,
  description description: String,
  status status: r5valuesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Searchparameter {
  Searchparameter(
    component: [],
    chain: [],
    modifier: [],
    comparator: [],
    multiple_and: None,
    multiple_or: None,
    target: [],
    constraint: None,
    processing_mode: None,
    expression: None,
    type_:,
    base: [],
    code:,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description:,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    derived_from: None,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SearchParameter#resource
pub type SearchparameterComponent {
  SearchparameterComponent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    definition: String,
    expression: String,
  )
}

pub fn searchparameter_component_new(
  expression expression: String,
  definition definition: String,
) -> SearchparameterComponent {
  SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn searchparameter_component_to_json(
  searchparameter_component: SearchparameterComponent,
) -> Json {
  let SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = searchparameter_component
  let fields = [
    #("expression", json.string(expression)),
    #("definition", json.string(definition)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn searchparameter_component_decoder() -> Decoder(SearchparameterComponent) {
  use expression <- decode.field("expression", decode.string)
  use definition <- decode.field("definition", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SearchparameterComponent(
    expression:,
    definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn searchparameter_to_json(searchparameter: Searchparameter) -> Json {
  let Searchparameter(
    component:,
    chain:,
    modifier:,
    comparator:,
    multiple_and:,
    multiple_or:,
    target:,
    constraint:,
    processing_mode:,
    expression:,
    type_:,
    base:,
    code:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = searchparameter
  let fields = [
    #("type", r5valuesets.searchparamtype_to_json(type_)),
    #("code", json.string(code)),
    #("description", json.string(description)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case component {
    [] -> fields
    _ -> [
      #("component", json.array(component, searchparameter_component_to_json)),
      ..fields
    ]
  }
  let fields = case chain {
    [] -> fields
    _ -> [#("chain", json.array(chain, json.string)), ..fields]
  }
  let fields = case modifier {
    [] -> fields
    _ -> [
      #(
        "modifier",
        json.array(modifier, r5valuesets.searchmodifiercode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case comparator {
    [] -> fields
    _ -> [
      #(
        "comparator",
        json.array(comparator, r5valuesets.searchcomparator_to_json),
      ),
      ..fields
    ]
  }
  let fields = case multiple_and {
    Some(v) -> [#("multipleAnd", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case multiple_or {
    Some(v) -> [#("multipleOr", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    [] -> fields
    _ -> [
      #(
        "target",
        json.array(
          target,
          r5valuesets.versionindependentallresourcetypes_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case constraint {
    Some(v) -> [#("constraint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case processing_mode {
    Some(v) -> [
      #("processingMode", r5valuesets.searchprocessingmode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case base {
    [] -> fields
    _ -> [
      #(
        "base",
        json.array(base, r5valuesets.versionindependentallresourcetypes_to_json),
      ),
      ..fields
    ]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    Some(v) -> [#("derivedFrom", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          SearchparameterVersionalgorithmString(_) -> "String"
          SearchparameterVersionalgorithmCoding(_) -> "Coding"
        },
        searchparameter_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Searchparameter")), ..fields]
  json.object(fields)
}

pub fn searchparameter_decoder() -> Decoder(Searchparameter) {
  use component <- decode.optional_field(
    "component",
    [],
    decode.list(searchparameter_component_decoder()),
  )
  use chain <- decode.optional_field("chain", [], decode.list(decode.string))
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(r5valuesets.searchmodifiercode_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    [],
    decode.list(r5valuesets.searchcomparator_decoder()),
  )
  use multiple_and <- decode.optional_field(
    "multipleAnd",
    None,
    decode.optional(decode.bool),
  )
  use multiple_or <- decode.optional_field(
    "multipleOr",
    None,
    decode.optional(decode.bool),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(r5valuesets.versionindependentallresourcetypes_decoder()),
  )
  use constraint <- decode.optional_field(
    "constraint",
    None,
    decode.optional(decode.string),
  )
  use processing_mode <- decode.optional_field(
    "processingMode",
    None,
    decode.optional(r5valuesets.searchprocessingmode_decoder()),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", r5valuesets.searchparamtype_decoder())
  use base <- decode.optional_field(
    "base",
    [],
    decode.list(r5valuesets.versionindependentallresourcetypes_decoder()),
  )
  use code <- decode.field("code", decode.string)
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.field("description", decode.string)
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    None,
    decode.optional(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(searchparameter_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Searchparameter",
    decode.failure(
      searchparameter_new(type_:, code:, description:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Searchparameter(
    component:,
    chain:,
    modifier:,
    comparator:,
    multiple_and:,
    multiple_or:,
    target:,
    constraint:,
    processing_mode:,
    expression:,
    type_:,
    base:,
    code:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type Servicerequest {
  Servicerequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: List(String),
    instantiates_uri: List(String),
    based_on: List(Reference),
    replaces: List(Reference),
    requisition: Option(Identifier),
    status: r5valuesets.Requeststatus,
    intent: r5valuesets.Requestintent,
    category: List(Codeableconcept),
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    code: Option(Codeablereference),
    order_detail: List(ServicerequestOrderdetail),
    quantity: Option(ServicerequestQuantity),
    subject: Reference,
    focus: List(Reference),
    encounter: Option(Reference),
    occurrence: Option(ServicerequestOccurrence),
    as_needed: Option(ServicerequestAsneeded),
    authored_on: Option(String),
    requester: Option(Reference),
    performer_type: Option(Codeableconcept),
    performer: List(Reference),
    location: List(Codeablereference),
    reason: List(Codeablereference),
    insurance: List(Reference),
    supporting_info: List(Codeablereference),
    specimen: List(Reference),
    body_site: List(Codeableconcept),
    body_structure: Option(Reference),
    note: List(Annotation),
    patient_instruction: List(ServicerequestPatientinstruction),
    relevant_history: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestQuantity {
  ServicerequestQuantityQuantity(quantity: Quantity)
  ServicerequestQuantityRatio(quantity: Ratio)
  ServicerequestQuantityRange(quantity: Range)
}

pub fn servicerequest_quantity_to_json(elt: ServicerequestQuantity) -> Json {
  case elt {
    ServicerequestQuantityQuantity(v) -> quantity_to_json(v)
    ServicerequestQuantityRatio(v) -> ratio_to_json(v)
    ServicerequestQuantityRange(v) -> range_to_json(v)
  }
}

pub fn servicerequest_quantity_decoder() -> Decoder(ServicerequestQuantity) {
  decode.one_of(
    decode.field("quantityQuantity", quantity_decoder(), decode.success)
      |> decode.map(ServicerequestQuantityQuantity),
    [
      decode.field("quantityRatio", ratio_decoder(), decode.success)
        |> decode.map(ServicerequestQuantityRatio),
      decode.field("quantityRange", range_decoder(), decode.success)
        |> decode.map(ServicerequestQuantityRange),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOccurrence {
  ServicerequestOccurrenceDatetime(occurrence: String)
  ServicerequestOccurrencePeriod(occurrence: Period)
  ServicerequestOccurrenceTiming(occurrence: Timing)
}

pub fn servicerequest_occurrence_to_json(elt: ServicerequestOccurrence) -> Json {
  case elt {
    ServicerequestOccurrenceDatetime(v) -> json.string(v)
    ServicerequestOccurrencePeriod(v) -> period_to_json(v)
    ServicerequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn servicerequest_occurrence_decoder() -> Decoder(ServicerequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(ServicerequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(ServicerequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(ServicerequestOccurrenceTiming),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestAsneeded {
  ServicerequestAsneededBoolean(as_needed: Bool)
  ServicerequestAsneededCodeableconcept(as_needed: Codeableconcept)
}

pub fn servicerequest_asneeded_to_json(elt: ServicerequestAsneeded) -> Json {
  case elt {
    ServicerequestAsneededBoolean(v) -> json.bool(v)
    ServicerequestAsneededCodeableconcept(v) -> codeableconcept_to_json(v)
  }
}

pub fn servicerequest_asneeded_decoder() -> Decoder(ServicerequestAsneeded) {
  decode.one_of(
    decode.field("asNeededBoolean", decode.bool, decode.success)
      |> decode.map(ServicerequestAsneededBoolean),
    [
      decode.field(
        "asNeededCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(ServicerequestAsneededCodeableconcept),
    ],
  )
}

pub fn servicerequest_new(
  subject subject: Reference,
  intent intent: r5valuesets.Requestintent,
  status status: r5valuesets.Requeststatus,
) -> Servicerequest {
  Servicerequest(
    relevant_history: [],
    patient_instruction: [],
    note: [],
    body_structure: None,
    body_site: [],
    specimen: [],
    supporting_info: [],
    insurance: [],
    reason: [],
    location: [],
    performer: [],
    performer_type: None,
    requester: None,
    authored_on: None,
    as_needed: None,
    occurrence: None,
    encounter: None,
    focus: [],
    subject:,
    quantity: None,
    order_detail: [],
    code: None,
    do_not_perform: None,
    priority: None,
    category: [],
    intent:,
    status:,
    requisition: None,
    replaces: [],
    based_on: [],
    instantiates_uri: [],
    instantiates_canonical: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOrderdetail {
  ServicerequestOrderdetail(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    parameter_focus: Option(Codeablereference),
    parameter: List(ServicerequestOrderdetailParameter),
  )
}

pub fn servicerequest_orderdetail_new() -> ServicerequestOrderdetail {
  ServicerequestOrderdetail(
    parameter: [],
    parameter_focus: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOrderdetailParameter {
  ServicerequestOrderdetailParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Codeableconcept,
    value: ServicerequestOrderdetailParameterValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestOrderdetailParameterValue {
  ServicerequestOrderdetailParameterValueQuantity(value: Quantity)
  ServicerequestOrderdetailParameterValueRatio(value: Ratio)
  ServicerequestOrderdetailParameterValueRange(value: Range)
  ServicerequestOrderdetailParameterValueBoolean(value: Bool)
  ServicerequestOrderdetailParameterValueCodeableconcept(value: Codeableconcept)
  ServicerequestOrderdetailParameterValueString(value: String)
  ServicerequestOrderdetailParameterValuePeriod(value: Period)
}

pub fn servicerequest_orderdetail_parameter_value_to_json(
  elt: ServicerequestOrderdetailParameterValue,
) -> Json {
  case elt {
    ServicerequestOrderdetailParameterValueQuantity(v) -> quantity_to_json(v)
    ServicerequestOrderdetailParameterValueRatio(v) -> ratio_to_json(v)
    ServicerequestOrderdetailParameterValueRange(v) -> range_to_json(v)
    ServicerequestOrderdetailParameterValueBoolean(v) -> json.bool(v)
    ServicerequestOrderdetailParameterValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    ServicerequestOrderdetailParameterValueString(v) -> json.string(v)
    ServicerequestOrderdetailParameterValuePeriod(v) -> period_to_json(v)
  }
}

pub fn servicerequest_orderdetail_parameter_value_decoder() -> Decoder(
  ServicerequestOrderdetailParameterValue,
) {
  decode.one_of(
    decode.field("valueQuantity", quantity_decoder(), decode.success)
      |> decode.map(ServicerequestOrderdetailParameterValueQuantity),
    [
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(ServicerequestOrderdetailParameterValueRatio),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(ServicerequestOrderdetailParameterValueRange),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ServicerequestOrderdetailParameterValueBoolean),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(ServicerequestOrderdetailParameterValueCodeableconcept),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ServicerequestOrderdetailParameterValueString),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(ServicerequestOrderdetailParameterValuePeriod),
    ],
  )
}

pub fn servicerequest_orderdetail_parameter_new(
  value value: ServicerequestOrderdetailParameterValue,
  code code: Codeableconcept,
) -> ServicerequestOrderdetailParameter {
  ServicerequestOrderdetailParameter(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestPatientinstruction {
  ServicerequestPatientinstruction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    instruction: Option(ServicerequestPatientinstructionInstruction),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ServiceRequest#resource
pub type ServicerequestPatientinstructionInstruction {
  ServicerequestPatientinstructionInstructionMarkdown(instruction: String)
  ServicerequestPatientinstructionInstructionReference(instruction: Reference)
}

pub fn servicerequest_patientinstruction_instruction_to_json(
  elt: ServicerequestPatientinstructionInstruction,
) -> Json {
  case elt {
    ServicerequestPatientinstructionInstructionMarkdown(v) -> json.string(v)
    ServicerequestPatientinstructionInstructionReference(v) ->
      reference_to_json(v)
  }
}

pub fn servicerequest_patientinstruction_instruction_decoder() -> Decoder(
  ServicerequestPatientinstructionInstruction,
) {
  decode.one_of(
    decode.field("instructionMarkdown", decode.string, decode.success)
      |> decode.map(ServicerequestPatientinstructionInstructionMarkdown),
    [
      decode.field("instructionReference", reference_decoder(), decode.success)
      |> decode.map(ServicerequestPatientinstructionInstructionReference),
    ],
  )
}

pub fn servicerequest_patientinstruction_new() -> ServicerequestPatientinstruction {
  ServicerequestPatientinstruction(
    instruction: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn servicerequest_patientinstruction_to_json(
  servicerequest_patientinstruction: ServicerequestPatientinstruction,
) -> Json {
  let ServicerequestPatientinstruction(
    instruction:,
    modifier_extension:,
    extension:,
    id:,
  ) = servicerequest_patientinstruction
  let fields = []
  let fields = case instruction {
    Some(v) -> [
      #(
        "instruction"
          <> case v {
          ServicerequestPatientinstructionInstructionMarkdown(_) -> "Markdown"
          ServicerequestPatientinstructionInstructionReference(_) -> "Reference"
        },
        servicerequest_patientinstruction_instruction_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn servicerequest_patientinstruction_decoder() -> Decoder(
  ServicerequestPatientinstruction,
) {
  use instruction <- decode.then(
    none_if_omitted(servicerequest_patientinstruction_instruction_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ServicerequestPatientinstruction(
    instruction:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn servicerequest_orderdetail_parameter_to_json(
  servicerequest_orderdetail_parameter: ServicerequestOrderdetailParameter,
) -> Json {
  let ServicerequestOrderdetailParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = servicerequest_orderdetail_parameter
  let fields = [
    #("value", servicerequest_orderdetail_parameter_value_to_json(value)),
    #("code", codeableconcept_to_json(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn servicerequest_orderdetail_parameter_decoder() -> Decoder(
  ServicerequestOrderdetailParameter,
) {
  use value <- decode.then(servicerequest_orderdetail_parameter_value_decoder())
  use code <- decode.field("code", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ServicerequestOrderdetailParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn servicerequest_orderdetail_to_json(
  servicerequest_orderdetail: ServicerequestOrderdetail,
) -> Json {
  let ServicerequestOrderdetail(
    parameter:,
    parameter_focus:,
    modifier_extension:,
    extension:,
    id:,
  ) = servicerequest_orderdetail
  let fields = []
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, servicerequest_orderdetail_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parameter_focus {
    Some(v) -> [#("parameterFocus", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn servicerequest_orderdetail_decoder() -> Decoder(
  ServicerequestOrderdetail,
) {
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(servicerequest_orderdetail_parameter_decoder()),
  )
  use parameter_focus <- decode.optional_field(
    "parameterFocus",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ServicerequestOrderdetail(
    parameter:,
    parameter_focus:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn servicerequest_to_json(servicerequest: Servicerequest) -> Json {
  let Servicerequest(
    relevant_history:,
    patient_instruction:,
    note:,
    body_structure:,
    body_site:,
    specimen:,
    supporting_info:,
    insurance:,
    reason:,
    location:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    as_needed:,
    occurrence:,
    encounter:,
    focus:,
    subject:,
    quantity:,
    order_detail:,
    code:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status:,
    requisition:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = servicerequest
  let fields = [
    #("subject", reference_to_json(subject)),
    #("intent", r5valuesets.requestintent_to_json(intent)),
    #("status", r5valuesets.requeststatus_to_json(status)),
  ]
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case patient_instruction {
    [] -> fields
    _ -> [
      #(
        "patientInstruction",
        json.array(
          patient_instruction,
          servicerequest_patientinstruction_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case body_structure {
    Some(v) -> [#("bodyStructure", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case body_site {
    [] -> fields
    _ -> [
      #("bodySite", json.array(body_site, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case specimen {
    [] -> fields
    _ -> [#("specimen", json.array(specimen, reference_to_json)), ..fields]
  }
  let fields = case supporting_info {
    [] -> fields
    _ -> [
      #(
        "supportingInfo",
        json.array(supporting_info, codeablereference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case location {
    [] -> fields
    _ -> [
      #("location", json.array(location, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case performer {
    [] -> fields
    _ -> [#("performer", json.array(performer, reference_to_json)), ..fields]
  }
  let fields = case performer_type {
    Some(v) -> [#("performerType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case as_needed {
    Some(v) -> [
      #(
        "asNeeded"
          <> case v {
          ServicerequestAsneededBoolean(_) -> "Boolean"
          ServicerequestAsneededCodeableconcept(_) -> "Codeableconcept"
        },
        servicerequest_asneeded_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          ServicerequestOccurrenceDatetime(_) -> "Datetime"
          ServicerequestOccurrencePeriod(_) -> "Period"
          ServicerequestOccurrenceTiming(_) -> "Timing"
        },
        servicerequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    [] -> fields
    _ -> [#("focus", json.array(focus, reference_to_json)), ..fields]
  }
  let fields = case quantity {
    Some(v) -> [
      #(
        "quantity"
          <> case v {
          ServicerequestQuantityQuantity(_) -> "Quantity"
          ServicerequestQuantityRatio(_) -> "Ratio"
          ServicerequestQuantityRange(_) -> "Range"
        },
        servicerequest_quantity_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case order_detail {
    [] -> fields
    _ -> [
      #(
        "orderDetail",
        json.array(order_detail, servicerequest_orderdetail_to_json),
      ),
      ..fields
    ]
  }
  let fields = case code {
    Some(v) -> [#("code", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requisition {
    Some(v) -> [#("requisition", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case replaces {
    [] -> fields
    _ -> [#("replaces", json.array(replaces, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    [] -> fields
    _ -> [
      #("instantiatesUri", json.array(instantiates_uri, json.string)),
      ..fields
    ]
  }
  let fields = case instantiates_canonical {
    [] -> fields
    _ -> [
      #(
        "instantiatesCanonical",
        json.array(instantiates_canonical, json.string),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Servicerequest")), ..fields]
  json.object(fields)
}

pub fn servicerequest_decoder() -> Decoder(Servicerequest) {
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use patient_instruction <- decode.optional_field(
    "patientInstruction",
    [],
    decode.list(servicerequest_patientinstruction_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use body_structure <- decode.optional_field(
    "bodyStructure",
    None,
    decode.optional(reference_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use specimen <- decode.optional_field(
    "specimen",
    [],
    decode.list(reference_decoder()),
  )
  use supporting_info <- decode.optional_field(
    "supportingInfo",
    [],
    decode.list(codeablereference_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    [],
    decode.list(codeablereference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use as_needed <- decode.then(
    none_if_omitted(servicerequest_asneeded_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(servicerequest_occurrence_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    [],
    decode.list(reference_decoder()),
  )
  use subject <- decode.field("subject", reference_decoder())
  use quantity <- decode.then(
    none_if_omitted(servicerequest_quantity_decoder()),
  )
  use order_detail <- decode.optional_field(
    "orderDetail",
    [],
    decode.list(servicerequest_orderdetail_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.requestintent_decoder())
  use status <- decode.field("status", r5valuesets.requeststatus_decoder())
  use requisition <- decode.optional_field(
    "requisition",
    None,
    decode.optional(identifier_decoder()),
  )
  use replaces <- decode.optional_field(
    "replaces",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    [],
    decode.list(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    [],
    decode.list(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Servicerequest",
    decode.failure(
      servicerequest_new(subject:, intent:, status:),
      "resourceType",
    ),
  )
  decode.success(Servicerequest(
    relevant_history:,
    patient_instruction:,
    note:,
    body_structure:,
    body_site:,
    specimen:,
    supporting_info:,
    insurance:,
    reason:,
    location:,
    performer:,
    performer_type:,
    requester:,
    authored_on:,
    as_needed:,
    occurrence:,
    encounter:,
    focus:,
    subject:,
    quantity:,
    order_detail:,
    code:,
    do_not_perform:,
    priority:,
    category:,
    intent:,
    status:,
    requisition:,
    replaces:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Slot#resource
pub type Slot {
  Slot(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    service_category: List(Codeableconcept),
    service_type: List(Codeablereference),
    specialty: List(Codeableconcept),
    appointment_type: List(Codeableconcept),
    schedule: Reference,
    status: r5valuesets.Slotstatus,
    start: String,
    end: String,
    overbooked: Option(Bool),
    comment: Option(String),
  )
}

pub fn slot_new(
  end end: String,
  start start: String,
  status status: r5valuesets.Slotstatus,
  schedule schedule: Reference,
) -> Slot {
  Slot(
    comment: None,
    overbooked: None,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type: [],
    specialty: [],
    service_type: [],
    service_category: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

pub fn slot_to_json(slot: Slot) -> Json {
  let Slot(
    comment:,
    overbooked:,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = slot
  let fields = [
    #("end", json.string(end)),
    #("start", json.string(start)),
    #("status", r5valuesets.slotstatus_to_json(status)),
    #("schedule", reference_to_json(schedule)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case overbooked {
    Some(v) -> [#("overbooked", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case appointment_type {
    [] -> fields
    _ -> [
      #(
        "appointmentType",
        json.array(appointment_type, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case specialty {
    [] -> fields
    _ -> [
      #("specialty", json.array(specialty, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case service_type {
    [] -> fields
    _ -> [
      #("serviceType", json.array(service_type, codeablereference_to_json)),
      ..fields
    ]
  }
  let fields = case service_category {
    [] -> fields
    _ -> [
      #(
        "serviceCategory",
        json.array(service_category, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Slot")), ..fields]
  json.object(fields)
}

pub fn slot_decoder() -> Decoder(Slot) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use overbooked <- decode.optional_field(
    "overbooked",
    None,
    decode.optional(decode.bool),
  )
  use end <- decode.field("end", decode.string)
  use start <- decode.field("start", decode.string)
  use status <- decode.field("status", r5valuesets.slotstatus_decoder())
  use schedule <- decode.field("schedule", reference_decoder())
  use appointment_type <- decode.optional_field(
    "appointmentType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use specialty <- decode.optional_field(
    "specialty",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use service_type <- decode.optional_field(
    "serviceType",
    [],
    decode.list(codeablereference_decoder()),
  )
  use service_category <- decode.optional_field(
    "serviceCategory",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Slot",
    decode.failure(slot_new(end:, start:, status:, schedule:), "resourceType"),
  )
  decode.success(Slot(
    comment:,
    overbooked:,
    end:,
    start:,
    status:,
    schedule:,
    appointment_type:,
    specialty:,
    service_type:,
    service_category:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type Specimen {
  Specimen(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    accession_identifier: Option(Identifier),
    status: Option(r5valuesets.Specimenstatus),
    type_: Option(Codeableconcept),
    subject: Option(Reference),
    received_time: Option(String),
    parent: List(Reference),
    request: List(Reference),
    combined: Option(r5valuesets.Specimencombined),
    role: List(Codeableconcept),
    feature: List(SpecimenFeature),
    collection: Option(SpecimenCollection),
    processing: List(SpecimenProcessing),
    container: List(SpecimenContainer),
    condition: List(Codeableconcept),
    note: List(Annotation),
  )
}

pub fn specimen_new() -> Specimen {
  Specimen(
    note: [],
    condition: [],
    container: [],
    processing: [],
    collection: None,
    feature: [],
    role: [],
    combined: None,
    request: [],
    parent: [],
    received_time: None,
    subject: None,
    type_: None,
    status: None,
    accession_identifier: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenFeature {
  SpecimenFeature(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    description: String,
  )
}

pub fn specimen_feature_new(
  description description: String,
  type_ type_: Codeableconcept,
) -> SpecimenFeature {
  SpecimenFeature(
    description:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenCollection {
  SpecimenCollection(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    collector: Option(Reference),
    collected: Option(SpecimenCollectionCollected),
    duration: Option(Duration),
    quantity: Option(Quantity),
    method: Option(Codeableconcept),
    device: Option(Codeablereference),
    procedure: Option(Reference),
    body_site: Option(Codeablereference),
    fasting_status: Option(SpecimenCollectionFastingstatus),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenCollectionCollected {
  SpecimenCollectionCollectedDatetime(collected: String)
  SpecimenCollectionCollectedPeriod(collected: Period)
}

pub fn specimen_collection_collected_to_json(
  elt: SpecimenCollectionCollected,
) -> Json {
  case elt {
    SpecimenCollectionCollectedDatetime(v) -> json.string(v)
    SpecimenCollectionCollectedPeriod(v) -> period_to_json(v)
  }
}

pub fn specimen_collection_collected_decoder() -> Decoder(
  SpecimenCollectionCollected,
) {
  decode.one_of(
    decode.field("collectedDateTime", decode.string, decode.success)
      |> decode.map(SpecimenCollectionCollectedDatetime),
    [
      decode.field("collectedPeriod", period_decoder(), decode.success)
      |> decode.map(SpecimenCollectionCollectedPeriod),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenCollectionFastingstatus {
  SpecimenCollectionFastingstatusCodeableconcept(
    fasting_status: Codeableconcept,
  )
  SpecimenCollectionFastingstatusDuration(fasting_status: Duration)
}

pub fn specimen_collection_fastingstatus_to_json(
  elt: SpecimenCollectionFastingstatus,
) -> Json {
  case elt {
    SpecimenCollectionFastingstatusCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SpecimenCollectionFastingstatusDuration(v) -> duration_to_json(v)
  }
}

pub fn specimen_collection_fastingstatus_decoder() -> Decoder(
  SpecimenCollectionFastingstatus,
) {
  decode.one_of(
    decode.field(
      "fastingStatusCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SpecimenCollectionFastingstatusCodeableconcept),
    [
      decode.field("fastingStatusDuration", duration_decoder(), decode.success)
      |> decode.map(SpecimenCollectionFastingstatusDuration),
    ],
  )
}

pub fn specimen_collection_new() -> SpecimenCollection {
  SpecimenCollection(
    fasting_status: None,
    body_site: None,
    procedure: None,
    device: None,
    method: None,
    quantity: None,
    duration: None,
    collected: None,
    collector: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenProcessing {
  SpecimenProcessing(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    method: Option(Codeableconcept),
    additive: List(Reference),
    time: Option(SpecimenProcessingTime),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenProcessingTime {
  SpecimenProcessingTimeDatetime(time: String)
  SpecimenProcessingTimePeriod(time: Period)
}

pub fn specimen_processing_time_to_json(elt: SpecimenProcessingTime) -> Json {
  case elt {
    SpecimenProcessingTimeDatetime(v) -> json.string(v)
    SpecimenProcessingTimePeriod(v) -> period_to_json(v)
  }
}

pub fn specimen_processing_time_decoder() -> Decoder(SpecimenProcessingTime) {
  decode.one_of(
    decode.field("timeDateTime", decode.string, decode.success)
      |> decode.map(SpecimenProcessingTimeDatetime),
    [
      decode.field("timePeriod", period_decoder(), decode.success)
      |> decode.map(SpecimenProcessingTimePeriod),
    ],
  )
}

pub fn specimen_processing_new() -> SpecimenProcessing {
  SpecimenProcessing(
    time: None,
    additive: [],
    method: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Specimen#resource
pub type SpecimenContainer {
  SpecimenContainer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    device: Reference,
    location: Option(Reference),
    specimen_quantity: Option(Quantity),
  )
}

pub fn specimen_container_new(device device: Reference) -> SpecimenContainer {
  SpecimenContainer(
    specimen_quantity: None,
    location: None,
    device:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn specimen_container_to_json(specimen_container: SpecimenContainer) -> Json {
  let SpecimenContainer(
    specimen_quantity:,
    location:,
    device:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_container
  let fields = [
    #("device", reference_to_json(device)),
  ]
  let fields = case specimen_quantity {
    Some(v) -> [#("specimenQuantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_container_decoder() -> Decoder(SpecimenContainer) {
  use specimen_quantity <- decode.optional_field(
    "specimenQuantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use device <- decode.field("device", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenContainer(
    specimen_quantity:,
    location:,
    device:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_processing_to_json(
  specimen_processing: SpecimenProcessing,
) -> Json {
  let SpecimenProcessing(
    time:,
    additive:,
    method:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_processing
  let fields = []
  let fields = case time {
    Some(v) -> [
      #(
        "time"
          <> case v {
          SpecimenProcessingTimeDatetime(_) -> "Datetime"
          SpecimenProcessingTimePeriod(_) -> "Period"
        },
        specimen_processing_time_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case additive {
    [] -> fields
    _ -> [#("additive", json.array(additive, reference_to_json)), ..fields]
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_processing_decoder() -> Decoder(SpecimenProcessing) {
  use time <- decode.then(none_if_omitted(specimen_processing_time_decoder()))
  use additive <- decode.optional_field(
    "additive",
    [],
    decode.list(reference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenProcessing(
    time:,
    additive:,
    method:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_collection_to_json(
  specimen_collection: SpecimenCollection,
) -> Json {
  let SpecimenCollection(
    fasting_status:,
    body_site:,
    procedure:,
    device:,
    method:,
    quantity:,
    duration:,
    collected:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_collection
  let fields = []
  let fields = case fasting_status {
    Some(v) -> [
      #(
        "fastingStatus"
          <> case v {
          SpecimenCollectionFastingstatusCodeableconcept(_) -> "Codeableconcept"
          SpecimenCollectionFastingstatusDuration(_) -> "Duration"
        },
        specimen_collection_fastingstatus_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case body_site {
    Some(v) -> [#("bodySite", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case procedure {
    Some(v) -> [#("procedure", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case device {
    Some(v) -> [#("device", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case collected {
    Some(v) -> [
      #(
        "collected"
          <> case v {
          SpecimenCollectionCollectedDatetime(_) -> "Datetime"
          SpecimenCollectionCollectedPeriod(_) -> "Period"
        },
        specimen_collection_collected_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case collector {
    Some(v) -> [#("collector", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_collection_decoder() -> Decoder(SpecimenCollection) {
  use fasting_status <- decode.then(
    none_if_omitted(specimen_collection_fastingstatus_decoder()),
  )
  use body_site <- decode.optional_field(
    "bodySite",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use procedure <- decode.optional_field(
    "procedure",
    None,
    decode.optional(reference_decoder()),
  )
  use device <- decode.optional_field(
    "device",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(duration_decoder()),
  )
  use collected <- decode.then(
    none_if_omitted(specimen_collection_collected_decoder()),
  )
  use collector <- decode.optional_field(
    "collector",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenCollection(
    fasting_status:,
    body_site:,
    procedure:,
    device:,
    method:,
    quantity:,
    duration:,
    collected:,
    collector:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_feature_to_json(specimen_feature: SpecimenFeature) -> Json {
  let SpecimenFeature(
    description:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimen_feature
  let fields = [
    #("description", json.string(description)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimen_feature_decoder() -> Decoder(SpecimenFeature) {
  use description <- decode.field("description", decode.string)
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimenFeature(
    description:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimen_to_json(specimen: Specimen) -> Json {
  let Specimen(
    note:,
    condition:,
    container:,
    processing:,
    collection:,
    feature:,
    role:,
    combined:,
    request:,
    parent:,
    received_time:,
    subject:,
    type_:,
    status:,
    accession_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = specimen
  let fields = []
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case condition {
    [] -> fields
    _ -> [
      #("condition", json.array(condition, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case container {
    [] -> fields
    _ -> [
      #("container", json.array(container, specimen_container_to_json)),
      ..fields
    ]
  }
  let fields = case processing {
    [] -> fields
    _ -> [
      #("processing", json.array(processing, specimen_processing_to_json)),
      ..fields
    ]
  }
  let fields = case collection {
    Some(v) -> [#("collection", specimen_collection_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case feature {
    [] -> fields
    _ -> [#("feature", json.array(feature, specimen_feature_to_json)), ..fields]
  }
  let fields = case role {
    [] -> fields
    _ -> [#("role", json.array(role, codeableconcept_to_json)), ..fields]
  }
  let fields = case combined {
    Some(v) -> [
      #("combined", r5valuesets.specimencombined_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case request {
    [] -> fields
    _ -> [#("request", json.array(request, reference_to_json)), ..fields]
  }
  let fields = case parent {
    [] -> fields
    _ -> [#("parent", json.array(parent, reference_to_json)), ..fields]
  }
  let fields = case received_time {
    Some(v) -> [#("receivedTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [#("subject", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.specimenstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case accession_identifier {
    Some(v) -> [#("accessionIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Specimen")), ..fields]
  json.object(fields)
}

pub fn specimen_decoder() -> Decoder(Specimen) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use condition <- decode.optional_field(
    "condition",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use container <- decode.optional_field(
    "container",
    [],
    decode.list(specimen_container_decoder()),
  )
  use processing <- decode.optional_field(
    "processing",
    [],
    decode.list(specimen_processing_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    None,
    decode.optional(specimen_collection_decoder()),
  )
  use feature <- decode.optional_field(
    "feature",
    [],
    decode.list(specimen_feature_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use combined <- decode.optional_field(
    "combined",
    None,
    decode.optional(r5valuesets.specimencombined_decoder()),
  )
  use request <- decode.optional_field(
    "request",
    [],
    decode.list(reference_decoder()),
  )
  use parent <- decode.optional_field(
    "parent",
    [],
    decode.list(reference_decoder()),
  )
  use received_time <- decode.optional_field(
    "receivedTime",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.optional_field(
    "subject",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.specimenstatus_decoder()),
  )
  use accession_identifier <- decode.optional_field(
    "accessionIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Specimen",
    decode.failure(specimen_new(), "resourceType"),
  )
  decode.success(Specimen(
    note:,
    condition:,
    container:,
    processing:,
    collection:,
    feature:,
    role:,
    combined:,
    request:,
    parent:,
    received_time:,
    subject:,
    type_:,
    status:,
    accession_identifier:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type Specimendefinition {
  Specimendefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: Option(Identifier),
    version: Option(String),
    version_algorithm: Option(SpecimendefinitionVersionalgorithm),
    name: Option(String),
    title: Option(String),
    derived_from_canonical: List(String),
    derived_from_uri: List(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    subject: Option(SpecimendefinitionSubject),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    type_collected: Option(Codeableconcept),
    patient_preparation: List(Codeableconcept),
    time_aspect: Option(String),
    collection: List(Codeableconcept),
    type_tested: List(SpecimendefinitionTypetested),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionVersionalgorithm {
  SpecimendefinitionVersionalgorithmString(version_algorithm: String)
  SpecimendefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn specimendefinition_versionalgorithm_to_json(
  elt: SpecimendefinitionVersionalgorithm,
) -> Json {
  case elt {
    SpecimendefinitionVersionalgorithmString(v) -> json.string(v)
    SpecimendefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn specimendefinition_versionalgorithm_decoder() -> Decoder(
  SpecimendefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(SpecimendefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(SpecimendefinitionVersionalgorithmCoding),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionSubject {
  SpecimendefinitionSubjectCodeableconcept(subject: Codeableconcept)
  SpecimendefinitionSubjectReference(subject: Reference)
}

pub fn specimendefinition_subject_to_json(
  elt: SpecimendefinitionSubject,
) -> Json {
  case elt {
    SpecimendefinitionSubjectCodeableconcept(v) -> codeableconcept_to_json(v)
    SpecimendefinitionSubjectReference(v) -> reference_to_json(v)
  }
}

pub fn specimendefinition_subject_decoder() -> Decoder(
  SpecimendefinitionSubject,
) {
  decode.one_of(
    decode.field(
      "subjectCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SpecimendefinitionSubjectCodeableconcept),
    [
      decode.field("subjectReference", reference_decoder(), decode.success)
      |> decode.map(SpecimendefinitionSubjectReference),
    ],
  )
}

pub fn specimendefinition_new(
  status status: r5valuesets.Publicationstatus,
) -> Specimendefinition {
  Specimendefinition(
    type_tested: [],
    collection: [],
    time_aspect: None,
    patient_preparation: [],
    type_collected: None,
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    subject: None,
    experimental: None,
    status:,
    derived_from_uri: [],
    derived_from_canonical: [],
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: None,
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetested {
  SpecimendefinitionTypetested(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    is_derived: Option(Bool),
    type_: Option(Codeableconcept),
    preference: r5valuesets.Specimencontainedpreference,
    container: Option(SpecimendefinitionTypetestedContainer),
    requirement: Option(String),
    retention_time: Option(Duration),
    single_use: Option(Bool),
    rejection_criterion: List(Codeableconcept),
    handling: List(SpecimendefinitionTypetestedHandling),
    testing_destination: List(Codeableconcept),
  )
}

pub fn specimendefinition_typetested_new(
  preference preference: r5valuesets.Specimencontainedpreference,
) -> SpecimendefinitionTypetested {
  SpecimendefinitionTypetested(
    testing_destination: [],
    handling: [],
    rejection_criterion: [],
    single_use: None,
    retention_time: None,
    requirement: None,
    container: None,
    preference:,
    type_: None,
    is_derived: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainer {
  SpecimendefinitionTypetestedContainer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    material: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    cap: Option(Codeableconcept),
    description: Option(String),
    capacity: Option(Quantity),
    minimum_volume: Option(SpecimendefinitionTypetestedContainerMinimumvolume),
    additive: List(SpecimendefinitionTypetestedContainerAdditive),
    preparation: Option(String),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerMinimumvolume {
  SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(
    minimum_volume: Quantity,
  )
  SpecimendefinitionTypetestedContainerMinimumvolumeString(
    minimum_volume: String,
  )
}

pub fn specimendefinition_typetested_container_minimumvolume_to_json(
  elt: SpecimendefinitionTypetestedContainerMinimumvolume,
) -> Json {
  case elt {
    SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(v) ->
      quantity_to_json(v)
    SpecimendefinitionTypetestedContainerMinimumvolumeString(v) ->
      json.string(v)
  }
}

pub fn specimendefinition_typetested_container_minimumvolume_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerMinimumvolume,
) {
  decode.one_of(
    decode.field("minimumVolumeQuantity", quantity_decoder(), decode.success)
      |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeQuantity),
    [
      decode.field("minimumVolumeString", decode.string, decode.success)
      |> decode.map(SpecimendefinitionTypetestedContainerMinimumvolumeString),
    ],
  )
}

pub fn specimendefinition_typetested_container_new() -> SpecimendefinitionTypetestedContainer {
  SpecimendefinitionTypetestedContainer(
    preparation: None,
    additive: [],
    minimum_volume: None,
    capacity: None,
    description: None,
    cap: None,
    type_: None,
    material: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditive {
  SpecimendefinitionTypetestedContainerAdditive(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedContainerAdditiveAdditive {
  SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(
    additive: Codeableconcept,
  )
  SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(
    additive: Reference,
  )
}

pub fn specimendefinition_typetested_container_additive_additive_to_json(
  elt: SpecimendefinitionTypetestedContainerAdditiveAdditive,
) -> Json {
  case elt {
    SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SpecimendefinitionTypetestedContainerAdditiveAdditiveReference(v) ->
      reference_to_json(v)
  }
}

pub fn specimendefinition_typetested_container_additive_additive_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerAdditiveAdditive,
) {
  decode.one_of(
    decode.field(
      "additiveCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(
        SpecimendefinitionTypetestedContainerAdditiveAdditiveCodeableconcept,
      ),
    [
      decode.field("additiveReference", reference_decoder(), decode.success)
      |> decode.map(
        SpecimendefinitionTypetestedContainerAdditiveAdditiveReference,
      ),
    ],
  )
}

pub fn specimendefinition_typetested_container_additive_new(
  additive additive: SpecimendefinitionTypetestedContainerAdditiveAdditive,
) -> SpecimendefinitionTypetestedContainerAdditive {
  SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SpecimenDefinition#resource
pub type SpecimendefinitionTypetestedHandling {
  SpecimendefinitionTypetestedHandling(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    temperature_qualifier: Option(Codeableconcept),
    temperature_range: Option(Range),
    max_duration: Option(Duration),
    instruction: Option(String),
  )
}

pub fn specimendefinition_typetested_handling_new() -> SpecimendefinitionTypetestedHandling {
  SpecimendefinitionTypetestedHandling(
    instruction: None,
    max_duration: None,
    temperature_range: None,
    temperature_qualifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn specimendefinition_typetested_handling_to_json(
  specimendefinition_typetested_handling: SpecimendefinitionTypetestedHandling,
) -> Json {
  let SpecimendefinitionTypetestedHandling(
    instruction:,
    max_duration:,
    temperature_range:,
    temperature_qualifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_handling
  let fields = []
  let fields = case instruction {
    Some(v) -> [#("instruction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max_duration {
    Some(v) -> [#("maxDuration", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case temperature_range {
    Some(v) -> [#("temperatureRange", range_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case temperature_qualifier {
    Some(v) -> [#("temperatureQualifier", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_handling_decoder() -> Decoder(
  SpecimendefinitionTypetestedHandling,
) {
  use instruction <- decode.optional_field(
    "instruction",
    None,
    decode.optional(decode.string),
  )
  use max_duration <- decode.optional_field(
    "maxDuration",
    None,
    decode.optional(duration_decoder()),
  )
  use temperature_range <- decode.optional_field(
    "temperatureRange",
    None,
    decode.optional(range_decoder()),
  )
  use temperature_qualifier <- decode.optional_field(
    "temperatureQualifier",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedHandling(
    instruction:,
    max_duration:,
    temperature_range:,
    temperature_qualifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_container_additive_to_json(
  specimendefinition_typetested_container_additive: SpecimendefinitionTypetestedContainerAdditive,
) -> Json {
  let SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_container_additive
  let fields = [
    #(
      "additive",
      specimendefinition_typetested_container_additive_additive_to_json(
        additive,
      ),
    ),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_container_additive_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainerAdditive,
) {
  use additive <- decode.then(
    specimendefinition_typetested_container_additive_additive_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedContainerAdditive(
    additive:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_container_to_json(
  specimendefinition_typetested_container: SpecimendefinitionTypetestedContainer,
) -> Json {
  let SpecimendefinitionTypetestedContainer(
    preparation:,
    additive:,
    minimum_volume:,
    capacity:,
    description:,
    cap:,
    type_:,
    material:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested_container
  let fields = []
  let fields = case preparation {
    Some(v) -> [#("preparation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case additive {
    [] -> fields
    _ -> [
      #(
        "additive",
        json.array(
          additive,
          specimendefinition_typetested_container_additive_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case minimum_volume {
    Some(v) -> [
      #(
        "minimumVolume"
          <> case v {
          SpecimendefinitionTypetestedContainerMinimumvolumeQuantity(_) ->
            "Quantity"
          SpecimendefinitionTypetestedContainerMinimumvolumeString(_) ->
            "String"
        },
        specimendefinition_typetested_container_minimumvolume_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case capacity {
    Some(v) -> [#("capacity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case cap {
    Some(v) -> [#("cap", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case material {
    Some(v) -> [#("material", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_container_decoder() -> Decoder(
  SpecimendefinitionTypetestedContainer,
) {
  use preparation <- decode.optional_field(
    "preparation",
    None,
    decode.optional(decode.string),
  )
  use additive <- decode.optional_field(
    "additive",
    [],
    decode.list(specimendefinition_typetested_container_additive_decoder()),
  )
  use minimum_volume <- decode.then(
    none_if_omitted(
      specimendefinition_typetested_container_minimumvolume_decoder(),
    ),
  )
  use capacity <- decode.optional_field(
    "capacity",
    None,
    decode.optional(quantity_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use cap <- decode.optional_field(
    "cap",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use material <- decode.optional_field(
    "material",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetestedContainer(
    preparation:,
    additive:,
    minimum_volume:,
    capacity:,
    description:,
    cap:,
    type_:,
    material:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_typetested_to_json(
  specimendefinition_typetested: SpecimendefinitionTypetested,
) -> Json {
  let SpecimendefinitionTypetested(
    testing_destination:,
    handling:,
    rejection_criterion:,
    single_use:,
    retention_time:,
    requirement:,
    container:,
    preference:,
    type_:,
    is_derived:,
    modifier_extension:,
    extension:,
    id:,
  ) = specimendefinition_typetested
  let fields = [
    #("preference", r5valuesets.specimencontainedpreference_to_json(preference)),
  ]
  let fields = case testing_destination {
    [] -> fields
    _ -> [
      #(
        "testingDestination",
        json.array(testing_destination, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case handling {
    [] -> fields
    _ -> [
      #(
        "handling",
        json.array(handling, specimendefinition_typetested_handling_to_json),
      ),
      ..fields
    ]
  }
  let fields = case rejection_criterion {
    [] -> fields
    _ -> [
      #(
        "rejectionCriterion",
        json.array(rejection_criterion, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case single_use {
    Some(v) -> [#("singleUse", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case retention_time {
    Some(v) -> [#("retentionTime", duration_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requirement {
    Some(v) -> [#("requirement", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case container {
    Some(v) -> [
      #("container", specimendefinition_typetested_container_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_derived {
    Some(v) -> [#("isDerived", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn specimendefinition_typetested_decoder() -> Decoder(
  SpecimendefinitionTypetested,
) {
  use testing_destination <- decode.optional_field(
    "testingDestination",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use handling <- decode.optional_field(
    "handling",
    [],
    decode.list(specimendefinition_typetested_handling_decoder()),
  )
  use rejection_criterion <- decode.optional_field(
    "rejectionCriterion",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use single_use <- decode.optional_field(
    "singleUse",
    None,
    decode.optional(decode.bool),
  )
  use retention_time <- decode.optional_field(
    "retentionTime",
    None,
    decode.optional(duration_decoder()),
  )
  use requirement <- decode.optional_field(
    "requirement",
    None,
    decode.optional(decode.string),
  )
  use container <- decode.optional_field(
    "container",
    None,
    decode.optional(specimendefinition_typetested_container_decoder()),
  )
  use preference <- decode.field(
    "preference",
    r5valuesets.specimencontainedpreference_decoder(),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use is_derived <- decode.optional_field(
    "isDerived",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SpecimendefinitionTypetested(
    testing_destination:,
    handling:,
    rejection_criterion:,
    single_use:,
    retention_time:,
    requirement:,
    container:,
    preference:,
    type_:,
    is_derived:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn specimendefinition_to_json(
  specimendefinition: Specimendefinition,
) -> Json {
  let Specimendefinition(
    type_tested:,
    collection:,
    time_aspect:,
    patient_preparation:,
    type_collected:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    derived_from_uri:,
    derived_from_canonical:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = specimendefinition
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case type_tested {
    [] -> fields
    _ -> [
      #(
        "typeTested",
        json.array(type_tested, specimendefinition_typetested_to_json),
      ),
      ..fields
    ]
  }
  let fields = case collection {
    [] -> fields
    _ -> [
      #("collection", json.array(collection, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case time_aspect {
    Some(v) -> [#("timeAspect", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case patient_preparation {
    [] -> fields
    _ -> [
      #(
        "patientPreparation",
        json.array(patient_preparation, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_collected {
    Some(v) -> [#("typeCollected", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subject {
    Some(v) -> [
      #(
        "subject"
          <> case v {
          SpecimendefinitionSubjectCodeableconcept(_) -> "Codeableconcept"
          SpecimendefinitionSubjectReference(_) -> "Reference"
        },
        specimendefinition_subject_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from_uri {
    [] -> fields
    _ -> [
      #("derivedFromUri", json.array(derived_from_uri, json.string)),
      ..fields
    ]
  }
  let fields = case derived_from_canonical {
    [] -> fields
    _ -> [
      #("derivedFromCanonical", json.array(derived_from_canonical, json.string)),
      ..fields
    ]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          SpecimendefinitionVersionalgorithmString(_) -> "String"
          SpecimendefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        specimendefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Specimendefinition")), ..fields]
  json.object(fields)
}

pub fn specimendefinition_decoder() -> Decoder(Specimendefinition) {
  use type_tested <- decode.optional_field(
    "typeTested",
    [],
    decode.list(specimendefinition_typetested_decoder()),
  )
  use collection <- decode.optional_field(
    "collection",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use time_aspect <- decode.optional_field(
    "timeAspect",
    None,
    decode.optional(decode.string),
  )
  use patient_preparation <- decode.optional_field(
    "patientPreparation",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_collected <- decode.optional_field(
    "typeCollected",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use subject <- decode.then(
    none_if_omitted(specimendefinition_subject_decoder()),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use derived_from_uri <- decode.optional_field(
    "derivedFromUri",
    [],
    decode.list(decode.string),
  )
  use derived_from_canonical <- decode.optional_field(
    "derivedFromCanonical",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(specimendefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Specimendefinition",
    decode.failure(specimendefinition_new(status:), "resourceType"),
  )
  decode.success(Specimendefinition(
    type_tested:,
    collection:,
    time_aspect:,
    patient_preparation:,
    type_collected:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    subject:,
    experimental:,
    status:,
    derived_from_uri:,
    derived_from_canonical:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type Structuredefinition {
  Structuredefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(StructuredefinitionVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    keyword: List(Coding),
    fhir_version: Option(r5valuesets.Fhirversion),
    mapping: List(StructuredefinitionMapping),
    kind: r5valuesets.Structuredefinitionkind,
    abstract: Bool,
    context: List(StructuredefinitionContext),
    context_invariant: List(String),
    type_: String,
    base_definition: Option(String),
    derivation: Option(r5valuesets.Typederivationrule),
    snapshot: Option(StructuredefinitionSnapshot),
    differential: Option(StructuredefinitionDifferential),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionVersionalgorithm {
  StructuredefinitionVersionalgorithmString(version_algorithm: String)
  StructuredefinitionVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn structuredefinition_versionalgorithm_to_json(
  elt: StructuredefinitionVersionalgorithm,
) -> Json {
  case elt {
    StructuredefinitionVersionalgorithmString(v) -> json.string(v)
    StructuredefinitionVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn structuredefinition_versionalgorithm_decoder() -> Decoder(
  StructuredefinitionVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(StructuredefinitionVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(StructuredefinitionVersionalgorithmCoding),
    ],
  )
}

pub fn structuredefinition_new(
  type_ type_: String,
  abstract abstract: Bool,
  kind kind: r5valuesets.Structuredefinitionkind,
  status status: r5valuesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Structuredefinition {
  Structuredefinition(
    differential: None,
    snapshot: None,
    derivation: None,
    base_definition: None,
    type_:,
    context_invariant: [],
    context: [],
    abstract:,
    kind:,
    mapping: [],
    fhir_version: None,
    keyword: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionMapping {
  StructuredefinitionMapping(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identity: String,
    uri: Option(String),
    name: Option(String),
    comment: Option(String),
  )
}

pub fn structuredefinition_mapping_new(
  identity identity: String,
) -> StructuredefinitionMapping {
  StructuredefinitionMapping(
    comment: None,
    name: None,
    uri: None,
    identity:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionContext {
  StructuredefinitionContext(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Extensioncontexttype,
    expression: String,
  )
}

pub fn structuredefinition_context_new(
  expression expression: String,
  type_ type_: r5valuesets.Extensioncontexttype,
) -> StructuredefinitionContext {
  StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionSnapshot {
  StructuredefinitionSnapshot(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    element: List(Elementdefinition),
  )
}

pub fn structuredefinition_snapshot_new() -> StructuredefinitionSnapshot {
  StructuredefinitionSnapshot(
    element: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureDefinition#resource
pub type StructuredefinitionDifferential {
  StructuredefinitionDifferential(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    element: List(Elementdefinition),
  )
}

pub fn structuredefinition_differential_new() -> StructuredefinitionDifferential {
  StructuredefinitionDifferential(
    element: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn structuredefinition_differential_to_json(
  structuredefinition_differential: StructuredefinitionDifferential,
) -> Json {
  let StructuredefinitionDifferential(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_differential
  let fields = []
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, elementdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_differential_decoder() -> Decoder(
  StructuredefinitionDifferential,
) {
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(elementdefinition_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionDifferential(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_snapshot_to_json(
  structuredefinition_snapshot: StructuredefinitionSnapshot,
) -> Json {
  let StructuredefinitionSnapshot(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_snapshot
  let fields = []
  let fields = case element {
    [] -> fields
    _ -> [
      #("element", json.array(element, elementdefinition_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_snapshot_decoder() -> Decoder(
  StructuredefinitionSnapshot,
) {
  use element <- decode.optional_field(
    "element",
    [],
    decode.list(elementdefinition_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionSnapshot(
    element:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_context_to_json(
  structuredefinition_context: StructuredefinitionContext,
) -> Json {
  let StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_context
  let fields = [
    #("expression", json.string(expression)),
    #("type", r5valuesets.extensioncontexttype_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_context_decoder() -> Decoder(
  StructuredefinitionContext,
) {
  use expression <- decode.field("expression", decode.string)
  use type_ <- decode.field("type", r5valuesets.extensioncontexttype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionContext(
    expression:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_mapping_to_json(
  structuredefinition_mapping: StructuredefinitionMapping,
) -> Json {
  let StructuredefinitionMapping(
    comment:,
    name:,
    uri:,
    identity:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuredefinition_mapping
  let fields = [
    #("identity", json.string(identity)),
  ]
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuredefinition_mapping_decoder() -> Decoder(
  StructuredefinitionMapping,
) {
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use identity <- decode.field("identity", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuredefinitionMapping(
    comment:,
    name:,
    uri:,
    identity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuredefinition_to_json(
  structuredefinition: Structuredefinition,
) -> Json {
  let Structuredefinition(
    differential:,
    snapshot:,
    derivation:,
    base_definition:,
    type_:,
    context_invariant:,
    context:,
    abstract:,
    kind:,
    mapping:,
    fhir_version:,
    keyword:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = structuredefinition
  let fields = [
    #("type", json.string(type_)),
    #("abstract", json.bool(abstract)),
    #("kind", r5valuesets.structuredefinitionkind_to_json(kind)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case differential {
    Some(v) -> [
      #("differential", structuredefinition_differential_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case snapshot {
    Some(v) -> [
      #("snapshot", structuredefinition_snapshot_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case derivation {
    Some(v) -> [
      #("derivation", r5valuesets.typederivationrule_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case base_definition {
    Some(v) -> [#("baseDefinition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context_invariant {
    [] -> fields
    _ -> [
      #("contextInvariant", json.array(context_invariant, json.string)),
      ..fields
    ]
  }
  let fields = case context {
    [] -> fields
    _ -> [
      #("context", json.array(context, structuredefinition_context_to_json)),
      ..fields
    ]
  }
  let fields = case mapping {
    [] -> fields
    _ -> [
      #("mapping", json.array(mapping, structuredefinition_mapping_to_json)),
      ..fields
    ]
  }
  let fields = case fhir_version {
    Some(v) -> [#("fhirVersion", r5valuesets.fhirversion_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case keyword {
    [] -> fields
    _ -> [#("keyword", json.array(keyword, coding_to_json)), ..fields]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          StructuredefinitionVersionalgorithmString(_) -> "String"
          StructuredefinitionVersionalgorithmCoding(_) -> "Coding"
        },
        structuredefinition_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Structuredefinition")), ..fields]
  json.object(fields)
}

pub fn structuredefinition_decoder() -> Decoder(Structuredefinition) {
  use differential <- decode.optional_field(
    "differential",
    None,
    decode.optional(structuredefinition_differential_decoder()),
  )
  use snapshot <- decode.optional_field(
    "snapshot",
    None,
    decode.optional(structuredefinition_snapshot_decoder()),
  )
  use derivation <- decode.optional_field(
    "derivation",
    None,
    decode.optional(r5valuesets.typederivationrule_decoder()),
  )
  use base_definition <- decode.optional_field(
    "baseDefinition",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.field("type", decode.string)
  use context_invariant <- decode.optional_field(
    "contextInvariant",
    [],
    decode.list(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    [],
    decode.list(structuredefinition_context_decoder()),
  )
  use abstract <- decode.field("abstract", decode.bool)
  use kind <- decode.field(
    "kind",
    r5valuesets.structuredefinitionkind_decoder(),
  )
  use mapping <- decode.optional_field(
    "mapping",
    [],
    decode.list(structuredefinition_mapping_decoder()),
  )
  use fhir_version <- decode.optional_field(
    "fhirVersion",
    None,
    decode.optional(r5valuesets.fhirversion_decoder()),
  )
  use keyword <- decode.optional_field(
    "keyword",
    [],
    decode.list(coding_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(structuredefinition_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Structuredefinition",
    decode.failure(
      structuredefinition_new(type_:, abstract:, kind:, status:, name:, url:),
      "resourceType",
    ),
  )
  decode.success(Structuredefinition(
    differential:,
    snapshot:,
    derivation:,
    base_definition:,
    type_:,
    context_invariant:,
    context:,
    abstract:,
    kind:,
    mapping:,
    fhir_version:,
    keyword:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type Structuremap {
  Structuremap(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(StructuremapVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    structure: List(StructuremapStructure),
    import_: List(String),
    const_: List(StructuremapConst),
    group: List(StructuremapGroup),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapVersionalgorithm {
  StructuremapVersionalgorithmString(version_algorithm: String)
  StructuremapVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn structuremap_versionalgorithm_to_json(
  elt: StructuremapVersionalgorithm,
) -> Json {
  case elt {
    StructuremapVersionalgorithmString(v) -> json.string(v)
    StructuremapVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn structuremap_versionalgorithm_decoder() -> Decoder(
  StructuremapVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(StructuremapVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(StructuremapVersionalgorithmCoding),
    ],
  )
}

pub fn structuremap_new(
  status status: r5valuesets.Publicationstatus,
  name name: String,
  url url: String,
) -> Structuremap {
  Structuremap(
    group: [],
    const_: [],
    import_: [],
    structure: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapStructure {
  StructuremapStructure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    mode: r5valuesets.Mapmodelmode,
    alias: Option(String),
    documentation: Option(String),
  )
}

pub fn structuremap_structure_new(
  mode mode: r5valuesets.Mapmodelmode,
  url url: String,
) -> StructuremapStructure {
  StructuremapStructure(
    documentation: None,
    alias: None,
    mode:,
    url:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapConst {
  StructuremapConst(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    value: Option(String),
  )
}

pub fn structuremap_const_new() -> StructuremapConst {
  StructuremapConst(
    value: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroup {
  StructuremapGroup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    extends: Option(String),
    type_mode: Option(r5valuesets.Mapgrouptypemode),
    documentation: Option(String),
    input: List(StructuremapGroupInput),
    rule: List(StructuremapGroupRule),
  )
}

pub fn structuremap_group_new(name name: String) -> StructuremapGroup {
  StructuremapGroup(
    rule: [],
    input: [],
    documentation: None,
    type_mode: None,
    extends: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupInput {
  StructuremapGroupInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: Option(String),
    mode: r5valuesets.Mapinputmode,
    documentation: Option(String),
  )
}

pub fn structuremap_group_input_new(
  mode mode: r5valuesets.Mapinputmode,
  name name: String,
) -> StructuremapGroupInput {
  StructuremapGroupInput(
    documentation: None,
    mode:,
    type_: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRule {
  StructuremapGroupRule(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    source: List(StructuremapGroupRuleSource),
    target: List(StructuremapGroupRuleTarget),
    dependent: List(StructuremapGroupRuleDependent),
    documentation: Option(String),
  )
}

pub fn structuremap_group_rule_new() -> StructuremapGroupRule {
  StructuremapGroupRule(
    documentation: None,
    dependent: [],
    target: [],
    source: [],
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleSource {
  StructuremapGroupRuleSource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    context: String,
    min: Option(Int),
    max: Option(String),
    type_: Option(String),
    default_value: Option(String),
    element: Option(String),
    list_mode: Option(r5valuesets.Mapsourcelistmode),
    variable: Option(String),
    condition: Option(String),
    check: Option(String),
    log_message: Option(String),
  )
}

pub fn structuremap_group_rule_source_new(
  context context: String,
) -> StructuremapGroupRuleSource {
  StructuremapGroupRuleSource(
    log_message: None,
    check: None,
    condition: None,
    variable: None,
    list_mode: None,
    element: None,
    default_value: None,
    type_: None,
    max: None,
    min: None,
    context:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTarget {
  StructuremapGroupRuleTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    context: Option(String),
    element: Option(String),
    variable: Option(String),
    list_mode: List(r5valuesets.Maptargetlistmode),
    list_rule_id: Option(String),
    transform: Option(r5valuesets.Maptransform),
    parameter: List(StructuremapGroupRuleTargetParameter),
  )
}

pub fn structuremap_group_rule_target_new() -> StructuremapGroupRuleTarget {
  StructuremapGroupRuleTarget(
    parameter: [],
    transform: None,
    list_rule_id: None,
    list_mode: [],
    variable: None,
    element: None,
    context: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameter {
  StructuremapGroupRuleTargetParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    value: StructuremapGroupRuleTargetParameterValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleTargetParameterValue {
  StructuremapGroupRuleTargetParameterValueId(value: String)
  StructuremapGroupRuleTargetParameterValueString(value: String)
  StructuremapGroupRuleTargetParameterValueBoolean(value: Bool)
  StructuremapGroupRuleTargetParameterValueInteger(value: Int)
  StructuremapGroupRuleTargetParameterValueDecimal(value: Float)
  StructuremapGroupRuleTargetParameterValueDate(value: String)
  StructuremapGroupRuleTargetParameterValueTime(value: String)
  StructuremapGroupRuleTargetParameterValueDatetime(value: String)
}

pub fn structuremap_group_rule_target_parameter_value_to_json(
  elt: StructuremapGroupRuleTargetParameterValue,
) -> Json {
  case elt {
    StructuremapGroupRuleTargetParameterValueId(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueString(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueBoolean(v) -> json.bool(v)
    StructuremapGroupRuleTargetParameterValueInteger(v) -> json.int(v)
    StructuremapGroupRuleTargetParameterValueDecimal(v) -> json.float(v)
    StructuremapGroupRuleTargetParameterValueDate(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueTime(v) -> json.string(v)
    StructuremapGroupRuleTargetParameterValueDatetime(v) -> json.string(v)
  }
}

pub fn structuremap_group_rule_target_parameter_value_decoder() -> Decoder(
  StructuremapGroupRuleTargetParameterValue,
) {
  decode.one_of(
    decode.field("valueId", decode.string, decode.success)
      |> decode.map(StructuremapGroupRuleTargetParameterValueId),
    [
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueString),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueInteger),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueDecimal),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueDate),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueTime),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(StructuremapGroupRuleTargetParameterValueDatetime),
    ],
  )
}

pub fn structuremap_group_rule_target_parameter_new(
  value value: StructuremapGroupRuleTargetParameterValue,
) -> StructuremapGroupRuleTargetParameter {
  StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/StructureMap#resource
pub type StructuremapGroupRuleDependent {
  StructuremapGroupRuleDependent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
  )
}

pub fn structuremap_group_rule_dependent_new(
  name name: String,
) -> StructuremapGroupRuleDependent {
  StructuremapGroupRuleDependent(
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn structuremap_group_rule_dependent_to_json(
  structuremap_group_rule_dependent: StructuremapGroupRuleDependent,
) -> Json {
  let StructuremapGroupRuleDependent(
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_dependent
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_dependent_decoder() -> Decoder(
  StructuremapGroupRuleDependent,
) {
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleDependent(
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_target_parameter_to_json(
  structuremap_group_rule_target_parameter: StructuremapGroupRuleTargetParameter,
) -> Json {
  let StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_target_parameter
  let fields = [
    #("value", structuremap_group_rule_target_parameter_value_to_json(value)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_target_parameter_decoder() -> Decoder(
  StructuremapGroupRuleTargetParameter,
) {
  use value <- decode.then(
    structuremap_group_rule_target_parameter_value_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleTargetParameter(
    value:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_target_to_json(
  structuremap_group_rule_target: StructuremapGroupRuleTarget,
) -> Json {
  let StructuremapGroupRuleTarget(
    parameter:,
    transform:,
    list_rule_id:,
    list_mode:,
    variable:,
    element:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_target
  let fields = []
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, structuremap_group_rule_target_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case transform {
    Some(v) -> [#("transform", r5valuesets.maptransform_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case list_rule_id {
    Some(v) -> [#("listRuleId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case list_mode {
    [] -> fields
    _ -> [
      #(
        "listMode",
        json.array(list_mode, r5valuesets.maptargetlistmode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case variable {
    Some(v) -> [#("variable", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case element {
    Some(v) -> [#("element", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case context {
    Some(v) -> [#("context", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_target_decoder() -> Decoder(
  StructuremapGroupRuleTarget,
) {
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(structuremap_group_rule_target_parameter_decoder()),
  )
  use transform <- decode.optional_field(
    "transform",
    None,
    decode.optional(r5valuesets.maptransform_decoder()),
  )
  use list_rule_id <- decode.optional_field(
    "listRuleId",
    None,
    decode.optional(decode.string),
  )
  use list_mode <- decode.optional_field(
    "listMode",
    [],
    decode.list(r5valuesets.maptargetlistmode_decoder()),
  )
  use variable <- decode.optional_field(
    "variable",
    None,
    decode.optional(decode.string),
  )
  use element <- decode.optional_field(
    "element",
    None,
    decode.optional(decode.string),
  )
  use context <- decode.optional_field(
    "context",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleTarget(
    parameter:,
    transform:,
    list_rule_id:,
    list_mode:,
    variable:,
    element:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_source_to_json(
  structuremap_group_rule_source: StructuremapGroupRuleSource,
) -> Json {
  let StructuremapGroupRuleSource(
    log_message:,
    check:,
    condition:,
    variable:,
    list_mode:,
    element:,
    default_value:,
    type_:,
    max:,
    min:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule_source
  let fields = [
    #("context", json.string(context)),
  ]
  let fields = case log_message {
    Some(v) -> [#("logMessage", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case check {
    Some(v) -> [#("check", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case condition {
    Some(v) -> [#("condition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case variable {
    Some(v) -> [#("variable", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case list_mode {
    Some(v) -> [
      #("listMode", r5valuesets.mapsourcelistmode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case element {
    Some(v) -> [#("element", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [#("defaultValue", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case max {
    Some(v) -> [#("max", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case min {
    Some(v) -> [#("min", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_source_decoder() -> Decoder(
  StructuremapGroupRuleSource,
) {
  use log_message <- decode.optional_field(
    "logMessage",
    None,
    decode.optional(decode.string),
  )
  use check <- decode.optional_field(
    "check",
    None,
    decode.optional(decode.string),
  )
  use condition <- decode.optional_field(
    "condition",
    None,
    decode.optional(decode.string),
  )
  use variable <- decode.optional_field(
    "variable",
    None,
    decode.optional(decode.string),
  )
  use list_mode <- decode.optional_field(
    "listMode",
    None,
    decode.optional(r5valuesets.mapsourcelistmode_decoder()),
  )
  use element <- decode.optional_field(
    "element",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.optional_field(
    "defaultValue",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use max <- decode.optional_field("max", None, decode.optional(decode.string))
  use min <- decode.optional_field("min", None, decode.optional(decode.int))
  use context <- decode.field("context", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRuleSource(
    log_message:,
    check:,
    condition:,
    variable:,
    list_mode:,
    element:,
    default_value:,
    type_:,
    max:,
    min:,
    context:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_rule_to_json(
  structuremap_group_rule: StructuremapGroupRule,
) -> Json {
  let StructuremapGroupRule(
    documentation:,
    dependent:,
    target:,
    source:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_rule
  let fields = []
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dependent {
    [] -> fields
    _ -> [
      #(
        "dependent",
        json.array(dependent, structuremap_group_rule_dependent_to_json),
      ),
      ..fields
    ]
  }
  let fields = case target {
    [] -> fields
    _ -> [
      #("target", json.array(target, structuremap_group_rule_target_to_json)),
      ..fields
    ]
  }
  let fields = case source {
    [] -> fields
    _ -> [
      #("source", json.array(source, structuremap_group_rule_source_to_json)),
      ..fields
    ]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_rule_decoder() -> Decoder(StructuremapGroupRule) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use dependent <- decode.optional_field(
    "dependent",
    [],
    decode.list(structuremap_group_rule_dependent_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(structuremap_group_rule_target_decoder()),
  )
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(structuremap_group_rule_source_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupRule(
    documentation:,
    dependent:,
    target:,
    source:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_input_to_json(
  structuremap_group_input: StructuremapGroupInput,
) -> Json {
  let StructuremapGroupInput(
    documentation:,
    mode:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group_input
  let fields = [
    #("mode", r5valuesets.mapinputmode_to_json(mode)),
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_input_decoder() -> Decoder(StructuremapGroupInput) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.mapinputmode_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroupInput(
    documentation:,
    mode:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_group_to_json(structuremap_group: StructuremapGroup) -> Json {
  let StructuremapGroup(
    rule:,
    input:,
    documentation:,
    type_mode:,
    extends:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_group
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case rule {
    [] -> fields
    _ -> [
      #("rule", json.array(rule, structuremap_group_rule_to_json)),
      ..fields
    ]
  }
  let fields = case input {
    [] -> fields
    _ -> [
      #("input", json.array(input, structuremap_group_input_to_json)),
      ..fields
    ]
  }
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_mode {
    Some(v) -> [
      #("typeMode", r5valuesets.mapgrouptypemode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case extends {
    Some(v) -> [#("extends", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_group_decoder() -> Decoder(StructuremapGroup) {
  use rule <- decode.optional_field(
    "rule",
    [],
    decode.list(structuremap_group_rule_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(structuremap_group_input_decoder()),
  )
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use type_mode <- decode.optional_field(
    "typeMode",
    None,
    decode.optional(r5valuesets.mapgrouptypemode_decoder()),
  )
  use extends <- decode.optional_field(
    "extends",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapGroup(
    rule:,
    input:,
    documentation:,
    type_mode:,
    extends:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_const_to_json(structuremap_const: StructuremapConst) -> Json {
  let StructuremapConst(value:, name:, modifier_extension:, extension:, id:) =
    structuremap_const
  let fields = []
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_const_decoder() -> Decoder(StructuremapConst) {
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapConst(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_structure_to_json(
  structuremap_structure: StructuremapStructure,
) -> Json {
  let StructuremapStructure(
    documentation:,
    alias:,
    mode:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ) = structuremap_structure
  let fields = [
    #("mode", r5valuesets.mapmodelmode_to_json(mode)),
    #("url", json.string(url)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case alias {
    Some(v) -> [#("alias", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn structuremap_structure_decoder() -> Decoder(StructuremapStructure) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use alias <- decode.optional_field(
    "alias",
    None,
    decode.optional(decode.string),
  )
  use mode <- decode.field("mode", r5valuesets.mapmodelmode_decoder())
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(StructuremapStructure(
    documentation:,
    alias:,
    mode:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn structuremap_to_json(structuremap: Structuremap) -> Json {
  let Structuremap(
    group:,
    const_:,
    import_:,
    structure:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = structuremap
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
    #("url", json.string(url)),
  ]
  let fields = case group {
    [] -> fields
    _ -> [#("group", json.array(group, structuremap_group_to_json)), ..fields]
  }
  let fields = case const_ {
    [] -> fields
    _ -> [#("const", json.array(const_, structuremap_const_to_json)), ..fields]
  }
  let fields = case import_ {
    [] -> fields
    _ -> [#("import", json.array(import_, json.string)), ..fields]
  }
  let fields = case structure {
    [] -> fields
    _ -> [
      #("structure", json.array(structure, structuremap_structure_to_json)),
      ..fields
    ]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          StructuremapVersionalgorithmString(_) -> "String"
          StructuremapVersionalgorithmCoding(_) -> "Coding"
        },
        structuremap_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Structuremap")), ..fields]
  json.object(fields)
}

pub fn structuremap_decoder() -> Decoder(Structuremap) {
  use group <- decode.optional_field(
    "group",
    [],
    decode.list(structuremap_group_decoder()),
  )
  use const_ <- decode.optional_field(
    "const",
    [],
    decode.list(structuremap_const_decoder()),
  )
  use import_ <- decode.optional_field("import", [], decode.list(decode.string))
  use structure <- decode.optional_field(
    "structure",
    [],
    decode.list(structuremap_structure_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(structuremap_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Structuremap",
    decode.failure(structuremap_new(status:, name:, url:), "resourceType"),
  )
  decode.success(Structuremap(
    group:,
    const_:,
    import_:,
    structure:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Subscription#resource
pub type Subscription {
  Subscription(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    name: Option(String),
    status: r5valuesets.Subscriptionstatus,
    topic: String,
    contact: List(Contactpoint),
    end: Option(String),
    managing_entity: Option(Reference),
    reason: Option(String),
    filter_by: List(SubscriptionFilterby),
    channel_type: Coding,
    endpoint: Option(String),
    parameter: List(SubscriptionParameter),
    heartbeat_period: Option(Int),
    timeout: Option(Int),
    content_type: Option(String),
    content: Option(r5valuesets.Subscriptionpayloadcontent),
    max_count: Option(Int),
  )
}

pub fn subscription_new(
  channel_type channel_type: Coding,
  topic topic: String,
  status status: r5valuesets.Subscriptionstatus,
) -> Subscription {
  Subscription(
    max_count: None,
    content: None,
    content_type: None,
    timeout: None,
    heartbeat_period: None,
    parameter: [],
    endpoint: None,
    channel_type:,
    filter_by: [],
    reason: None,
    managing_entity: None,
    end: None,
    contact: [],
    topic:,
    status:,
    name: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Subscription#resource
pub type SubscriptionFilterby {
  SubscriptionFilterby(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource_type: Option(String),
    filter_parameter: String,
    comparator: Option(r5valuesets.Searchcomparator),
    modifier: Option(r5valuesets.Searchmodifiercode),
    value: String,
  )
}

pub fn subscription_filterby_new(
  value value: String,
  filter_parameter filter_parameter: String,
) -> SubscriptionFilterby {
  SubscriptionFilterby(
    value:,
    modifier: None,
    comparator: None,
    filter_parameter:,
    resource_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Subscription#resource
pub type SubscriptionParameter {
  SubscriptionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    value: String,
  )
}

pub fn subscription_parameter_new(
  value value: String,
  name name: String,
) -> SubscriptionParameter {
  SubscriptionParameter(
    value:,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscription_parameter_to_json(
  subscription_parameter: SubscriptionParameter,
) -> Json {
  let SubscriptionParameter(value:, name:, modifier_extension:, extension:, id:) =
    subscription_parameter
  let fields = [
    #("value", json.string(value)),
    #("name", json.string(name)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscription_parameter_decoder() -> Decoder(SubscriptionParameter) {
  use value <- decode.field("value", decode.string)
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptionParameter(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscription_filterby_to_json(
  subscription_filterby: SubscriptionFilterby,
) -> Json {
  let SubscriptionFilterby(
    value:,
    modifier:,
    comparator:,
    filter_parameter:,
    resource_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscription_filterby
  let fields = [
    #("value", json.string(value)),
    #("filterParameter", json.string(filter_parameter)),
  ]
  let fields = case modifier {
    Some(v) -> [
      #("modifier", r5valuesets.searchmodifiercode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case comparator {
    Some(v) -> [
      #("comparator", r5valuesets.searchcomparator_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource_type {
    Some(v) -> [#("resourceType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscription_filterby_decoder() -> Decoder(SubscriptionFilterby) {
  use value <- decode.field("value", decode.string)
  use modifier <- decode.optional_field(
    "modifier",
    None,
    decode.optional(r5valuesets.searchmodifiercode_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(r5valuesets.searchcomparator_decoder()),
  )
  use filter_parameter <- decode.field("filterParameter", decode.string)
  use resource_type <- decode.optional_field(
    "resourceType",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptionFilterby(
    value:,
    modifier:,
    comparator:,
    filter_parameter:,
    resource_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscription_to_json(subscription: Subscription) -> Json {
  let Subscription(
    max_count:,
    content:,
    content_type:,
    timeout:,
    heartbeat_period:,
    parameter:,
    endpoint:,
    channel_type:,
    filter_by:,
    reason:,
    managing_entity:,
    end:,
    contact:,
    topic:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscription
  let fields = [
    #("channelType", coding_to_json(channel_type)),
    #("topic", json.string(topic)),
    #("status", r5valuesets.subscriptionstatus_to_json(status)),
  ]
  let fields = case max_count {
    Some(v) -> [#("maxCount", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case content {
    Some(v) -> [
      #("content", r5valuesets.subscriptionpayloadcontent_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case timeout {
    Some(v) -> [#("timeout", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case heartbeat_period {
    Some(v) -> [#("heartbeatPeriod", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, subscription_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case endpoint {
    Some(v) -> [#("endpoint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case filter_by {
    [] -> fields
    _ -> [
      #("filterBy", json.array(filter_by, subscription_filterby_to_json)),
      ..fields
    ]
  }
  let fields = case reason {
    Some(v) -> [#("reason", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case managing_entity {
    Some(v) -> [#("managingEntity", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case end {
    Some(v) -> [#("end", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactpoint_to_json)), ..fields]
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscription")), ..fields]
  json.object(fields)
}

pub fn subscription_decoder() -> Decoder(Subscription) {
  use max_count <- decode.optional_field(
    "maxCount",
    None,
    decode.optional(decode.int),
  )
  use content <- decode.optional_field(
    "content",
    None,
    decode.optional(r5valuesets.subscriptionpayloadcontent_decoder()),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use timeout <- decode.optional_field(
    "timeout",
    None,
    decode.optional(decode.int),
  )
  use heartbeat_period <- decode.optional_field(
    "heartbeatPeriod",
    None,
    decode.optional(decode.int),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(subscription_parameter_decoder()),
  )
  use endpoint <- decode.optional_field(
    "endpoint",
    None,
    decode.optional(decode.string),
  )
  use channel_type <- decode.field("channelType", coding_decoder())
  use filter_by <- decode.optional_field(
    "filterBy",
    [],
    decode.list(subscription_filterby_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(decode.string),
  )
  use managing_entity <- decode.optional_field(
    "managingEntity",
    None,
    decode.optional(reference_decoder()),
  )
  use end <- decode.optional_field("end", None, decode.optional(decode.string))
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactpoint_decoder()),
  )
  use topic <- decode.field("topic", decode.string)
  use status <- decode.field("status", r5valuesets.subscriptionstatus_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscription",
    decode.failure(
      subscription_new(channel_type:, topic:, status:),
      "resourceType",
    ),
  )
  decode.success(Subscription(
    max_count:,
    content:,
    content_type:,
    timeout:,
    heartbeat_period:,
    parameter:,
    endpoint:,
    channel_type:,
    filter_by:,
    reason:,
    managing_entity:,
    end:,
    contact:,
    topic:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionStatus#resource
pub type Subscriptionstatus {
  Subscriptionstatus(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    status: Option(r5valuesets.Subscriptionstatus),
    type_: r5valuesets.Subscriptionnotificationtype,
    events_since_subscription_start: Option(Int),
    notification_event: List(SubscriptionstatusNotificationevent),
    subscription: Reference,
    topic: Option(String),
    error: List(Codeableconcept),
  )
}

pub fn subscriptionstatus_new(
  subscription subscription: Reference,
  type_ type_: r5valuesets.Subscriptionnotificationtype,
) -> Subscriptionstatus {
  Subscriptionstatus(
    error: [],
    topic: None,
    subscription:,
    notification_event: [],
    events_since_subscription_start: None,
    type_:,
    status: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionStatus#resource
pub type SubscriptionstatusNotificationevent {
  SubscriptionstatusNotificationevent(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    event_number: Int,
    timestamp: Option(String),
    focus: Option(Reference),
    additional_context: List(Reference),
  )
}

pub fn subscriptionstatus_notificationevent_new(
  event_number event_number: Int,
) -> SubscriptionstatusNotificationevent {
  SubscriptionstatusNotificationevent(
    additional_context: [],
    focus: None,
    timestamp: None,
    event_number:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscriptionstatus_notificationevent_to_json(
  subscriptionstatus_notificationevent: SubscriptionstatusNotificationevent,
) -> Json {
  let SubscriptionstatusNotificationevent(
    additional_context:,
    focus:,
    timestamp:,
    event_number:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptionstatus_notificationevent
  let fields = [
    #("eventNumber", json.int(event_number)),
  ]
  let fields = case additional_context {
    [] -> fields
    _ -> [
      #("additionalContext", json.array(additional_context, reference_to_json)),
      ..fields
    ]
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case timestamp {
    Some(v) -> [#("timestamp", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptionstatus_notificationevent_decoder() -> Decoder(
  SubscriptionstatusNotificationevent,
) {
  use additional_context <- decode.optional_field(
    "additionalContext",
    [],
    decode.list(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use timestamp <- decode.optional_field(
    "timestamp",
    None,
    decode.optional(decode.string),
  )
  use event_number <- decode.field("eventNumber", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptionstatusNotificationevent(
    additional_context:,
    focus:,
    timestamp:,
    event_number:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptionstatus_to_json(
  subscriptionstatus: Subscriptionstatus,
) -> Json {
  let Subscriptionstatus(
    error:,
    topic:,
    subscription:,
    notification_event:,
    events_since_subscription_start:,
    type_:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscriptionstatus
  let fields = [
    #("subscription", reference_to_json(subscription)),
    #("type", r5valuesets.subscriptionnotificationtype_to_json(type_)),
  ]
  let fields = case error {
    [] -> fields
    _ -> [#("error", json.array(error, codeableconcept_to_json)), ..fields]
  }
  let fields = case topic {
    Some(v) -> [#("topic", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case notification_event {
    [] -> fields
    _ -> [
      #(
        "notificationEvent",
        json.array(
          notification_event,
          subscriptionstatus_notificationevent_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case events_since_subscription_start {
    Some(v) -> [#("eventsSinceSubscriptionStart", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.subscriptionstatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscriptionstatus")), ..fields]
  json.object(fields)
}

pub fn subscriptionstatus_decoder() -> Decoder(Subscriptionstatus) {
  use error <- decode.optional_field(
    "error",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    None,
    decode.optional(decode.string),
  )
  use subscription <- decode.field("subscription", reference_decoder())
  use notification_event <- decode.optional_field(
    "notificationEvent",
    [],
    decode.list(subscriptionstatus_notificationevent_decoder()),
  )
  use events_since_subscription_start <- decode.optional_field(
    "eventsSinceSubscriptionStart",
    None,
    decode.optional(decode.int),
  )
  use type_ <- decode.field(
    "type",
    r5valuesets.subscriptionnotificationtype_decoder(),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.subscriptionstatus_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscriptionstatus",
    decode.failure(
      subscriptionstatus_new(subscription:, type_:),
      "resourceType",
    ),
  )
  decode.success(Subscriptionstatus(
    error:,
    topic:,
    subscription:,
    notification_event:,
    events_since_subscription_start:,
    type_:,
    status:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type Subscriptiontopic {
  Subscriptiontopic(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(SubscriptiontopicVersionalgorithm),
    name: Option(String),
    title: Option(String),
    derived_from: List(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    resource_trigger: List(SubscriptiontopicResourcetrigger),
    event_trigger: List(SubscriptiontopicEventtrigger),
    can_filter_by: List(SubscriptiontopicCanfilterby),
    notification_shape: List(SubscriptiontopicNotificationshape),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicVersionalgorithm {
  SubscriptiontopicVersionalgorithmString(version_algorithm: String)
  SubscriptiontopicVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn subscriptiontopic_versionalgorithm_to_json(
  elt: SubscriptiontopicVersionalgorithm,
) -> Json {
  case elt {
    SubscriptiontopicVersionalgorithmString(v) -> json.string(v)
    SubscriptiontopicVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn subscriptiontopic_versionalgorithm_decoder() -> Decoder(
  SubscriptiontopicVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(SubscriptiontopicVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(SubscriptiontopicVersionalgorithmCoding),
    ],
  )
}

pub fn subscriptiontopic_new(
  status status: r5valuesets.Publicationstatus,
  url url: String,
) -> Subscriptiontopic {
  Subscriptiontopic(
    notification_shape: [],
    can_filter_by: [],
    event_trigger: [],
    resource_trigger: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    derived_from: [],
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url:,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicResourcetrigger {
  SubscriptiontopicResourcetrigger(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    resource: String,
    supported_interaction: List(r5valuesets.Interactiontrigger),
    query_criteria: Option(SubscriptiontopicResourcetriggerQuerycriteria),
    fhir_path_criteria: Option(String),
  )
}

pub fn subscriptiontopic_resourcetrigger_new(
  resource resource: String,
) -> SubscriptiontopicResourcetrigger {
  SubscriptiontopicResourcetrigger(
    fhir_path_criteria: None,
    query_criteria: None,
    supported_interaction: [],
    resource:,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicResourcetriggerQuerycriteria {
  SubscriptiontopicResourcetriggerQuerycriteria(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    previous: Option(String),
    result_for_create: Option(r5valuesets.Subscriptiontopiccrbehavior),
    current: Option(String),
    result_for_delete: Option(r5valuesets.Subscriptiontopiccrbehavior),
    require_both: Option(Bool),
  )
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_new() -> SubscriptiontopicResourcetriggerQuerycriteria {
  SubscriptiontopicResourcetriggerQuerycriteria(
    require_both: None,
    result_for_delete: None,
    current: None,
    result_for_create: None,
    previous: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicEventtrigger {
  SubscriptiontopicEventtrigger(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    event: Codeableconcept,
    resource: String,
  )
}

pub fn subscriptiontopic_eventtrigger_new(
  resource resource: String,
  event event: Codeableconcept,
) -> SubscriptiontopicEventtrigger {
  SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicCanfilterby {
  SubscriptiontopicCanfilterby(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    resource: Option(String),
    filter_parameter: String,
    filter_definition: Option(String),
    comparator: List(r5valuesets.Searchcomparator),
    modifier: List(r5valuesets.Searchmodifiercode),
  )
}

pub fn subscriptiontopic_canfilterby_new(
  filter_parameter filter_parameter: String,
) -> SubscriptiontopicCanfilterby {
  SubscriptiontopicCanfilterby(
    modifier: [],
    comparator: [],
    filter_definition: None,
    filter_parameter:,
    resource: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubscriptionTopic#resource
pub type SubscriptiontopicNotificationshape {
  SubscriptiontopicNotificationshape(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    resource: String,
    include: List(String),
    rev_include: List(String),
  )
}

pub fn subscriptiontopic_notificationshape_new(
  resource resource: String,
) -> SubscriptiontopicNotificationshape {
  SubscriptiontopicNotificationshape(
    rev_include: [],
    include: [],
    resource:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn subscriptiontopic_notificationshape_to_json(
  subscriptiontopic_notificationshape: SubscriptiontopicNotificationshape,
) -> Json {
  let SubscriptiontopicNotificationshape(
    rev_include:,
    include:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_notificationshape
  let fields = [
    #("resource", json.string(resource)),
  ]
  let fields = case rev_include {
    [] -> fields
    _ -> [#("revInclude", json.array(rev_include, json.string)), ..fields]
  }
  let fields = case include {
    [] -> fields
    _ -> [#("include", json.array(include, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_notificationshape_decoder() -> Decoder(
  SubscriptiontopicNotificationshape,
) {
  use rev_include <- decode.optional_field(
    "revInclude",
    [],
    decode.list(decode.string),
  )
  use include <- decode.optional_field(
    "include",
    [],
    decode.list(decode.string),
  )
  use resource <- decode.field("resource", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicNotificationshape(
    rev_include:,
    include:,
    resource:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_canfilterby_to_json(
  subscriptiontopic_canfilterby: SubscriptiontopicCanfilterby,
) -> Json {
  let SubscriptiontopicCanfilterby(
    modifier:,
    comparator:,
    filter_definition:,
    filter_parameter:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_canfilterby
  let fields = [
    #("filterParameter", json.string(filter_parameter)),
  ]
  let fields = case modifier {
    [] -> fields
    _ -> [
      #(
        "modifier",
        json.array(modifier, r5valuesets.searchmodifiercode_to_json),
      ),
      ..fields
    ]
  }
  let fields = case comparator {
    [] -> fields
    _ -> [
      #(
        "comparator",
        json.array(comparator, r5valuesets.searchcomparator_to_json),
      ),
      ..fields
    ]
  }
  let fields = case filter_definition {
    Some(v) -> [#("filterDefinition", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_canfilterby_decoder() -> Decoder(
  SubscriptiontopicCanfilterby,
) {
  use modifier <- decode.optional_field(
    "modifier",
    [],
    decode.list(r5valuesets.searchmodifiercode_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    [],
    decode.list(r5valuesets.searchcomparator_decoder()),
  )
  use filter_definition <- decode.optional_field(
    "filterDefinition",
    None,
    decode.optional(decode.string),
  )
  use filter_parameter <- decode.field("filterParameter", decode.string)
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicCanfilterby(
    modifier:,
    comparator:,
    filter_definition:,
    filter_parameter:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_eventtrigger_to_json(
  subscriptiontopic_eventtrigger: SubscriptiontopicEventtrigger,
) -> Json {
  let SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_eventtrigger
  let fields = [
    #("resource", json.string(resource)),
    #("event", codeableconcept_to_json(event)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_eventtrigger_decoder() -> Decoder(
  SubscriptiontopicEventtrigger,
) {
  use resource <- decode.field("resource", decode.string)
  use event <- decode.field("event", codeableconcept_decoder())
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicEventtrigger(
    resource:,
    event:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_to_json(
  subscriptiontopic_resourcetrigger_querycriteria: SubscriptiontopicResourcetriggerQuerycriteria,
) -> Json {
  let SubscriptiontopicResourcetriggerQuerycriteria(
    require_both:,
    result_for_delete:,
    current:,
    result_for_create:,
    previous:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_resourcetrigger_querycriteria
  let fields = []
  let fields = case require_both {
    Some(v) -> [#("requireBoth", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case result_for_delete {
    Some(v) -> [
      #("resultForDelete", r5valuesets.subscriptiontopiccrbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case current {
    Some(v) -> [#("current", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case result_for_create {
    Some(v) -> [
      #("resultForCreate", r5valuesets.subscriptiontopiccrbehavior_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case previous {
    Some(v) -> [#("previous", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_resourcetrigger_querycriteria_decoder() -> Decoder(
  SubscriptiontopicResourcetriggerQuerycriteria,
) {
  use require_both <- decode.optional_field(
    "requireBoth",
    None,
    decode.optional(decode.bool),
  )
  use result_for_delete <- decode.optional_field(
    "resultForDelete",
    None,
    decode.optional(r5valuesets.subscriptiontopiccrbehavior_decoder()),
  )
  use current <- decode.optional_field(
    "current",
    None,
    decode.optional(decode.string),
  )
  use result_for_create <- decode.optional_field(
    "resultForCreate",
    None,
    decode.optional(r5valuesets.subscriptiontopiccrbehavior_decoder()),
  )
  use previous <- decode.optional_field(
    "previous",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicResourcetriggerQuerycriteria(
    require_both:,
    result_for_delete:,
    current:,
    result_for_create:,
    previous:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_resourcetrigger_to_json(
  subscriptiontopic_resourcetrigger: SubscriptiontopicResourcetrigger,
) -> Json {
  let SubscriptiontopicResourcetrigger(
    fhir_path_criteria:,
    query_criteria:,
    supported_interaction:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = subscriptiontopic_resourcetrigger
  let fields = [
    #("resource", json.string(resource)),
  ]
  let fields = case fhir_path_criteria {
    Some(v) -> [#("fhirPathCriteria", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case query_criteria {
    Some(v) -> [
      #(
        "queryCriteria",
        subscriptiontopic_resourcetrigger_querycriteria_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case supported_interaction {
    [] -> fields
    _ -> [
      #(
        "supportedInteraction",
        json.array(
          supported_interaction,
          r5valuesets.interactiontrigger_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn subscriptiontopic_resourcetrigger_decoder() -> Decoder(
  SubscriptiontopicResourcetrigger,
) {
  use fhir_path_criteria <- decode.optional_field(
    "fhirPathCriteria",
    None,
    decode.optional(decode.string),
  )
  use query_criteria <- decode.optional_field(
    "queryCriteria",
    None,
    decode.optional(subscriptiontopic_resourcetrigger_querycriteria_decoder()),
  )
  use supported_interaction <- decode.optional_field(
    "supportedInteraction",
    [],
    decode.list(r5valuesets.interactiontrigger_decoder()),
  )
  use resource <- decode.field("resource", decode.string)
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubscriptiontopicResourcetrigger(
    fhir_path_criteria:,
    query_criteria:,
    supported_interaction:,
    resource:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn subscriptiontopic_to_json(subscriptiontopic: Subscriptiontopic) -> Json {
  let Subscriptiontopic(
    notification_shape:,
    can_filter_by:,
    event_trigger:,
    resource_trigger:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = subscriptiontopic
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("url", json.string(url)),
  ]
  let fields = case notification_shape {
    [] -> fields
    _ -> [
      #(
        "notificationShape",
        json.array(
          notification_shape,
          subscriptiontopic_notificationshape_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case can_filter_by {
    [] -> fields
    _ -> [
      #(
        "canFilterBy",
        json.array(can_filter_by, subscriptiontopic_canfilterby_to_json),
      ),
      ..fields
    ]
  }
  let fields = case event_trigger {
    [] -> fields
    _ -> [
      #(
        "eventTrigger",
        json.array(event_trigger, subscriptiontopic_eventtrigger_to_json),
      ),
      ..fields
    ]
  }
  let fields = case resource_trigger {
    [] -> fields
    _ -> [
      #(
        "resourceTrigger",
        json.array(resource_trigger, subscriptiontopic_resourcetrigger_to_json),
      ),
      ..fields
    ]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case derived_from {
    [] -> fields
    _ -> [#("derivedFrom", json.array(derived_from, json.string)), ..fields]
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          SubscriptiontopicVersionalgorithmString(_) -> "String"
          SubscriptiontopicVersionalgorithmCoding(_) -> "Coding"
        },
        subscriptiontopic_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Subscriptiontopic")), ..fields]
  json.object(fields)
}

pub fn subscriptiontopic_decoder() -> Decoder(Subscriptiontopic) {
  use notification_shape <- decode.optional_field(
    "notificationShape",
    [],
    decode.list(subscriptiontopic_notificationshape_decoder()),
  )
  use can_filter_by <- decode.optional_field(
    "canFilterBy",
    [],
    decode.list(subscriptiontopic_canfilterby_decoder()),
  )
  use event_trigger <- decode.optional_field(
    "eventTrigger",
    [],
    decode.list(subscriptiontopic_eventtrigger_decoder()),
  )
  use resource_trigger <- decode.optional_field(
    "resourceTrigger",
    [],
    decode.list(subscriptiontopic_resourcetrigger_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use derived_from <- decode.optional_field(
    "derivedFrom",
    [],
    decode.list(decode.string),
  )
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(subscriptiontopic_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Subscriptiontopic",
    decode.failure(subscriptiontopic_new(status:, url:), "resourceType"),
  )
  decode.success(Subscriptiontopic(
    notification_shape:,
    can_filter_by:,
    event_trigger:,
    resource_trigger:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    derived_from:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Substance#resource
pub type Substance {
  Substance(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instance: Bool,
    status: Option(r5valuesets.Substancestatus),
    category: List(Codeableconcept),
    code: Codeablereference,
    description: Option(String),
    expiry: Option(String),
    quantity: Option(Quantity),
    ingredient: List(SubstanceIngredient),
  )
}

pub fn substance_new(
  code code: Codeablereference,
  instance instance: Bool,
) -> Substance {
  Substance(
    ingredient: [],
    quantity: None,
    expiry: None,
    description: None,
    code:,
    category: [],
    status: None,
    instance:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Substance#resource
pub type SubstanceIngredient {
  SubstanceIngredient(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Ratio),
    substance: SubstanceIngredientSubstance,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Substance#resource
pub type SubstanceIngredientSubstance {
  SubstanceIngredientSubstanceCodeableconcept(substance: Codeableconcept)
  SubstanceIngredientSubstanceReference(substance: Reference)
}

pub fn substance_ingredient_substance_to_json(
  elt: SubstanceIngredientSubstance,
) -> Json {
  case elt {
    SubstanceIngredientSubstanceCodeableconcept(v) -> codeableconcept_to_json(v)
    SubstanceIngredientSubstanceReference(v) -> reference_to_json(v)
  }
}

pub fn substance_ingredient_substance_decoder() -> Decoder(
  SubstanceIngredientSubstance,
) {
  decode.one_of(
    decode.field(
      "substanceCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SubstanceIngredientSubstanceCodeableconcept),
    [
      decode.field("substanceReference", reference_decoder(), decode.success)
      |> decode.map(SubstanceIngredientSubstanceReference),
    ],
  )
}

pub fn substance_ingredient_new(
  substance substance: SubstanceIngredientSubstance,
) -> SubstanceIngredient {
  SubstanceIngredient(
    substance:,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substance_ingredient_to_json(
  substance_ingredient: SubstanceIngredient,
) -> Json {
  let SubstanceIngredient(
    substance:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = substance_ingredient
  let fields = [
    #("substance", substance_ingredient_substance_to_json(substance)),
  ]
  let fields = case quantity {
    Some(v) -> [#("quantity", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substance_ingredient_decoder() -> Decoder(SubstanceIngredient) {
  use substance <- decode.then(substance_ingredient_substance_decoder())
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(ratio_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstanceIngredient(
    substance:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substance_to_json(substance: Substance) -> Json {
  let Substance(
    ingredient:,
    quantity:,
    expiry:,
    description:,
    code:,
    category:,
    status:,
    instance:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substance
  let fields = [
    #("code", codeablereference_to_json(code)),
    #("instance", json.bool(instance)),
  ]
  let fields = case ingredient {
    [] -> fields
    _ -> [
      #("ingredient", json.array(ingredient, substance_ingredient_to_json)),
      ..fields
    ]
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expiry {
    Some(v) -> [#("expiry", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.substancestatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substance")), ..fields]
  json.object(fields)
}

pub fn substance_decoder() -> Decoder(Substance) {
  use ingredient <- decode.optional_field(
    "ingredient",
    [],
    decode.list(substance_ingredient_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use expiry <- decode.optional_field(
    "expiry",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", codeablereference_decoder())
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.substancestatus_decoder()),
  )
  use instance <- decode.field("instance", decode.bool)
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substance",
    decode.failure(substance_new(code:, instance:), "resourceType"),
  )
  decode.success(Substance(
    ingredient:,
    quantity:,
    expiry:,
    description:,
    code:,
    category:,
    status:,
    instance:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type Substancedefinition {
  Substancedefinition(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    version: Option(String),
    status: Option(Codeableconcept),
    classification: List(Codeableconcept),
    domain: Option(Codeableconcept),
    grade: List(Codeableconcept),
    description: Option(String),
    information_source: List(Reference),
    note: List(Annotation),
    manufacturer: List(Reference),
    supplier: List(Reference),
    moiety: List(SubstancedefinitionMoiety),
    characterization: List(SubstancedefinitionCharacterization),
    property: List(SubstancedefinitionProperty),
    reference_information: Option(Reference),
    molecular_weight: List(SubstancedefinitionMolecularweight),
    structure: Option(SubstancedefinitionStructure),
    code: List(SubstancedefinitionCode),
    name: List(SubstancedefinitionName),
    relationship: List(SubstancedefinitionRelationship),
    nucleic_acid: Option(Reference),
    polymer: Option(Reference),
    protein: Option(Reference),
    source_material: Option(SubstancedefinitionSourcematerial),
  )
}

pub fn substancedefinition_new() -> Substancedefinition {
  Substancedefinition(
    source_material: None,
    protein: None,
    polymer: None,
    nucleic_acid: None,
    relationship: [],
    name: [],
    code: [],
    structure: None,
    molecular_weight: [],
    reference_information: None,
    property: [],
    characterization: [],
    moiety: [],
    supplier: [],
    manufacturer: [],
    note: [],
    information_source: [],
    description: None,
    grade: [],
    domain: None,
    classification: [],
    status: None,
    version: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMoiety {
  SubstancedefinitionMoiety(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    role: Option(Codeableconcept),
    identifier: Option(Identifier),
    name: Option(String),
    stereochemistry: Option(Codeableconcept),
    optical_activity: Option(Codeableconcept),
    molecular_formula: Option(String),
    amount: Option(SubstancedefinitionMoietyAmount),
    measurement_type: Option(Codeableconcept),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMoietyAmount {
  SubstancedefinitionMoietyAmountQuantity(amount: Quantity)
  SubstancedefinitionMoietyAmountString(amount: String)
}

pub fn substancedefinition_moiety_amount_to_json(
  elt: SubstancedefinitionMoietyAmount,
) -> Json {
  case elt {
    SubstancedefinitionMoietyAmountQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionMoietyAmountString(v) -> json.string(v)
  }
}

pub fn substancedefinition_moiety_amount_decoder() -> Decoder(
  SubstancedefinitionMoietyAmount,
) {
  decode.one_of(
    decode.field("amountQuantity", quantity_decoder(), decode.success)
      |> decode.map(SubstancedefinitionMoietyAmountQuantity),
    [
      decode.field("amountString", decode.string, decode.success)
      |> decode.map(SubstancedefinitionMoietyAmountString),
    ],
  )
}

pub fn substancedefinition_moiety_new() -> SubstancedefinitionMoiety {
  SubstancedefinitionMoiety(
    measurement_type: None,
    amount: None,
    molecular_formula: None,
    optical_activity: None,
    stereochemistry: None,
    name: None,
    identifier: None,
    role: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionCharacterization {
  SubstancedefinitionCharacterization(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    technique: Option(Codeableconcept),
    form: Option(Codeableconcept),
    description: Option(String),
    file: List(Attachment),
  )
}

pub fn substancedefinition_characterization_new() -> SubstancedefinitionCharacterization {
  SubstancedefinitionCharacterization(
    file: [],
    description: None,
    form: None,
    technique: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionProperty {
  SubstancedefinitionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: Option(SubstancedefinitionPropertyValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionPropertyValue {
  SubstancedefinitionPropertyValueCodeableconcept(value: Codeableconcept)
  SubstancedefinitionPropertyValueQuantity(value: Quantity)
  SubstancedefinitionPropertyValueDate(value: String)
  SubstancedefinitionPropertyValueBoolean(value: Bool)
  SubstancedefinitionPropertyValueAttachment(value: Attachment)
}

pub fn substancedefinition_property_value_to_json(
  elt: SubstancedefinitionPropertyValue,
) -> Json {
  case elt {
    SubstancedefinitionPropertyValueCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SubstancedefinitionPropertyValueQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionPropertyValueDate(v) -> json.string(v)
    SubstancedefinitionPropertyValueBoolean(v) -> json.bool(v)
    SubstancedefinitionPropertyValueAttachment(v) -> attachment_to_json(v)
  }
}

pub fn substancedefinition_property_value_decoder() -> Decoder(
  SubstancedefinitionPropertyValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SubstancedefinitionPropertyValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(SubstancedefinitionPropertyValueQuantity),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(SubstancedefinitionPropertyValueDate),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(SubstancedefinitionPropertyValueBoolean),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(SubstancedefinitionPropertyValueAttachment),
    ],
  )
}

pub fn substancedefinition_property_new(
  type_ type_: Codeableconcept,
) -> SubstancedefinitionProperty {
  SubstancedefinitionProperty(
    value: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionMolecularweight {
  SubstancedefinitionMolecularweight(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    method: Option(Codeableconcept),
    type_: Option(Codeableconcept),
    amount: Quantity,
  )
}

pub fn substancedefinition_molecularweight_new(
  amount amount: Quantity,
) -> SubstancedefinitionMolecularweight {
  SubstancedefinitionMolecularweight(
    amount:,
    type_: None,
    method: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionStructure {
  SubstancedefinitionStructure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    stereochemistry: Option(Codeableconcept),
    optical_activity: Option(Codeableconcept),
    molecular_formula: Option(String),
    molecular_formula_by_moiety: Option(String),
    technique: List(Codeableconcept),
    source_document: List(Reference),
    representation: List(SubstancedefinitionStructureRepresentation),
  )
}

pub fn substancedefinition_structure_new() -> SubstancedefinitionStructure {
  SubstancedefinitionStructure(
    representation: [],
    source_document: [],
    technique: [],
    molecular_formula_by_moiety: None,
    molecular_formula: None,
    optical_activity: None,
    stereochemistry: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionStructureRepresentation {
  SubstancedefinitionStructureRepresentation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    representation: Option(String),
    format: Option(Codeableconcept),
    document: Option(Reference),
  )
}

pub fn substancedefinition_structure_representation_new() -> SubstancedefinitionStructureRepresentation {
  SubstancedefinitionStructureRepresentation(
    document: None,
    format: None,
    representation: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionCode {
  SubstancedefinitionCode(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    status: Option(Codeableconcept),
    status_date: Option(String),
    note: List(Annotation),
    source: List(Reference),
  )
}

pub fn substancedefinition_code_new() -> SubstancedefinitionCode {
  SubstancedefinitionCode(
    source: [],
    note: [],
    status_date: None,
    status: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionName {
  SubstancedefinitionName(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    type_: Option(Codeableconcept),
    status: Option(Codeableconcept),
    preferred: Option(Bool),
    language: List(Codeableconcept),
    domain: List(Codeableconcept),
    jurisdiction: List(Codeableconcept),
    official: List(SubstancedefinitionNameOfficial),
    source: List(Reference),
  )
}

pub fn substancedefinition_name_new(
  name name: String,
) -> SubstancedefinitionName {
  SubstancedefinitionName(
    source: [],
    official: [],
    jurisdiction: [],
    domain: [],
    language: [],
    preferred: None,
    status: None,
    type_: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionNameOfficial {
  SubstancedefinitionNameOfficial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    authority: Option(Codeableconcept),
    status: Option(Codeableconcept),
    date: Option(String),
  )
}

pub fn substancedefinition_name_official_new() -> SubstancedefinitionNameOfficial {
  SubstancedefinitionNameOfficial(
    date: None,
    status: None,
    authority: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationship {
  SubstancedefinitionRelationship(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    substance_definition: Option(
      SubstancedefinitionRelationshipSubstancedefinition,
    ),
    type_: Codeableconcept,
    is_defining: Option(Bool),
    amount: Option(SubstancedefinitionRelationshipAmount),
    ratio_high_limit_amount: Option(Ratio),
    comparator: Option(Codeableconcept),
    source: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationshipSubstancedefinition {
  SubstancedefinitionRelationshipSubstancedefinitionReference(
    substance_definition: Reference,
  )
  SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(
    substance_definition: Codeableconcept,
  )
}

pub fn substancedefinition_relationship_substancedefinition_to_json(
  elt: SubstancedefinitionRelationshipSubstancedefinition,
) -> Json {
  case elt {
    SubstancedefinitionRelationshipSubstancedefinitionReference(v) ->
      reference_to_json(v)
    SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(v) ->
      codeableconcept_to_json(v)
  }
}

pub fn substancedefinition_relationship_substancedefinition_decoder() -> Decoder(
  SubstancedefinitionRelationshipSubstancedefinition,
) {
  decode.one_of(
    decode.field(
      "substanceDefinitionReference",
      reference_decoder(),
      decode.success,
    )
      |> decode.map(SubstancedefinitionRelationshipSubstancedefinitionReference),
    [
      decode.field(
        "substanceDefinitionCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
      |> decode.map(
        SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept,
      ),
    ],
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionRelationshipAmount {
  SubstancedefinitionRelationshipAmountQuantity(amount: Quantity)
  SubstancedefinitionRelationshipAmountRatio(amount: Ratio)
  SubstancedefinitionRelationshipAmountString(amount: String)
}

pub fn substancedefinition_relationship_amount_to_json(
  elt: SubstancedefinitionRelationshipAmount,
) -> Json {
  case elt {
    SubstancedefinitionRelationshipAmountQuantity(v) -> quantity_to_json(v)
    SubstancedefinitionRelationshipAmountRatio(v) -> ratio_to_json(v)
    SubstancedefinitionRelationshipAmountString(v) -> json.string(v)
  }
}

pub fn substancedefinition_relationship_amount_decoder() -> Decoder(
  SubstancedefinitionRelationshipAmount,
) {
  decode.one_of(
    decode.field("amountQuantity", quantity_decoder(), decode.success)
      |> decode.map(SubstancedefinitionRelationshipAmountQuantity),
    [
      decode.field("amountRatio", ratio_decoder(), decode.success)
        |> decode.map(SubstancedefinitionRelationshipAmountRatio),
      decode.field("amountString", decode.string, decode.success)
        |> decode.map(SubstancedefinitionRelationshipAmountString),
    ],
  )
}

pub fn substancedefinition_relationship_new(
  type_ type_: Codeableconcept,
) -> SubstancedefinitionRelationship {
  SubstancedefinitionRelationship(
    source: [],
    comparator: None,
    ratio_high_limit_amount: None,
    amount: None,
    is_defining: None,
    type_:,
    substance_definition: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceDefinition#resource
pub type SubstancedefinitionSourcematerial {
  SubstancedefinitionSourcematerial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    genus: Option(Codeableconcept),
    species: Option(Codeableconcept),
    part: Option(Codeableconcept),
    country_of_origin: List(Codeableconcept),
  )
}

pub fn substancedefinition_sourcematerial_new() -> SubstancedefinitionSourcematerial {
  SubstancedefinitionSourcematerial(
    country_of_origin: [],
    part: None,
    species: None,
    genus: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancedefinition_sourcematerial_to_json(
  substancedefinition_sourcematerial: SubstancedefinitionSourcematerial,
) -> Json {
  let SubstancedefinitionSourcematerial(
    country_of_origin:,
    part:,
    species:,
    genus:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_sourcematerial
  let fields = []
  let fields = case country_of_origin {
    [] -> fields
    _ -> [
      #(
        "countryOfOrigin",
        json.array(country_of_origin, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case part {
    Some(v) -> [#("part", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case species {
    Some(v) -> [#("species", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case genus {
    Some(v) -> [#("genus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_sourcematerial_decoder() -> Decoder(
  SubstancedefinitionSourcematerial,
) {
  use country_of_origin <- decode.optional_field(
    "countryOfOrigin",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use species <- decode.optional_field(
    "species",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use genus <- decode.optional_field(
    "genus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionSourcematerial(
    country_of_origin:,
    part:,
    species:,
    genus:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_relationship_to_json(
  substancedefinition_relationship: SubstancedefinitionRelationship,
) -> Json {
  let SubstancedefinitionRelationship(
    source:,
    comparator:,
    ratio_high_limit_amount:,
    amount:,
    is_defining:,
    type_:,
    substance_definition:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_relationship
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case comparator {
    Some(v) -> [#("comparator", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case ratio_high_limit_amount {
    Some(v) -> [#("ratioHighLimitAmount", ratio_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [
      #(
        "amount"
          <> case v {
          SubstancedefinitionRelationshipAmountQuantity(_) -> "Quantity"
          SubstancedefinitionRelationshipAmountRatio(_) -> "Ratio"
          SubstancedefinitionRelationshipAmountString(_) -> "String"
        },
        substancedefinition_relationship_amount_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case is_defining {
    Some(v) -> [#("isDefining", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case substance_definition {
    Some(v) -> [
      #(
        "substanceDefinition"
          <> case v {
          SubstancedefinitionRelationshipSubstancedefinitionReference(_) ->
            "Reference"
          SubstancedefinitionRelationshipSubstancedefinitionCodeableconcept(_) ->
            "Codeableconcept"
        },
        substancedefinition_relationship_substancedefinition_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_relationship_decoder() -> Decoder(
  SubstancedefinitionRelationship,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use comparator <- decode.optional_field(
    "comparator",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use ratio_high_limit_amount <- decode.optional_field(
    "ratioHighLimitAmount",
    None,
    decode.optional(ratio_decoder()),
  )
  use amount <- decode.then(
    none_if_omitted(substancedefinition_relationship_amount_decoder()),
  )
  use is_defining <- decode.optional_field(
    "isDefining",
    None,
    decode.optional(decode.bool),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use substance_definition <- decode.then(
    none_if_omitted(
      substancedefinition_relationship_substancedefinition_decoder(),
    ),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionRelationship(
    source:,
    comparator:,
    ratio_high_limit_amount:,
    amount:,
    is_defining:,
    type_:,
    substance_definition:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_name_official_to_json(
  substancedefinition_name_official: SubstancedefinitionNameOfficial,
) -> Json {
  let SubstancedefinitionNameOfficial(
    date:,
    status:,
    authority:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_name_official
  let fields = []
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authority {
    Some(v) -> [#("authority", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_name_official_decoder() -> Decoder(
  SubstancedefinitionNameOfficial,
) {
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use authority <- decode.optional_field(
    "authority",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionNameOfficial(
    date:,
    status:,
    authority:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_name_to_json(
  substancedefinition_name: SubstancedefinitionName,
) -> Json {
  let SubstancedefinitionName(
    source:,
    official:,
    jurisdiction:,
    domain:,
    language:,
    preferred:,
    status:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_name
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case official {
    [] -> fields
    _ -> [
      #(
        "official",
        json.array(official, substancedefinition_name_official_to_json),
      ),
      ..fields
    ]
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case domain {
    [] -> fields
    _ -> [#("domain", json.array(domain, codeableconcept_to_json)), ..fields]
  }
  let fields = case language {
    [] -> fields
    _ -> [
      #("language", json.array(language, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case preferred {
    Some(v) -> [#("preferred", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_name_decoder() -> Decoder(SubstancedefinitionName) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use official <- decode.optional_field(
    "official",
    [],
    decode.list(substancedefinition_name_official_decoder()),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use preferred <- decode.optional_field(
    "preferred",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionName(
    source:,
    official:,
    jurisdiction:,
    domain:,
    language:,
    preferred:,
    status:,
    type_:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_code_to_json(
  substancedefinition_code: SubstancedefinitionCode,
) -> Json {
  let SubstancedefinitionCode(
    source:,
    note:,
    status_date:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_code
  let fields = []
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_code_decoder() -> Decoder(SubstancedefinitionCode) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionCode(
    source:,
    note:,
    status_date:,
    status:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_structure_representation_to_json(
  substancedefinition_structure_representation: SubstancedefinitionStructureRepresentation,
) -> Json {
  let SubstancedefinitionStructureRepresentation(
    document:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_structure_representation
  let fields = []
  let fields = case document {
    Some(v) -> [#("document", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case format {
    Some(v) -> [#("format", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case representation {
    Some(v) -> [#("representation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_structure_representation_decoder() -> Decoder(
  SubstancedefinitionStructureRepresentation,
) {
  use document <- decode.optional_field(
    "document",
    None,
    decode.optional(reference_decoder()),
  )
  use format <- decode.optional_field(
    "format",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use representation <- decode.optional_field(
    "representation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionStructureRepresentation(
    document:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_structure_to_json(
  substancedefinition_structure: SubstancedefinitionStructure,
) -> Json {
  let SubstancedefinitionStructure(
    representation:,
    source_document:,
    technique:,
    molecular_formula_by_moiety:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_structure
  let fields = []
  let fields = case representation {
    [] -> fields
    _ -> [
      #(
        "representation",
        json.array(
          representation,
          substancedefinition_structure_representation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case source_document {
    [] -> fields
    _ -> [
      #("sourceDocument", json.array(source_document, reference_to_json)),
      ..fields
    ]
  }
  let fields = case technique {
    [] -> fields
    _ -> [
      #("technique", json.array(technique, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case molecular_formula_by_moiety {
    Some(v) -> [#("molecularFormulaByMoiety", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case molecular_formula {
    Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case optical_activity {
    Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case stereochemistry {
    Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_structure_decoder() -> Decoder(
  SubstancedefinitionStructure,
) {
  use representation <- decode.optional_field(
    "representation",
    [],
    decode.list(substancedefinition_structure_representation_decoder()),
  )
  use source_document <- decode.optional_field(
    "sourceDocument",
    [],
    decode.list(reference_decoder()),
  )
  use technique <- decode.optional_field(
    "technique",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use molecular_formula_by_moiety <- decode.optional_field(
    "molecularFormulaByMoiety",
    None,
    decode.optional(decode.string),
  )
  use molecular_formula <- decode.optional_field(
    "molecularFormula",
    None,
    decode.optional(decode.string),
  )
  use optical_activity <- decode.optional_field(
    "opticalActivity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use stereochemistry <- decode.optional_field(
    "stereochemistry",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionStructure(
    representation:,
    source_document:,
    technique:,
    molecular_formula_by_moiety:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_molecularweight_to_json(
  substancedefinition_molecularweight: SubstancedefinitionMolecularweight,
) -> Json {
  let SubstancedefinitionMolecularweight(
    amount:,
    type_:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_molecularweight
  let fields = [
    #("amount", quantity_to_json(amount)),
  ]
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_molecularweight_decoder() -> Decoder(
  SubstancedefinitionMolecularweight,
) {
  use amount <- decode.field("amount", quantity_decoder())
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionMolecularweight(
    amount:,
    type_:,
    method:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_property_to_json(
  substancedefinition_property: SubstancedefinitionProperty,
) -> Json {
  let SubstancedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_property
  let fields = [
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          SubstancedefinitionPropertyValueCodeableconcept(_) ->
            "Codeableconcept"
          SubstancedefinitionPropertyValueQuantity(_) -> "Quantity"
          SubstancedefinitionPropertyValueDate(_) -> "Date"
          SubstancedefinitionPropertyValueBoolean(_) -> "Boolean"
          SubstancedefinitionPropertyValueAttachment(_) -> "Attachment"
        },
        substancedefinition_property_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_property_decoder() -> Decoder(
  SubstancedefinitionProperty,
) {
  use value <- decode.then(
    none_if_omitted(substancedefinition_property_value_decoder()),
  )
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionProperty(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_characterization_to_json(
  substancedefinition_characterization: SubstancedefinitionCharacterization,
) -> Json {
  let SubstancedefinitionCharacterization(
    file:,
    description:,
    form:,
    technique:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_characterization
  let fields = []
  let fields = case file {
    [] -> fields
    _ -> [#("file", json.array(file, attachment_to_json)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case form {
    Some(v) -> [#("form", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case technique {
    Some(v) -> [#("technique", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_characterization_decoder() -> Decoder(
  SubstancedefinitionCharacterization,
) {
  use file <- decode.optional_field(
    "file",
    [],
    decode.list(attachment_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use form <- decode.optional_field(
    "form",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use technique <- decode.optional_field(
    "technique",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionCharacterization(
    file:,
    description:,
    form:,
    technique:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_moiety_to_json(
  substancedefinition_moiety: SubstancedefinitionMoiety,
) -> Json {
  let SubstancedefinitionMoiety(
    measurement_type:,
    amount:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    name:,
    identifier:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancedefinition_moiety
  let fields = []
  let fields = case measurement_type {
    Some(v) -> [#("measurementType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [
      #(
        "amount"
          <> case v {
          SubstancedefinitionMoietyAmountQuantity(_) -> "Quantity"
          SubstancedefinitionMoietyAmountString(_) -> "String"
        },
        substancedefinition_moiety_amount_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case molecular_formula {
    Some(v) -> [#("molecularFormula", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case optical_activity {
    Some(v) -> [#("opticalActivity", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case stereochemistry {
    Some(v) -> [#("stereochemistry", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case role {
    Some(v) -> [#("role", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancedefinition_moiety_decoder() -> Decoder(
  SubstancedefinitionMoiety,
) {
  use measurement_type <- decode.optional_field(
    "measurementType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use amount <- decode.then(
    none_if_omitted(substancedefinition_moiety_amount_decoder()),
  )
  use molecular_formula <- decode.optional_field(
    "molecularFormula",
    None,
    decode.optional(decode.string),
  )
  use optical_activity <- decode.optional_field(
    "opticalActivity",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use stereochemistry <- decode.optional_field(
    "stereochemistry",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use role <- decode.optional_field(
    "role",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancedefinitionMoiety(
    measurement_type:,
    amount:,
    molecular_formula:,
    optical_activity:,
    stereochemistry:,
    name:,
    identifier:,
    role:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancedefinition_to_json(
  substancedefinition: Substancedefinition,
) -> Json {
  let Substancedefinition(
    source_material:,
    protein:,
    polymer:,
    nucleic_acid:,
    relationship:,
    name:,
    code:,
    structure:,
    molecular_weight:,
    reference_information:,
    property:,
    characterization:,
    moiety:,
    supplier:,
    manufacturer:,
    note:,
    information_source:,
    description:,
    grade:,
    domain:,
    classification:,
    status:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancedefinition
  let fields = []
  let fields = case source_material {
    Some(v) -> [
      #("sourceMaterial", substancedefinition_sourcematerial_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case protein {
    Some(v) -> [#("protein", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case polymer {
    Some(v) -> [#("polymer", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case nucleic_acid {
    Some(v) -> [#("nucleicAcid", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relationship {
    [] -> fields
    _ -> [
      #(
        "relationship",
        json.array(relationship, substancedefinition_relationship_to_json),
      ),
      ..fields
    ]
  }
  let fields = case name {
    [] -> fields
    _ -> [
      #("name", json.array(name, substancedefinition_name_to_json)),
      ..fields
    ]
  }
  let fields = case code {
    [] -> fields
    _ -> [
      #("code", json.array(code, substancedefinition_code_to_json)),
      ..fields
    ]
  }
  let fields = case structure {
    Some(v) -> [
      #("structure", substancedefinition_structure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case molecular_weight {
    [] -> fields
    _ -> [
      #(
        "molecularWeight",
        json.array(
          molecular_weight,
          substancedefinition_molecularweight_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case reference_information {
    Some(v) -> [#("referenceInformation", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, substancedefinition_property_to_json)),
      ..fields
    ]
  }
  let fields = case characterization {
    [] -> fields
    _ -> [
      #(
        "characterization",
        json.array(
          characterization,
          substancedefinition_characterization_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case moiety {
    [] -> fields
    _ -> [
      #("moiety", json.array(moiety, substancedefinition_moiety_to_json)),
      ..fields
    ]
  }
  let fields = case supplier {
    [] -> fields
    _ -> [#("supplier", json.array(supplier, reference_to_json)), ..fields]
  }
  let fields = case manufacturer {
    [] -> fields
    _ -> [
      #("manufacturer", json.array(manufacturer, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case information_source {
    [] -> fields
    _ -> [
      #("informationSource", json.array(information_source, reference_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case grade {
    [] -> fields
    _ -> [#("grade", json.array(grade, codeableconcept_to_json)), ..fields]
  }
  let fields = case domain {
    Some(v) -> [#("domain", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case classification {
    [] -> fields
    _ -> [
      #("classification", json.array(classification, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case status {
    Some(v) -> [#("status", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substancedefinition")), ..fields]
  json.object(fields)
}

pub fn substancedefinition_decoder() -> Decoder(Substancedefinition) {
  use source_material <- decode.optional_field(
    "sourceMaterial",
    None,
    decode.optional(substancedefinition_sourcematerial_decoder()),
  )
  use protein <- decode.optional_field(
    "protein",
    None,
    decode.optional(reference_decoder()),
  )
  use polymer <- decode.optional_field(
    "polymer",
    None,
    decode.optional(reference_decoder()),
  )
  use nucleic_acid <- decode.optional_field(
    "nucleicAcid",
    None,
    decode.optional(reference_decoder()),
  )
  use relationship <- decode.optional_field(
    "relationship",
    [],
    decode.list(substancedefinition_relationship_decoder()),
  )
  use name <- decode.optional_field(
    "name",
    [],
    decode.list(substancedefinition_name_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    [],
    decode.list(substancedefinition_code_decoder()),
  )
  use structure <- decode.optional_field(
    "structure",
    None,
    decode.optional(substancedefinition_structure_decoder()),
  )
  use molecular_weight <- decode.optional_field(
    "molecularWeight",
    [],
    decode.list(substancedefinition_molecularweight_decoder()),
  )
  use reference_information <- decode.optional_field(
    "referenceInformation",
    None,
    decode.optional(reference_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(substancedefinition_property_decoder()),
  )
  use characterization <- decode.optional_field(
    "characterization",
    [],
    decode.list(substancedefinition_characterization_decoder()),
  )
  use moiety <- decode.optional_field(
    "moiety",
    [],
    decode.list(substancedefinition_moiety_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    [],
    decode.list(reference_decoder()),
  )
  use manufacturer <- decode.optional_field(
    "manufacturer",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use information_source <- decode.optional_field(
    "informationSource",
    [],
    decode.list(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use grade <- decode.optional_field(
    "grade",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use domain <- decode.optional_field(
    "domain",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use classification <- decode.optional_field(
    "classification",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancedefinition",
    decode.failure(substancedefinition_new(), "resourceType"),
  )
  decode.success(Substancedefinition(
    source_material:,
    protein:,
    polymer:,
    nucleic_acid:,
    relationship:,
    name:,
    code:,
    structure:,
    molecular_weight:,
    reference_information:,
    property:,
    characterization:,
    moiety:,
    supplier:,
    manufacturer:,
    note:,
    information_source:,
    description:,
    grade:,
    domain:,
    classification:,
    status:,
    version:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceNucleicAcid#resource
pub type Substancenucleicacid {
  Substancenucleicacid(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence_type: Option(Codeableconcept),
    number_of_subunits: Option(Int),
    area_of_hybridisation: Option(String),
    oligo_nucleotide_type: Option(Codeableconcept),
    subunit: List(SubstancenucleicacidSubunit),
  )
}

pub fn substancenucleicacid_new() -> Substancenucleicacid {
  Substancenucleicacid(
    subunit: [],
    oligo_nucleotide_type: None,
    area_of_hybridisation: None,
    number_of_subunits: None,
    sequence_type: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunit {
  SubstancenucleicacidSubunit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    subunit: Option(Int),
    sequence: Option(String),
    length: Option(Int),
    sequence_attachment: Option(Attachment),
    five_prime: Option(Codeableconcept),
    three_prime: Option(Codeableconcept),
    linkage: List(SubstancenucleicacidSubunitLinkage),
    sugar: List(SubstancenucleicacidSubunitSugar),
  )
}

pub fn substancenucleicacid_subunit_new() -> SubstancenucleicacidSubunit {
  SubstancenucleicacidSubunit(
    sugar: [],
    linkage: [],
    three_prime: None,
    five_prime: None,
    sequence_attachment: None,
    length: None,
    sequence: None,
    subunit: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunitLinkage {
  SubstancenucleicacidSubunitLinkage(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    connectivity: Option(String),
    identifier: Option(Identifier),
    name: Option(String),
    residue_site: Option(String),
  )
}

pub fn substancenucleicacid_subunit_linkage_new() -> SubstancenucleicacidSubunitLinkage {
  SubstancenucleicacidSubunitLinkage(
    residue_site: None,
    name: None,
    identifier: None,
    connectivity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceNucleicAcid#resource
pub type SubstancenucleicacidSubunitSugar {
  SubstancenucleicacidSubunitSugar(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    name: Option(String),
    residue_site: Option(String),
  )
}

pub fn substancenucleicacid_subunit_sugar_new() -> SubstancenucleicacidSubunitSugar {
  SubstancenucleicacidSubunitSugar(
    residue_site: None,
    name: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancenucleicacid_subunit_sugar_to_json(
  substancenucleicacid_subunit_sugar: SubstancenucleicacidSubunitSugar,
) -> Json {
  let SubstancenucleicacidSubunitSugar(
    residue_site:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancenucleicacid_subunit_sugar
  let fields = []
  let fields = case residue_site {
    Some(v) -> [#("residueSite", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancenucleicacid_subunit_sugar_decoder() -> Decoder(
  SubstancenucleicacidSubunitSugar,
) {
  use residue_site <- decode.optional_field(
    "residueSite",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancenucleicacidSubunitSugar(
    residue_site:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancenucleicacid_subunit_linkage_to_json(
  substancenucleicacid_subunit_linkage: SubstancenucleicacidSubunitLinkage,
) -> Json {
  let SubstancenucleicacidSubunitLinkage(
    residue_site:,
    name:,
    identifier:,
    connectivity:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancenucleicacid_subunit_linkage
  let fields = []
  let fields = case residue_site {
    Some(v) -> [#("residueSite", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case connectivity {
    Some(v) -> [#("connectivity", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancenucleicacid_subunit_linkage_decoder() -> Decoder(
  SubstancenucleicacidSubunitLinkage,
) {
  use residue_site <- decode.optional_field(
    "residueSite",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use connectivity <- decode.optional_field(
    "connectivity",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancenucleicacidSubunitLinkage(
    residue_site:,
    name:,
    identifier:,
    connectivity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancenucleicacid_subunit_to_json(
  substancenucleicacid_subunit: SubstancenucleicacidSubunit,
) -> Json {
  let SubstancenucleicacidSubunit(
    sugar:,
    linkage:,
    three_prime:,
    five_prime:,
    sequence_attachment:,
    length:,
    sequence:,
    subunit:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancenucleicacid_subunit
  let fields = []
  let fields = case sugar {
    [] -> fields
    _ -> [
      #("sugar", json.array(sugar, substancenucleicacid_subunit_sugar_to_json)),
      ..fields
    ]
  }
  let fields = case linkage {
    [] -> fields
    _ -> [
      #(
        "linkage",
        json.array(linkage, substancenucleicacid_subunit_linkage_to_json),
      ),
      ..fields
    ]
  }
  let fields = case three_prime {
    Some(v) -> [#("threePrime", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case five_prime {
    Some(v) -> [#("fivePrime", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sequence_attachment {
    Some(v) -> [#("sequenceAttachment", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case length {
    Some(v) -> [#("length", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subunit {
    Some(v) -> [#("subunit", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancenucleicacid_subunit_decoder() -> Decoder(
  SubstancenucleicacidSubunit,
) {
  use sugar <- decode.optional_field(
    "sugar",
    [],
    decode.list(substancenucleicacid_subunit_sugar_decoder()),
  )
  use linkage <- decode.optional_field(
    "linkage",
    [],
    decode.list(substancenucleicacid_subunit_linkage_decoder()),
  )
  use three_prime <- decode.optional_field(
    "threePrime",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use five_prime <- decode.optional_field(
    "fivePrime",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use sequence_attachment <- decode.optional_field(
    "sequenceAttachment",
    None,
    decode.optional(attachment_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(decode.int),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.string),
  )
  use subunit <- decode.optional_field(
    "subunit",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancenucleicacidSubunit(
    sugar:,
    linkage:,
    three_prime:,
    five_prime:,
    sequence_attachment:,
    length:,
    sequence:,
    subunit:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancenucleicacid_to_json(
  substancenucleicacid: Substancenucleicacid,
) -> Json {
  let Substancenucleicacid(
    subunit:,
    oligo_nucleotide_type:,
    area_of_hybridisation:,
    number_of_subunits:,
    sequence_type:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancenucleicacid
  let fields = []
  let fields = case subunit {
    [] -> fields
    _ -> [
      #("subunit", json.array(subunit, substancenucleicacid_subunit_to_json)),
      ..fields
    ]
  }
  let fields = case oligo_nucleotide_type {
    Some(v) -> [#("oligoNucleotideType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case area_of_hybridisation {
    Some(v) -> [#("areaOfHybridisation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case number_of_subunits {
    Some(v) -> [#("numberOfSubunits", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sequence_type {
    Some(v) -> [#("sequenceType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Substancenucleicacid")),
    ..fields
  ]
  json.object(fields)
}

pub fn substancenucleicacid_decoder() -> Decoder(Substancenucleicacid) {
  use subunit <- decode.optional_field(
    "subunit",
    [],
    decode.list(substancenucleicacid_subunit_decoder()),
  )
  use oligo_nucleotide_type <- decode.optional_field(
    "oligoNucleotideType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use area_of_hybridisation <- decode.optional_field(
    "areaOfHybridisation",
    None,
    decode.optional(decode.string),
  )
  use number_of_subunits <- decode.optional_field(
    "numberOfSubunits",
    None,
    decode.optional(decode.int),
  )
  use sequence_type <- decode.optional_field(
    "sequenceType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancenucleicacid",
    decode.failure(substancenucleicacid_new(), "resourceType"),
  )
  decode.success(Substancenucleicacid(
    subunit:,
    oligo_nucleotide_type:,
    area_of_hybridisation:,
    number_of_subunits:,
    sequence_type:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type Substancepolymer {
  Substancepolymer(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    class: Option(Codeableconcept),
    geometry: Option(Codeableconcept),
    copolymer_connectivity: List(Codeableconcept),
    modification: Option(String),
    monomer_set: List(SubstancepolymerMonomerset),
    repeat: List(SubstancepolymerRepeat),
  )
}

pub fn substancepolymer_new() -> Substancepolymer {
  Substancepolymer(
    repeat: [],
    monomer_set: [],
    modification: None,
    copolymer_connectivity: [],
    geometry: None,
    class: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerMonomerset {
  SubstancepolymerMonomerset(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    ratio_type: Option(Codeableconcept),
    starting_material: List(SubstancepolymerMonomersetStartingmaterial),
  )
}

pub fn substancepolymer_monomerset_new() -> SubstancepolymerMonomerset {
  SubstancepolymerMonomerset(
    starting_material: [],
    ratio_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerMonomersetStartingmaterial {
  SubstancepolymerMonomersetStartingmaterial(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    category: Option(Codeableconcept),
    is_defining: Option(Bool),
    amount: Option(Quantity),
  )
}

pub fn substancepolymer_monomerset_startingmaterial_new() -> SubstancepolymerMonomersetStartingmaterial {
  SubstancepolymerMonomersetStartingmaterial(
    amount: None,
    is_defining: None,
    category: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeat {
  SubstancepolymerRepeat(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    average_molecular_formula: Option(String),
    repeat_unit_amount_type: Option(Codeableconcept),
    repeat_unit: List(SubstancepolymerRepeatRepeatunit),
  )
}

pub fn substancepolymer_repeat_new() -> SubstancepolymerRepeat {
  SubstancepolymerRepeat(
    repeat_unit: [],
    repeat_unit_amount_type: None,
    average_molecular_formula: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunit {
  SubstancepolymerRepeatRepeatunit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    unit: Option(String),
    orientation: Option(Codeableconcept),
    amount: Option(Int),
    degree_of_polymerisation: List(
      SubstancepolymerRepeatRepeatunitDegreeofpolymerisation,
    ),
    structural_representation: List(
      SubstancepolymerRepeatRepeatunitStructuralrepresentation,
    ),
  )
}

pub fn substancepolymer_repeat_repeatunit_new() -> SubstancepolymerRepeatRepeatunit {
  SubstancepolymerRepeatRepeatunit(
    structural_representation: [],
    degree_of_polymerisation: [],
    amount: None,
    orientation: None,
    unit: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunitDegreeofpolymerisation {
  SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    average: Option(Int),
    low: Option(Int),
    high: Option(Int),
  )
}

pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_new() -> SubstancepolymerRepeatRepeatunitDegreeofpolymerisation {
  SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(
    high: None,
    low: None,
    average: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstancePolymer#resource
pub type SubstancepolymerRepeatRepeatunitStructuralrepresentation {
  SubstancepolymerRepeatRepeatunitStructuralrepresentation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    representation: Option(String),
    format: Option(Codeableconcept),
    attachment: Option(Attachment),
  )
}

pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_new() -> SubstancepolymerRepeatRepeatunitStructuralrepresentation {
  SubstancepolymerRepeatRepeatunitStructuralrepresentation(
    attachment: None,
    format: None,
    representation: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_to_json(
  substancepolymer_repeat_repeatunit_structuralrepresentation: SubstancepolymerRepeatRepeatunitStructuralrepresentation,
) -> Json {
  let SubstancepolymerRepeatRepeatunitStructuralrepresentation(
    attachment:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_repeat_repeatunit_structuralrepresentation
  let fields = []
  let fields = case attachment {
    Some(v) -> [#("attachment", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case format {
    Some(v) -> [#("format", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case representation {
    Some(v) -> [#("representation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_repeat_repeatunit_structuralrepresentation_decoder() -> Decoder(
  SubstancepolymerRepeatRepeatunitStructuralrepresentation,
) {
  use attachment <- decode.optional_field(
    "attachment",
    None,
    decode.optional(attachment_decoder()),
  )
  use format <- decode.optional_field(
    "format",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use representation <- decode.optional_field(
    "representation",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerRepeatRepeatunitStructuralrepresentation(
    attachment:,
    format:,
    representation:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_to_json(
  substancepolymer_repeat_repeatunit_degreeofpolymerisation: SubstancepolymerRepeatRepeatunitDegreeofpolymerisation,
) -> Json {
  let SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(
    high:,
    low:,
    average:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_repeat_repeatunit_degreeofpolymerisation
  let fields = []
  let fields = case high {
    Some(v) -> [#("high", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case low {
    Some(v) -> [#("low", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case average {
    Some(v) -> [#("average", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_repeat_repeatunit_degreeofpolymerisation_decoder() -> Decoder(
  SubstancepolymerRepeatRepeatunitDegreeofpolymerisation,
) {
  use high <- decode.optional_field("high", None, decode.optional(decode.int))
  use low <- decode.optional_field("low", None, decode.optional(decode.int))
  use average <- decode.optional_field(
    "average",
    None,
    decode.optional(decode.int),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerRepeatRepeatunitDegreeofpolymerisation(
    high:,
    low:,
    average:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_repeat_repeatunit_to_json(
  substancepolymer_repeat_repeatunit: SubstancepolymerRepeatRepeatunit,
) -> Json {
  let SubstancepolymerRepeatRepeatunit(
    structural_representation:,
    degree_of_polymerisation:,
    amount:,
    orientation:,
    unit:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_repeat_repeatunit
  let fields = []
  let fields = case structural_representation {
    [] -> fields
    _ -> [
      #(
        "structuralRepresentation",
        json.array(
          structural_representation,
          substancepolymer_repeat_repeatunit_structuralrepresentation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case degree_of_polymerisation {
    [] -> fields
    _ -> [
      #(
        "degreeOfPolymerisation",
        json.array(
          degree_of_polymerisation,
          substancepolymer_repeat_repeatunit_degreeofpolymerisation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case amount {
    Some(v) -> [#("amount", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case orientation {
    Some(v) -> [#("orientation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case unit {
    Some(v) -> [#("unit", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_repeat_repeatunit_decoder() -> Decoder(
  SubstancepolymerRepeatRepeatunit,
) {
  use structural_representation <- decode.optional_field(
    "structuralRepresentation",
    [],
    decode.list(
      substancepolymer_repeat_repeatunit_structuralrepresentation_decoder(),
    ),
  )
  use degree_of_polymerisation <- decode.optional_field(
    "degreeOfPolymerisation",
    [],
    decode.list(
      substancepolymer_repeat_repeatunit_degreeofpolymerisation_decoder(),
    ),
  )
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(decode.int),
  )
  use orientation <- decode.optional_field(
    "orientation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use unit <- decode.optional_field(
    "unit",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerRepeatRepeatunit(
    structural_representation:,
    degree_of_polymerisation:,
    amount:,
    orientation:,
    unit:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_repeat_to_json(
  substancepolymer_repeat: SubstancepolymerRepeat,
) -> Json {
  let SubstancepolymerRepeat(
    repeat_unit:,
    repeat_unit_amount_type:,
    average_molecular_formula:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_repeat
  let fields = []
  let fields = case repeat_unit {
    [] -> fields
    _ -> [
      #(
        "repeatUnit",
        json.array(repeat_unit, substancepolymer_repeat_repeatunit_to_json),
      ),
      ..fields
    ]
  }
  let fields = case repeat_unit_amount_type {
    Some(v) -> [#("repeatUnitAmountType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case average_molecular_formula {
    Some(v) -> [#("averageMolecularFormula", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_repeat_decoder() -> Decoder(SubstancepolymerRepeat) {
  use repeat_unit <- decode.optional_field(
    "repeatUnit",
    [],
    decode.list(substancepolymer_repeat_repeatunit_decoder()),
  )
  use repeat_unit_amount_type <- decode.optional_field(
    "repeatUnitAmountType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use average_molecular_formula <- decode.optional_field(
    "averageMolecularFormula",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerRepeat(
    repeat_unit:,
    repeat_unit_amount_type:,
    average_molecular_formula:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_monomerset_startingmaterial_to_json(
  substancepolymer_monomerset_startingmaterial: SubstancepolymerMonomersetStartingmaterial,
) -> Json {
  let SubstancepolymerMonomersetStartingmaterial(
    amount:,
    is_defining:,
    category:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_monomerset_startingmaterial
  let fields = []
  let fields = case amount {
    Some(v) -> [#("amount", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case is_defining {
    Some(v) -> [#("isDefining", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_monomerset_startingmaterial_decoder() -> Decoder(
  SubstancepolymerMonomersetStartingmaterial,
) {
  use amount <- decode.optional_field(
    "amount",
    None,
    decode.optional(quantity_decoder()),
  )
  use is_defining <- decode.optional_field(
    "isDefining",
    None,
    decode.optional(decode.bool),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerMonomersetStartingmaterial(
    amount:,
    is_defining:,
    category:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_monomerset_to_json(
  substancepolymer_monomerset: SubstancepolymerMonomerset,
) -> Json {
  let SubstancepolymerMonomerset(
    starting_material:,
    ratio_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancepolymer_monomerset
  let fields = []
  let fields = case starting_material {
    [] -> fields
    _ -> [
      #(
        "startingMaterial",
        json.array(
          starting_material,
          substancepolymer_monomerset_startingmaterial_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case ratio_type {
    Some(v) -> [#("ratioType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancepolymer_monomerset_decoder() -> Decoder(
  SubstancepolymerMonomerset,
) {
  use starting_material <- decode.optional_field(
    "startingMaterial",
    [],
    decode.list(substancepolymer_monomerset_startingmaterial_decoder()),
  )
  use ratio_type <- decode.optional_field(
    "ratioType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancepolymerMonomerset(
    starting_material:,
    ratio_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancepolymer_to_json(substancepolymer: Substancepolymer) -> Json {
  let Substancepolymer(
    repeat:,
    monomer_set:,
    modification:,
    copolymer_connectivity:,
    geometry:,
    class:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancepolymer
  let fields = []
  let fields = case repeat {
    [] -> fields
    _ -> [
      #("repeat", json.array(repeat, substancepolymer_repeat_to_json)),
      ..fields
    ]
  }
  let fields = case monomer_set {
    [] -> fields
    _ -> [
      #(
        "monomerSet",
        json.array(monomer_set, substancepolymer_monomerset_to_json),
      ),
      ..fields
    ]
  }
  let fields = case modification {
    Some(v) -> [#("modification", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copolymer_connectivity {
    [] -> fields
    _ -> [
      #(
        "copolymerConnectivity",
        json.array(copolymer_connectivity, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case geometry {
    Some(v) -> [#("geometry", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case class {
    Some(v) -> [#("class", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substancepolymer")), ..fields]
  json.object(fields)
}

pub fn substancepolymer_decoder() -> Decoder(Substancepolymer) {
  use repeat <- decode.optional_field(
    "repeat",
    [],
    decode.list(substancepolymer_repeat_decoder()),
  )
  use monomer_set <- decode.optional_field(
    "monomerSet",
    [],
    decode.list(substancepolymer_monomerset_decoder()),
  )
  use modification <- decode.optional_field(
    "modification",
    None,
    decode.optional(decode.string),
  )
  use copolymer_connectivity <- decode.optional_field(
    "copolymerConnectivity",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use geometry <- decode.optional_field(
    "geometry",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use class <- decode.optional_field(
    "class",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancepolymer",
    decode.failure(substancepolymer_new(), "resourceType"),
  )
  decode.success(Substancepolymer(
    repeat:,
    monomer_set:,
    modification:,
    copolymer_connectivity:,
    geometry:,
    class:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceProtein#resource
pub type Substanceprotein {
  Substanceprotein(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence_type: Option(Codeableconcept),
    number_of_subunits: Option(Int),
    disulfide_linkage: List(String),
    subunit: List(SubstanceproteinSubunit),
  )
}

pub fn substanceprotein_new() -> Substanceprotein {
  Substanceprotein(
    subunit: [],
    disulfide_linkage: [],
    number_of_subunits: None,
    sequence_type: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceProtein#resource
pub type SubstanceproteinSubunit {
  SubstanceproteinSubunit(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    subunit: Option(Int),
    sequence: Option(String),
    length: Option(Int),
    sequence_attachment: Option(Attachment),
    n_terminal_modification_id: Option(Identifier),
    n_terminal_modification: Option(String),
    c_terminal_modification_id: Option(Identifier),
    c_terminal_modification: Option(String),
  )
}

pub fn substanceprotein_subunit_new() -> SubstanceproteinSubunit {
  SubstanceproteinSubunit(
    c_terminal_modification: None,
    c_terminal_modification_id: None,
    n_terminal_modification: None,
    n_terminal_modification_id: None,
    sequence_attachment: None,
    length: None,
    sequence: None,
    subunit: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substanceprotein_subunit_to_json(
  substanceprotein_subunit: SubstanceproteinSubunit,
) -> Json {
  let SubstanceproteinSubunit(
    c_terminal_modification:,
    c_terminal_modification_id:,
    n_terminal_modification:,
    n_terminal_modification_id:,
    sequence_attachment:,
    length:,
    sequence:,
    subunit:,
    modifier_extension:,
    extension:,
    id:,
  ) = substanceprotein_subunit
  let fields = []
  let fields = case c_terminal_modification {
    Some(v) -> [#("cTerminalModification", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case c_terminal_modification_id {
    Some(v) -> [#("cTerminalModificationId", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case n_terminal_modification {
    Some(v) -> [#("nTerminalModification", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case n_terminal_modification_id {
    Some(v) -> [#("nTerminalModificationId", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case sequence_attachment {
    Some(v) -> [#("sequenceAttachment", attachment_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case length {
    Some(v) -> [#("length", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case subunit {
    Some(v) -> [#("subunit", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substanceprotein_subunit_decoder() -> Decoder(SubstanceproteinSubunit) {
  use c_terminal_modification <- decode.optional_field(
    "cTerminalModification",
    None,
    decode.optional(decode.string),
  )
  use c_terminal_modification_id <- decode.optional_field(
    "cTerminalModificationId",
    None,
    decode.optional(identifier_decoder()),
  )
  use n_terminal_modification <- decode.optional_field(
    "nTerminalModification",
    None,
    decode.optional(decode.string),
  )
  use n_terminal_modification_id <- decode.optional_field(
    "nTerminalModificationId",
    None,
    decode.optional(identifier_decoder()),
  )
  use sequence_attachment <- decode.optional_field(
    "sequenceAttachment",
    None,
    decode.optional(attachment_decoder()),
  )
  use length <- decode.optional_field(
    "length",
    None,
    decode.optional(decode.int),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.string),
  )
  use subunit <- decode.optional_field(
    "subunit",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstanceproteinSubunit(
    c_terminal_modification:,
    c_terminal_modification_id:,
    n_terminal_modification:,
    n_terminal_modification_id:,
    sequence_attachment:,
    length:,
    sequence:,
    subunit:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substanceprotein_to_json(substanceprotein: Substanceprotein) -> Json {
  let Substanceprotein(
    subunit:,
    disulfide_linkage:,
    number_of_subunits:,
    sequence_type:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substanceprotein
  let fields = []
  let fields = case subunit {
    [] -> fields
    _ -> [
      #("subunit", json.array(subunit, substanceprotein_subunit_to_json)),
      ..fields
    ]
  }
  let fields = case disulfide_linkage {
    [] -> fields
    _ -> [
      #("disulfideLinkage", json.array(disulfide_linkage, json.string)),
      ..fields
    ]
  }
  let fields = case number_of_subunits {
    Some(v) -> [#("numberOfSubunits", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case sequence_type {
    Some(v) -> [#("sequenceType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Substanceprotein")), ..fields]
  json.object(fields)
}

pub fn substanceprotein_decoder() -> Decoder(Substanceprotein) {
  use subunit <- decode.optional_field(
    "subunit",
    [],
    decode.list(substanceprotein_subunit_decoder()),
  )
  use disulfide_linkage <- decode.optional_field(
    "disulfideLinkage",
    [],
    decode.list(decode.string),
  )
  use number_of_subunits <- decode.optional_field(
    "numberOfSubunits",
    None,
    decode.optional(decode.int),
  )
  use sequence_type <- decode.optional_field(
    "sequenceType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substanceprotein",
    decode.failure(substanceprotein_new(), "resourceType"),
  )
  decode.success(Substanceprotein(
    subunit:,
    disulfide_linkage:,
    number_of_subunits:,
    sequence_type:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceReferenceInformation#resource
pub type Substancereferenceinformation {
  Substancereferenceinformation(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    comment: Option(String),
    gene: List(SubstancereferenceinformationGene),
    gene_element: List(SubstancereferenceinformationGeneelement),
    target: List(SubstancereferenceinformationTarget),
  )
}

pub fn substancereferenceinformation_new() -> Substancereferenceinformation {
  Substancereferenceinformation(
    target: [],
    gene_element: [],
    gene: [],
    comment: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationGene {
  SubstancereferenceinformationGene(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    gene_sequence_origin: Option(Codeableconcept),
    gene: Option(Codeableconcept),
    source: List(Reference),
  )
}

pub fn substancereferenceinformation_gene_new() -> SubstancereferenceinformationGene {
  SubstancereferenceinformationGene(
    source: [],
    gene: None,
    gene_sequence_origin: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationGeneelement {
  SubstancereferenceinformationGeneelement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Codeableconcept),
    element: Option(Identifier),
    source: List(Reference),
  )
}

pub fn substancereferenceinformation_geneelement_new() -> SubstancereferenceinformationGeneelement {
  SubstancereferenceinformationGeneelement(
    source: [],
    element: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationTarget {
  SubstancereferenceinformationTarget(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: Option(Identifier),
    type_: Option(Codeableconcept),
    interaction: Option(Codeableconcept),
    organism: Option(Codeableconcept),
    organism_type: Option(Codeableconcept),
    amount: Option(SubstancereferenceinformationTargetAmount),
    amount_type: Option(Codeableconcept),
    source: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceReferenceInformation#resource
pub type SubstancereferenceinformationTargetAmount {
  SubstancereferenceinformationTargetAmountQuantity(amount: Quantity)
  SubstancereferenceinformationTargetAmountRange(amount: Range)
  SubstancereferenceinformationTargetAmountString(amount: String)
}

pub fn substancereferenceinformation_target_amount_to_json(
  elt: SubstancereferenceinformationTargetAmount,
) -> Json {
  case elt {
    SubstancereferenceinformationTargetAmountQuantity(v) -> quantity_to_json(v)
    SubstancereferenceinformationTargetAmountRange(v) -> range_to_json(v)
    SubstancereferenceinformationTargetAmountString(v) -> json.string(v)
  }
}

pub fn substancereferenceinformation_target_amount_decoder() -> Decoder(
  SubstancereferenceinformationTargetAmount,
) {
  decode.one_of(
    decode.field("amountQuantity", quantity_decoder(), decode.success)
      |> decode.map(SubstancereferenceinformationTargetAmountQuantity),
    [
      decode.field("amountRange", range_decoder(), decode.success)
        |> decode.map(SubstancereferenceinformationTargetAmountRange),
      decode.field("amountString", decode.string, decode.success)
        |> decode.map(SubstancereferenceinformationTargetAmountString),
    ],
  )
}

pub fn substancereferenceinformation_target_new() -> SubstancereferenceinformationTarget {
  SubstancereferenceinformationTarget(
    source: [],
    amount_type: None,
    amount: None,
    organism_type: None,
    organism: None,
    interaction: None,
    type_: None,
    target: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancereferenceinformation_target_to_json(
  substancereferenceinformation_target: SubstancereferenceinformationTarget,
) -> Json {
  let SubstancereferenceinformationTarget(
    source:,
    amount_type:,
    amount:,
    organism_type:,
    organism:,
    interaction:,
    type_:,
    target:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancereferenceinformation_target
  let fields = []
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case amount_type {
    Some(v) -> [#("amountType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case amount {
    Some(v) -> [
      #(
        "amount"
          <> case v {
          SubstancereferenceinformationTargetAmountQuantity(_) -> "Quantity"
          SubstancereferenceinformationTargetAmountRange(_) -> "Range"
          SubstancereferenceinformationTargetAmountString(_) -> "String"
        },
        substancereferenceinformation_target_amount_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case organism_type {
    Some(v) -> [#("organismType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case organism {
    Some(v) -> [#("organism", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case interaction {
    Some(v) -> [#("interaction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target {
    Some(v) -> [#("target", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancereferenceinformation_target_decoder() -> Decoder(
  SubstancereferenceinformationTarget,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use amount_type <- decode.optional_field(
    "amountType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use amount <- decode.then(
    none_if_omitted(substancereferenceinformation_target_amount_decoder()),
  )
  use organism_type <- decode.optional_field(
    "organismType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use organism <- decode.optional_field(
    "organism",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use interaction <- decode.optional_field(
    "interaction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use target <- decode.optional_field(
    "target",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancereferenceinformationTarget(
    source:,
    amount_type:,
    amount:,
    organism_type:,
    organism:,
    interaction:,
    type_:,
    target:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancereferenceinformation_geneelement_to_json(
  substancereferenceinformation_geneelement: SubstancereferenceinformationGeneelement,
) -> Json {
  let SubstancereferenceinformationGeneelement(
    source:,
    element:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancereferenceinformation_geneelement
  let fields = []
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case element {
    Some(v) -> [#("element", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancereferenceinformation_geneelement_decoder() -> Decoder(
  SubstancereferenceinformationGeneelement,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use element <- decode.optional_field(
    "element",
    None,
    decode.optional(identifier_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancereferenceinformationGeneelement(
    source:,
    element:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancereferenceinformation_gene_to_json(
  substancereferenceinformation_gene: SubstancereferenceinformationGene,
) -> Json {
  let SubstancereferenceinformationGene(
    source:,
    gene:,
    gene_sequence_origin:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancereferenceinformation_gene
  let fields = []
  let fields = case source {
    [] -> fields
    _ -> [#("source", json.array(source, reference_to_json)), ..fields]
  }
  let fields = case gene {
    Some(v) -> [#("gene", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case gene_sequence_origin {
    Some(v) -> [#("geneSequenceOrigin", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancereferenceinformation_gene_decoder() -> Decoder(
  SubstancereferenceinformationGene,
) {
  use source <- decode.optional_field(
    "source",
    [],
    decode.list(reference_decoder()),
  )
  use gene <- decode.optional_field(
    "gene",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use gene_sequence_origin <- decode.optional_field(
    "geneSequenceOrigin",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancereferenceinformationGene(
    source:,
    gene:,
    gene_sequence_origin:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancereferenceinformation_to_json(
  substancereferenceinformation: Substancereferenceinformation,
) -> Json {
  let Substancereferenceinformation(
    target:,
    gene_element:,
    gene:,
    comment:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancereferenceinformation
  let fields = []
  let fields = case target {
    [] -> fields
    _ -> [
      #(
        "target",
        json.array(target, substancereferenceinformation_target_to_json),
      ),
      ..fields
    ]
  }
  let fields = case gene_element {
    [] -> fields
    _ -> [
      #(
        "geneElement",
        json.array(
          gene_element,
          substancereferenceinformation_geneelement_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case gene {
    [] -> fields
    _ -> [
      #("gene", json.array(gene, substancereferenceinformation_gene_to_json)),
      ..fields
    ]
  }
  let fields = case comment {
    Some(v) -> [#("comment", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Substancereferenceinformation")),
    ..fields
  ]
  json.object(fields)
}

pub fn substancereferenceinformation_decoder() -> Decoder(
  Substancereferenceinformation,
) {
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(substancereferenceinformation_target_decoder()),
  )
  use gene_element <- decode.optional_field(
    "geneElement",
    [],
    decode.list(substancereferenceinformation_geneelement_decoder()),
  )
  use gene <- decode.optional_field(
    "gene",
    [],
    decode.list(substancereferenceinformation_gene_decoder()),
  )
  use comment <- decode.optional_field(
    "comment",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancereferenceinformation",
    decode.failure(substancereferenceinformation_new(), "resourceType"),
  )
  decode.success(Substancereferenceinformation(
    target:,
    gene_element:,
    gene:,
    comment:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type Substancesourcematerial {
  Substancesourcematerial(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    source_material_class: Option(Codeableconcept),
    source_material_type: Option(Codeableconcept),
    source_material_state: Option(Codeableconcept),
    organism_id: Option(Identifier),
    organism_name: Option(String),
    parent_substance_id: List(Identifier),
    parent_substance_name: List(String),
    country_of_origin: List(Codeableconcept),
    geographical_location: List(String),
    development_stage: Option(Codeableconcept),
    fraction_description: List(SubstancesourcematerialFractiondescription),
    organism: Option(SubstancesourcematerialOrganism),
    part_description: List(SubstancesourcematerialPartdescription),
  )
}

pub fn substancesourcematerial_new() -> Substancesourcematerial {
  Substancesourcematerial(
    part_description: [],
    organism: None,
    fraction_description: [],
    development_stage: None,
    geographical_location: [],
    country_of_origin: [],
    parent_substance_name: [],
    parent_substance_id: [],
    organism_name: None,
    organism_id: None,
    source_material_state: None,
    source_material_type: None,
    source_material_class: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialFractiondescription {
  SubstancesourcematerialFractiondescription(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    fraction: Option(String),
    material_type: Option(Codeableconcept),
  )
}

pub fn substancesourcematerial_fractiondescription_new() -> SubstancesourcematerialFractiondescription {
  SubstancesourcematerialFractiondescription(
    material_type: None,
    fraction: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganism {
  SubstancesourcematerialOrganism(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    family: Option(Codeableconcept),
    genus: Option(Codeableconcept),
    species: Option(Codeableconcept),
    intraspecific_type: Option(Codeableconcept),
    intraspecific_description: Option(String),
    author: List(SubstancesourcematerialOrganismAuthor),
    hybrid: Option(SubstancesourcematerialOrganismHybrid),
    organism_general: Option(SubstancesourcematerialOrganismOrganismgeneral),
  )
}

pub fn substancesourcematerial_organism_new() -> SubstancesourcematerialOrganism {
  SubstancesourcematerialOrganism(
    organism_general: None,
    hybrid: None,
    author: [],
    intraspecific_description: None,
    intraspecific_type: None,
    species: None,
    genus: None,
    family: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismAuthor {
  SubstancesourcematerialOrganismAuthor(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    author_type: Option(Codeableconcept),
    author_description: Option(String),
  )
}

pub fn substancesourcematerial_organism_author_new() -> SubstancesourcematerialOrganismAuthor {
  SubstancesourcematerialOrganismAuthor(
    author_description: None,
    author_type: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismHybrid {
  SubstancesourcematerialOrganismHybrid(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    maternal_organism_id: Option(String),
    maternal_organism_name: Option(String),
    paternal_organism_id: Option(String),
    paternal_organism_name: Option(String),
    hybrid_type: Option(Codeableconcept),
  )
}

pub fn substancesourcematerial_organism_hybrid_new() -> SubstancesourcematerialOrganismHybrid {
  SubstancesourcematerialOrganismHybrid(
    hybrid_type: None,
    paternal_organism_name: None,
    paternal_organism_id: None,
    maternal_organism_name: None,
    maternal_organism_id: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialOrganismOrganismgeneral {
  SubstancesourcematerialOrganismOrganismgeneral(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    kingdom: Option(Codeableconcept),
    phylum: Option(Codeableconcept),
    class: Option(Codeableconcept),
    order: Option(Codeableconcept),
  )
}

pub fn substancesourcematerial_organism_organismgeneral_new() -> SubstancesourcematerialOrganismOrganismgeneral {
  SubstancesourcematerialOrganismOrganismgeneral(
    order: None,
    class: None,
    phylum: None,
    kingdom: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SubstanceSourceMaterial#resource
pub type SubstancesourcematerialPartdescription {
  SubstancesourcematerialPartdescription(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    part: Option(Codeableconcept),
    part_location: Option(Codeableconcept),
  )
}

pub fn substancesourcematerial_partdescription_new() -> SubstancesourcematerialPartdescription {
  SubstancesourcematerialPartdescription(
    part_location: None,
    part: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn substancesourcematerial_partdescription_to_json(
  substancesourcematerial_partdescription: SubstancesourcematerialPartdescription,
) -> Json {
  let SubstancesourcematerialPartdescription(
    part_location:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_partdescription
  let fields = []
  let fields = case part_location {
    Some(v) -> [#("partLocation", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part {
    Some(v) -> [#("part", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_partdescription_decoder() -> Decoder(
  SubstancesourcematerialPartdescription,
) {
  use part_location <- decode.optional_field(
    "partLocation",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use part <- decode.optional_field(
    "part",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialPartdescription(
    part_location:,
    part:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_organism_organismgeneral_to_json(
  substancesourcematerial_organism_organismgeneral: SubstancesourcematerialOrganismOrganismgeneral,
) -> Json {
  let SubstancesourcematerialOrganismOrganismgeneral(
    order:,
    class:,
    phylum:,
    kingdom:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_organism_organismgeneral
  let fields = []
  let fields = case order {
    Some(v) -> [#("order", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case class {
    Some(v) -> [#("class", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case phylum {
    Some(v) -> [#("phylum", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case kingdom {
    Some(v) -> [#("kingdom", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_organism_organismgeneral_decoder() -> Decoder(
  SubstancesourcematerialOrganismOrganismgeneral,
) {
  use order <- decode.optional_field(
    "order",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use class <- decode.optional_field(
    "class",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use phylum <- decode.optional_field(
    "phylum",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use kingdom <- decode.optional_field(
    "kingdom",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialOrganismOrganismgeneral(
    order:,
    class:,
    phylum:,
    kingdom:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_organism_hybrid_to_json(
  substancesourcematerial_organism_hybrid: SubstancesourcematerialOrganismHybrid,
) -> Json {
  let SubstancesourcematerialOrganismHybrid(
    hybrid_type:,
    paternal_organism_name:,
    paternal_organism_id:,
    maternal_organism_name:,
    maternal_organism_id:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_organism_hybrid
  let fields = []
  let fields = case hybrid_type {
    Some(v) -> [#("hybridType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case paternal_organism_name {
    Some(v) -> [#("paternalOrganismName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case paternal_organism_id {
    Some(v) -> [#("paternalOrganismId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case maternal_organism_name {
    Some(v) -> [#("maternalOrganismName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case maternal_organism_id {
    Some(v) -> [#("maternalOrganismId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_organism_hybrid_decoder() -> Decoder(
  SubstancesourcematerialOrganismHybrid,
) {
  use hybrid_type <- decode.optional_field(
    "hybridType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use paternal_organism_name <- decode.optional_field(
    "paternalOrganismName",
    None,
    decode.optional(decode.string),
  )
  use paternal_organism_id <- decode.optional_field(
    "paternalOrganismId",
    None,
    decode.optional(decode.string),
  )
  use maternal_organism_name <- decode.optional_field(
    "maternalOrganismName",
    None,
    decode.optional(decode.string),
  )
  use maternal_organism_id <- decode.optional_field(
    "maternalOrganismId",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialOrganismHybrid(
    hybrid_type:,
    paternal_organism_name:,
    paternal_organism_id:,
    maternal_organism_name:,
    maternal_organism_id:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_organism_author_to_json(
  substancesourcematerial_organism_author: SubstancesourcematerialOrganismAuthor,
) -> Json {
  let SubstancesourcematerialOrganismAuthor(
    author_description:,
    author_type:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_organism_author
  let fields = []
  let fields = case author_description {
    Some(v) -> [#("authorDescription", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case author_type {
    Some(v) -> [#("authorType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_organism_author_decoder() -> Decoder(
  SubstancesourcematerialOrganismAuthor,
) {
  use author_description <- decode.optional_field(
    "authorDescription",
    None,
    decode.optional(decode.string),
  )
  use author_type <- decode.optional_field(
    "authorType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialOrganismAuthor(
    author_description:,
    author_type:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_organism_to_json(
  substancesourcematerial_organism: SubstancesourcematerialOrganism,
) -> Json {
  let SubstancesourcematerialOrganism(
    organism_general:,
    hybrid:,
    author:,
    intraspecific_description:,
    intraspecific_type:,
    species:,
    genus:,
    family:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_organism
  let fields = []
  let fields = case organism_general {
    Some(v) -> [
      #(
        "organismGeneral",
        substancesourcematerial_organism_organismgeneral_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case hybrid {
    Some(v) -> [
      #("hybrid", substancesourcematerial_organism_hybrid_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case author {
    [] -> fields
    _ -> [
      #(
        "author",
        json.array(author, substancesourcematerial_organism_author_to_json),
      ),
      ..fields
    ]
  }
  let fields = case intraspecific_description {
    Some(v) -> [#("intraspecificDescription", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case intraspecific_type {
    Some(v) -> [#("intraspecificType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case species {
    Some(v) -> [#("species", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case genus {
    Some(v) -> [#("genus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case family {
    Some(v) -> [#("family", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_organism_decoder() -> Decoder(
  SubstancesourcematerialOrganism,
) {
  use organism_general <- decode.optional_field(
    "organismGeneral",
    None,
    decode.optional(substancesourcematerial_organism_organismgeneral_decoder()),
  )
  use hybrid <- decode.optional_field(
    "hybrid",
    None,
    decode.optional(substancesourcematerial_organism_hybrid_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(substancesourcematerial_organism_author_decoder()),
  )
  use intraspecific_description <- decode.optional_field(
    "intraspecificDescription",
    None,
    decode.optional(decode.string),
  )
  use intraspecific_type <- decode.optional_field(
    "intraspecificType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use species <- decode.optional_field(
    "species",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use genus <- decode.optional_field(
    "genus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use family <- decode.optional_field(
    "family",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialOrganism(
    organism_general:,
    hybrid:,
    author:,
    intraspecific_description:,
    intraspecific_type:,
    species:,
    genus:,
    family:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_fractiondescription_to_json(
  substancesourcematerial_fractiondescription: SubstancesourcematerialFractiondescription,
) -> Json {
  let SubstancesourcematerialFractiondescription(
    material_type:,
    fraction:,
    modifier_extension:,
    extension:,
    id:,
  ) = substancesourcematerial_fractiondescription
  let fields = []
  let fields = case material_type {
    Some(v) -> [#("materialType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case fraction {
    Some(v) -> [#("fraction", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn substancesourcematerial_fractiondescription_decoder() -> Decoder(
  SubstancesourcematerialFractiondescription,
) {
  use material_type <- decode.optional_field(
    "materialType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use fraction <- decode.optional_field(
    "fraction",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SubstancesourcematerialFractiondescription(
    material_type:,
    fraction:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn substancesourcematerial_to_json(
  substancesourcematerial: Substancesourcematerial,
) -> Json {
  let Substancesourcematerial(
    part_description:,
    organism:,
    fraction_description:,
    development_stage:,
    geographical_location:,
    country_of_origin:,
    parent_substance_name:,
    parent_substance_id:,
    organism_name:,
    organism_id:,
    source_material_state:,
    source_material_type:,
    source_material_class:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = substancesourcematerial
  let fields = []
  let fields = case part_description {
    [] -> fields
    _ -> [
      #(
        "partDescription",
        json.array(
          part_description,
          substancesourcematerial_partdescription_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case organism {
    Some(v) -> [
      #("organism", substancesourcematerial_organism_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case fraction_description {
    [] -> fields
    _ -> [
      #(
        "fractionDescription",
        json.array(
          fraction_description,
          substancesourcematerial_fractiondescription_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case development_stage {
    Some(v) -> [#("developmentStage", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case geographical_location {
    [] -> fields
    _ -> [
      #("geographicalLocation", json.array(geographical_location, json.string)),
      ..fields
    ]
  }
  let fields = case country_of_origin {
    [] -> fields
    _ -> [
      #(
        "countryOfOrigin",
        json.array(country_of_origin, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case parent_substance_name {
    [] -> fields
    _ -> [
      #("parentSubstanceName", json.array(parent_substance_name, json.string)),
      ..fields
    ]
  }
  let fields = case parent_substance_id {
    [] -> fields
    _ -> [
      #(
        "parentSubstanceId",
        json.array(parent_substance_id, identifier_to_json),
      ),
      ..fields
    ]
  }
  let fields = case organism_name {
    Some(v) -> [#("organismName", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case organism_id {
    Some(v) -> [#("organismId", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source_material_state {
    Some(v) -> [#("sourceMaterialState", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source_material_type {
    Some(v) -> [#("sourceMaterialType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case source_material_class {
    Some(v) -> [#("sourceMaterialClass", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Substancesourcematerial")),
    ..fields
  ]
  json.object(fields)
}

pub fn substancesourcematerial_decoder() -> Decoder(Substancesourcematerial) {
  use part_description <- decode.optional_field(
    "partDescription",
    [],
    decode.list(substancesourcematerial_partdescription_decoder()),
  )
  use organism <- decode.optional_field(
    "organism",
    None,
    decode.optional(substancesourcematerial_organism_decoder()),
  )
  use fraction_description <- decode.optional_field(
    "fractionDescription",
    [],
    decode.list(substancesourcematerial_fractiondescription_decoder()),
  )
  use development_stage <- decode.optional_field(
    "developmentStage",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use geographical_location <- decode.optional_field(
    "geographicalLocation",
    [],
    decode.list(decode.string),
  )
  use country_of_origin <- decode.optional_field(
    "countryOfOrigin",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use parent_substance_name <- decode.optional_field(
    "parentSubstanceName",
    [],
    decode.list(decode.string),
  )
  use parent_substance_id <- decode.optional_field(
    "parentSubstanceId",
    [],
    decode.list(identifier_decoder()),
  )
  use organism_name <- decode.optional_field(
    "organismName",
    None,
    decode.optional(decode.string),
  )
  use organism_id <- decode.optional_field(
    "organismId",
    None,
    decode.optional(identifier_decoder()),
  )
  use source_material_state <- decode.optional_field(
    "sourceMaterialState",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use source_material_type <- decode.optional_field(
    "sourceMaterialType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use source_material_class <- decode.optional_field(
    "sourceMaterialClass",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Substancesourcematerial",
    decode.failure(substancesourcematerial_new(), "resourceType"),
  )
  decode.success(Substancesourcematerial(
    part_description:,
    organism:,
    fraction_description:,
    development_stage:,
    geographical_location:,
    country_of_origin:,
    parent_substance_name:,
    parent_substance_id:,
    organism_name:,
    organism_id:,
    source_material_state:,
    source_material_type:,
    source_material_class:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyDelivery#resource
pub type Supplydelivery {
  Supplydelivery(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    based_on: List(Reference),
    part_of: List(Reference),
    status: Option(r5valuesets.Supplydeliverystatus),
    patient: Option(Reference),
    type_: Option(Codeableconcept),
    supplied_item: List(SupplydeliverySupplieditem),
    occurrence: Option(SupplydeliveryOccurrence),
    supplier: Option(Reference),
    destination: Option(Reference),
    receiver: List(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliveryOccurrence {
  SupplydeliveryOccurrenceDatetime(occurrence: String)
  SupplydeliveryOccurrencePeriod(occurrence: Period)
  SupplydeliveryOccurrenceTiming(occurrence: Timing)
}

pub fn supplydelivery_occurrence_to_json(elt: SupplydeliveryOccurrence) -> Json {
  case elt {
    SupplydeliveryOccurrenceDatetime(v) -> json.string(v)
    SupplydeliveryOccurrencePeriod(v) -> period_to_json(v)
    SupplydeliveryOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn supplydelivery_occurrence_decoder() -> Decoder(SupplydeliveryOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(SupplydeliveryOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(SupplydeliveryOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(SupplydeliveryOccurrenceTiming),
    ],
  )
}

pub fn supplydelivery_new() -> Supplydelivery {
  Supplydelivery(
    receiver: [],
    destination: None,
    supplier: None,
    occurrence: None,
    supplied_item: [],
    type_: None,
    patient: None,
    status: None,
    part_of: [],
    based_on: [],
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditem {
  SupplydeliverySupplieditem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    quantity: Option(Quantity),
    item: Option(SupplydeliverySupplieditemItem),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyDelivery#resource
pub type SupplydeliverySupplieditemItem {
  SupplydeliverySupplieditemItemCodeableconcept(item: Codeableconcept)
  SupplydeliverySupplieditemItemReference(item: Reference)
}

pub fn supplydelivery_supplieditem_item_to_json(
  elt: SupplydeliverySupplieditemItem,
) -> Json {
  case elt {
    SupplydeliverySupplieditemItemCodeableconcept(v) ->
      codeableconcept_to_json(v)
    SupplydeliverySupplieditemItemReference(v) -> reference_to_json(v)
  }
}

pub fn supplydelivery_supplieditem_item_decoder() -> Decoder(
  SupplydeliverySupplieditemItem,
) {
  decode.one_of(
    decode.field(
      "itemCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SupplydeliverySupplieditemItemCodeableconcept),
    [
      decode.field("itemReference", reference_decoder(), decode.success)
      |> decode.map(SupplydeliverySupplieditemItemReference),
    ],
  )
}

pub fn supplydelivery_supplieditem_new() -> SupplydeliverySupplieditem {
  SupplydeliverySupplieditem(
    item: None,
    quantity: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn supplydelivery_supplieditem_to_json(
  supplydelivery_supplieditem: SupplydeliverySupplieditem,
) -> Json {
  let SupplydeliverySupplieditem(
    item:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ) = supplydelivery_supplieditem
  let fields = []
  let fields = case item {
    Some(v) -> [
      #(
        "item"
          <> case v {
          SupplydeliverySupplieditemItemCodeableconcept(_) -> "Codeableconcept"
          SupplydeliverySupplieditemItemReference(_) -> "Reference"
        },
        supplydelivery_supplieditem_item_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case quantity {
    Some(v) -> [#("quantity", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn supplydelivery_supplieditem_decoder() -> Decoder(
  SupplydeliverySupplieditem,
) {
  use item <- decode.then(
    none_if_omitted(supplydelivery_supplieditem_item_decoder()),
  )
  use quantity <- decode.optional_field(
    "quantity",
    None,
    decode.optional(quantity_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SupplydeliverySupplieditem(
    item:,
    quantity:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn supplydelivery_to_json(supplydelivery: Supplydelivery) -> Json {
  let Supplydelivery(
    receiver:,
    destination:,
    supplier:,
    occurrence:,
    supplied_item:,
    type_:,
    patient:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = supplydelivery
  let fields = []
  let fields = case receiver {
    [] -> fields
    _ -> [#("receiver", json.array(receiver, reference_to_json)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case supplier {
    Some(v) -> [#("supplier", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          SupplydeliveryOccurrenceDatetime(_) -> "Datetime"
          SupplydeliveryOccurrencePeriod(_) -> "Period"
          SupplydeliveryOccurrenceTiming(_) -> "Timing"
        },
        supplydelivery_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case supplied_item {
    [] -> fields
    _ -> [
      #(
        "suppliedItem",
        json.array(supplied_item, supplydelivery_supplieditem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    Some(v) -> [#("type", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case patient {
    Some(v) -> [#("patient", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.supplydeliverystatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Supplydelivery")), ..fields]
  json.object(fields)
}

pub fn supplydelivery_decoder() -> Decoder(Supplydelivery) {
  use receiver <- decode.optional_field(
    "receiver",
    [],
    decode.list(reference_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(reference_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    None,
    decode.optional(reference_decoder()),
  )
  use occurrence <- decode.then(
    none_if_omitted(supplydelivery_occurrence_decoder()),
  )
  use supplied_item <- decode.optional_field(
    "suppliedItem",
    [],
    decode.list(supplydelivery_supplieditem_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use patient <- decode.optional_field(
    "patient",
    None,
    decode.optional(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.supplydeliverystatus_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Supplydelivery",
    decode.failure(supplydelivery_new(), "resourceType"),
  )
  decode.success(Supplydelivery(
    receiver:,
    destination:,
    supplier:,
    occurrence:,
    supplied_item:,
    type_:,
    patient:,
    status:,
    part_of:,
    based_on:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyRequest#resource
pub type Supplyrequest {
  Supplyrequest(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: Option(r5valuesets.Supplyrequeststatus),
    based_on: List(Reference),
    category: Option(Codeableconcept),
    priority: Option(r5valuesets.Requestpriority),
    deliver_for: Option(Reference),
    item: Codeablereference,
    quantity: Quantity,
    parameter: List(SupplyrequestParameter),
    occurrence: Option(SupplyrequestOccurrence),
    authored_on: Option(String),
    requester: Option(Reference),
    supplier: List(Reference),
    reason: List(Codeablereference),
    deliver_from: Option(Reference),
    deliver_to: Option(Reference),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestOccurrence {
  SupplyrequestOccurrenceDatetime(occurrence: String)
  SupplyrequestOccurrencePeriod(occurrence: Period)
  SupplyrequestOccurrenceTiming(occurrence: Timing)
}

pub fn supplyrequest_occurrence_to_json(elt: SupplyrequestOccurrence) -> Json {
  case elt {
    SupplyrequestOccurrenceDatetime(v) -> json.string(v)
    SupplyrequestOccurrencePeriod(v) -> period_to_json(v)
    SupplyrequestOccurrenceTiming(v) -> timing_to_json(v)
  }
}

pub fn supplyrequest_occurrence_decoder() -> Decoder(SupplyrequestOccurrence) {
  decode.one_of(
    decode.field("occurrenceDateTime", decode.string, decode.success)
      |> decode.map(SupplyrequestOccurrenceDatetime),
    [
      decode.field("occurrencePeriod", period_decoder(), decode.success)
        |> decode.map(SupplyrequestOccurrencePeriod),
      decode.field("occurrenceTiming", timing_decoder(), decode.success)
        |> decode.map(SupplyrequestOccurrenceTiming),
    ],
  )
}

pub fn supplyrequest_new(
  quantity quantity: Quantity,
  item item: Codeablereference,
) -> Supplyrequest {
  Supplyrequest(
    deliver_to: None,
    deliver_from: None,
    reason: [],
    supplier: [],
    requester: None,
    authored_on: None,
    occurrence: None,
    parameter: [],
    quantity:,
    item:,
    deliver_for: None,
    priority: None,
    category: None,
    based_on: [],
    status: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameter {
  SupplyrequestParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(Codeableconcept),
    value: Option(SupplyrequestParameterValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/SupplyRequest#resource
pub type SupplyrequestParameterValue {
  SupplyrequestParameterValueCodeableconcept(value: Codeableconcept)
  SupplyrequestParameterValueQuantity(value: Quantity)
  SupplyrequestParameterValueRange(value: Range)
  SupplyrequestParameterValueBoolean(value: Bool)
}

pub fn supplyrequest_parameter_value_to_json(
  elt: SupplyrequestParameterValue,
) -> Json {
  case elt {
    SupplyrequestParameterValueCodeableconcept(v) -> codeableconcept_to_json(v)
    SupplyrequestParameterValueQuantity(v) -> quantity_to_json(v)
    SupplyrequestParameterValueRange(v) -> range_to_json(v)
    SupplyrequestParameterValueBoolean(v) -> json.bool(v)
  }
}

pub fn supplyrequest_parameter_value_decoder() -> Decoder(
  SupplyrequestParameterValue,
) {
  decode.one_of(
    decode.field(
      "valueCodeableConcept",
      codeableconcept_decoder(),
      decode.success,
    )
      |> decode.map(SupplyrequestParameterValueCodeableconcept),
    [
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(SupplyrequestParameterValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(SupplyrequestParameterValueRange),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(SupplyrequestParameterValueBoolean),
    ],
  )
}

pub fn supplyrequest_parameter_new() -> SupplyrequestParameter {
  SupplyrequestParameter(
    value: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn supplyrequest_parameter_to_json(
  supplyrequest_parameter: SupplyrequestParameter,
) -> Json {
  let SupplyrequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = supplyrequest_parameter
  let fields = []
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          SupplyrequestParameterValueCodeableconcept(_) -> "Codeableconcept"
          SupplyrequestParameterValueQuantity(_) -> "Quantity"
          SupplyrequestParameterValueRange(_) -> "Range"
          SupplyrequestParameterValueBoolean(_) -> "Boolean"
        },
        supplyrequest_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn supplyrequest_parameter_decoder() -> Decoder(SupplyrequestParameter) {
  use value <- decode.then(
    none_if_omitted(supplyrequest_parameter_value_decoder()),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(SupplyrequestParameter(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn supplyrequest_to_json(supplyrequest: Supplyrequest) -> Json {
  let Supplyrequest(
    deliver_to:,
    deliver_from:,
    reason:,
    supplier:,
    requester:,
    authored_on:,
    occurrence:,
    parameter:,
    quantity:,
    item:,
    deliver_for:,
    priority:,
    category:,
    based_on:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = supplyrequest
  let fields = [
    #("quantity", quantity_to_json(quantity)),
    #("item", codeablereference_to_json(item)),
  ]
  let fields = case deliver_to {
    Some(v) -> [#("deliverTo", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case deliver_from {
    Some(v) -> [#("deliverFrom", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case supplier {
    [] -> fields
    _ -> [#("supplier", json.array(supplier, reference_to_json)), ..fields]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case occurrence {
    Some(v) -> [
      #(
        "occurrence"
          <> case v {
          SupplyrequestOccurrenceDatetime(_) -> "Datetime"
          SupplyrequestOccurrencePeriod(_) -> "Period"
          SupplyrequestOccurrenceTiming(_) -> "Timing"
        },
        supplyrequest_occurrence_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #("parameter", json.array(parameter, supplyrequest_parameter_to_json)),
      ..fields
    ]
  }
  let fields = case deliver_for {
    Some(v) -> [#("deliverFor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case category {
    Some(v) -> [#("category", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case status {
    Some(v) -> [
      #("status", r5valuesets.supplyrequeststatus_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Supplyrequest")), ..fields]
  json.object(fields)
}

pub fn supplyrequest_decoder() -> Decoder(Supplyrequest) {
  use deliver_to <- decode.optional_field(
    "deliverTo",
    None,
    decode.optional(reference_decoder()),
  )
  use deliver_from <- decode.optional_field(
    "deliverFrom",
    None,
    decode.optional(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use supplier <- decode.optional_field(
    "supplier",
    [],
    decode.list(reference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use occurrence <- decode.then(
    none_if_omitted(supplyrequest_occurrence_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(supplyrequest_parameter_decoder()),
  )
  use quantity <- decode.field("quantity", quantity_decoder())
  use item <- decode.field("item", codeablereference_decoder())
  use deliver_for <- decode.optional_field(
    "deliverFor",
    None,
    decode.optional(reference_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.supplyrequeststatus_decoder()),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Supplyrequest",
    decode.failure(supplyrequest_new(quantity:, item:), "resourceType"),
  )
  decode.success(Supplyrequest(
    deliver_to:,
    deliver_from:,
    reason:,
    supplier:,
    requester:,
    authored_on:,
    occurrence:,
    parameter:,
    quantity:,
    item:,
    deliver_for:,
    priority:,
    category:,
    based_on:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type Task {
  Task(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: Option(String),
    instantiates_uri: Option(String),
    based_on: List(Reference),
    group_identifier: Option(Identifier),
    part_of: List(Reference),
    status: r5valuesets.Taskstatus,
    status_reason: Option(Codeablereference),
    business_status: Option(Codeableconcept),
    intent: r5valuesets.Taskintent,
    priority: Option(r5valuesets.Requestpriority),
    do_not_perform: Option(Bool),
    code: Option(Codeableconcept),
    description: Option(String),
    focus: Option(Reference),
    for: Option(Reference),
    encounter: Option(Reference),
    requested_period: Option(Period),
    execution_period: Option(Period),
    authored_on: Option(String),
    last_modified: Option(String),
    requester: Option(Reference),
    requested_performer: List(Codeablereference),
    owner: Option(Reference),
    performer: List(TaskPerformer),
    location: Option(Reference),
    reason: List(Codeablereference),
    insurance: List(Reference),
    note: List(Annotation),
    relevant_history: List(Reference),
    restriction: Option(TaskRestriction),
    input: List(TaskInput),
    output: List(TaskOutput),
  )
}

pub fn task_new(
  intent intent: r5valuesets.Taskintent,
  status status: r5valuesets.Taskstatus,
) -> Task {
  Task(
    output: [],
    input: [],
    restriction: None,
    relevant_history: [],
    note: [],
    insurance: [],
    reason: [],
    location: None,
    performer: [],
    owner: None,
    requested_performer: [],
    requester: None,
    last_modified: None,
    authored_on: None,
    execution_period: None,
    requested_period: None,
    encounter: None,
    for: None,
    focus: None,
    description: None,
    code: None,
    do_not_perform: None,
    priority: None,
    intent:,
    business_status: None,
    status_reason: None,
    status:,
    part_of: [],
    group_identifier: None,
    based_on: [],
    instantiates_uri: None,
    instantiates_canonical: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskPerformer {
  TaskPerformer(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    function: Option(Codeableconcept),
    actor: Reference,
  )
}

pub fn task_performer_new(actor actor: Reference) -> TaskPerformer {
  TaskPerformer(
    actor:,
    function: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskRestriction {
  TaskRestriction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    repetitions: Option(Int),
    period: Option(Period),
    recipient: List(Reference),
  )
}

pub fn task_restriction_new() -> TaskRestriction {
  TaskRestriction(
    recipient: [],
    period: None,
    repetitions: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskInput {
  TaskInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TaskInputValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskInputValue {
  TaskInputValueBase64binary(value: String)
  TaskInputValueBoolean(value: Bool)
  TaskInputValueCanonical(value: String)
  TaskInputValueCode(value: String)
  TaskInputValueDate(value: String)
  TaskInputValueDatetime(value: String)
  TaskInputValueDecimal(value: Float)
  TaskInputValueId(value: String)
  TaskInputValueInstant(value: String)
  TaskInputValueInteger(value: Int)
  TaskInputValueInteger64(value: Int)
  TaskInputValueMarkdown(value: String)
  TaskInputValueOid(value: String)
  TaskInputValuePositiveint(value: Int)
  TaskInputValueString(value: String)
  TaskInputValueTime(value: String)
  TaskInputValueUnsignedint(value: Int)
  TaskInputValueUri(value: String)
  TaskInputValueUrl(value: String)
  TaskInputValueUuid(value: String)
  TaskInputValueAddress(value: Address)
  TaskInputValueAge(value: Age)
  TaskInputValueAnnotation(value: Annotation)
  TaskInputValueAttachment(value: Attachment)
  TaskInputValueCodeableconcept(value: Codeableconcept)
  TaskInputValueCodeablereference(value: Codeablereference)
  TaskInputValueCoding(value: Coding)
  TaskInputValueContactpoint(value: Contactpoint)
  TaskInputValueCount(value: Count)
  TaskInputValueDistance(value: Distance)
  TaskInputValueDuration(value: Duration)
  TaskInputValueHumanname(value: Humanname)
  TaskInputValueIdentifier(value: Identifier)
  TaskInputValueMoney(value: Money)
  TaskInputValuePeriod(value: Period)
  TaskInputValueQuantity(value: Quantity)
  TaskInputValueRange(value: Range)
  TaskInputValueRatio(value: Ratio)
  TaskInputValueRatiorange(value: Ratiorange)
  TaskInputValueReference(value: Reference)
  TaskInputValueSampleddata(value: Sampleddata)
  TaskInputValueSignature(value: Signature)
  TaskInputValueTiming(value: Timing)
  TaskInputValueContactdetail(value: Contactdetail)
  TaskInputValueDatarequirement(value: Datarequirement)
  TaskInputValueExpression(value: Expression)
  TaskInputValueParameterdefinition(value: Parameterdefinition)
  TaskInputValueRelatedartifact(value: Relatedartifact)
  TaskInputValueTriggerdefinition(value: Triggerdefinition)
  TaskInputValueUsagecontext(value: Usagecontext)
  TaskInputValueAvailability(value: Availability)
  TaskInputValueExtendedcontactdetail(value: Extendedcontactdetail)
  TaskInputValueDosage(value: Dosage)
  TaskInputValueMeta(value: Meta)
}

pub fn task_input_value_to_json(elt: TaskInputValue) -> Json {
  case elt {
    TaskInputValueBase64binary(v) -> json.string(v)
    TaskInputValueBoolean(v) -> json.bool(v)
    TaskInputValueCanonical(v) -> json.string(v)
    TaskInputValueCode(v) -> json.string(v)
    TaskInputValueDate(v) -> json.string(v)
    TaskInputValueDatetime(v) -> json.string(v)
    TaskInputValueDecimal(v) -> json.float(v)
    TaskInputValueId(v) -> json.string(v)
    TaskInputValueInstant(v) -> json.string(v)
    TaskInputValueInteger(v) -> json.int(v)
    TaskInputValueInteger64(v) -> json.int(v)
    TaskInputValueMarkdown(v) -> json.string(v)
    TaskInputValueOid(v) -> json.string(v)
    TaskInputValuePositiveint(v) -> json.int(v)
    TaskInputValueString(v) -> json.string(v)
    TaskInputValueTime(v) -> json.string(v)
    TaskInputValueUnsignedint(v) -> json.int(v)
    TaskInputValueUri(v) -> json.string(v)
    TaskInputValueUrl(v) -> json.string(v)
    TaskInputValueUuid(v) -> json.string(v)
    TaskInputValueAddress(v) -> address_to_json(v)
    TaskInputValueAge(v) -> age_to_json(v)
    TaskInputValueAnnotation(v) -> annotation_to_json(v)
    TaskInputValueAttachment(v) -> attachment_to_json(v)
    TaskInputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TaskInputValueCodeablereference(v) -> codeablereference_to_json(v)
    TaskInputValueCoding(v) -> coding_to_json(v)
    TaskInputValueContactpoint(v) -> contactpoint_to_json(v)
    TaskInputValueCount(v) -> count_to_json(v)
    TaskInputValueDistance(v) -> distance_to_json(v)
    TaskInputValueDuration(v) -> duration_to_json(v)
    TaskInputValueHumanname(v) -> humanname_to_json(v)
    TaskInputValueIdentifier(v) -> identifier_to_json(v)
    TaskInputValueMoney(v) -> money_to_json(v)
    TaskInputValuePeriod(v) -> period_to_json(v)
    TaskInputValueQuantity(v) -> quantity_to_json(v)
    TaskInputValueRange(v) -> range_to_json(v)
    TaskInputValueRatio(v) -> ratio_to_json(v)
    TaskInputValueRatiorange(v) -> ratiorange_to_json(v)
    TaskInputValueReference(v) -> reference_to_json(v)
    TaskInputValueSampleddata(v) -> sampleddata_to_json(v)
    TaskInputValueSignature(v) -> signature_to_json(v)
    TaskInputValueTiming(v) -> timing_to_json(v)
    TaskInputValueContactdetail(v) -> contactdetail_to_json(v)
    TaskInputValueDatarequirement(v) -> datarequirement_to_json(v)
    TaskInputValueExpression(v) -> expression_to_json(v)
    TaskInputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TaskInputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TaskInputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TaskInputValueUsagecontext(v) -> usagecontext_to_json(v)
    TaskInputValueAvailability(v) -> availability_to_json(v)
    TaskInputValueExtendedcontactdetail(v) -> extendedcontactdetail_to_json(v)
    TaskInputValueDosage(v) -> dosage_to_json(v)
    TaskInputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn task_input_value_decoder() -> Decoder(TaskInputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TaskInputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TaskInputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TaskInputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TaskInputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TaskInputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TaskInputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TaskInputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TaskInputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TaskInputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TaskInputValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(TaskInputValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TaskInputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TaskInputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TaskInputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TaskInputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TaskInputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TaskInputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TaskInputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TaskInputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TaskInputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TaskInputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TaskInputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TaskInputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TaskInputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TaskInputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TaskInputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TaskInputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TaskInputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TaskInputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TaskInputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TaskInputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TaskInputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TaskInputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TaskInputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TaskInputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TaskInputValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(TaskInputValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TaskInputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TaskInputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TaskInputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TaskInputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TaskInputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TaskInputValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(TaskInputValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskInputValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TaskInputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TaskInputValueMeta),
    ],
  )
}

pub fn task_input_new(
  value value: TaskInputValue,
  type_ type_: Codeableconcept,
) -> TaskInput {
  TaskInput(value:, type_:, modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskOutput {
  TaskOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TaskOutputValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Task#resource
pub type TaskOutputValue {
  TaskOutputValueBase64binary(value: String)
  TaskOutputValueBoolean(value: Bool)
  TaskOutputValueCanonical(value: String)
  TaskOutputValueCode(value: String)
  TaskOutputValueDate(value: String)
  TaskOutputValueDatetime(value: String)
  TaskOutputValueDecimal(value: Float)
  TaskOutputValueId(value: String)
  TaskOutputValueInstant(value: String)
  TaskOutputValueInteger(value: Int)
  TaskOutputValueInteger64(value: Int)
  TaskOutputValueMarkdown(value: String)
  TaskOutputValueOid(value: String)
  TaskOutputValuePositiveint(value: Int)
  TaskOutputValueString(value: String)
  TaskOutputValueTime(value: String)
  TaskOutputValueUnsignedint(value: Int)
  TaskOutputValueUri(value: String)
  TaskOutputValueUrl(value: String)
  TaskOutputValueUuid(value: String)
  TaskOutputValueAddress(value: Address)
  TaskOutputValueAge(value: Age)
  TaskOutputValueAnnotation(value: Annotation)
  TaskOutputValueAttachment(value: Attachment)
  TaskOutputValueCodeableconcept(value: Codeableconcept)
  TaskOutputValueCodeablereference(value: Codeablereference)
  TaskOutputValueCoding(value: Coding)
  TaskOutputValueContactpoint(value: Contactpoint)
  TaskOutputValueCount(value: Count)
  TaskOutputValueDistance(value: Distance)
  TaskOutputValueDuration(value: Duration)
  TaskOutputValueHumanname(value: Humanname)
  TaskOutputValueIdentifier(value: Identifier)
  TaskOutputValueMoney(value: Money)
  TaskOutputValuePeriod(value: Period)
  TaskOutputValueQuantity(value: Quantity)
  TaskOutputValueRange(value: Range)
  TaskOutputValueRatio(value: Ratio)
  TaskOutputValueRatiorange(value: Ratiorange)
  TaskOutputValueReference(value: Reference)
  TaskOutputValueSampleddata(value: Sampleddata)
  TaskOutputValueSignature(value: Signature)
  TaskOutputValueTiming(value: Timing)
  TaskOutputValueContactdetail(value: Contactdetail)
  TaskOutputValueDatarequirement(value: Datarequirement)
  TaskOutputValueExpression(value: Expression)
  TaskOutputValueParameterdefinition(value: Parameterdefinition)
  TaskOutputValueRelatedartifact(value: Relatedartifact)
  TaskOutputValueTriggerdefinition(value: Triggerdefinition)
  TaskOutputValueUsagecontext(value: Usagecontext)
  TaskOutputValueAvailability(value: Availability)
  TaskOutputValueExtendedcontactdetail(value: Extendedcontactdetail)
  TaskOutputValueDosage(value: Dosage)
  TaskOutputValueMeta(value: Meta)
}

pub fn task_output_value_to_json(elt: TaskOutputValue) -> Json {
  case elt {
    TaskOutputValueBase64binary(v) -> json.string(v)
    TaskOutputValueBoolean(v) -> json.bool(v)
    TaskOutputValueCanonical(v) -> json.string(v)
    TaskOutputValueCode(v) -> json.string(v)
    TaskOutputValueDate(v) -> json.string(v)
    TaskOutputValueDatetime(v) -> json.string(v)
    TaskOutputValueDecimal(v) -> json.float(v)
    TaskOutputValueId(v) -> json.string(v)
    TaskOutputValueInstant(v) -> json.string(v)
    TaskOutputValueInteger(v) -> json.int(v)
    TaskOutputValueInteger64(v) -> json.int(v)
    TaskOutputValueMarkdown(v) -> json.string(v)
    TaskOutputValueOid(v) -> json.string(v)
    TaskOutputValuePositiveint(v) -> json.int(v)
    TaskOutputValueString(v) -> json.string(v)
    TaskOutputValueTime(v) -> json.string(v)
    TaskOutputValueUnsignedint(v) -> json.int(v)
    TaskOutputValueUri(v) -> json.string(v)
    TaskOutputValueUrl(v) -> json.string(v)
    TaskOutputValueUuid(v) -> json.string(v)
    TaskOutputValueAddress(v) -> address_to_json(v)
    TaskOutputValueAge(v) -> age_to_json(v)
    TaskOutputValueAnnotation(v) -> annotation_to_json(v)
    TaskOutputValueAttachment(v) -> attachment_to_json(v)
    TaskOutputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TaskOutputValueCodeablereference(v) -> codeablereference_to_json(v)
    TaskOutputValueCoding(v) -> coding_to_json(v)
    TaskOutputValueContactpoint(v) -> contactpoint_to_json(v)
    TaskOutputValueCount(v) -> count_to_json(v)
    TaskOutputValueDistance(v) -> distance_to_json(v)
    TaskOutputValueDuration(v) -> duration_to_json(v)
    TaskOutputValueHumanname(v) -> humanname_to_json(v)
    TaskOutputValueIdentifier(v) -> identifier_to_json(v)
    TaskOutputValueMoney(v) -> money_to_json(v)
    TaskOutputValuePeriod(v) -> period_to_json(v)
    TaskOutputValueQuantity(v) -> quantity_to_json(v)
    TaskOutputValueRange(v) -> range_to_json(v)
    TaskOutputValueRatio(v) -> ratio_to_json(v)
    TaskOutputValueRatiorange(v) -> ratiorange_to_json(v)
    TaskOutputValueReference(v) -> reference_to_json(v)
    TaskOutputValueSampleddata(v) -> sampleddata_to_json(v)
    TaskOutputValueSignature(v) -> signature_to_json(v)
    TaskOutputValueTiming(v) -> timing_to_json(v)
    TaskOutputValueContactdetail(v) -> contactdetail_to_json(v)
    TaskOutputValueDatarequirement(v) -> datarequirement_to_json(v)
    TaskOutputValueExpression(v) -> expression_to_json(v)
    TaskOutputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TaskOutputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TaskOutputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TaskOutputValueUsagecontext(v) -> usagecontext_to_json(v)
    TaskOutputValueAvailability(v) -> availability_to_json(v)
    TaskOutputValueExtendedcontactdetail(v) -> extendedcontactdetail_to_json(v)
    TaskOutputValueDosage(v) -> dosage_to_json(v)
    TaskOutputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn task_output_value_decoder() -> Decoder(TaskOutputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TaskOutputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TaskOutputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TaskOutputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TaskOutputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TaskOutputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TaskOutputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TaskOutputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TaskOutputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TaskOutputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TaskOutputValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(TaskOutputValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TaskOutputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TaskOutputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TaskOutputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TaskOutputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TaskOutputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TaskOutputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TaskOutputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TaskOutputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TaskOutputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TaskOutputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TaskOutputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TaskOutputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TaskOutputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TaskOutputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TaskOutputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TaskOutputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TaskOutputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TaskOutputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TaskOutputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TaskOutputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TaskOutputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TaskOutputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TaskOutputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TaskOutputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TaskOutputValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(TaskOutputValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TaskOutputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TaskOutputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TaskOutputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TaskOutputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TaskOutputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TaskOutputValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(TaskOutputValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TaskOutputValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TaskOutputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TaskOutputValueMeta),
    ],
  )
}

pub fn task_output_new(
  value value: TaskOutputValue,
  type_ type_: Codeableconcept,
) -> TaskOutput {
  TaskOutput(value:, type_:, modifier_extension: [], extension: [], id: None)
}

pub fn task_output_to_json(task_output: TaskOutput) -> Json {
  let TaskOutput(value:, type_:, modifier_extension:, extension:, id:) =
    task_output
  let fields = [
    #("value", task_output_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_output_decoder() -> Decoder(TaskOutput) {
  use value <- decode.then(task_output_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskOutput(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn task_input_to_json(task_input: TaskInput) -> Json {
  let TaskInput(value:, type_:, modifier_extension:, extension:, id:) =
    task_input
  let fields = [
    #("value", task_input_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_input_decoder() -> Decoder(TaskInput) {
  use value <- decode.then(task_input_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskInput(value:, type_:, modifier_extension:, extension:, id:))
}

pub fn task_restriction_to_json(task_restriction: TaskRestriction) -> Json {
  let TaskRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ) = task_restriction
  let fields = []
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case repetitions {
    Some(v) -> [#("repetitions", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_restriction_decoder() -> Decoder(TaskRestriction) {
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use repetitions <- decode.optional_field(
    "repetitions",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn task_performer_to_json(task_performer: TaskPerformer) -> Json {
  let TaskPerformer(actor:, function:, modifier_extension:, extension:, id:) =
    task_performer
  let fields = [
    #("actor", reference_to_json(actor)),
  ]
  let fields = case function {
    Some(v) -> [#("function", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn task_performer_decoder() -> Decoder(TaskPerformer) {
  use actor <- decode.field("actor", reference_decoder())
  use function <- decode.optional_field(
    "function",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TaskPerformer(
    actor:,
    function:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn task_to_json(task: Task) -> Json {
  let Task(
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    reason:,
    location:,
    performer:,
    owner:,
    requested_performer:,
    requester:,
    last_modified:,
    authored_on:,
    execution_period:,
    requested_period:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    do_not_perform:,
    priority:,
    intent:,
    business_status:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = task
  let fields = [
    #("intent", r5valuesets.taskintent_to_json(intent)),
    #("status", r5valuesets.taskstatus_to_json(status)),
  ]
  let fields = case output {
    [] -> fields
    _ -> [#("output", json.array(output, task_output_to_json)), ..fields]
  }
  let fields = case input {
    [] -> fields
    _ -> [#("input", json.array(input, task_input_to_json)), ..fields]
  }
  let fields = case restriction {
    Some(v) -> [#("restriction", task_restriction_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case reason {
    [] -> fields
    _ -> [#("reason", json.array(reason, codeablereference_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer {
    [] -> fields
    _ -> [
      #("performer", json.array(performer, task_performer_to_json)),
      ..fields
    ]
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requested_performer {
    [] -> fields
    _ -> [
      #(
        "requestedPerformer",
        json.array(requested_performer, codeablereference_to_json),
      ),
      ..fields
    ]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_modified {
    Some(v) -> [#("lastModified", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case execution_period {
    Some(v) -> [#("executionPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case requested_period {
    Some(v) -> [#("requestedPeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case for {
    Some(v) -> [#("for", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case do_not_perform {
    Some(v) -> [#("doNotPerform", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case business_status {
    Some(v) -> [#("businessStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Task")), ..fields]
  json.object(fields)
}

pub fn task_decoder() -> Decoder(Task) {
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(task_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(task_input_decoder()),
  )
  use restriction <- decode.optional_field(
    "restriction",
    None,
    decode.optional(task_restriction_decoder()),
  )
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    [],
    decode.list(codeablereference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use performer <- decode.optional_field(
    "performer",
    [],
    decode.list(task_performer_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use requested_performer <- decode.optional_field(
    "requestedPerformer",
    [],
    decode.list(codeablereference_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use last_modified <- decode.optional_field(
    "lastModified",
    None,
    decode.optional(decode.string),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use execution_period <- decode.optional_field(
    "executionPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use requested_period <- decode.optional_field(
    "requestedPeriod",
    None,
    decode.optional(period_decoder()),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use for <- decode.optional_field(
    "for",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use do_not_perform <- decode.optional_field(
    "doNotPerform",
    None,
    decode.optional(decode.bool),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.taskintent_decoder())
  use business_status <- decode.optional_field(
    "businessStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use status <- decode.field("status", r5valuesets.taskstatus_decoder())
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Task",
    decode.failure(task_new(intent:, status:), "resourceType"),
  )
  decode.success(Task(
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    reason:,
    location:,
    performer:,
    owner:,
    requested_performer:,
    requester:,
    last_modified:,
    authored_on:,
    execution_period:,
    requested_period:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    do_not_perform:,
    priority:,
    intent:,
    business_status:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type Terminologycapabilities {
  Terminologycapabilities(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(TerminologycapabilitiesVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: String,
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    kind: r5valuesets.Capabilitystatementkind,
    software: Option(TerminologycapabilitiesSoftware),
    implementation: Option(TerminologycapabilitiesImplementation),
    locked_date: Option(Bool),
    code_system: List(TerminologycapabilitiesCodesystem),
    expansion: Option(TerminologycapabilitiesExpansion),
    code_search: Option(r5valuesets.Codesearchsupport),
    validate_code: Option(TerminologycapabilitiesValidatecode),
    translation: Option(TerminologycapabilitiesTranslation),
    closure: Option(TerminologycapabilitiesClosure),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesVersionalgorithm {
  TerminologycapabilitiesVersionalgorithmString(version_algorithm: String)
  TerminologycapabilitiesVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn terminologycapabilities_versionalgorithm_to_json(
  elt: TerminologycapabilitiesVersionalgorithm,
) -> Json {
  case elt {
    TerminologycapabilitiesVersionalgorithmString(v) -> json.string(v)
    TerminologycapabilitiesVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn terminologycapabilities_versionalgorithm_decoder() -> Decoder(
  TerminologycapabilitiesVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(TerminologycapabilitiesVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(TerminologycapabilitiesVersionalgorithmCoding),
    ],
  )
}

pub fn terminologycapabilities_new(
  kind kind: r5valuesets.Capabilitystatementkind,
  date date: String,
  status status: r5valuesets.Publicationstatus,
) -> Terminologycapabilities {
  Terminologycapabilities(
    closure: None,
    translation: None,
    validate_code: None,
    code_search: None,
    expansion: None,
    code_system: [],
    locked_date: None,
    implementation: None,
    software: None,
    kind:,
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date:,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesSoftware {
  TerminologycapabilitiesSoftware(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    version: Option(String),
  )
}

pub fn terminologycapabilities_software_new(
  name name: String,
) -> TerminologycapabilitiesSoftware {
  TerminologycapabilitiesSoftware(
    version: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesImplementation {
  TerminologycapabilitiesImplementation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: String,
    url: Option(String),
  )
}

pub fn terminologycapabilities_implementation_new(
  description description: String,
) -> TerminologycapabilitiesImplementation {
  TerminologycapabilitiesImplementation(
    url: None,
    description:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystem {
  TerminologycapabilitiesCodesystem(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    uri: Option(String),
    version: List(TerminologycapabilitiesCodesystemVersion),
    content: r5valuesets.Codesystemcontentmode,
    subsumption: Option(Bool),
  )
}

pub fn terminologycapabilities_codesystem_new(
  content content: r5valuesets.Codesystemcontentmode,
) -> TerminologycapabilitiesCodesystem {
  TerminologycapabilitiesCodesystem(
    subsumption: None,
    content:,
    version: [],
    uri: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersion {
  TerminologycapabilitiesCodesystemVersion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: Option(String),
    is_default: Option(Bool),
    compositional: Option(Bool),
    language: List(r5valuesets.Languages),
    filter: List(TerminologycapabilitiesCodesystemVersionFilter),
    property: List(String),
  )
}

pub fn terminologycapabilities_codesystem_version_new() -> TerminologycapabilitiesCodesystemVersion {
  TerminologycapabilitiesCodesystemVersion(
    property: [],
    filter: [],
    language: [],
    compositional: None,
    is_default: None,
    code: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesCodesystemVersionFilter {
  TerminologycapabilitiesCodesystemVersionFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    op: List(String),
  )
}

pub fn terminologycapabilities_codesystem_version_filter_new(
  code code: String,
) -> TerminologycapabilitiesCodesystemVersionFilter {
  TerminologycapabilitiesCodesystemVersionFilter(
    op: [],
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansion {
  TerminologycapabilitiesExpansion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    hierarchical: Option(Bool),
    paging: Option(Bool),
    incomplete: Option(Bool),
    parameter: List(TerminologycapabilitiesExpansionParameter),
    text_filter: Option(String),
  )
}

pub fn terminologycapabilities_expansion_new() -> TerminologycapabilitiesExpansion {
  TerminologycapabilitiesExpansion(
    text_filter: None,
    parameter: [],
    incomplete: None,
    paging: None,
    hierarchical: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesExpansionParameter {
  TerminologycapabilitiesExpansionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    documentation: Option(String),
  )
}

pub fn terminologycapabilities_expansion_parameter_new(
  name name: String,
) -> TerminologycapabilitiesExpansionParameter {
  TerminologycapabilitiesExpansionParameter(
    documentation: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesValidatecode {
  TerminologycapabilitiesValidatecode(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    translations: Bool,
  )
}

pub fn terminologycapabilities_validatecode_new(
  translations translations: Bool,
) -> TerminologycapabilitiesValidatecode {
  TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesTranslation {
  TerminologycapabilitiesTranslation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    needs_map: Bool,
  )
}

pub fn terminologycapabilities_translation_new(
  needs_map needs_map: Bool,
) -> TerminologycapabilitiesTranslation {
  TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TerminologyCapabilities#resource
pub type TerminologycapabilitiesClosure {
  TerminologycapabilitiesClosure(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    translation: Option(Bool),
  )
}

pub fn terminologycapabilities_closure_new() -> TerminologycapabilitiesClosure {
  TerminologycapabilitiesClosure(
    translation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn terminologycapabilities_closure_to_json(
  terminologycapabilities_closure: TerminologycapabilitiesClosure,
) -> Json {
  let TerminologycapabilitiesClosure(
    translation:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_closure
  let fields = []
  let fields = case translation {
    Some(v) -> [#("translation", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_closure_decoder() -> Decoder(
  TerminologycapabilitiesClosure,
) {
  use translation <- decode.optional_field(
    "translation",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesClosure(
    translation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_translation_to_json(
  terminologycapabilities_translation: TerminologycapabilitiesTranslation,
) -> Json {
  let TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_translation
  let fields = [
    #("needsMap", json.bool(needs_map)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_translation_decoder() -> Decoder(
  TerminologycapabilitiesTranslation,
) {
  use needs_map <- decode.field("needsMap", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesTranslation(
    needs_map:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_validatecode_to_json(
  terminologycapabilities_validatecode: TerminologycapabilitiesValidatecode,
) -> Json {
  let TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_validatecode
  let fields = [
    #("translations", json.bool(translations)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_validatecode_decoder() -> Decoder(
  TerminologycapabilitiesValidatecode,
) {
  use translations <- decode.field("translations", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesValidatecode(
    translations:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_expansion_parameter_to_json(
  terminologycapabilities_expansion_parameter: TerminologycapabilitiesExpansionParameter,
) -> Json {
  let TerminologycapabilitiesExpansionParameter(
    documentation:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_expansion_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case documentation {
    Some(v) -> [#("documentation", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_expansion_parameter_decoder() -> Decoder(
  TerminologycapabilitiesExpansionParameter,
) {
  use documentation <- decode.optional_field(
    "documentation",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesExpansionParameter(
    documentation:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_expansion_to_json(
  terminologycapabilities_expansion: TerminologycapabilitiesExpansion,
) -> Json {
  let TerminologycapabilitiesExpansion(
    text_filter:,
    parameter:,
    incomplete:,
    paging:,
    hierarchical:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_expansion
  let fields = []
  let fields = case text_filter {
    Some(v) -> [#("textFilter", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(
          parameter,
          terminologycapabilities_expansion_parameter_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case incomplete {
    Some(v) -> [#("incomplete", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case paging {
    Some(v) -> [#("paging", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case hierarchical {
    Some(v) -> [#("hierarchical", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_expansion_decoder() -> Decoder(
  TerminologycapabilitiesExpansion,
) {
  use text_filter <- decode.optional_field(
    "textFilter",
    None,
    decode.optional(decode.string),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(terminologycapabilities_expansion_parameter_decoder()),
  )
  use incomplete <- decode.optional_field(
    "incomplete",
    None,
    decode.optional(decode.bool),
  )
  use paging <- decode.optional_field(
    "paging",
    None,
    decode.optional(decode.bool),
  )
  use hierarchical <- decode.optional_field(
    "hierarchical",
    None,
    decode.optional(decode.bool),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesExpansion(
    text_filter:,
    parameter:,
    incomplete:,
    paging:,
    hierarchical:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_version_filter_to_json(
  terminologycapabilities_codesystem_version_filter: TerminologycapabilitiesCodesystemVersionFilter,
) -> Json {
  let TerminologycapabilitiesCodesystemVersionFilter(
    op:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem_version_filter
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case op {
    [] -> fields
    _ -> [#("op", json.array(op, json.string)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_version_filter_decoder() -> Decoder(
  TerminologycapabilitiesCodesystemVersionFilter,
) {
  use op <- decode.optional_field("op", [], decode.list(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystemVersionFilter(
    op:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_version_to_json(
  terminologycapabilities_codesystem_version: TerminologycapabilitiesCodesystemVersion,
) -> Json {
  let TerminologycapabilitiesCodesystemVersion(
    property:,
    filter:,
    language:,
    compositional:,
    is_default:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem_version
  let fields = []
  let fields = case property {
    [] -> fields
    _ -> [#("property", json.array(property, json.string)), ..fields]
  }
  let fields = case filter {
    [] -> fields
    _ -> [
      #(
        "filter",
        json.array(
          filter,
          terminologycapabilities_codesystem_version_filter_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case language {
    [] -> fields
    _ -> [
      #("language", json.array(language, r5valuesets.languages_to_json)),
      ..fields
    ]
  }
  let fields = case compositional {
    Some(v) -> [#("compositional", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case is_default {
    Some(v) -> [#("isDefault", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_version_decoder() -> Decoder(
  TerminologycapabilitiesCodesystemVersion,
) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(decode.string),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(terminologycapabilities_codesystem_version_filter_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    [],
    decode.list(r5valuesets.languages_decoder()),
  )
  use compositional <- decode.optional_field(
    "compositional",
    None,
    decode.optional(decode.bool),
  )
  use is_default <- decode.optional_field(
    "isDefault",
    None,
    decode.optional(decode.bool),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystemVersion(
    property:,
    filter:,
    language:,
    compositional:,
    is_default:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_codesystem_to_json(
  terminologycapabilities_codesystem: TerminologycapabilitiesCodesystem,
) -> Json {
  let TerminologycapabilitiesCodesystem(
    subsumption:,
    content:,
    version:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_codesystem
  let fields = [
    #("content", r5valuesets.codesystemcontentmode_to_json(content)),
  ]
  let fields = case subsumption {
    Some(v) -> [#("subsumption", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    [] -> fields
    _ -> [
      #(
        "version",
        json.array(version, terminologycapabilities_codesystem_version_to_json),
      ),
      ..fields
    ]
  }
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_codesystem_decoder() -> Decoder(
  TerminologycapabilitiesCodesystem,
) {
  use subsumption <- decode.optional_field(
    "subsumption",
    None,
    decode.optional(decode.bool),
  )
  use content <- decode.field(
    "content",
    r5valuesets.codesystemcontentmode_decoder(),
  )
  use version <- decode.optional_field(
    "version",
    [],
    decode.list(terminologycapabilities_codesystem_version_decoder()),
  )
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesCodesystem(
    subsumption:,
    content:,
    version:,
    uri:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_implementation_to_json(
  terminologycapabilities_implementation: TerminologycapabilitiesImplementation,
) -> Json {
  let TerminologycapabilitiesImplementation(
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_implementation
  let fields = [
    #("description", json.string(description)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_implementation_decoder() -> Decoder(
  TerminologycapabilitiesImplementation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use description <- decode.field("description", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesImplementation(
    url:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_software_to_json(
  terminologycapabilities_software: TerminologycapabilitiesSoftware,
) -> Json {
  let TerminologycapabilitiesSoftware(
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = terminologycapabilities_software
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn terminologycapabilities_software_decoder() -> Decoder(
  TerminologycapabilitiesSoftware,
) {
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TerminologycapabilitiesSoftware(
    version:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn terminologycapabilities_to_json(
  terminologycapabilities: Terminologycapabilities,
) -> Json {
  let Terminologycapabilities(
    closure:,
    translation:,
    validate_code:,
    code_search:,
    expansion:,
    code_system:,
    locked_date:,
    implementation:,
    software:,
    kind:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = terminologycapabilities
  let fields = [
    #("kind", r5valuesets.capabilitystatementkind_to_json(kind)),
    #("date", json.string(date)),
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case closure {
    Some(v) -> [
      #("closure", terminologycapabilities_closure_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case translation {
    Some(v) -> [
      #("translation", terminologycapabilities_translation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case validate_code {
    Some(v) -> [
      #("validateCode", terminologycapabilities_validatecode_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code_search {
    Some(v) -> [
      #("codeSearch", r5valuesets.codesearchsupport_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case expansion {
    Some(v) -> [
      #("expansion", terminologycapabilities_expansion_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case code_system {
    [] -> fields
    _ -> [
      #(
        "codeSystem",
        json.array(code_system, terminologycapabilities_codesystem_to_json),
      ),
      ..fields
    ]
  }
  let fields = case locked_date {
    Some(v) -> [#("lockedDate", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case implementation {
    Some(v) -> [
      #("implementation", terminologycapabilities_implementation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case software {
    Some(v) -> [
      #("software", terminologycapabilities_software_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          TerminologycapabilitiesVersionalgorithmString(_) -> "String"
          TerminologycapabilitiesVersionalgorithmCoding(_) -> "Coding"
        },
        terminologycapabilities_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [
    #("resourceType", json.string("Terminologycapabilities")),
    ..fields
  ]
  json.object(fields)
}

pub fn terminologycapabilities_decoder() -> Decoder(Terminologycapabilities) {
  use closure <- decode.optional_field(
    "closure",
    None,
    decode.optional(terminologycapabilities_closure_decoder()),
  )
  use translation <- decode.optional_field(
    "translation",
    None,
    decode.optional(terminologycapabilities_translation_decoder()),
  )
  use validate_code <- decode.optional_field(
    "validateCode",
    None,
    decode.optional(terminologycapabilities_validatecode_decoder()),
  )
  use code_search <- decode.optional_field(
    "codeSearch",
    None,
    decode.optional(r5valuesets.codesearchsupport_decoder()),
  )
  use expansion <- decode.optional_field(
    "expansion",
    None,
    decode.optional(terminologycapabilities_expansion_decoder()),
  )
  use code_system <- decode.optional_field(
    "codeSystem",
    [],
    decode.list(terminologycapabilities_codesystem_decoder()),
  )
  use locked_date <- decode.optional_field(
    "lockedDate",
    None,
    decode.optional(decode.bool),
  )
  use implementation <- decode.optional_field(
    "implementation",
    None,
    decode.optional(terminologycapabilities_implementation_decoder()),
  )
  use software <- decode.optional_field(
    "software",
    None,
    decode.optional(terminologycapabilities_software_decoder()),
  )
  use kind <- decode.field(
    "kind",
    r5valuesets.capabilitystatementkind_decoder(),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.field("date", decode.string)
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(terminologycapabilities_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Terminologycapabilities",
    decode.failure(
      terminologycapabilities_new(kind:, date:, status:),
      "resourceType",
    ),
  )
  decode.success(Terminologycapabilities(
    closure:,
    translation:,
    validate_code:,
    code_search:,
    expansion:,
    code_system:,
    locked_date:,
    implementation:,
    software:,
    kind:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type Testplan {
  Testplan(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(TestplanVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    category: List(Codeableconcept),
    scope: List(Reference),
    test_tools: Option(String),
    dependency: List(TestplanDependency),
    exit_criteria: Option(String),
    test_case: List(TestplanTestcase),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanVersionalgorithm {
  TestplanVersionalgorithmString(version_algorithm: String)
  TestplanVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn testplan_versionalgorithm_to_json(elt: TestplanVersionalgorithm) -> Json {
  case elt {
    TestplanVersionalgorithmString(v) -> json.string(v)
    TestplanVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn testplan_versionalgorithm_decoder() -> Decoder(TestplanVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(TestplanVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(TestplanVersionalgorithmCoding),
    ],
  )
}

pub fn testplan_new(status status: r5valuesets.Publicationstatus) -> Testplan {
  Testplan(
    test_case: [],
    exit_criteria: None,
    dependency: [],
    test_tools: None,
    scope: [],
    category: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanDependency {
  TestplanDependency(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    predecessor: Option(Reference),
  )
}

pub fn testplan_dependency_new() -> TestplanDependency {
  TestplanDependency(
    predecessor: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcase {
  TestplanTestcase(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    sequence: Option(Int),
    scope: List(Reference),
    dependency: List(TestplanTestcaseDependency),
    test_run: List(TestplanTestcaseTestrun),
    test_data: List(TestplanTestcaseTestdata),
    assertion: List(TestplanTestcaseAssertion),
  )
}

pub fn testplan_testcase_new() -> TestplanTestcase {
  TestplanTestcase(
    assertion: [],
    test_data: [],
    test_run: [],
    dependency: [],
    scope: [],
    sequence: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseDependency {
  TestplanTestcaseDependency(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    description: Option(String),
    predecessor: Option(Reference),
  )
}

pub fn testplan_testcase_dependency_new() -> TestplanTestcaseDependency {
  TestplanTestcaseDependency(
    predecessor: None,
    description: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseTestrun {
  TestplanTestcaseTestrun(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    narrative: Option(String),
    script: Option(TestplanTestcaseTestrunScript),
  )
}

pub fn testplan_testcase_testrun_new() -> TestplanTestcaseTestrun {
  TestplanTestcaseTestrun(
    script: None,
    narrative: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseTestrunScript {
  TestplanTestcaseTestrunScript(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(Codeableconcept),
    source: Option(TestplanTestcaseTestrunScriptSource),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseTestrunScriptSource {
  TestplanTestcaseTestrunScriptSourceString(source: String)
  TestplanTestcaseTestrunScriptSourceReference(source: Reference)
}

pub fn testplan_testcase_testrun_script_source_to_json(
  elt: TestplanTestcaseTestrunScriptSource,
) -> Json {
  case elt {
    TestplanTestcaseTestrunScriptSourceString(v) -> json.string(v)
    TestplanTestcaseTestrunScriptSourceReference(v) -> reference_to_json(v)
  }
}

pub fn testplan_testcase_testrun_script_source_decoder() -> Decoder(
  TestplanTestcaseTestrunScriptSource,
) {
  decode.one_of(
    decode.field("sourceString", decode.string, decode.success)
      |> decode.map(TestplanTestcaseTestrunScriptSourceString),
    [
      decode.field("sourceReference", reference_decoder(), decode.success)
      |> decode.map(TestplanTestcaseTestrunScriptSourceReference),
    ],
  )
}

pub fn testplan_testcase_testrun_script_new() -> TestplanTestcaseTestrunScript {
  TestplanTestcaseTestrunScript(
    source: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseTestdata {
  TestplanTestcaseTestdata(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Coding,
    content: Option(Reference),
    source: Option(TestplanTestcaseTestdataSource),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseTestdataSource {
  TestplanTestcaseTestdataSourceString(source: String)
  TestplanTestcaseTestdataSourceReference(source: Reference)
}

pub fn testplan_testcase_testdata_source_to_json(
  elt: TestplanTestcaseTestdataSource,
) -> Json {
  case elt {
    TestplanTestcaseTestdataSourceString(v) -> json.string(v)
    TestplanTestcaseTestdataSourceReference(v) -> reference_to_json(v)
  }
}

pub fn testplan_testcase_testdata_source_decoder() -> Decoder(
  TestplanTestcaseTestdataSource,
) {
  decode.one_of(
    decode.field("sourceString", decode.string, decode.success)
      |> decode.map(TestplanTestcaseTestdataSourceString),
    [
      decode.field("sourceReference", reference_decoder(), decode.success)
      |> decode.map(TestplanTestcaseTestdataSourceReference),
    ],
  )
}

pub fn testplan_testcase_testdata_new(
  type_ type_: Coding,
) -> TestplanTestcaseTestdata {
  TestplanTestcaseTestdata(
    source: None,
    content: None,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestPlan#resource
pub type TestplanTestcaseAssertion {
  TestplanTestcaseAssertion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: List(Codeableconcept),
    object: List(Codeablereference),
    result: List(Codeablereference),
  )
}

pub fn testplan_testcase_assertion_new() -> TestplanTestcaseAssertion {
  TestplanTestcaseAssertion(
    result: [],
    object: [],
    type_: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn testplan_testcase_assertion_to_json(
  testplan_testcase_assertion: TestplanTestcaseAssertion,
) -> Json {
  let TestplanTestcaseAssertion(
    result:,
    object:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase_assertion
  let fields = []
  let fields = case result {
    [] -> fields
    _ -> [#("result", json.array(result, codeablereference_to_json)), ..fields]
  }
  let fields = case object {
    [] -> fields
    _ -> [#("object", json.array(object, codeablereference_to_json)), ..fields]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_assertion_decoder() -> Decoder(
  TestplanTestcaseAssertion,
) {
  use result <- decode.optional_field(
    "result",
    [],
    decode.list(codeablereference_decoder()),
  )
  use object <- decode.optional_field(
    "object",
    [],
    decode.list(codeablereference_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcaseAssertion(
    result:,
    object:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_testcase_testdata_to_json(
  testplan_testcase_testdata: TestplanTestcaseTestdata,
) -> Json {
  let TestplanTestcaseTestdata(
    source:,
    content:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase_testdata
  let fields = [
    #("type", coding_to_json(type_)),
  ]
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          TestplanTestcaseTestdataSourceString(_) -> "String"
          TestplanTestcaseTestdataSourceReference(_) -> "Reference"
        },
        testplan_testcase_testdata_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case content {
    Some(v) -> [#("content", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_testdata_decoder() -> Decoder(TestplanTestcaseTestdata) {
  use source <- decode.then(
    none_if_omitted(testplan_testcase_testdata_source_decoder()),
  )
  use content <- decode.optional_field(
    "content",
    None,
    decode.optional(reference_decoder()),
  )
  use type_ <- decode.field("type", coding_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcaseTestdata(
    source:,
    content:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_testcase_testrun_script_to_json(
  testplan_testcase_testrun_script: TestplanTestcaseTestrunScript,
) -> Json {
  let TestplanTestcaseTestrunScript(
    source:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase_testrun_script
  let fields = []
  let fields = case source {
    Some(v) -> [
      #(
        "source"
          <> case v {
          TestplanTestcaseTestrunScriptSourceString(_) -> "String"
          TestplanTestcaseTestrunScriptSourceReference(_) -> "Reference"
        },
        testplan_testcase_testrun_script_source_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_testrun_script_decoder() -> Decoder(
  TestplanTestcaseTestrunScript,
) {
  use source <- decode.then(
    none_if_omitted(testplan_testcase_testrun_script_source_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcaseTestrunScript(
    source:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_testcase_testrun_to_json(
  testplan_testcase_testrun: TestplanTestcaseTestrun,
) -> Json {
  let TestplanTestcaseTestrun(
    script:,
    narrative:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase_testrun
  let fields = []
  let fields = case script {
    Some(v) -> [
      #("script", testplan_testcase_testrun_script_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case narrative {
    Some(v) -> [#("narrative", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_testrun_decoder() -> Decoder(TestplanTestcaseTestrun) {
  use script <- decode.optional_field(
    "script",
    None,
    decode.optional(testplan_testcase_testrun_script_decoder()),
  )
  use narrative <- decode.optional_field(
    "narrative",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcaseTestrun(
    script:,
    narrative:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_testcase_dependency_to_json(
  testplan_testcase_dependency: TestplanTestcaseDependency,
) -> Json {
  let TestplanTestcaseDependency(
    predecessor:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase_dependency
  let fields = []
  let fields = case predecessor {
    Some(v) -> [#("predecessor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_dependency_decoder() -> Decoder(
  TestplanTestcaseDependency,
) {
  use predecessor <- decode.optional_field(
    "predecessor",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcaseDependency(
    predecessor:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_testcase_to_json(testplan_testcase: TestplanTestcase) -> Json {
  let TestplanTestcase(
    assertion:,
    test_data:,
    test_run:,
    dependency:,
    scope:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_testcase
  let fields = []
  let fields = case assertion {
    [] -> fields
    _ -> [
      #("assertion", json.array(assertion, testplan_testcase_assertion_to_json)),
      ..fields
    ]
  }
  let fields = case test_data {
    [] -> fields
    _ -> [
      #("testData", json.array(test_data, testplan_testcase_testdata_to_json)),
      ..fields
    ]
  }
  let fields = case test_run {
    [] -> fields
    _ -> [
      #("testRun", json.array(test_run, testplan_testcase_testrun_to_json)),
      ..fields
    ]
  }
  let fields = case dependency {
    [] -> fields
    _ -> [
      #(
        "dependency",
        json.array(dependency, testplan_testcase_dependency_to_json),
      ),
      ..fields
    ]
  }
  let fields = case scope {
    [] -> fields
    _ -> [#("scope", json.array(scope, reference_to_json)), ..fields]
  }
  let fields = case sequence {
    Some(v) -> [#("sequence", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_testcase_decoder() -> Decoder(TestplanTestcase) {
  use assertion <- decode.optional_field(
    "assertion",
    [],
    decode.list(testplan_testcase_assertion_decoder()),
  )
  use test_data <- decode.optional_field(
    "testData",
    [],
    decode.list(testplan_testcase_testdata_decoder()),
  )
  use test_run <- decode.optional_field(
    "testRun",
    [],
    decode.list(testplan_testcase_testrun_decoder()),
  )
  use dependency <- decode.optional_field(
    "dependency",
    [],
    decode.list(testplan_testcase_dependency_decoder()),
  )
  use scope <- decode.optional_field(
    "scope",
    [],
    decode.list(reference_decoder()),
  )
  use sequence <- decode.optional_field(
    "sequence",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanTestcase(
    assertion:,
    test_data:,
    test_run:,
    dependency:,
    scope:,
    sequence:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_dependency_to_json(
  testplan_dependency: TestplanDependency,
) -> Json {
  let TestplanDependency(
    predecessor:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ) = testplan_dependency
  let fields = []
  let fields = case predecessor {
    Some(v) -> [#("predecessor", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testplan_dependency_decoder() -> Decoder(TestplanDependency) {
  use predecessor <- decode.optional_field(
    "predecessor",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestplanDependency(
    predecessor:,
    description:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testplan_to_json(testplan: Testplan) -> Json {
  let Testplan(
    test_case:,
    exit_criteria:,
    dependency:,
    test_tools:,
    scope:,
    category:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = testplan
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case test_case {
    [] -> fields
    _ -> [
      #("testCase", json.array(test_case, testplan_testcase_to_json)),
      ..fields
    ]
  }
  let fields = case exit_criteria {
    Some(v) -> [#("exitCriteria", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case dependency {
    [] -> fields
    _ -> [
      #("dependency", json.array(dependency, testplan_dependency_to_json)),
      ..fields
    ]
  }
  let fields = case test_tools {
    Some(v) -> [#("testTools", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case scope {
    [] -> fields
    _ -> [#("scope", json.array(scope, reference_to_json)), ..fields]
  }
  let fields = case category {
    [] -> fields
    _ -> [
      #("category", json.array(category, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          TestplanVersionalgorithmString(_) -> "String"
          TestplanVersionalgorithmCoding(_) -> "Coding"
        },
        testplan_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Testplan")), ..fields]
  json.object(fields)
}

pub fn testplan_decoder() -> Decoder(Testplan) {
  use test_case <- decode.optional_field(
    "testCase",
    [],
    decode.list(testplan_testcase_decoder()),
  )
  use exit_criteria <- decode.optional_field(
    "exitCriteria",
    None,
    decode.optional(decode.string),
  )
  use dependency <- decode.optional_field(
    "dependency",
    [],
    decode.list(testplan_dependency_decoder()),
  )
  use test_tools <- decode.optional_field(
    "testTools",
    None,
    decode.optional(decode.string),
  )
  use scope <- decode.optional_field(
    "scope",
    [],
    decode.list(reference_decoder()),
  )
  use category <- decode.optional_field(
    "category",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(testplan_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Testplan",
    decode.failure(testplan_new(status:), "resourceType"),
  )
  decode.success(Testplan(
    test_case:,
    exit_criteria:,
    dependency:,
    test_tools:,
    scope:,
    category:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type Testreport {
  Testreport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(Identifier),
    name: Option(String),
    status: r5valuesets.Reportstatuscodes,
    test_script: String,
    result: r5valuesets.Reportresultcodes,
    score: Option(Float),
    tester: Option(String),
    issued: Option(String),
    participant: List(TestreportParticipant),
    setup: Option(TestreportSetup),
    test_: List(TestreportTest),
    teardown: Option(TestreportTeardown),
  )
}

pub fn testreport_new(
  result result: r5valuesets.Reportresultcodes,
  test_script test_script: String,
  status status: r5valuesets.Reportstatuscodes,
) -> Testreport {
  Testreport(
    teardown: None,
    test_: [],
    setup: None,
    participant: [],
    issued: None,
    tester: None,
    score: None,
    result:,
    test_script:,
    status:,
    name: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportParticipant {
  TestreportParticipant(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: r5valuesets.Reportparticipanttype,
    uri: String,
    display: Option(String),
  )
}

pub fn testreport_participant_new(
  uri uri: String,
  type_ type_: r5valuesets.Reportparticipanttype,
) -> TestreportParticipant {
  TestreportParticipant(
    display: None,
    uri:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetup {
  TestreportSetup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestreportSetupAction),
  )
}

pub fn testreport_setup_new() -> TestreportSetup {
  TestreportSetup(action: [], modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetupAction {
  TestreportSetupAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    operation: Option(TestreportSetupActionOperation),
    assert_: Option(TestreportSetupActionAssert),
  )
}

pub fn testreport_setup_action_new() -> TestreportSetupAction {
  TestreportSetupAction(
    assert_: None,
    operation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetupActionOperation {
  TestreportSetupActionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    result: r5valuesets.Reportactionresultcodes,
    message: Option(String),
    detail: Option(String),
  )
}

pub fn testreport_setup_action_operation_new(
  result result: r5valuesets.Reportactionresultcodes,
) -> TestreportSetupActionOperation {
  TestreportSetupActionOperation(
    detail: None,
    message: None,
    result:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetupActionAssert {
  TestreportSetupActionAssert(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    result: r5valuesets.Reportactionresultcodes,
    message: Option(String),
    detail: Option(String),
    requirement: List(TestreportSetupActionAssertRequirement),
  )
}

pub fn testreport_setup_action_assert_new(
  result result: r5valuesets.Reportactionresultcodes,
) -> TestreportSetupActionAssert {
  TestreportSetupActionAssert(
    requirement: [],
    detail: None,
    message: None,
    result:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetupActionAssertRequirement {
  TestreportSetupActionAssertRequirement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link: Option(TestreportSetupActionAssertRequirementLink),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportSetupActionAssertRequirementLink {
  TestreportSetupActionAssertRequirementLinkUri(link: String)
  TestreportSetupActionAssertRequirementLinkCanonical(link: String)
}

pub fn testreport_setup_action_assert_requirement_link_to_json(
  elt: TestreportSetupActionAssertRequirementLink,
) -> Json {
  case elt {
    TestreportSetupActionAssertRequirementLinkUri(v) -> json.string(v)
    TestreportSetupActionAssertRequirementLinkCanonical(v) -> json.string(v)
  }
}

pub fn testreport_setup_action_assert_requirement_link_decoder() -> Decoder(
  TestreportSetupActionAssertRequirementLink,
) {
  decode.one_of(
    decode.field("linkUri", decode.string, decode.success)
      |> decode.map(TestreportSetupActionAssertRequirementLinkUri),
    [
      decode.field("linkCanonical", decode.string, decode.success)
      |> decode.map(TestreportSetupActionAssertRequirementLinkCanonical),
    ],
  )
}

pub fn testreport_setup_action_assert_requirement_new() -> TestreportSetupActionAssertRequirement {
  TestreportSetupActionAssertRequirement(
    link: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportTest {
  TestreportTest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    description: Option(String),
    action: List(TestreportTestAction),
  )
}

pub fn testreport_test_new() -> TestreportTest {
  TestreportTest(
    action: [],
    description: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportTestAction {
  TestreportTestAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testreport_test_action_new() -> TestreportTestAction {
  TestreportTestAction(modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportTeardown {
  TestreportTeardown(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestreportTeardownAction),
  )
}

pub fn testreport_teardown_new() -> TestreportTeardown {
  TestreportTeardown(
    action: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestReport#resource
pub type TestreportTeardownAction {
  TestreportTeardownAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testreport_teardown_action_new() -> TestreportTeardownAction {
  TestreportTeardownAction(modifier_extension: [], extension: [], id: None)
}

pub fn testreport_teardown_action_to_json(
  testreport_teardown_action: TestreportTeardownAction,
) -> Json {
  let TestreportTeardownAction(modifier_extension:, extension:, id:) =
    testreport_teardown_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_teardown_action_decoder() -> Decoder(TestreportTeardownAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTeardownAction(modifier_extension:, extension:, id:))
}

pub fn testreport_teardown_to_json(
  testreport_teardown: TestreportTeardown,
) -> Json {
  let TestreportTeardown(action:, modifier_extension:, extension:, id:) =
    testreport_teardown
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_teardown_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_teardown_decoder() -> Decoder(TestreportTeardown) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_teardown_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTeardown(
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_test_action_to_json(
  testreport_test_action: TestreportTestAction,
) -> Json {
  let TestreportTestAction(modifier_extension:, extension:, id:) =
    testreport_test_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_test_action_decoder() -> Decoder(TestreportTestAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTestAction(modifier_extension:, extension:, id:))
}

pub fn testreport_test_to_json(testreport_test: TestreportTest) -> Json {
  let TestreportTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_test
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_test_action_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_test_decoder() -> Decoder(TestreportTest) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_test_action_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_assert_requirement_to_json(
  testreport_setup_action_assert_requirement: TestreportSetupActionAssertRequirement,
) -> Json {
  let TestreportSetupActionAssertRequirement(
    link:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action_assert_requirement
  let fields = []
  let fields = case link {
    Some(v) -> [
      #(
        "link"
          <> case v {
          TestreportSetupActionAssertRequirementLinkUri(_) -> "Uri"
          TestreportSetupActionAssertRequirementLinkCanonical(_) -> "Canonical"
        },
        testreport_setup_action_assert_requirement_link_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_assert_requirement_decoder() -> Decoder(
  TestreportSetupActionAssertRequirement,
) {
  use link <- decode.then(
    none_if_omitted(testreport_setup_action_assert_requirement_link_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupActionAssertRequirement(
    link:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_assert_to_json(
  testreport_setup_action_assert: TestreportSetupActionAssert,
) -> Json {
  let TestreportSetupActionAssert(
    requirement:,
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action_assert
  let fields = [
    #("result", r5valuesets.reportactionresultcodes_to_json(result)),
  ]
  let fields = case requirement {
    [] -> fields
    _ -> [
      #(
        "requirement",
        json.array(
          requirement,
          testreport_setup_action_assert_requirement_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case message {
    Some(v) -> [#("message", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_assert_decoder() -> Decoder(
  TestreportSetupActionAssert,
) {
  use requirement <- decode.optional_field(
    "requirement",
    [],
    decode.list(testreport_setup_action_assert_requirement_decoder()),
  )
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.optional_field(
    "message",
    None,
    decode.optional(decode.string),
  )
  use result <- decode.field(
    "result",
    r5valuesets.reportactionresultcodes_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupActionAssert(
    requirement:,
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_operation_to_json(
  testreport_setup_action_operation: TestreportSetupActionOperation,
) -> Json {
  let TestreportSetupActionOperation(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action_operation
  let fields = [
    #("result", r5valuesets.reportactionresultcodes_to_json(result)),
  ]
  let fields = case detail {
    Some(v) -> [#("detail", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case message {
    Some(v) -> [#("message", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_operation_decoder() -> Decoder(
  TestreportSetupActionOperation,
) {
  use detail <- decode.optional_field(
    "detail",
    None,
    decode.optional(decode.string),
  )
  use message <- decode.optional_field(
    "message",
    None,
    decode.optional(decode.string),
  )
  use result <- decode.field(
    "result",
    r5valuesets.reportactionresultcodes_decoder(),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupActionOperation(
    detail:,
    message:,
    result:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_action_to_json(
  testreport_setup_action: TestreportSetupAction,
) -> Json {
  let TestreportSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_setup_action
  let fields = []
  let fields = case assert_ {
    Some(v) -> [
      #("assert", testreport_setup_action_assert_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", testreport_setup_action_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_action_decoder() -> Decoder(TestreportSetupAction) {
  use assert_ <- decode.optional_field(
    "assert",
    None,
    decode.optional(testreport_setup_action_assert_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(testreport_setup_action_operation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_setup_to_json(testreport_setup: TestreportSetup) -> Json {
  let TestreportSetup(action:, modifier_extension:, extension:, id:) =
    testreport_setup
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testreport_setup_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_setup_decoder() -> Decoder(TestreportSetup) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testreport_setup_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportSetup(action:, modifier_extension:, extension:, id:))
}

pub fn testreport_participant_to_json(
  testreport_participant: TestreportParticipant,
) -> Json {
  let TestreportParticipant(
    display:,
    uri:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testreport_participant
  let fields = [
    #("uri", json.string(uri)),
    #("type", r5valuesets.reportparticipanttype_to_json(type_)),
  ]
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testreport_participant_decoder() -> Decoder(TestreportParticipant) {
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use uri <- decode.field("uri", decode.string)
  use type_ <- decode.field("type", r5valuesets.reportparticipanttype_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestreportParticipant(
    display:,
    uri:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testreport_to_json(testreport: Testreport) -> Json {
  let Testreport(
    teardown:,
    test_:,
    setup:,
    participant:,
    issued:,
    tester:,
    score:,
    result:,
    test_script:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = testreport
  let fields = [
    #("result", r5valuesets.reportresultcodes_to_json(result)),
    #("testScript", json.string(test_script)),
    #("status", r5valuesets.reportstatuscodes_to_json(status)),
  ]
  let fields = case teardown {
    Some(v) -> [#("teardown", testreport_teardown_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case test_ {
    [] -> fields
    _ -> [#("test", json.array(test_, testreport_test_to_json)), ..fields]
  }
  let fields = case setup {
    Some(v) -> [#("setup", testreport_setup_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case participant {
    [] -> fields
    _ -> [
      #("participant", json.array(participant, testreport_participant_to_json)),
      ..fields
    ]
  }
  let fields = case issued {
    Some(v) -> [#("issued", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case tester {
    Some(v) -> [#("tester", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case score {
    Some(v) -> [#("score", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Testreport")), ..fields]
  json.object(fields)
}

pub fn testreport_decoder() -> Decoder(Testreport) {
  use teardown <- decode.optional_field(
    "teardown",
    None,
    decode.optional(testreport_teardown_decoder()),
  )
  use test_ <- decode.optional_field(
    "test",
    [],
    decode.list(testreport_test_decoder()),
  )
  use setup <- decode.optional_field(
    "setup",
    None,
    decode.optional(testreport_setup_decoder()),
  )
  use participant <- decode.optional_field(
    "participant",
    [],
    decode.list(testreport_participant_decoder()),
  )
  use issued <- decode.optional_field(
    "issued",
    None,
    decode.optional(decode.string),
  )
  use tester <- decode.optional_field(
    "tester",
    None,
    decode.optional(decode.string),
  )
  use score <- decode.optional_field(
    "score",
    None,
    decode.optional(decode.float),
  )
  use result <- decode.field("result", r5valuesets.reportresultcodes_decoder())
  use test_script <- decode.field("testScript", decode.string)
  use status <- decode.field("status", r5valuesets.reportstatuscodes_decoder())
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Testreport",
    decode.failure(
      testreport_new(result:, test_script:, status:),
      "resourceType",
    ),
  )
  decode.success(Testreport(
    teardown:,
    test_:,
    setup:,
    participant:,
    issued:,
    tester:,
    score:,
    result:,
    test_script:,
    status:,
    name:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type Testscript {
  Testscript(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(TestscriptVersionalgorithm),
    name: String,
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    origin: List(TestscriptOrigin),
    destination: List(TestscriptDestination),
    metadata: Option(TestscriptMetadata),
    scope: List(TestscriptScope),
    fixture: List(TestscriptFixture),
    profile: List(String),
    variable: List(TestscriptVariable),
    setup: Option(TestscriptSetup),
    test_: List(TestscriptTest),
    teardown: Option(TestscriptTeardown),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptVersionalgorithm {
  TestscriptVersionalgorithmString(version_algorithm: String)
  TestscriptVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn testscript_versionalgorithm_to_json(
  elt: TestscriptVersionalgorithm,
) -> Json {
  case elt {
    TestscriptVersionalgorithmString(v) -> json.string(v)
    TestscriptVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn testscript_versionalgorithm_decoder() -> Decoder(
  TestscriptVersionalgorithm,
) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(TestscriptVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(TestscriptVersionalgorithmCoding),
    ],
  )
}

pub fn testscript_new(
  status status: r5valuesets.Publicationstatus,
  name name: String,
) -> Testscript {
  Testscript(
    teardown: None,
    test_: [],
    setup: None,
    variable: [],
    profile: [],
    fixture: [],
    scope: [],
    metadata: None,
    destination: [],
    origin: [],
    copyright_label: None,
    copyright: None,
    purpose: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name:,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptOrigin {
  TestscriptOrigin(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    index: Int,
    profile: Coding,
    url: Option(String),
  )
}

pub fn testscript_origin_new(
  profile profile: Coding,
  index index: Int,
) -> TestscriptOrigin {
  TestscriptOrigin(
    url: None,
    profile:,
    index:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptDestination {
  TestscriptDestination(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    index: Int,
    profile: Coding,
    url: Option(String),
  )
}

pub fn testscript_destination_new(
  profile profile: Coding,
  index index: Int,
) -> TestscriptDestination {
  TestscriptDestination(
    url: None,
    profile:,
    index:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptMetadata {
  TestscriptMetadata(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link: List(TestscriptMetadataLink),
    capability: List(TestscriptMetadataCapability),
  )
}

pub fn testscript_metadata_new() -> TestscriptMetadata {
  TestscriptMetadata(
    capability: [],
    link: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptMetadataLink {
  TestscriptMetadataLink(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: String,
    description: Option(String),
  )
}

pub fn testscript_metadata_link_new(url url: String) -> TestscriptMetadataLink {
  TestscriptMetadataLink(
    description: None,
    url:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptMetadataCapability {
  TestscriptMetadataCapability(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    required: Bool,
    validated: Bool,
    description: Option(String),
    origin: List(Int),
    destination: Option(Int),
    link: List(String),
    capabilities: String,
  )
}

pub fn testscript_metadata_capability_new(
  capabilities capabilities: String,
  validated validated: Bool,
  required required: Bool,
) -> TestscriptMetadataCapability {
  TestscriptMetadataCapability(
    capabilities:,
    link: [],
    destination: None,
    origin: [],
    description: None,
    validated:,
    required:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptScope {
  TestscriptScope(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    artifact: String,
    conformance: Option(Codeableconcept),
    phase: Option(Codeableconcept),
  )
}

pub fn testscript_scope_new(artifact artifact: String) -> TestscriptScope {
  TestscriptScope(
    phase: None,
    conformance: None,
    artifact:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptFixture {
  TestscriptFixture(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    autocreate: Bool,
    autodelete: Bool,
    resource: Option(Reference),
  )
}

pub fn testscript_fixture_new(
  autodelete autodelete: Bool,
  autocreate autocreate: Bool,
) -> TestscriptFixture {
  TestscriptFixture(
    resource: None,
    autodelete:,
    autocreate:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptVariable {
  TestscriptVariable(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    default_value: Option(String),
    description: Option(String),
    expression: Option(String),
    header_field: Option(String),
    hint: Option(String),
    path: Option(String),
    source_id: Option(String),
  )
}

pub fn testscript_variable_new(name name: String) -> TestscriptVariable {
  TestscriptVariable(
    source_id: None,
    path: None,
    hint: None,
    header_field: None,
    expression: None,
    description: None,
    default_value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetup {
  TestscriptSetup(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestscriptSetupAction),
  )
}

pub fn testscript_setup_new() -> TestscriptSetup {
  TestscriptSetup(action: [], modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupAction {
  TestscriptSetupAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    operation: Option(TestscriptSetupActionOperation),
    assert_: Option(TestscriptSetupActionAssert),
  )
}

pub fn testscript_setup_action_new() -> TestscriptSetupAction {
  TestscriptSetupAction(
    assert_: None,
    operation: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperation {
  TestscriptSetupActionOperation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Option(Coding),
    resource: Option(String),
    label: Option(String),
    description: Option(String),
    accept: Option(String),
    content_type: Option(String),
    destination: Option(Int),
    encode_request_url: Bool,
    method: Option(r5valuesets.Httpoperations),
    origin: Option(Int),
    params: Option(String),
    request_header: List(TestscriptSetupActionOperationRequestheader),
    request_id: Option(String),
    response_id: Option(String),
    source_id: Option(String),
    target_id: Option(String),
    url: Option(String),
  )
}

pub fn testscript_setup_action_operation_new(
  encode_request_url encode_request_url: Bool,
) -> TestscriptSetupActionOperation {
  TestscriptSetupActionOperation(
    url: None,
    target_id: None,
    source_id: None,
    response_id: None,
    request_id: None,
    request_header: [],
    params: None,
    origin: None,
    method: None,
    encode_request_url:,
    destination: None,
    content_type: None,
    accept: None,
    description: None,
    label: None,
    resource: None,
    type_: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionOperationRequestheader {
  TestscriptSetupActionOperationRequestheader(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    field: String,
    value: String,
  )
}

pub fn testscript_setup_action_operation_requestheader_new(
  value value: String,
  field field: String,
) -> TestscriptSetupActionOperationRequestheader {
  TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionAssert {
  TestscriptSetupActionAssert(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    label: Option(String),
    description: Option(String),
    direction: Option(r5valuesets.Assertdirectioncodes),
    compare_to_source_id: Option(String),
    compare_to_source_expression: Option(String),
    compare_to_source_path: Option(String),
    content_type: Option(String),
    default_manual_completion: Option(r5valuesets.Assertmanualcompletioncodes),
    expression: Option(String),
    header_field: Option(String),
    minimum_id: Option(String),
    navigation_links: Option(Bool),
    operator: Option(r5valuesets.Assertoperatorcodes),
    path: Option(String),
    request_method: Option(r5valuesets.Httpoperations),
    request_url: Option(String),
    resource: Option(String),
    response: Option(r5valuesets.Assertresponsecodetypes),
    response_code: Option(String),
    source_id: Option(String),
    stop_test_on_fail: Bool,
    validate_profile_id: Option(String),
    value: Option(String),
    warning_only: Bool,
    requirement: List(TestscriptSetupActionAssertRequirement),
  )
}

pub fn testscript_setup_action_assert_new(
  warning_only warning_only: Bool,
  stop_test_on_fail stop_test_on_fail: Bool,
) -> TestscriptSetupActionAssert {
  TestscriptSetupActionAssert(
    requirement: [],
    warning_only:,
    value: None,
    validate_profile_id: None,
    stop_test_on_fail:,
    source_id: None,
    response_code: None,
    response: None,
    resource: None,
    request_url: None,
    request_method: None,
    path: None,
    operator: None,
    navigation_links: None,
    minimum_id: None,
    header_field: None,
    expression: None,
    default_manual_completion: None,
    content_type: None,
    compare_to_source_path: None,
    compare_to_source_expression: None,
    compare_to_source_id: None,
    direction: None,
    description: None,
    label: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionAssertRequirement {
  TestscriptSetupActionAssertRequirement(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    link: Option(TestscriptSetupActionAssertRequirementLink),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptSetupActionAssertRequirementLink {
  TestscriptSetupActionAssertRequirementLinkUri(link: String)
  TestscriptSetupActionAssertRequirementLinkCanonical(link: String)
}

pub fn testscript_setup_action_assert_requirement_link_to_json(
  elt: TestscriptSetupActionAssertRequirementLink,
) -> Json {
  case elt {
    TestscriptSetupActionAssertRequirementLinkUri(v) -> json.string(v)
    TestscriptSetupActionAssertRequirementLinkCanonical(v) -> json.string(v)
  }
}

pub fn testscript_setup_action_assert_requirement_link_decoder() -> Decoder(
  TestscriptSetupActionAssertRequirementLink,
) {
  decode.one_of(
    decode.field("linkUri", decode.string, decode.success)
      |> decode.map(TestscriptSetupActionAssertRequirementLinkUri),
    [
      decode.field("linkCanonical", decode.string, decode.success)
      |> decode.map(TestscriptSetupActionAssertRequirementLinkCanonical),
    ],
  )
}

pub fn testscript_setup_action_assert_requirement_new() -> TestscriptSetupActionAssertRequirement {
  TestscriptSetupActionAssertRequirement(
    link: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptTest {
  TestscriptTest(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: Option(String),
    description: Option(String),
    action: List(TestscriptTestAction),
  )
}

pub fn testscript_test_new() -> TestscriptTest {
  TestscriptTest(
    action: [],
    description: None,
    name: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptTestAction {
  TestscriptTestAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testscript_test_action_new() -> TestscriptTestAction {
  TestscriptTestAction(modifier_extension: [], extension: [], id: None)
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptTeardown {
  TestscriptTeardown(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    action: List(TestscriptTeardownAction),
  )
}

pub fn testscript_teardown_new() -> TestscriptTeardown {
  TestscriptTeardown(
    action: [],
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/TestScript#resource
pub type TestscriptTeardownAction {
  TestscriptTeardownAction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
  )
}

pub fn testscript_teardown_action_new() -> TestscriptTeardownAction {
  TestscriptTeardownAction(modifier_extension: [], extension: [], id: None)
}

pub fn testscript_teardown_action_to_json(
  testscript_teardown_action: TestscriptTeardownAction,
) -> Json {
  let TestscriptTeardownAction(modifier_extension:, extension:, id:) =
    testscript_teardown_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_teardown_action_decoder() -> Decoder(TestscriptTeardownAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTeardownAction(modifier_extension:, extension:, id:))
}

pub fn testscript_teardown_to_json(
  testscript_teardown: TestscriptTeardown,
) -> Json {
  let TestscriptTeardown(action:, modifier_extension:, extension:, id:) =
    testscript_teardown
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_teardown_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_teardown_decoder() -> Decoder(TestscriptTeardown) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_teardown_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTeardown(
    action:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_test_action_to_json(
  testscript_test_action: TestscriptTestAction,
) -> Json {
  let TestscriptTestAction(modifier_extension:, extension:, id:) =
    testscript_test_action
  let fields = []
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_test_action_decoder() -> Decoder(TestscriptTestAction) {
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTestAction(modifier_extension:, extension:, id:))
}

pub fn testscript_test_to_json(testscript_test: TestscriptTest) -> Json {
  let TestscriptTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_test
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_test_action_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_test_decoder() -> Decoder(TestscriptTest) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_test_action_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptTest(
    action:,
    description:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_assert_requirement_to_json(
  testscript_setup_action_assert_requirement: TestscriptSetupActionAssertRequirement,
) -> Json {
  let TestscriptSetupActionAssertRequirement(
    link:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_assert_requirement
  let fields = []
  let fields = case link {
    Some(v) -> [
      #(
        "link"
          <> case v {
          TestscriptSetupActionAssertRequirementLinkUri(_) -> "Uri"
          TestscriptSetupActionAssertRequirementLinkCanonical(_) -> "Canonical"
        },
        testscript_setup_action_assert_requirement_link_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_assert_requirement_decoder() -> Decoder(
  TestscriptSetupActionAssertRequirement,
) {
  use link <- decode.then(
    none_if_omitted(testscript_setup_action_assert_requirement_link_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionAssertRequirement(
    link:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_assert_to_json(
  testscript_setup_action_assert: TestscriptSetupActionAssert,
) -> Json {
  let TestscriptSetupActionAssert(
    requirement:,
    warning_only:,
    value:,
    validate_profile_id:,
    stop_test_on_fail:,
    source_id:,
    response_code:,
    response:,
    resource:,
    request_url:,
    request_method:,
    path:,
    operator:,
    navigation_links:,
    minimum_id:,
    header_field:,
    expression:,
    default_manual_completion:,
    content_type:,
    compare_to_source_path:,
    compare_to_source_expression:,
    compare_to_source_id:,
    direction:,
    description:,
    label:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_assert
  let fields = [
    #("warningOnly", json.bool(warning_only)),
    #("stopTestOnFail", json.bool(stop_test_on_fail)),
  ]
  let fields = case requirement {
    [] -> fields
    _ -> [
      #(
        "requirement",
        json.array(
          requirement,
          testscript_setup_action_assert_requirement_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case value {
    Some(v) -> [#("value", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case validate_profile_id {
    Some(v) -> [#("validateProfileId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response_code {
    Some(v) -> [#("responseCode", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response {
    Some(v) -> [
      #("response", r5valuesets.assertresponsecodetypes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_url {
    Some(v) -> [#("requestURL", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_method {
    Some(v) -> [
      #("requestMethod", r5valuesets.httpoperations_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case operator {
    Some(v) -> [
      #("operator", r5valuesets.assertoperatorcodes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case navigation_links {
    Some(v) -> [#("navigationLinks", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case minimum_id {
    Some(v) -> [#("minimumId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case header_field {
    Some(v) -> [#("headerField", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_manual_completion {
    Some(v) -> [
      #(
        "defaultManualCompletion",
        r5valuesets.assertmanualcompletioncodes_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_path {
    Some(v) -> [#("compareToSourcePath", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_expression {
    Some(v) -> [#("compareToSourceExpression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case compare_to_source_id {
    Some(v) -> [#("compareToSourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case direction {
    Some(v) -> [
      #("direction", r5valuesets.assertdirectioncodes_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_assert_decoder() -> Decoder(
  TestscriptSetupActionAssert,
) {
  use requirement <- decode.optional_field(
    "requirement",
    [],
    decode.list(testscript_setup_action_assert_requirement_decoder()),
  )
  use warning_only <- decode.field("warningOnly", decode.bool)
  use value <- decode.optional_field(
    "value",
    None,
    decode.optional(decode.string),
  )
  use validate_profile_id <- decode.optional_field(
    "validateProfileId",
    None,
    decode.optional(decode.string),
  )
  use stop_test_on_fail <- decode.field("stopTestOnFail", decode.bool)
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use response_code <- decode.optional_field(
    "responseCode",
    None,
    decode.optional(decode.string),
  )
  use response <- decode.optional_field(
    "response",
    None,
    decode.optional(r5valuesets.assertresponsecodetypes_decoder()),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use request_url <- decode.optional_field(
    "requestURL",
    None,
    decode.optional(decode.string),
  )
  use request_method <- decode.optional_field(
    "requestMethod",
    None,
    decode.optional(r5valuesets.httpoperations_decoder()),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use operator <- decode.optional_field(
    "operator",
    None,
    decode.optional(r5valuesets.assertoperatorcodes_decoder()),
  )
  use navigation_links <- decode.optional_field(
    "navigationLinks",
    None,
    decode.optional(decode.bool),
  )
  use minimum_id <- decode.optional_field(
    "minimumId",
    None,
    decode.optional(decode.string),
  )
  use header_field <- decode.optional_field(
    "headerField",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use default_manual_completion <- decode.optional_field(
    "defaultManualCompletion",
    None,
    decode.optional(r5valuesets.assertmanualcompletioncodes_decoder()),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_path <- decode.optional_field(
    "compareToSourcePath",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_expression <- decode.optional_field(
    "compareToSourceExpression",
    None,
    decode.optional(decode.string),
  )
  use compare_to_source_id <- decode.optional_field(
    "compareToSourceId",
    None,
    decode.optional(decode.string),
  )
  use direction <- decode.optional_field(
    "direction",
    None,
    decode.optional(r5valuesets.assertdirectioncodes_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionAssert(
    requirement:,
    warning_only:,
    value:,
    validate_profile_id:,
    stop_test_on_fail:,
    source_id:,
    response_code:,
    response:,
    resource:,
    request_url:,
    request_method:,
    path:,
    operator:,
    navigation_links:,
    minimum_id:,
    header_field:,
    expression:,
    default_manual_completion:,
    content_type:,
    compare_to_source_path:,
    compare_to_source_expression:,
    compare_to_source_id:,
    direction:,
    description:,
    label:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_operation_requestheader_to_json(
  testscript_setup_action_operation_requestheader: TestscriptSetupActionOperationRequestheader,
) -> Json {
  let TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_operation_requestheader
  let fields = [
    #("value", json.string(value)),
    #("field", json.string(field)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_operation_requestheader_decoder() -> Decoder(
  TestscriptSetupActionOperationRequestheader,
) {
  use value <- decode.field("value", decode.string)
  use field <- decode.field("field", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionOperationRequestheader(
    value:,
    field:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_operation_to_json(
  testscript_setup_action_operation: TestscriptSetupActionOperation,
) -> Json {
  let TestscriptSetupActionOperation(
    url:,
    target_id:,
    source_id:,
    response_id:,
    request_id:,
    request_header:,
    params:,
    origin:,
    method:,
    encode_request_url:,
    destination:,
    content_type:,
    accept:,
    description:,
    label:,
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action_operation
  let fields = [
    #("encodeRequestUrl", json.bool(encode_request_url)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case target_id {
    Some(v) -> [#("targetId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case response_id {
    Some(v) -> [#("responseId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_id {
    Some(v) -> [#("requestId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case request_header {
    [] -> fields
    _ -> [
      #(
        "requestHeader",
        json.array(
          request_header,
          testscript_setup_action_operation_requestheader_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case params {
    Some(v) -> [#("params", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    Some(v) -> [#("origin", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case method {
    Some(v) -> [#("method", r5valuesets.httpoperations_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    Some(v) -> [#("destination", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case content_type {
    Some(v) -> [#("contentType", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case accept {
    Some(v) -> [#("accept", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case label {
    Some(v) -> [#("label", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case resource {
    Some(v) -> [#("resource", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case type_ {
    Some(v) -> [#("type", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_operation_decoder() -> Decoder(
  TestscriptSetupActionOperation,
) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use target_id <- decode.optional_field(
    "targetId",
    None,
    decode.optional(decode.string),
  )
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use response_id <- decode.optional_field(
    "responseId",
    None,
    decode.optional(decode.string),
  )
  use request_id <- decode.optional_field(
    "requestId",
    None,
    decode.optional(decode.string),
  )
  use request_header <- decode.optional_field(
    "requestHeader",
    [],
    decode.list(testscript_setup_action_operation_requestheader_decoder()),
  )
  use params <- decode.optional_field(
    "params",
    None,
    decode.optional(decode.string),
  )
  use origin <- decode.optional_field(
    "origin",
    None,
    decode.optional(decode.int),
  )
  use method <- decode.optional_field(
    "method",
    None,
    decode.optional(r5valuesets.httpoperations_decoder()),
  )
  use encode_request_url <- decode.field("encodeRequestUrl", decode.bool)
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(decode.int),
  )
  use content_type <- decode.optional_field(
    "contentType",
    None,
    decode.optional(decode.string),
  )
  use accept <- decode.optional_field(
    "accept",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use label <- decode.optional_field(
    "label",
    None,
    decode.optional(decode.string),
  )
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(decode.string),
  )
  use type_ <- decode.optional_field(
    "type",
    None,
    decode.optional(coding_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupActionOperation(
    url:,
    target_id:,
    source_id:,
    response_id:,
    request_id:,
    request_header:,
    params:,
    origin:,
    method:,
    encode_request_url:,
    destination:,
    content_type:,
    accept:,
    description:,
    label:,
    resource:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_action_to_json(
  testscript_setup_action: TestscriptSetupAction,
) -> Json {
  let TestscriptSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_setup_action
  let fields = []
  let fields = case assert_ {
    Some(v) -> [
      #("assert", testscript_setup_action_assert_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case operation {
    Some(v) -> [
      #("operation", testscript_setup_action_operation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_action_decoder() -> Decoder(TestscriptSetupAction) {
  use assert_ <- decode.optional_field(
    "assert",
    None,
    decode.optional(testscript_setup_action_assert_decoder()),
  )
  use operation <- decode.optional_field(
    "operation",
    None,
    decode.optional(testscript_setup_action_operation_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetupAction(
    assert_:,
    operation:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_setup_to_json(testscript_setup: TestscriptSetup) -> Json {
  let TestscriptSetup(action:, modifier_extension:, extension:, id:) =
    testscript_setup
  let fields = []
  let fields = case action {
    [] -> fields
    _ -> [
      #("action", json.array(action, testscript_setup_action_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_setup_decoder() -> Decoder(TestscriptSetup) {
  use action <- decode.optional_field(
    "action",
    [],
    decode.list(testscript_setup_action_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptSetup(action:, modifier_extension:, extension:, id:))
}

pub fn testscript_variable_to_json(
  testscript_variable: TestscriptVariable,
) -> Json {
  let TestscriptVariable(
    source_id:,
    path:,
    hint:,
    header_field:,
    expression:,
    description:,
    default_value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_variable
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case source_id {
    Some(v) -> [#("sourceId", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case path {
    Some(v) -> [#("path", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case hint {
    Some(v) -> [#("hint", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case header_field {
    Some(v) -> [#("headerField", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case expression {
    Some(v) -> [#("expression", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case default_value {
    Some(v) -> [#("defaultValue", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_variable_decoder() -> Decoder(TestscriptVariable) {
  use source_id <- decode.optional_field(
    "sourceId",
    None,
    decode.optional(decode.string),
  )
  use path <- decode.optional_field(
    "path",
    None,
    decode.optional(decode.string),
  )
  use hint <- decode.optional_field(
    "hint",
    None,
    decode.optional(decode.string),
  )
  use header_field <- decode.optional_field(
    "headerField",
    None,
    decode.optional(decode.string),
  )
  use expression <- decode.optional_field(
    "expression",
    None,
    decode.optional(decode.string),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use default_value <- decode.optional_field(
    "defaultValue",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptVariable(
    source_id:,
    path:,
    hint:,
    header_field:,
    expression:,
    description:,
    default_value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_fixture_to_json(testscript_fixture: TestscriptFixture) -> Json {
  let TestscriptFixture(
    resource:,
    autodelete:,
    autocreate:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_fixture
  let fields = [
    #("autodelete", json.bool(autodelete)),
    #("autocreate", json.bool(autocreate)),
  ]
  let fields = case resource {
    Some(v) -> [#("resource", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_fixture_decoder() -> Decoder(TestscriptFixture) {
  use resource <- decode.optional_field(
    "resource",
    None,
    decode.optional(reference_decoder()),
  )
  use autodelete <- decode.field("autodelete", decode.bool)
  use autocreate <- decode.field("autocreate", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptFixture(
    resource:,
    autodelete:,
    autocreate:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_scope_to_json(testscript_scope: TestscriptScope) -> Json {
  let TestscriptScope(
    phase:,
    conformance:,
    artifact:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_scope
  let fields = [
    #("artifact", json.string(artifact)),
  ]
  let fields = case phase {
    Some(v) -> [#("phase", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case conformance {
    Some(v) -> [#("conformance", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_scope_decoder() -> Decoder(TestscriptScope) {
  use phase <- decode.optional_field(
    "phase",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use conformance <- decode.optional_field(
    "conformance",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use artifact <- decode.field("artifact", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptScope(
    phase:,
    conformance:,
    artifact:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_capability_to_json(
  testscript_metadata_capability: TestscriptMetadataCapability,
) -> Json {
  let TestscriptMetadataCapability(
    capabilities:,
    link:,
    destination:,
    origin:,
    description:,
    validated:,
    required:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata_capability
  let fields = [
    #("capabilities", json.string(capabilities)),
    #("validated", json.bool(validated)),
    #("required", json.bool(required)),
  ]
  let fields = case link {
    [] -> fields
    _ -> [#("link", json.array(link, json.string)), ..fields]
  }
  let fields = case destination {
    Some(v) -> [#("destination", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case origin {
    [] -> fields
    _ -> [#("origin", json.array(origin, json.int)), ..fields]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_capability_decoder() -> Decoder(
  TestscriptMetadataCapability,
) {
  use capabilities <- decode.field("capabilities", decode.string)
  use link <- decode.optional_field("link", [], decode.list(decode.string))
  use destination <- decode.optional_field(
    "destination",
    None,
    decode.optional(decode.int),
  )
  use origin <- decode.optional_field("origin", [], decode.list(decode.int))
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use validated <- decode.field("validated", decode.bool)
  use required <- decode.field("required", decode.bool)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadataCapability(
    capabilities:,
    link:,
    destination:,
    origin:,
    description:,
    validated:,
    required:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_link_to_json(
  testscript_metadata_link: TestscriptMetadataLink,
) -> Json {
  let TestscriptMetadataLink(
    description:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata_link
  let fields = [
    #("url", json.string(url)),
  ]
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_link_decoder() -> Decoder(TestscriptMetadataLink) {
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use url <- decode.field("url", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadataLink(
    description:,
    url:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_metadata_to_json(
  testscript_metadata: TestscriptMetadata,
) -> Json {
  let TestscriptMetadata(
    capability:,
    link:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_metadata
  let fields = []
  let fields = case capability {
    [] -> fields
    _ -> [
      #(
        "capability",
        json.array(capability, testscript_metadata_capability_to_json),
      ),
      ..fields
    ]
  }
  let fields = case link {
    [] -> fields
    _ -> [
      #("link", json.array(link, testscript_metadata_link_to_json)),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_metadata_decoder() -> Decoder(TestscriptMetadata) {
  use capability <- decode.optional_field(
    "capability",
    [],
    decode.list(testscript_metadata_capability_decoder()),
  )
  use link <- decode.optional_field(
    "link",
    [],
    decode.list(testscript_metadata_link_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptMetadata(
    capability:,
    link:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_destination_to_json(
  testscript_destination: TestscriptDestination,
) -> Json {
  let TestscriptDestination(
    url:,
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_destination
  let fields = [
    #("profile", coding_to_json(profile)),
    #("index", json.int(index)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_destination_decoder() -> Decoder(TestscriptDestination) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use profile <- decode.field("profile", coding_decoder())
  use index <- decode.field("index", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptDestination(
    url:,
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_origin_to_json(testscript_origin: TestscriptOrigin) -> Json {
  let TestscriptOrigin(
    url:,
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ) = testscript_origin
  let fields = [
    #("profile", coding_to_json(profile)),
    #("index", json.int(index)),
  ]
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn testscript_origin_decoder() -> Decoder(TestscriptOrigin) {
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use profile <- decode.field("profile", coding_decoder())
  use index <- decode.field("index", decode.int)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TestscriptOrigin(
    url:,
    profile:,
    index:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn testscript_to_json(testscript: Testscript) -> Json {
  let Testscript(
    teardown:,
    test_:,
    setup:,
    variable:,
    profile:,
    fixture:,
    scope:,
    metadata:,
    destination:,
    origin:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = testscript
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
    #("name", json.string(name)),
  ]
  let fields = case teardown {
    Some(v) -> [#("teardown", testscript_teardown_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case test_ {
    [] -> fields
    _ -> [#("test", json.array(test_, testscript_test_to_json)), ..fields]
  }
  let fields = case setup {
    Some(v) -> [#("setup", testscript_setup_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case variable {
    [] -> fields
    _ -> [
      #("variable", json.array(variable, testscript_variable_to_json)),
      ..fields
    ]
  }
  let fields = case profile {
    [] -> fields
    _ -> [#("profile", json.array(profile, json.string)), ..fields]
  }
  let fields = case fixture {
    [] -> fields
    _ -> [
      #("fixture", json.array(fixture, testscript_fixture_to_json)),
      ..fields
    ]
  }
  let fields = case scope {
    [] -> fields
    _ -> [#("scope", json.array(scope, testscript_scope_to_json)), ..fields]
  }
  let fields = case metadata {
    Some(v) -> [#("metadata", testscript_metadata_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case destination {
    [] -> fields
    _ -> [
      #("destination", json.array(destination, testscript_destination_to_json)),
      ..fields
    ]
  }
  let fields = case origin {
    [] -> fields
    _ -> [#("origin", json.array(origin, testscript_origin_to_json)), ..fields]
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          TestscriptVersionalgorithmString(_) -> "String"
          TestscriptVersionalgorithmCoding(_) -> "Coding"
        },
        testscript_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Testscript")), ..fields]
  json.object(fields)
}

pub fn testscript_decoder() -> Decoder(Testscript) {
  use teardown <- decode.optional_field(
    "teardown",
    None,
    decode.optional(testscript_teardown_decoder()),
  )
  use test_ <- decode.optional_field(
    "test",
    [],
    decode.list(testscript_test_decoder()),
  )
  use setup <- decode.optional_field(
    "setup",
    None,
    decode.optional(testscript_setup_decoder()),
  )
  use variable <- decode.optional_field(
    "variable",
    [],
    decode.list(testscript_variable_decoder()),
  )
  use profile <- decode.optional_field(
    "profile",
    [],
    decode.list(decode.string),
  )
  use fixture <- decode.optional_field(
    "fixture",
    [],
    decode.list(testscript_fixture_decoder()),
  )
  use scope <- decode.optional_field(
    "scope",
    [],
    decode.list(testscript_scope_decoder()),
  )
  use metadata <- decode.optional_field(
    "metadata",
    None,
    decode.optional(testscript_metadata_decoder()),
  )
  use destination <- decode.optional_field(
    "destination",
    [],
    decode.list(testscript_destination_decoder()),
  )
  use origin <- decode.optional_field(
    "origin",
    [],
    decode.list(testscript_origin_decoder()),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.field("name", decode.string)
  use version_algorithm <- decode.then(
    none_if_omitted(testscript_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Testscript",
    decode.failure(testscript_new(status:, name:), "resourceType"),
  )
  decode.success(Testscript(
    teardown:,
    test_:,
    setup:,
    variable:,
    profile:,
    fixture:,
    scope:,
    metadata:,
    destination:,
    origin:,
    copyright_label:,
    copyright:,
    purpose:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type Transport {
  Transport(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    instantiates_canonical: Option(String),
    instantiates_uri: Option(String),
    based_on: List(Reference),
    group_identifier: Option(Identifier),
    part_of: List(Reference),
    status: Option(r5valuesets.Transportstatus),
    status_reason: Option(Codeableconcept),
    intent: r5valuesets.Transportintent,
    priority: Option(r5valuesets.Requestpriority),
    code: Option(Codeableconcept),
    description: Option(String),
    focus: Option(Reference),
    for: Option(Reference),
    encounter: Option(Reference),
    completion_time: Option(String),
    authored_on: Option(String),
    last_modified: Option(String),
    requester: Option(Reference),
    performer_type: List(Codeableconcept),
    owner: Option(Reference),
    location: Option(Reference),
    insurance: List(Reference),
    note: List(Annotation),
    relevant_history: List(Reference),
    restriction: Option(TransportRestriction),
    input: List(TransportInput),
    output: List(TransportOutput),
    requested_location: Reference,
    current_location: Reference,
    reason: Option(Codeablereference),
    history: Option(Reference),
  )
}

pub fn transport_new(
  current_location current_location: Reference,
  requested_location requested_location: Reference,
  intent intent: r5valuesets.Transportintent,
) -> Transport {
  Transport(
    history: None,
    reason: None,
    current_location:,
    requested_location:,
    output: [],
    input: [],
    restriction: None,
    relevant_history: [],
    note: [],
    insurance: [],
    location: None,
    owner: None,
    performer_type: [],
    requester: None,
    last_modified: None,
    authored_on: None,
    completion_time: None,
    encounter: None,
    for: None,
    focus: None,
    description: None,
    code: None,
    priority: None,
    intent:,
    status_reason: None,
    status: None,
    part_of: [],
    group_identifier: None,
    based_on: [],
    instantiates_uri: None,
    instantiates_canonical: None,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type TransportRestriction {
  TransportRestriction(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    repetitions: Option(Int),
    period: Option(Period),
    recipient: List(Reference),
  )
}

pub fn transport_restriction_new() -> TransportRestriction {
  TransportRestriction(
    recipient: [],
    period: None,
    repetitions: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type TransportInput {
  TransportInput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TransportInputValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type TransportInputValue {
  TransportInputValueBase64binary(value: String)
  TransportInputValueBoolean(value: Bool)
  TransportInputValueCanonical(value: String)
  TransportInputValueCode(value: String)
  TransportInputValueDate(value: String)
  TransportInputValueDatetime(value: String)
  TransportInputValueDecimal(value: Float)
  TransportInputValueId(value: String)
  TransportInputValueInstant(value: String)
  TransportInputValueInteger(value: Int)
  TransportInputValueInteger64(value: Int)
  TransportInputValueMarkdown(value: String)
  TransportInputValueOid(value: String)
  TransportInputValuePositiveint(value: Int)
  TransportInputValueString(value: String)
  TransportInputValueTime(value: String)
  TransportInputValueUnsignedint(value: Int)
  TransportInputValueUri(value: String)
  TransportInputValueUrl(value: String)
  TransportInputValueUuid(value: String)
  TransportInputValueAddress(value: Address)
  TransportInputValueAge(value: Age)
  TransportInputValueAnnotation(value: Annotation)
  TransportInputValueAttachment(value: Attachment)
  TransportInputValueCodeableconcept(value: Codeableconcept)
  TransportInputValueCodeablereference(value: Codeablereference)
  TransportInputValueCoding(value: Coding)
  TransportInputValueContactpoint(value: Contactpoint)
  TransportInputValueCount(value: Count)
  TransportInputValueDistance(value: Distance)
  TransportInputValueDuration(value: Duration)
  TransportInputValueHumanname(value: Humanname)
  TransportInputValueIdentifier(value: Identifier)
  TransportInputValueMoney(value: Money)
  TransportInputValuePeriod(value: Period)
  TransportInputValueQuantity(value: Quantity)
  TransportInputValueRange(value: Range)
  TransportInputValueRatio(value: Ratio)
  TransportInputValueRatiorange(value: Ratiorange)
  TransportInputValueReference(value: Reference)
  TransportInputValueSampleddata(value: Sampleddata)
  TransportInputValueSignature(value: Signature)
  TransportInputValueTiming(value: Timing)
  TransportInputValueContactdetail(value: Contactdetail)
  TransportInputValueDatarequirement(value: Datarequirement)
  TransportInputValueExpression(value: Expression)
  TransportInputValueParameterdefinition(value: Parameterdefinition)
  TransportInputValueRelatedartifact(value: Relatedartifact)
  TransportInputValueTriggerdefinition(value: Triggerdefinition)
  TransportInputValueUsagecontext(value: Usagecontext)
  TransportInputValueAvailability(value: Availability)
  TransportInputValueExtendedcontactdetail(value: Extendedcontactdetail)
  TransportInputValueDosage(value: Dosage)
  TransportInputValueMeta(value: Meta)
}

pub fn transport_input_value_to_json(elt: TransportInputValue) -> Json {
  case elt {
    TransportInputValueBase64binary(v) -> json.string(v)
    TransportInputValueBoolean(v) -> json.bool(v)
    TransportInputValueCanonical(v) -> json.string(v)
    TransportInputValueCode(v) -> json.string(v)
    TransportInputValueDate(v) -> json.string(v)
    TransportInputValueDatetime(v) -> json.string(v)
    TransportInputValueDecimal(v) -> json.float(v)
    TransportInputValueId(v) -> json.string(v)
    TransportInputValueInstant(v) -> json.string(v)
    TransportInputValueInteger(v) -> json.int(v)
    TransportInputValueInteger64(v) -> json.int(v)
    TransportInputValueMarkdown(v) -> json.string(v)
    TransportInputValueOid(v) -> json.string(v)
    TransportInputValuePositiveint(v) -> json.int(v)
    TransportInputValueString(v) -> json.string(v)
    TransportInputValueTime(v) -> json.string(v)
    TransportInputValueUnsignedint(v) -> json.int(v)
    TransportInputValueUri(v) -> json.string(v)
    TransportInputValueUrl(v) -> json.string(v)
    TransportInputValueUuid(v) -> json.string(v)
    TransportInputValueAddress(v) -> address_to_json(v)
    TransportInputValueAge(v) -> age_to_json(v)
    TransportInputValueAnnotation(v) -> annotation_to_json(v)
    TransportInputValueAttachment(v) -> attachment_to_json(v)
    TransportInputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TransportInputValueCodeablereference(v) -> codeablereference_to_json(v)
    TransportInputValueCoding(v) -> coding_to_json(v)
    TransportInputValueContactpoint(v) -> contactpoint_to_json(v)
    TransportInputValueCount(v) -> count_to_json(v)
    TransportInputValueDistance(v) -> distance_to_json(v)
    TransportInputValueDuration(v) -> duration_to_json(v)
    TransportInputValueHumanname(v) -> humanname_to_json(v)
    TransportInputValueIdentifier(v) -> identifier_to_json(v)
    TransportInputValueMoney(v) -> money_to_json(v)
    TransportInputValuePeriod(v) -> period_to_json(v)
    TransportInputValueQuantity(v) -> quantity_to_json(v)
    TransportInputValueRange(v) -> range_to_json(v)
    TransportInputValueRatio(v) -> ratio_to_json(v)
    TransportInputValueRatiorange(v) -> ratiorange_to_json(v)
    TransportInputValueReference(v) -> reference_to_json(v)
    TransportInputValueSampleddata(v) -> sampleddata_to_json(v)
    TransportInputValueSignature(v) -> signature_to_json(v)
    TransportInputValueTiming(v) -> timing_to_json(v)
    TransportInputValueContactdetail(v) -> contactdetail_to_json(v)
    TransportInputValueDatarequirement(v) -> datarequirement_to_json(v)
    TransportInputValueExpression(v) -> expression_to_json(v)
    TransportInputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TransportInputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TransportInputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TransportInputValueUsagecontext(v) -> usagecontext_to_json(v)
    TransportInputValueAvailability(v) -> availability_to_json(v)
    TransportInputValueExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    TransportInputValueDosage(v) -> dosage_to_json(v)
    TransportInputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn transport_input_value_decoder() -> Decoder(TransportInputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TransportInputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TransportInputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TransportInputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TransportInputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TransportInputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TransportInputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TransportInputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TransportInputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TransportInputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TransportInputValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(TransportInputValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TransportInputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TransportInputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TransportInputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TransportInputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TransportInputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TransportInputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TransportInputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TransportInputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TransportInputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TransportInputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TransportInputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TransportInputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TransportInputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TransportInputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TransportInputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TransportInputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TransportInputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TransportInputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TransportInputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TransportInputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TransportInputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TransportInputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TransportInputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TransportInputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TransportInputValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(TransportInputValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TransportInputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TransportInputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TransportInputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TransportInputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TransportInputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TransportInputValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(TransportInputValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TransportInputValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TransportInputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TransportInputValueMeta),
    ],
  )
}

pub fn transport_input_new(
  value value: TransportInputValue,
  type_ type_: Codeableconcept,
) -> TransportInput {
  TransportInput(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type TransportOutput {
  TransportOutput(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    type_: Codeableconcept,
    value: TransportOutputValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/Transport#resource
pub type TransportOutputValue {
  TransportOutputValueBase64binary(value: String)
  TransportOutputValueBoolean(value: Bool)
  TransportOutputValueCanonical(value: String)
  TransportOutputValueCode(value: String)
  TransportOutputValueDate(value: String)
  TransportOutputValueDatetime(value: String)
  TransportOutputValueDecimal(value: Float)
  TransportOutputValueId(value: String)
  TransportOutputValueInstant(value: String)
  TransportOutputValueInteger(value: Int)
  TransportOutputValueInteger64(value: Int)
  TransportOutputValueMarkdown(value: String)
  TransportOutputValueOid(value: String)
  TransportOutputValuePositiveint(value: Int)
  TransportOutputValueString(value: String)
  TransportOutputValueTime(value: String)
  TransportOutputValueUnsignedint(value: Int)
  TransportOutputValueUri(value: String)
  TransportOutputValueUrl(value: String)
  TransportOutputValueUuid(value: String)
  TransportOutputValueAddress(value: Address)
  TransportOutputValueAge(value: Age)
  TransportOutputValueAnnotation(value: Annotation)
  TransportOutputValueAttachment(value: Attachment)
  TransportOutputValueCodeableconcept(value: Codeableconcept)
  TransportOutputValueCodeablereference(value: Codeablereference)
  TransportOutputValueCoding(value: Coding)
  TransportOutputValueContactpoint(value: Contactpoint)
  TransportOutputValueCount(value: Count)
  TransportOutputValueDistance(value: Distance)
  TransportOutputValueDuration(value: Duration)
  TransportOutputValueHumanname(value: Humanname)
  TransportOutputValueIdentifier(value: Identifier)
  TransportOutputValueMoney(value: Money)
  TransportOutputValuePeriod(value: Period)
  TransportOutputValueQuantity(value: Quantity)
  TransportOutputValueRange(value: Range)
  TransportOutputValueRatio(value: Ratio)
  TransportOutputValueRatiorange(value: Ratiorange)
  TransportOutputValueReference(value: Reference)
  TransportOutputValueSampleddata(value: Sampleddata)
  TransportOutputValueSignature(value: Signature)
  TransportOutputValueTiming(value: Timing)
  TransportOutputValueContactdetail(value: Contactdetail)
  TransportOutputValueDatarequirement(value: Datarequirement)
  TransportOutputValueExpression(value: Expression)
  TransportOutputValueParameterdefinition(value: Parameterdefinition)
  TransportOutputValueRelatedartifact(value: Relatedartifact)
  TransportOutputValueTriggerdefinition(value: Triggerdefinition)
  TransportOutputValueUsagecontext(value: Usagecontext)
  TransportOutputValueAvailability(value: Availability)
  TransportOutputValueExtendedcontactdetail(value: Extendedcontactdetail)
  TransportOutputValueDosage(value: Dosage)
  TransportOutputValueMeta(value: Meta)
}

pub fn transport_output_value_to_json(elt: TransportOutputValue) -> Json {
  case elt {
    TransportOutputValueBase64binary(v) -> json.string(v)
    TransportOutputValueBoolean(v) -> json.bool(v)
    TransportOutputValueCanonical(v) -> json.string(v)
    TransportOutputValueCode(v) -> json.string(v)
    TransportOutputValueDate(v) -> json.string(v)
    TransportOutputValueDatetime(v) -> json.string(v)
    TransportOutputValueDecimal(v) -> json.float(v)
    TransportOutputValueId(v) -> json.string(v)
    TransportOutputValueInstant(v) -> json.string(v)
    TransportOutputValueInteger(v) -> json.int(v)
    TransportOutputValueInteger64(v) -> json.int(v)
    TransportOutputValueMarkdown(v) -> json.string(v)
    TransportOutputValueOid(v) -> json.string(v)
    TransportOutputValuePositiveint(v) -> json.int(v)
    TransportOutputValueString(v) -> json.string(v)
    TransportOutputValueTime(v) -> json.string(v)
    TransportOutputValueUnsignedint(v) -> json.int(v)
    TransportOutputValueUri(v) -> json.string(v)
    TransportOutputValueUrl(v) -> json.string(v)
    TransportOutputValueUuid(v) -> json.string(v)
    TransportOutputValueAddress(v) -> address_to_json(v)
    TransportOutputValueAge(v) -> age_to_json(v)
    TransportOutputValueAnnotation(v) -> annotation_to_json(v)
    TransportOutputValueAttachment(v) -> attachment_to_json(v)
    TransportOutputValueCodeableconcept(v) -> codeableconcept_to_json(v)
    TransportOutputValueCodeablereference(v) -> codeablereference_to_json(v)
    TransportOutputValueCoding(v) -> coding_to_json(v)
    TransportOutputValueContactpoint(v) -> contactpoint_to_json(v)
    TransportOutputValueCount(v) -> count_to_json(v)
    TransportOutputValueDistance(v) -> distance_to_json(v)
    TransportOutputValueDuration(v) -> duration_to_json(v)
    TransportOutputValueHumanname(v) -> humanname_to_json(v)
    TransportOutputValueIdentifier(v) -> identifier_to_json(v)
    TransportOutputValueMoney(v) -> money_to_json(v)
    TransportOutputValuePeriod(v) -> period_to_json(v)
    TransportOutputValueQuantity(v) -> quantity_to_json(v)
    TransportOutputValueRange(v) -> range_to_json(v)
    TransportOutputValueRatio(v) -> ratio_to_json(v)
    TransportOutputValueRatiorange(v) -> ratiorange_to_json(v)
    TransportOutputValueReference(v) -> reference_to_json(v)
    TransportOutputValueSampleddata(v) -> sampleddata_to_json(v)
    TransportOutputValueSignature(v) -> signature_to_json(v)
    TransportOutputValueTiming(v) -> timing_to_json(v)
    TransportOutputValueContactdetail(v) -> contactdetail_to_json(v)
    TransportOutputValueDatarequirement(v) -> datarequirement_to_json(v)
    TransportOutputValueExpression(v) -> expression_to_json(v)
    TransportOutputValueParameterdefinition(v) -> parameterdefinition_to_json(v)
    TransportOutputValueRelatedartifact(v) -> relatedartifact_to_json(v)
    TransportOutputValueTriggerdefinition(v) -> triggerdefinition_to_json(v)
    TransportOutputValueUsagecontext(v) -> usagecontext_to_json(v)
    TransportOutputValueAvailability(v) -> availability_to_json(v)
    TransportOutputValueExtendedcontactdetail(v) ->
      extendedcontactdetail_to_json(v)
    TransportOutputValueDosage(v) -> dosage_to_json(v)
    TransportOutputValueMeta(v) -> meta_to_json(v)
  }
}

pub fn transport_output_value_decoder() -> Decoder(TransportOutputValue) {
  decode.one_of(
    decode.field("valueBase64Binary", decode.string, decode.success)
      |> decode.map(TransportOutputValueBase64binary),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(TransportOutputValueBoolean),
      decode.field("valueCanonical", decode.string, decode.success)
        |> decode.map(TransportOutputValueCanonical),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(TransportOutputValueCode),
      decode.field("valueDate", decode.string, decode.success)
        |> decode.map(TransportOutputValueDate),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(TransportOutputValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(TransportOutputValueDecimal),
      decode.field("valueId", decode.string, decode.success)
        |> decode.map(TransportOutputValueId),
      decode.field("valueInstant", decode.string, decode.success)
        |> decode.map(TransportOutputValueInstant),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(TransportOutputValueInteger),
      decode.field("valueInteger64", decode.int, decode.success)
        |> decode.map(TransportOutputValueInteger64),
      decode.field("valueMarkdown", decode.string, decode.success)
        |> decode.map(TransportOutputValueMarkdown),
      decode.field("valueOid", decode.string, decode.success)
        |> decode.map(TransportOutputValueOid),
      decode.field("valuePositiveInt", decode.int, decode.success)
        |> decode.map(TransportOutputValuePositiveint),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(TransportOutputValueString),
      decode.field("valueTime", decode.string, decode.success)
        |> decode.map(TransportOutputValueTime),
      decode.field("valueUnsignedInt", decode.int, decode.success)
        |> decode.map(TransportOutputValueUnsignedint),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(TransportOutputValueUri),
      decode.field("valueUrl", decode.string, decode.success)
        |> decode.map(TransportOutputValueUrl),
      decode.field("valueUuid", decode.string, decode.success)
        |> decode.map(TransportOutputValueUuid),
      decode.field("valueAddress", address_decoder(), decode.success)
        |> decode.map(TransportOutputValueAddress),
      decode.field("valueAge", age_decoder(), decode.success)
        |> decode.map(TransportOutputValueAge),
      decode.field("valueAnnotation", annotation_decoder(), decode.success)
        |> decode.map(TransportOutputValueAnnotation),
      decode.field("valueAttachment", attachment_decoder(), decode.success)
        |> decode.map(TransportOutputValueAttachment),
      decode.field(
        "valueCodeableConcept",
        codeableconcept_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueCodeableconcept),
      decode.field(
        "valueCodeableReference",
        codeablereference_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueCodeablereference),
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(TransportOutputValueCoding),
      decode.field("valueContactPoint", contactpoint_decoder(), decode.success)
        |> decode.map(TransportOutputValueContactpoint),
      decode.field("valueCount", count_decoder(), decode.success)
        |> decode.map(TransportOutputValueCount),
      decode.field("valueDistance", distance_decoder(), decode.success)
        |> decode.map(TransportOutputValueDistance),
      decode.field("valueDuration", duration_decoder(), decode.success)
        |> decode.map(TransportOutputValueDuration),
      decode.field("valueHumanName", humanname_decoder(), decode.success)
        |> decode.map(TransportOutputValueHumanname),
      decode.field("valueIdentifier", identifier_decoder(), decode.success)
        |> decode.map(TransportOutputValueIdentifier),
      decode.field("valueMoney", money_decoder(), decode.success)
        |> decode.map(TransportOutputValueMoney),
      decode.field("valuePeriod", period_decoder(), decode.success)
        |> decode.map(TransportOutputValuePeriod),
      decode.field("valueQuantity", quantity_decoder(), decode.success)
        |> decode.map(TransportOutputValueQuantity),
      decode.field("valueRange", range_decoder(), decode.success)
        |> decode.map(TransportOutputValueRange),
      decode.field("valueRatio", ratio_decoder(), decode.success)
        |> decode.map(TransportOutputValueRatio),
      decode.field("valueRatioRange", ratiorange_decoder(), decode.success)
        |> decode.map(TransportOutputValueRatiorange),
      decode.field("valueReference", reference_decoder(), decode.success)
        |> decode.map(TransportOutputValueReference),
      decode.field("valueSampledData", sampleddata_decoder(), decode.success)
        |> decode.map(TransportOutputValueSampleddata),
      decode.field("valueSignature", signature_decoder(), decode.success)
        |> decode.map(TransportOutputValueSignature),
      decode.field("valueTiming", timing_decoder(), decode.success)
        |> decode.map(TransportOutputValueTiming),
      decode.field(
        "valueContactDetail",
        contactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueContactdetail),
      decode.field(
        "valueDataRequirement",
        datarequirement_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueDatarequirement),
      decode.field("valueExpression", expression_decoder(), decode.success)
        |> decode.map(TransportOutputValueExpression),
      decode.field(
        "valueParameterDefinition",
        parameterdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueParameterdefinition),
      decode.field(
        "valueRelatedArtifact",
        relatedartifact_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueRelatedartifact),
      decode.field(
        "valueTriggerDefinition",
        triggerdefinition_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueTriggerdefinition),
      decode.field("valueUsageContext", usagecontext_decoder(), decode.success)
        |> decode.map(TransportOutputValueUsagecontext),
      decode.field("valueAvailability", availability_decoder(), decode.success)
        |> decode.map(TransportOutputValueAvailability),
      decode.field(
        "valueExtendedContactDetail",
        extendedcontactdetail_decoder(),
        decode.success,
      )
        |> decode.map(TransportOutputValueExtendedcontactdetail),
      decode.field("valueDosage", dosage_decoder(), decode.success)
        |> decode.map(TransportOutputValueDosage),
      decode.field("valueMeta", meta_decoder(), decode.success)
        |> decode.map(TransportOutputValueMeta),
    ],
  )
}

pub fn transport_output_new(
  value value: TransportOutputValue,
  type_ type_: Codeableconcept,
) -> TransportOutput {
  TransportOutput(
    value:,
    type_:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn transport_output_to_json(transport_output: TransportOutput) -> Json {
  let TransportOutput(value:, type_:, modifier_extension:, extension:, id:) =
    transport_output
  let fields = [
    #("value", transport_output_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn transport_output_decoder() -> Decoder(TransportOutput) {
  use value <- decode.then(transport_output_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TransportOutput(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn transport_input_to_json(transport_input: TransportInput) -> Json {
  let TransportInput(value:, type_:, modifier_extension:, extension:, id:) =
    transport_input
  let fields = [
    #("value", transport_input_value_to_json(value)),
    #("type", codeableconcept_to_json(type_)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn transport_input_decoder() -> Decoder(TransportInput) {
  use value <- decode.then(transport_input_value_decoder())
  use type_ <- decode.field("type", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TransportInput(
    value:,
    type_:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn transport_restriction_to_json(
  transport_restriction: TransportRestriction,
) -> Json {
  let TransportRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ) = transport_restriction
  let fields = []
  let fields = case recipient {
    [] -> fields
    _ -> [#("recipient", json.array(recipient, reference_to_json)), ..fields]
  }
  let fields = case period {
    Some(v) -> [#("period", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case repetitions {
    Some(v) -> [#("repetitions", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn transport_restriction_decoder() -> Decoder(TransportRestriction) {
  use recipient <- decode.optional_field(
    "recipient",
    [],
    decode.list(reference_decoder()),
  )
  use period <- decode.optional_field(
    "period",
    None,
    decode.optional(period_decoder()),
  )
  use repetitions <- decode.optional_field(
    "repetitions",
    None,
    decode.optional(decode.int),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(TransportRestriction(
    recipient:,
    period:,
    repetitions:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn transport_to_json(transport: Transport) -> Json {
  let Transport(
    history:,
    reason:,
    current_location:,
    requested_location:,
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    location:,
    owner:,
    performer_type:,
    requester:,
    last_modified:,
    authored_on:,
    completion_time:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    priority:,
    intent:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = transport
  let fields = [
    #("currentLocation", reference_to_json(current_location)),
    #("requestedLocation", reference_to_json(requested_location)),
    #("intent", r5valuesets.transportintent_to_json(intent)),
  ]
  let fields = case history {
    Some(v) -> [#("history", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case reason {
    Some(v) -> [#("reason", codeablereference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case output {
    [] -> fields
    _ -> [#("output", json.array(output, transport_output_to_json)), ..fields]
  }
  let fields = case input {
    [] -> fields
    _ -> [#("input", json.array(input, transport_input_to_json)), ..fields]
  }
  let fields = case restriction {
    Some(v) -> [#("restriction", transport_restriction_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case relevant_history {
    [] -> fields
    _ -> [
      #("relevantHistory", json.array(relevant_history, reference_to_json)),
      ..fields
    ]
  }
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case insurance {
    [] -> fields
    _ -> [#("insurance", json.array(insurance, reference_to_json)), ..fields]
  }
  let fields = case location {
    Some(v) -> [#("location", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case owner {
    Some(v) -> [#("owner", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case performer_type {
    [] -> fields
    _ -> [
      #("performerType", json.array(performer_type, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case requester {
    Some(v) -> [#("requester", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_modified {
    Some(v) -> [#("lastModified", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case authored_on {
    Some(v) -> [#("authoredOn", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case completion_time {
    Some(v) -> [#("completionTime", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case for {
    Some(v) -> [#("for", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case focus {
    Some(v) -> [#("focus", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case priority {
    Some(v) -> [#("priority", r5valuesets.requestpriority_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_reason {
    Some(v) -> [#("statusReason", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status {
    Some(v) -> [#("status", r5valuesets.transportstatus_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case part_of {
    [] -> fields
    _ -> [#("partOf", json.array(part_of, reference_to_json)), ..fields]
  }
  let fields = case group_identifier {
    Some(v) -> [#("groupIdentifier", identifier_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case based_on {
    [] -> fields
    _ -> [#("basedOn", json.array(based_on, reference_to_json)), ..fields]
  }
  let fields = case instantiates_uri {
    Some(v) -> [#("instantiatesUri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case instantiates_canonical {
    Some(v) -> [#("instantiatesCanonical", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Transport")), ..fields]
  json.object(fields)
}

pub fn transport_decoder() -> Decoder(Transport) {
  use history <- decode.optional_field(
    "history",
    None,
    decode.optional(reference_decoder()),
  )
  use reason <- decode.optional_field(
    "reason",
    None,
    decode.optional(codeablereference_decoder()),
  )
  use current_location <- decode.field("currentLocation", reference_decoder())
  use requested_location <- decode.field(
    "requestedLocation",
    reference_decoder(),
  )
  use output <- decode.optional_field(
    "output",
    [],
    decode.list(transport_output_decoder()),
  )
  use input <- decode.optional_field(
    "input",
    [],
    decode.list(transport_input_decoder()),
  )
  use restriction <- decode.optional_field(
    "restriction",
    None,
    decode.optional(transport_restriction_decoder()),
  )
  use relevant_history <- decode.optional_field(
    "relevantHistory",
    [],
    decode.list(reference_decoder()),
  )
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use insurance <- decode.optional_field(
    "insurance",
    [],
    decode.list(reference_decoder()),
  )
  use location <- decode.optional_field(
    "location",
    None,
    decode.optional(reference_decoder()),
  )
  use owner <- decode.optional_field(
    "owner",
    None,
    decode.optional(reference_decoder()),
  )
  use performer_type <- decode.optional_field(
    "performerType",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use requester <- decode.optional_field(
    "requester",
    None,
    decode.optional(reference_decoder()),
  )
  use last_modified <- decode.optional_field(
    "lastModified",
    None,
    decode.optional(decode.string),
  )
  use authored_on <- decode.optional_field(
    "authoredOn",
    None,
    decode.optional(decode.string),
  )
  use completion_time <- decode.optional_field(
    "completionTime",
    None,
    decode.optional(decode.string),
  )
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use for <- decode.optional_field(
    "for",
    None,
    decode.optional(reference_decoder()),
  )
  use focus <- decode.optional_field(
    "focus",
    None,
    decode.optional(reference_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use priority <- decode.optional_field(
    "priority",
    None,
    decode.optional(r5valuesets.requestpriority_decoder()),
  )
  use intent <- decode.field("intent", r5valuesets.transportintent_decoder())
  use status_reason <- decode.optional_field(
    "statusReason",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status <- decode.optional_field(
    "status",
    None,
    decode.optional(r5valuesets.transportstatus_decoder()),
  )
  use part_of <- decode.optional_field(
    "partOf",
    [],
    decode.list(reference_decoder()),
  )
  use group_identifier <- decode.optional_field(
    "groupIdentifier",
    None,
    decode.optional(identifier_decoder()),
  )
  use based_on <- decode.optional_field(
    "basedOn",
    [],
    decode.list(reference_decoder()),
  )
  use instantiates_uri <- decode.optional_field(
    "instantiatesUri",
    None,
    decode.optional(decode.string),
  )
  use instantiates_canonical <- decode.optional_field(
    "instantiatesCanonical",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Transport",
    decode.failure(
      transport_new(current_location:, requested_location:, intent:),
      "resourceType",
    ),
  )
  decode.success(Transport(
    history:,
    reason:,
    current_location:,
    requested_location:,
    output:,
    input:,
    restriction:,
    relevant_history:,
    note:,
    insurance:,
    location:,
    owner:,
    performer_type:,
    requester:,
    last_modified:,
    authored_on:,
    completion_time:,
    encounter:,
    for:,
    focus:,
    description:,
    code:,
    priority:,
    intent:,
    status_reason:,
    status:,
    part_of:,
    group_identifier:,
    based_on:,
    instantiates_uri:,
    instantiates_canonical:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type Valueset {
  Valueset(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    url: Option(String),
    identifier: List(Identifier),
    version: Option(String),
    version_algorithm: Option(ValuesetVersionalgorithm),
    name: Option(String),
    title: Option(String),
    status: r5valuesets.Publicationstatus,
    experimental: Option(Bool),
    date: Option(String),
    publisher: Option(String),
    contact: List(Contactdetail),
    description: Option(String),
    use_context: List(Usagecontext),
    jurisdiction: List(Codeableconcept),
    immutable: Option(Bool),
    purpose: Option(String),
    copyright: Option(String),
    copyright_label: Option(String),
    approval_date: Option(String),
    last_review_date: Option(String),
    effective_period: Option(Period),
    topic: List(Codeableconcept),
    author: List(Contactdetail),
    editor: List(Contactdetail),
    reviewer: List(Contactdetail),
    endorser: List(Contactdetail),
    related_artifact: List(Relatedartifact),
    compose: Option(ValuesetCompose),
    expansion: Option(ValuesetExpansion),
    scope: Option(ValuesetScope),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetVersionalgorithm {
  ValuesetVersionalgorithmString(version_algorithm: String)
  ValuesetVersionalgorithmCoding(version_algorithm: Coding)
}

pub fn valueset_versionalgorithm_to_json(elt: ValuesetVersionalgorithm) -> Json {
  case elt {
    ValuesetVersionalgorithmString(v) -> json.string(v)
    ValuesetVersionalgorithmCoding(v) -> coding_to_json(v)
  }
}

pub fn valueset_versionalgorithm_decoder() -> Decoder(ValuesetVersionalgorithm) {
  decode.one_of(
    decode.field("versionAlgorithmString", decode.string, decode.success)
      |> decode.map(ValuesetVersionalgorithmString),
    [
      decode.field("versionAlgorithmCoding", coding_decoder(), decode.success)
      |> decode.map(ValuesetVersionalgorithmCoding),
    ],
  )
}

pub fn valueset_new(status status: r5valuesets.Publicationstatus) -> Valueset {
  Valueset(
    scope: None,
    expansion: None,
    compose: None,
    related_artifact: [],
    endorser: [],
    reviewer: [],
    editor: [],
    author: [],
    topic: [],
    effective_period: None,
    last_review_date: None,
    approval_date: None,
    copyright_label: None,
    copyright: None,
    purpose: None,
    immutable: None,
    jurisdiction: [],
    use_context: [],
    description: None,
    contact: [],
    publisher: None,
    date: None,
    experimental: None,
    status:,
    title: None,
    name: None,
    version_algorithm: None,
    version: None,
    identifier: [],
    url: None,
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetCompose {
  ValuesetCompose(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    locked_date: Option(String),
    inactive: Option(Bool),
    include: List(ValuesetComposeInclude),
    property: List(String),
  )
}

pub fn valueset_compose_new() -> ValuesetCompose {
  ValuesetCompose(
    property: [],
    include: [],
    inactive: None,
    locked_date: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetComposeInclude {
  ValuesetComposeInclude(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system: Option(String),
    version: Option(String),
    concept: List(ValuesetComposeIncludeConcept),
    filter: List(ValuesetComposeIncludeFilter),
    value_set: List(String),
    copyright: Option(String),
  )
}

pub fn valueset_compose_include_new() -> ValuesetComposeInclude {
  ValuesetComposeInclude(
    copyright: None,
    value_set: [],
    filter: [],
    concept: [],
    version: None,
    system: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConcept {
  ValuesetComposeIncludeConcept(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    display: Option(String),
    designation: List(ValuesetComposeIncludeConceptDesignation),
  )
}

pub fn valueset_compose_include_concept_new(
  code code: String,
) -> ValuesetComposeIncludeConcept {
  ValuesetComposeIncludeConcept(
    designation: [],
    display: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeConceptDesignation {
  ValuesetComposeIncludeConceptDesignation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    language: Option(String),
    use_: Option(Coding),
    additional_use: List(Coding),
    value: String,
  )
}

pub fn valueset_compose_include_concept_designation_new(
  value value: String,
) -> ValuesetComposeIncludeConceptDesignation {
  ValuesetComposeIncludeConceptDesignation(
    value:,
    additional_use: [],
    use_: None,
    language: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetComposeIncludeFilter {
  ValuesetComposeIncludeFilter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    property: String,
    op: r5valuesets.Filteroperator,
    value: String,
  )
}

pub fn valueset_compose_include_filter_new(
  value value: String,
  op op: r5valuesets.Filteroperator,
  property property: String,
) -> ValuesetComposeIncludeFilter {
  ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansion {
  ValuesetExpansion(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: Option(String),
    next: Option(String),
    timestamp: String,
    total: Option(Int),
    offset: Option(Int),
    parameter: List(ValuesetExpansionParameter),
    property: List(ValuesetExpansionProperty),
    contains: List(ValuesetExpansionContains),
  )
}

pub fn valueset_expansion_new(timestamp timestamp: String) -> ValuesetExpansion {
  ValuesetExpansion(
    contains: [],
    property: [],
    parameter: [],
    offset: None,
    total: None,
    timestamp:,
    next: None,
    identifier: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameter {
  ValuesetExpansionParameter(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    name: String,
    value: Option(ValuesetExpansionParameterValue),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionParameterValue {
  ValuesetExpansionParameterValueString(value: String)
  ValuesetExpansionParameterValueBoolean(value: Bool)
  ValuesetExpansionParameterValueInteger(value: Int)
  ValuesetExpansionParameterValueDecimal(value: Float)
  ValuesetExpansionParameterValueUri(value: String)
  ValuesetExpansionParameterValueCode(value: String)
  ValuesetExpansionParameterValueDatetime(value: String)
}

pub fn valueset_expansion_parameter_value_to_json(
  elt: ValuesetExpansionParameterValue,
) -> Json {
  case elt {
    ValuesetExpansionParameterValueString(v) -> json.string(v)
    ValuesetExpansionParameterValueBoolean(v) -> json.bool(v)
    ValuesetExpansionParameterValueInteger(v) -> json.int(v)
    ValuesetExpansionParameterValueDecimal(v) -> json.float(v)
    ValuesetExpansionParameterValueUri(v) -> json.string(v)
    ValuesetExpansionParameterValueCode(v) -> json.string(v)
    ValuesetExpansionParameterValueDatetime(v) -> json.string(v)
  }
}

pub fn valueset_expansion_parameter_value_decoder() -> Decoder(
  ValuesetExpansionParameterValue,
) {
  decode.one_of(
    decode.field("valueString", decode.string, decode.success)
      |> decode.map(ValuesetExpansionParameterValueString),
    [
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ValuesetExpansionParameterValueBoolean),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ValuesetExpansionParameterValueInteger),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ValuesetExpansionParameterValueDecimal),
      decode.field("valueUri", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueUri),
      decode.field("valueCode", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueCode),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ValuesetExpansionParameterValueDatetime),
    ],
  )
}

pub fn valueset_expansion_parameter_new(
  name name: String,
) -> ValuesetExpansionParameter {
  ValuesetExpansionParameter(
    value: None,
    name:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionProperty {
  ValuesetExpansionProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    uri: Option(String),
  )
}

pub fn valueset_expansion_property_new(
  code code: String,
) -> ValuesetExpansionProperty {
  ValuesetExpansionProperty(
    uri: None,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContains {
  ValuesetExpansionContains(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    system: Option(String),
    abstract: Option(Bool),
    inactive: Option(Bool),
    version: Option(String),
    code: Option(String),
    display: Option(String),
    property: List(ValuesetExpansionContainsProperty),
  )
}

pub fn valueset_expansion_contains_new() -> ValuesetExpansionContains {
  ValuesetExpansionContains(
    property: [],
    display: None,
    code: None,
    version: None,
    inactive: None,
    abstract: None,
    system: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContainsProperty {
  ValuesetExpansionContainsProperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    value: ValuesetExpansionContainsPropertyValue,
    sub_property: List(ValuesetExpansionContainsPropertySubproperty),
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContainsPropertyValue {
  ValuesetExpansionContainsPropertyValueCode(value: String)
  ValuesetExpansionContainsPropertyValueCoding(value: Coding)
  ValuesetExpansionContainsPropertyValueString(value: String)
  ValuesetExpansionContainsPropertyValueInteger(value: Int)
  ValuesetExpansionContainsPropertyValueBoolean(value: Bool)
  ValuesetExpansionContainsPropertyValueDatetime(value: String)
  ValuesetExpansionContainsPropertyValueDecimal(value: Float)
}

pub fn valueset_expansion_contains_property_value_to_json(
  elt: ValuesetExpansionContainsPropertyValue,
) -> Json {
  case elt {
    ValuesetExpansionContainsPropertyValueCode(v) -> json.string(v)
    ValuesetExpansionContainsPropertyValueCoding(v) -> coding_to_json(v)
    ValuesetExpansionContainsPropertyValueString(v) -> json.string(v)
    ValuesetExpansionContainsPropertyValueInteger(v) -> json.int(v)
    ValuesetExpansionContainsPropertyValueBoolean(v) -> json.bool(v)
    ValuesetExpansionContainsPropertyValueDatetime(v) -> json.string(v)
    ValuesetExpansionContainsPropertyValueDecimal(v) -> json.float(v)
  }
}

pub fn valueset_expansion_contains_property_value_decoder() -> Decoder(
  ValuesetExpansionContainsPropertyValue,
) {
  decode.one_of(
    decode.field("valueCode", decode.string, decode.success)
      |> decode.map(ValuesetExpansionContainsPropertyValueCode),
    [
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueCoding),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueString),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueInteger),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueBoolean),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertyValueDecimal),
    ],
  )
}

pub fn valueset_expansion_contains_property_new(
  value value: ValuesetExpansionContainsPropertyValue,
  code code: String,
) -> ValuesetExpansionContainsProperty {
  ValuesetExpansionContainsProperty(
    sub_property: [],
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContainsPropertySubproperty {
  ValuesetExpansionContainsPropertySubproperty(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    code: String,
    value: ValuesetExpansionContainsPropertySubpropertyValue,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetExpansionContainsPropertySubpropertyValue {
  ValuesetExpansionContainsPropertySubpropertyValueCode(value: String)
  ValuesetExpansionContainsPropertySubpropertyValueCoding(value: Coding)
  ValuesetExpansionContainsPropertySubpropertyValueString(value: String)
  ValuesetExpansionContainsPropertySubpropertyValueInteger(value: Int)
  ValuesetExpansionContainsPropertySubpropertyValueBoolean(value: Bool)
  ValuesetExpansionContainsPropertySubpropertyValueDatetime(value: String)
  ValuesetExpansionContainsPropertySubpropertyValueDecimal(value: Float)
}

pub fn valueset_expansion_contains_property_subproperty_value_to_json(
  elt: ValuesetExpansionContainsPropertySubpropertyValue,
) -> Json {
  case elt {
    ValuesetExpansionContainsPropertySubpropertyValueCode(v) -> json.string(v)
    ValuesetExpansionContainsPropertySubpropertyValueCoding(v) ->
      coding_to_json(v)
    ValuesetExpansionContainsPropertySubpropertyValueString(v) -> json.string(v)
    ValuesetExpansionContainsPropertySubpropertyValueInteger(v) -> json.int(v)
    ValuesetExpansionContainsPropertySubpropertyValueBoolean(v) -> json.bool(v)
    ValuesetExpansionContainsPropertySubpropertyValueDatetime(v) ->
      json.string(v)
    ValuesetExpansionContainsPropertySubpropertyValueDecimal(v) -> json.float(v)
  }
}

pub fn valueset_expansion_contains_property_subproperty_value_decoder() -> Decoder(
  ValuesetExpansionContainsPropertySubpropertyValue,
) {
  decode.one_of(
    decode.field("valueCode", decode.string, decode.success)
      |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueCode),
    [
      decode.field("valueCoding", coding_decoder(), decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueCoding),
      decode.field("valueString", decode.string, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueString),
      decode.field("valueInteger", decode.int, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueInteger),
      decode.field("valueBoolean", decode.bool, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueBoolean),
      decode.field("valueDateTime", decode.string, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueDatetime),
      decode.field("valueDecimal", decode.float, decode.success)
        |> decode.map(ValuesetExpansionContainsPropertySubpropertyValueDecimal),
    ],
  )
}

pub fn valueset_expansion_contains_property_subproperty_new(
  value value: ValuesetExpansionContainsPropertySubpropertyValue,
  code code: String,
) -> ValuesetExpansionContainsPropertySubproperty {
  ValuesetExpansionContainsPropertySubproperty(
    value:,
    code:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/ValueSet#resource
pub type ValuesetScope {
  ValuesetScope(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    inclusion_criteria: Option(String),
    exclusion_criteria: Option(String),
  )
}

pub fn valueset_scope_new() -> ValuesetScope {
  ValuesetScope(
    exclusion_criteria: None,
    inclusion_criteria: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn valueset_scope_to_json(valueset_scope: ValuesetScope) -> Json {
  let ValuesetScope(
    exclusion_criteria:,
    inclusion_criteria:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_scope
  let fields = []
  let fields = case exclusion_criteria {
    Some(v) -> [#("exclusionCriteria", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case inclusion_criteria {
    Some(v) -> [#("inclusionCriteria", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_scope_decoder() -> Decoder(ValuesetScope) {
  use exclusion_criteria <- decode.optional_field(
    "exclusionCriteria",
    None,
    decode.optional(decode.string),
  )
  use inclusion_criteria <- decode.optional_field(
    "inclusionCriteria",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetScope(
    exclusion_criteria:,
    inclusion_criteria:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_contains_property_subproperty_to_json(
  valueset_expansion_contains_property_subproperty: ValuesetExpansionContainsPropertySubproperty,
) -> Json {
  let ValuesetExpansionContainsPropertySubproperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_contains_property_subproperty
  let fields = [
    #(
      "value",
      valueset_expansion_contains_property_subproperty_value_to_json(value),
    ),
    #("code", json.string(code)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_contains_property_subproperty_decoder() -> Decoder(
  ValuesetExpansionContainsPropertySubproperty,
) {
  use value <- decode.then(
    valueset_expansion_contains_property_subproperty_value_decoder(),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionContainsPropertySubproperty(
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_contains_property_to_json(
  valueset_expansion_contains_property: ValuesetExpansionContainsProperty,
) -> Json {
  let ValuesetExpansionContainsProperty(
    sub_property:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_contains_property
  let fields = [
    #("value", valueset_expansion_contains_property_value_to_json(value)),
    #("code", json.string(code)),
  ]
  let fields = case sub_property {
    [] -> fields
    _ -> [
      #(
        "subProperty",
        json.array(
          sub_property,
          valueset_expansion_contains_property_subproperty_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_contains_property_decoder() -> Decoder(
  ValuesetExpansionContainsProperty,
) {
  use sub_property <- decode.optional_field(
    "subProperty",
    [],
    decode.list(valueset_expansion_contains_property_subproperty_decoder()),
  )
  use value <- decode.then(valueset_expansion_contains_property_value_decoder())
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionContainsProperty(
    sub_property:,
    value:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_contains_to_json(
  valueset_expansion_contains: ValuesetExpansionContains,
) -> Json {
  let ValuesetExpansionContains(
    property:,
    display:,
    code:,
    version:,
    inactive:,
    abstract:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_contains
  let fields = []
  let fields = case property {
    [] -> fields
    _ -> [
      #(
        "property",
        json.array(property, valueset_expansion_contains_property_to_json),
      ),
      ..fields
    ]
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case code {
    Some(v) -> [#("code", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case abstract {
    Some(v) -> [#("abstract", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_contains_decoder() -> Decoder(
  ValuesetExpansionContains,
) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(valueset_expansion_contains_property_decoder()),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.optional_field(
    "code",
    None,
    decode.optional(decode.string),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use abstract <- decode.optional_field(
    "abstract",
    None,
    decode.optional(decode.bool),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionContains(
    property:,
    display:,
    code:,
    version:,
    inactive:,
    abstract:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_property_to_json(
  valueset_expansion_property: ValuesetExpansionProperty,
) -> Json {
  let ValuesetExpansionProperty(
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_property
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case uri {
    Some(v) -> [#("uri", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_property_decoder() -> Decoder(
  ValuesetExpansionProperty,
) {
  use uri <- decode.optional_field("uri", None, decode.optional(decode.string))
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionProperty(
    uri:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_parameter_to_json(
  valueset_expansion_parameter: ValuesetExpansionParameter,
) -> Json {
  let ValuesetExpansionParameter(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion_parameter
  let fields = [
    #("name", json.string(name)),
  ]
  let fields = case value {
    Some(v) -> [
      #(
        "value"
          <> case v {
          ValuesetExpansionParameterValueString(_) -> "String"
          ValuesetExpansionParameterValueBoolean(_) -> "Boolean"
          ValuesetExpansionParameterValueInteger(_) -> "Integer"
          ValuesetExpansionParameterValueDecimal(_) -> "Decimal"
          ValuesetExpansionParameterValueUri(_) -> "Uri"
          ValuesetExpansionParameterValueCode(_) -> "Code"
          ValuesetExpansionParameterValueDatetime(_) -> "Datetime"
        },
        valueset_expansion_parameter_value_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_parameter_decoder() -> Decoder(
  ValuesetExpansionParameter,
) {
  use value <- decode.then(
    none_if_omitted(valueset_expansion_parameter_value_decoder()),
  )
  use name <- decode.field("name", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansionParameter(
    value:,
    name:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_expansion_to_json(valueset_expansion: ValuesetExpansion) -> Json {
  let ValuesetExpansion(
    contains:,
    property:,
    parameter:,
    offset:,
    total:,
    timestamp:,
    next:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_expansion
  let fields = [
    #("timestamp", json.string(timestamp)),
  ]
  let fields = case contains {
    [] -> fields
    _ -> [
      #("contains", json.array(contains, valueset_expansion_contains_to_json)),
      ..fields
    ]
  }
  let fields = case property {
    [] -> fields
    _ -> [
      #("property", json.array(property, valueset_expansion_property_to_json)),
      ..fields
    ]
  }
  let fields = case parameter {
    [] -> fields
    _ -> [
      #(
        "parameter",
        json.array(parameter, valueset_expansion_parameter_to_json),
      ),
      ..fields
    ]
  }
  let fields = case offset {
    Some(v) -> [#("offset", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case total {
    Some(v) -> [#("total", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case next {
    Some(v) -> [#("next", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    Some(v) -> [#("identifier", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_expansion_decoder() -> Decoder(ValuesetExpansion) {
  use contains <- decode.optional_field(
    "contains",
    [],
    decode.list(valueset_expansion_contains_decoder()),
  )
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(valueset_expansion_property_decoder()),
  )
  use parameter <- decode.optional_field(
    "parameter",
    [],
    decode.list(valueset_expansion_parameter_decoder()),
  )
  use offset <- decode.optional_field(
    "offset",
    None,
    decode.optional(decode.int),
  )
  use total <- decode.optional_field("total", None, decode.optional(decode.int))
  use timestamp <- decode.field("timestamp", decode.string)
  use next <- decode.optional_field(
    "next",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetExpansion(
    contains:,
    property:,
    parameter:,
    offset:,
    total:,
    timestamp:,
    next:,
    identifier:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_filter_to_json(
  valueset_compose_include_filter: ValuesetComposeIncludeFilter,
) -> Json {
  let ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_filter
  let fields = [
    #("value", json.string(value)),
    #("op", r5valuesets.filteroperator_to_json(op)),
    #("property", json.string(property)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_filter_decoder() -> Decoder(
  ValuesetComposeIncludeFilter,
) {
  use value <- decode.field("value", decode.string)
  use op <- decode.field("op", r5valuesets.filteroperator_decoder())
  use property <- decode.field("property", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeFilter(
    value:,
    op:,
    property:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_concept_designation_to_json(
  valueset_compose_include_concept_designation: ValuesetComposeIncludeConceptDesignation,
) -> Json {
  let ValuesetComposeIncludeConceptDesignation(
    value:,
    additional_use:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_concept_designation
  let fields = [
    #("value", json.string(value)),
  ]
  let fields = case additional_use {
    [] -> fields
    _ -> [
      #("additionalUse", json.array(additional_use, coding_to_json)),
      ..fields
    ]
  }
  let fields = case use_ {
    Some(v) -> [#("use", coding_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_concept_designation_decoder() -> Decoder(
  ValuesetComposeIncludeConceptDesignation,
) {
  use value <- decode.field("value", decode.string)
  use additional_use <- decode.optional_field(
    "additionalUse",
    [],
    decode.list(coding_decoder()),
  )
  use use_ <- decode.optional_field(
    "use",
    None,
    decode.optional(coding_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeConceptDesignation(
    value:,
    additional_use:,
    use_:,
    language:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_concept_to_json(
  valueset_compose_include_concept: ValuesetComposeIncludeConcept,
) -> Json {
  let ValuesetComposeIncludeConcept(
    designation:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include_concept
  let fields = [
    #("code", json.string(code)),
  ]
  let fields = case designation {
    [] -> fields
    _ -> [
      #(
        "designation",
        json.array(
          designation,
          valueset_compose_include_concept_designation_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case display {
    Some(v) -> [#("display", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_concept_decoder() -> Decoder(
  ValuesetComposeIncludeConcept,
) {
  use designation <- decode.optional_field(
    "designation",
    [],
    decode.list(valueset_compose_include_concept_designation_decoder()),
  )
  use display <- decode.optional_field(
    "display",
    None,
    decode.optional(decode.string),
  )
  use code <- decode.field("code", decode.string)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeIncludeConcept(
    designation:,
    display:,
    code:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_include_to_json(
  valueset_compose_include: ValuesetComposeInclude,
) -> Json {
  let ValuesetComposeInclude(
    copyright:,
    value_set:,
    filter:,
    concept:,
    version:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose_include
  let fields = []
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case value_set {
    [] -> fields
    _ -> [#("valueSet", json.array(value_set, json.string)), ..fields]
  }
  let fields = case filter {
    [] -> fields
    _ -> [
      #("filter", json.array(filter, valueset_compose_include_filter_to_json)),
      ..fields
    ]
  }
  let fields = case concept {
    [] -> fields
    _ -> [
      #(
        "concept",
        json.array(concept, valueset_compose_include_concept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case system {
    Some(v) -> [#("system", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_include_decoder() -> Decoder(ValuesetComposeInclude) {
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use value_set <- decode.optional_field(
    "valueSet",
    [],
    decode.list(decode.string),
  )
  use filter <- decode.optional_field(
    "filter",
    [],
    decode.list(valueset_compose_include_filter_decoder()),
  )
  use concept <- decode.optional_field(
    "concept",
    [],
    decode.list(valueset_compose_include_concept_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use system <- decode.optional_field(
    "system",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetComposeInclude(
    copyright:,
    value_set:,
    filter:,
    concept:,
    version:,
    system:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_compose_to_json(valueset_compose: ValuesetCompose) -> Json {
  let ValuesetCompose(
    property:,
    include:,
    inactive:,
    locked_date:,
    modifier_extension:,
    extension:,
    id:,
  ) = valueset_compose
  let fields = []
  let fields = case property {
    [] -> fields
    _ -> [#("property", json.array(property, json.string)), ..fields]
  }
  let fields = case include {
    [] -> fields
    _ -> [
      #("include", json.array(include, valueset_compose_include_to_json)),
      ..fields
    ]
  }
  let fields = case inactive {
    Some(v) -> [#("inactive", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case locked_date {
    Some(v) -> [#("lockedDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn valueset_compose_decoder() -> Decoder(ValuesetCompose) {
  use property <- decode.optional_field(
    "property",
    [],
    decode.list(decode.string),
  )
  use include <- decode.optional_field(
    "include",
    [],
    decode.list(valueset_compose_include_decoder()),
  )
  use inactive <- decode.optional_field(
    "inactive",
    None,
    decode.optional(decode.bool),
  )
  use locked_date <- decode.optional_field(
    "lockedDate",
    None,
    decode.optional(decode.string),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(ValuesetCompose(
    property:,
    include:,
    inactive:,
    locked_date:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn valueset_to_json(valueset: Valueset) -> Json {
  let Valueset(
    scope:,
    expansion:,
    compose:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    immutable:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = valueset
  let fields = [
    #("status", r5valuesets.publicationstatus_to_json(status)),
  ]
  let fields = case scope {
    Some(v) -> [#("scope", valueset_scope_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case expansion {
    Some(v) -> [#("expansion", valueset_expansion_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case compose {
    Some(v) -> [#("compose", valueset_compose_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case related_artifact {
    [] -> fields
    _ -> [
      #(
        "relatedArtifact",
        json.array(related_artifact, relatedartifact_to_json),
      ),
      ..fields
    ]
  }
  let fields = case endorser {
    [] -> fields
    _ -> [#("endorser", json.array(endorser, contactdetail_to_json)), ..fields]
  }
  let fields = case reviewer {
    [] -> fields
    _ -> [#("reviewer", json.array(reviewer, contactdetail_to_json)), ..fields]
  }
  let fields = case editor {
    [] -> fields
    _ -> [#("editor", json.array(editor, contactdetail_to_json)), ..fields]
  }
  let fields = case author {
    [] -> fields
    _ -> [#("author", json.array(author, contactdetail_to_json)), ..fields]
  }
  let fields = case topic {
    [] -> fields
    _ -> [#("topic", json.array(topic, codeableconcept_to_json)), ..fields]
  }
  let fields = case effective_period {
    Some(v) -> [#("effectivePeriod", period_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case last_review_date {
    Some(v) -> [#("lastReviewDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case approval_date {
    Some(v) -> [#("approvalDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright_label {
    Some(v) -> [#("copyrightLabel", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case copyright {
    Some(v) -> [#("copyright", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case purpose {
    Some(v) -> [#("purpose", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case immutable {
    Some(v) -> [#("immutable", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case jurisdiction {
    [] -> fields
    _ -> [
      #("jurisdiction", json.array(jurisdiction, codeableconcept_to_json)),
      ..fields
    ]
  }
  let fields = case use_context {
    [] -> fields
    _ -> [
      #("useContext", json.array(use_context, usagecontext_to_json)),
      ..fields
    ]
  }
  let fields = case description {
    Some(v) -> [#("description", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case contact {
    [] -> fields
    _ -> [#("contact", json.array(contact, contactdetail_to_json)), ..fields]
  }
  let fields = case publisher {
    Some(v) -> [#("publisher", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case experimental {
    Some(v) -> [#("experimental", json.bool(v)), ..fields]
    None -> fields
  }
  let fields = case title {
    Some(v) -> [#("title", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case name {
    Some(v) -> [#("name", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case version_algorithm {
    Some(v) -> [
      #(
        "versionAlgorithm"
          <> case v {
          ValuesetVersionalgorithmString(_) -> "String"
          ValuesetVersionalgorithmCoding(_) -> "Coding"
        },
        valueset_versionalgorithm_to_json(v),
      ),
      ..fields
    ]
    None -> fields
  }
  let fields = case version {
    Some(v) -> [#("version", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case url {
    Some(v) -> [#("url", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Valueset")), ..fields]
  json.object(fields)
}

pub fn valueset_decoder() -> Decoder(Valueset) {
  use scope <- decode.optional_field(
    "scope",
    None,
    decode.optional(valueset_scope_decoder()),
  )
  use expansion <- decode.optional_field(
    "expansion",
    None,
    decode.optional(valueset_expansion_decoder()),
  )
  use compose <- decode.optional_field(
    "compose",
    None,
    decode.optional(valueset_compose_decoder()),
  )
  use related_artifact <- decode.optional_field(
    "relatedArtifact",
    [],
    decode.list(relatedartifact_decoder()),
  )
  use endorser <- decode.optional_field(
    "endorser",
    [],
    decode.list(contactdetail_decoder()),
  )
  use reviewer <- decode.optional_field(
    "reviewer",
    [],
    decode.list(contactdetail_decoder()),
  )
  use editor <- decode.optional_field(
    "editor",
    [],
    decode.list(contactdetail_decoder()),
  )
  use author <- decode.optional_field(
    "author",
    [],
    decode.list(contactdetail_decoder()),
  )
  use topic <- decode.optional_field(
    "topic",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use effective_period <- decode.optional_field(
    "effectivePeriod",
    None,
    decode.optional(period_decoder()),
  )
  use last_review_date <- decode.optional_field(
    "lastReviewDate",
    None,
    decode.optional(decode.string),
  )
  use approval_date <- decode.optional_field(
    "approvalDate",
    None,
    decode.optional(decode.string),
  )
  use copyright_label <- decode.optional_field(
    "copyrightLabel",
    None,
    decode.optional(decode.string),
  )
  use copyright <- decode.optional_field(
    "copyright",
    None,
    decode.optional(decode.string),
  )
  use purpose <- decode.optional_field(
    "purpose",
    None,
    decode.optional(decode.string),
  )
  use immutable <- decode.optional_field(
    "immutable",
    None,
    decode.optional(decode.bool),
  )
  use jurisdiction <- decode.optional_field(
    "jurisdiction",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use use_context <- decode.optional_field(
    "useContext",
    [],
    decode.list(usagecontext_decoder()),
  )
  use description <- decode.optional_field(
    "description",
    None,
    decode.optional(decode.string),
  )
  use contact <- decode.optional_field(
    "contact",
    [],
    decode.list(contactdetail_decoder()),
  )
  use publisher <- decode.optional_field(
    "publisher",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use experimental <- decode.optional_field(
    "experimental",
    None,
    decode.optional(decode.bool),
  )
  use status <- decode.field("status", r5valuesets.publicationstatus_decoder())
  use title <- decode.optional_field(
    "title",
    None,
    decode.optional(decode.string),
  )
  use name <- decode.optional_field(
    "name",
    None,
    decode.optional(decode.string),
  )
  use version_algorithm <- decode.then(
    none_if_omitted(valueset_versionalgorithm_decoder()),
  )
  use version <- decode.optional_field(
    "version",
    None,
    decode.optional(decode.string),
  )
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use url <- decode.optional_field("url", None, decode.optional(decode.string))
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Valueset",
    decode.failure(valueset_new(status:), "resourceType"),
  )
  decode.success(Valueset(
    scope:,
    expansion:,
    compose:,
    related_artifact:,
    endorser:,
    reviewer:,
    editor:,
    author:,
    topic:,
    effective_period:,
    last_review_date:,
    approval_date:,
    copyright_label:,
    copyright:,
    purpose:,
    immutable:,
    jurisdiction:,
    use_context:,
    description:,
    contact:,
    publisher:,
    date:,
    experimental:,
    status:,
    title:,
    name:,
    version_algorithm:,
    version:,
    identifier:,
    url:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/VerificationResult#resource
pub type Verificationresult {
  Verificationresult(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    target: List(Reference),
    target_location: List(String),
    need: Option(Codeableconcept),
    status: r5valuesets.Verificationresultstatus,
    status_date: Option(String),
    validation_type: Option(Codeableconcept),
    validation_process: List(Codeableconcept),
    frequency: Option(Timing),
    last_performed: Option(String),
    next_scheduled: Option(String),
    failure_action: Option(Codeableconcept),
    primary_source: List(VerificationresultPrimarysource),
    attestation: Option(VerificationresultAttestation),
    validator: List(VerificationresultValidator),
  )
}

pub fn verificationresult_new(
  status status: r5valuesets.Verificationresultstatus,
) -> Verificationresult {
  Verificationresult(
    validator: [],
    attestation: None,
    primary_source: [],
    failure_action: None,
    next_scheduled: None,
    last_performed: None,
    frequency: None,
    validation_process: [],
    validation_type: None,
    status_date: None,
    status:,
    need: None,
    target_location: [],
    target: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VerificationResult#resource
pub type VerificationresultPrimarysource {
  VerificationresultPrimarysource(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    who: Option(Reference),
    type_: List(Codeableconcept),
    communication_method: List(Codeableconcept),
    validation_status: Option(Codeableconcept),
    validation_date: Option(String),
    can_push_updates: Option(Codeableconcept),
    push_type_available: List(Codeableconcept),
  )
}

pub fn verificationresult_primarysource_new() -> VerificationresultPrimarysource {
  VerificationresultPrimarysource(
    push_type_available: [],
    can_push_updates: None,
    validation_date: None,
    validation_status: None,
    communication_method: [],
    type_: [],
    who: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VerificationResult#resource
pub type VerificationresultAttestation {
  VerificationresultAttestation(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    who: Option(Reference),
    on_behalf_of: Option(Reference),
    communication_method: Option(Codeableconcept),
    date: Option(String),
    source_identity_certificate: Option(String),
    proxy_identity_certificate: Option(String),
    proxy_signature: Option(Signature),
    source_signature: Option(Signature),
  )
}

pub fn verificationresult_attestation_new() -> VerificationresultAttestation {
  VerificationresultAttestation(
    source_signature: None,
    proxy_signature: None,
    proxy_identity_certificate: None,
    source_identity_certificate: None,
    date: None,
    communication_method: None,
    on_behalf_of: None,
    who: None,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VerificationResult#resource
pub type VerificationresultValidator {
  VerificationresultValidator(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    organization: Reference,
    identity_certificate: Option(String),
    attestation_signature: Option(Signature),
  )
}

pub fn verificationresult_validator_new(
  organization organization: Reference,
) -> VerificationresultValidator {
  VerificationresultValidator(
    attestation_signature: None,
    identity_certificate: None,
    organization:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn verificationresult_validator_to_json(
  verificationresult_validator: VerificationresultValidator,
) -> Json {
  let VerificationresultValidator(
    attestation_signature:,
    identity_certificate:,
    organization:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_validator
  let fields = [
    #("organization", reference_to_json(organization)),
  ]
  let fields = case attestation_signature {
    Some(v) -> [#("attestationSignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identity_certificate {
    Some(v) -> [#("identityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_validator_decoder() -> Decoder(
  VerificationresultValidator,
) {
  use attestation_signature <- decode.optional_field(
    "attestationSignature",
    None,
    decode.optional(signature_decoder()),
  )
  use identity_certificate <- decode.optional_field(
    "identityCertificate",
    None,
    decode.optional(decode.string),
  )
  use organization <- decode.field("organization", reference_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultValidator(
    attestation_signature:,
    identity_certificate:,
    organization:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_attestation_to_json(
  verificationresult_attestation: VerificationresultAttestation,
) -> Json {
  let VerificationresultAttestation(
    source_signature:,
    proxy_signature:,
    proxy_identity_certificate:,
    source_identity_certificate:,
    date:,
    communication_method:,
    on_behalf_of:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_attestation
  let fields = []
  let fields = case source_signature {
    Some(v) -> [#("sourceSignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case proxy_signature {
    Some(v) -> [#("proxySignature", signature_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case proxy_identity_certificate {
    Some(v) -> [#("proxyIdentityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case source_identity_certificate {
    Some(v) -> [#("sourceIdentityCertificate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case date {
    Some(v) -> [#("date", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case communication_method {
    Some(v) -> [#("communicationMethod", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case on_behalf_of {
    Some(v) -> [#("onBehalfOf", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_attestation_decoder() -> Decoder(
  VerificationresultAttestation,
) {
  use source_signature <- decode.optional_field(
    "sourceSignature",
    None,
    decode.optional(signature_decoder()),
  )
  use proxy_signature <- decode.optional_field(
    "proxySignature",
    None,
    decode.optional(signature_decoder()),
  )
  use proxy_identity_certificate <- decode.optional_field(
    "proxyIdentityCertificate",
    None,
    decode.optional(decode.string),
  )
  use source_identity_certificate <- decode.optional_field(
    "sourceIdentityCertificate",
    None,
    decode.optional(decode.string),
  )
  use date <- decode.optional_field(
    "date",
    None,
    decode.optional(decode.string),
  )
  use communication_method <- decode.optional_field(
    "communicationMethod",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use on_behalf_of <- decode.optional_field(
    "onBehalfOf",
    None,
    decode.optional(reference_decoder()),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultAttestation(
    source_signature:,
    proxy_signature:,
    proxy_identity_certificate:,
    source_identity_certificate:,
    date:,
    communication_method:,
    on_behalf_of:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_primarysource_to_json(
  verificationresult_primarysource: VerificationresultPrimarysource,
) -> Json {
  let VerificationresultPrimarysource(
    push_type_available:,
    can_push_updates:,
    validation_date:,
    validation_status:,
    communication_method:,
    type_:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ) = verificationresult_primarysource
  let fields = []
  let fields = case push_type_available {
    [] -> fields
    _ -> [
      #(
        "pushTypeAvailable",
        json.array(push_type_available, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case can_push_updates {
    Some(v) -> [#("canPushUpdates", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case validation_date {
    Some(v) -> [#("validationDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case validation_status {
    Some(v) -> [#("validationStatus", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case communication_method {
    [] -> fields
    _ -> [
      #(
        "communicationMethod",
        json.array(communication_method, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case type_ {
    [] -> fields
    _ -> [#("type", json.array(type_, codeableconcept_to_json)), ..fields]
  }
  let fields = case who {
    Some(v) -> [#("who", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn verificationresult_primarysource_decoder() -> Decoder(
  VerificationresultPrimarysource,
) {
  use push_type_available <- decode.optional_field(
    "pushTypeAvailable",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use can_push_updates <- decode.optional_field(
    "canPushUpdates",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use validation_date <- decode.optional_field(
    "validationDate",
    None,
    decode.optional(decode.string),
  )
  use validation_status <- decode.optional_field(
    "validationStatus",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use communication_method <- decode.optional_field(
    "communicationMethod",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use type_ <- decode.optional_field(
    "type",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use who <- decode.optional_field(
    "who",
    None,
    decode.optional(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VerificationresultPrimarysource(
    push_type_available:,
    can_push_updates:,
    validation_date:,
    validation_status:,
    communication_method:,
    type_:,
    who:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn verificationresult_to_json(
  verificationresult: Verificationresult,
) -> Json {
  let Verificationresult(
    validator:,
    attestation:,
    primary_source:,
    failure_action:,
    next_scheduled:,
    last_performed:,
    frequency:,
    validation_process:,
    validation_type:,
    status_date:,
    status:,
    need:,
    target_location:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = verificationresult
  let fields = [
    #("status", r5valuesets.verificationresultstatus_to_json(status)),
  ]
  let fields = case validator {
    [] -> fields
    _ -> [
      #(
        "validator",
        json.array(validator, verificationresult_validator_to_json),
      ),
      ..fields
    ]
  }
  let fields = case attestation {
    Some(v) -> [
      #("attestation", verificationresult_attestation_to_json(v)),
      ..fields
    ]
    None -> fields
  }
  let fields = case primary_source {
    [] -> fields
    _ -> [
      #(
        "primarySource",
        json.array(primary_source, verificationresult_primarysource_to_json),
      ),
      ..fields
    ]
  }
  let fields = case failure_action {
    Some(v) -> [#("failureAction", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case next_scheduled {
    Some(v) -> [#("nextScheduled", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case last_performed {
    Some(v) -> [#("lastPerformed", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case frequency {
    Some(v) -> [#("frequency", timing_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case validation_process {
    [] -> fields
    _ -> [
      #(
        "validationProcess",
        json.array(validation_process, codeableconcept_to_json),
      ),
      ..fields
    ]
  }
  let fields = case validation_type {
    Some(v) -> [#("validationType", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case status_date {
    Some(v) -> [#("statusDate", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case need {
    Some(v) -> [#("need", codeableconcept_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case target_location {
    [] -> fields
    _ -> [
      #("targetLocation", json.array(target_location, json.string)),
      ..fields
    ]
  }
  let fields = case target {
    [] -> fields
    _ -> [#("target", json.array(target, reference_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Verificationresult")), ..fields]
  json.object(fields)
}

pub fn verificationresult_decoder() -> Decoder(Verificationresult) {
  use validator <- decode.optional_field(
    "validator",
    [],
    decode.list(verificationresult_validator_decoder()),
  )
  use attestation <- decode.optional_field(
    "attestation",
    None,
    decode.optional(verificationresult_attestation_decoder()),
  )
  use primary_source <- decode.optional_field(
    "primarySource",
    [],
    decode.list(verificationresult_primarysource_decoder()),
  )
  use failure_action <- decode.optional_field(
    "failureAction",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use next_scheduled <- decode.optional_field(
    "nextScheduled",
    None,
    decode.optional(decode.string),
  )
  use last_performed <- decode.optional_field(
    "lastPerformed",
    None,
    decode.optional(decode.string),
  )
  use frequency <- decode.optional_field(
    "frequency",
    None,
    decode.optional(timing_decoder()),
  )
  use validation_process <- decode.optional_field(
    "validationProcess",
    [],
    decode.list(codeableconcept_decoder()),
  )
  use validation_type <- decode.optional_field(
    "validationType",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use status_date <- decode.optional_field(
    "statusDate",
    None,
    decode.optional(decode.string),
  )
  use status <- decode.field(
    "status",
    r5valuesets.verificationresultstatus_decoder(),
  )
  use need <- decode.optional_field(
    "need",
    None,
    decode.optional(codeableconcept_decoder()),
  )
  use target_location <- decode.optional_field(
    "targetLocation",
    [],
    decode.list(decode.string),
  )
  use target <- decode.optional_field(
    "target",
    [],
    decode.list(reference_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Verificationresult",
    decode.failure(verificationresult_new(status:), "resourceType"),
  )
  decode.success(Verificationresult(
    validator:,
    attestation:,
    primary_source:,
    failure_action:,
    next_scheduled:,
    last_performed:,
    frequency:,
    validation_process:,
    validation_type:,
    status_date:,
    status:,
    need:,
    target_location:,
    target:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

///http://hl7.org/fhir/r5/StructureDefinition/VisionPrescription#resource
pub type Visionprescription {
  Visionprescription(
    id: Option(String),
    meta: Option(Meta),
    implicit_rules: Option(String),
    language: Option(String),
    text: Option(Narrative),
    contained: List(Resource),
    extension: List(Extension),
    modifier_extension: List(Extension),
    identifier: List(Identifier),
    status: r5valuesets.Fmstatus,
    created: String,
    patient: Reference,
    encounter: Option(Reference),
    date_written: String,
    prescriber: Reference,
    lens_specification: List(VisionprescriptionLensspecification),
  )
}

pub fn visionprescription_new(
  prescriber prescriber: Reference,
  date_written date_written: String,
  patient patient: Reference,
  created created: String,
  status status: r5valuesets.Fmstatus,
) -> Visionprescription {
  Visionprescription(
    lens_specification: [],
    prescriber:,
    date_written:,
    encounter: None,
    patient:,
    created:,
    status:,
    identifier: [],
    modifier_extension: [],
    extension: [],
    contained: [],
    text: None,
    language: None,
    implicit_rules: None,
    meta: None,
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecification {
  VisionprescriptionLensspecification(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    product: Codeableconcept,
    eye: r5valuesets.Visioneyecodes,
    sphere: Option(Float),
    cylinder: Option(Float),
    axis: Option(Int),
    prism: List(VisionprescriptionLensspecificationPrism),
    add: Option(Float),
    power: Option(Float),
    back_curve: Option(Float),
    diameter: Option(Float),
    duration: Option(Quantity),
    color: Option(String),
    brand: Option(String),
    note: List(Annotation),
  )
}

pub fn visionprescription_lensspecification_new(
  eye eye: r5valuesets.Visioneyecodes,
  product product: Codeableconcept,
) -> VisionprescriptionLensspecification {
  VisionprescriptionLensspecification(
    note: [],
    brand: None,
    color: None,
    duration: None,
    diameter: None,
    back_curve: None,
    power: None,
    add: None,
    prism: [],
    axis: None,
    cylinder: None,
    sphere: None,
    eye:,
    product:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

///http://hl7.org/fhir/r5/StructureDefinition/VisionPrescription#resource
pub type VisionprescriptionLensspecificationPrism {
  VisionprescriptionLensspecificationPrism(
    id: Option(String),
    extension: List(Extension),
    modifier_extension: List(Extension),
    amount: Float,
    base: r5valuesets.Visionbasecodes,
  )
}

pub fn visionprescription_lensspecification_prism_new(
  base base: r5valuesets.Visionbasecodes,
  amount amount: Float,
) -> VisionprescriptionLensspecificationPrism {
  VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension: [],
    extension: [],
    id: None,
  )
}

pub fn visionprescription_lensspecification_prism_to_json(
  visionprescription_lensspecification_prism: VisionprescriptionLensspecificationPrism,
) -> Json {
  let VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ) = visionprescription_lensspecification_prism
  let fields = [
    #("base", r5valuesets.visionbasecodes_to_json(base)),
    #("amount", json.float(amount)),
  ]
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn visionprescription_lensspecification_prism_decoder() -> Decoder(
  VisionprescriptionLensspecificationPrism,
) {
  use base <- decode.field("base", r5valuesets.visionbasecodes_decoder())
  use amount <- decode.field("amount", decode.float)
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VisionprescriptionLensspecificationPrism(
    base:,
    amount:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn visionprescription_lensspecification_to_json(
  visionprescription_lensspecification: VisionprescriptionLensspecification,
) -> Json {
  let VisionprescriptionLensspecification(
    note:,
    brand:,
    color:,
    duration:,
    diameter:,
    back_curve:,
    power:,
    add:,
    prism:,
    axis:,
    cylinder:,
    sphere:,
    eye:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ) = visionprescription_lensspecification
  let fields = [
    #("eye", r5valuesets.visioneyecodes_to_json(eye)),
    #("product", codeableconcept_to_json(product)),
  ]
  let fields = case note {
    [] -> fields
    _ -> [#("note", json.array(note, annotation_to_json)), ..fields]
  }
  let fields = case brand {
    Some(v) -> [#("brand", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case color {
    Some(v) -> [#("color", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case duration {
    Some(v) -> [#("duration", quantity_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case diameter {
    Some(v) -> [#("diameter", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case back_curve {
    Some(v) -> [#("backCurve", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case power {
    Some(v) -> [#("power", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case add {
    Some(v) -> [#("add", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case prism {
    [] -> fields
    _ -> [
      #(
        "prism",
        json.array(prism, visionprescription_lensspecification_prism_to_json),
      ),
      ..fields
    ]
  }
  let fields = case axis {
    Some(v) -> [#("axis", json.int(v)), ..fields]
    None -> fields
  }
  let fields = case cylinder {
    Some(v) -> [#("cylinder", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case sphere {
    Some(v) -> [#("sphere", json.float(v)), ..fields]
    None -> fields
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  json.object(fields)
}

pub fn visionprescription_lensspecification_decoder() -> Decoder(
  VisionprescriptionLensspecification,
) {
  use note <- decode.optional_field(
    "note",
    [],
    decode.list(annotation_decoder()),
  )
  use brand <- decode.optional_field(
    "brand",
    None,
    decode.optional(decode.string),
  )
  use color <- decode.optional_field(
    "color",
    None,
    decode.optional(decode.string),
  )
  use duration <- decode.optional_field(
    "duration",
    None,
    decode.optional(quantity_decoder()),
  )
  use diameter <- decode.optional_field(
    "diameter",
    None,
    decode.optional(decode.float),
  )
  use back_curve <- decode.optional_field(
    "backCurve",
    None,
    decode.optional(decode.float),
  )
  use power <- decode.optional_field(
    "power",
    None,
    decode.optional(decode.float),
  )
  use add <- decode.optional_field("add", None, decode.optional(decode.float))
  use prism <- decode.optional_field(
    "prism",
    [],
    decode.list(visionprescription_lensspecification_prism_decoder()),
  )
  use axis <- decode.optional_field("axis", None, decode.optional(decode.int))
  use cylinder <- decode.optional_field(
    "cylinder",
    None,
    decode.optional(decode.float),
  )
  use sphere <- decode.optional_field(
    "sphere",
    None,
    decode.optional(decode.float),
  )
  use eye <- decode.field("eye", r5valuesets.visioneyecodes_decoder())
  use product <- decode.field("product", codeableconcept_decoder())
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))
  decode.success(VisionprescriptionLensspecification(
    note:,
    brand:,
    color:,
    duration:,
    diameter:,
    back_curve:,
    power:,
    add:,
    prism:,
    axis:,
    cylinder:,
    sphere:,
    eye:,
    product:,
    modifier_extension:,
    extension:,
    id:,
  ))
}

pub fn visionprescription_to_json(
  visionprescription: Visionprescription,
) -> Json {
  let Visionprescription(
    lens_specification:,
    prescriber:,
    date_written:,
    encounter:,
    patient:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ) = visionprescription
  let fields = [
    #("prescriber", reference_to_json(prescriber)),
    #("dateWritten", json.string(date_written)),
    #("patient", reference_to_json(patient)),
    #("created", json.string(created)),
    #("status", r5valuesets.fmstatus_to_json(status)),
  ]
  let fields = case lens_specification {
    [] -> fields
    _ -> [
      #(
        "lensSpecification",
        json.array(
          lens_specification,
          visionprescription_lensspecification_to_json,
        ),
      ),
      ..fields
    ]
  }
  let fields = case encounter {
    Some(v) -> [#("encounter", reference_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case identifier {
    [] -> fields
    _ -> [#("identifier", json.array(identifier, identifier_to_json)), ..fields]
  }
  let fields = case modifier_extension {
    [] -> fields
    _ -> [
      #("modifierExtension", json.array(modifier_extension, extension_to_json)),
      ..fields
    ]
  }
  let fields = case extension {
    [] -> fields
    _ -> [#("extension", json.array(extension, extension_to_json)), ..fields]
  }
  let fields = case contained {
    [] -> fields
    _ -> [#("contained", json.array(contained, resource_to_json)), ..fields]
  }
  let fields = case text {
    Some(v) -> [#("text", narrative_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case language {
    Some(v) -> [#("language", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case implicit_rules {
    Some(v) -> [#("implicitRules", json.string(v)), ..fields]
    None -> fields
  }
  let fields = case meta {
    Some(v) -> [#("meta", meta_to_json(v)), ..fields]
    None -> fields
  }
  let fields = case id {
    Some(v) -> [#("id", json.string(v)), ..fields]
    None -> fields
  }
  let fields = [#("resourceType", json.string("Visionprescription")), ..fields]
  json.object(fields)
}

pub fn visionprescription_decoder() -> Decoder(Visionprescription) {
  use lens_specification <- decode.optional_field(
    "lensSpecification",
    [],
    decode.list(visionprescription_lensspecification_decoder()),
  )
  use prescriber <- decode.field("prescriber", reference_decoder())
  use date_written <- decode.field("dateWritten", decode.string)
  use encounter <- decode.optional_field(
    "encounter",
    None,
    decode.optional(reference_decoder()),
  )
  use patient <- decode.field("patient", reference_decoder())
  use created <- decode.field("created", decode.string)
  use status <- decode.field("status", r5valuesets.fmstatus_decoder())
  use identifier <- decode.optional_field(
    "identifier",
    [],
    decode.list(identifier_decoder()),
  )
  use modifier_extension <- decode.optional_field(
    "modifierExtension",
    [],
    decode.list(extension_decoder()),
  )
  use extension <- decode.optional_field(
    "extension",
    [],
    decode.list(extension_decoder()),
  )
  use contained <- decode.optional_field(
    "contained",
    [],
    decode.list(resource_decoder()),
  )
  use text <- decode.optional_field(
    "text",
    None,
    decode.optional(narrative_decoder()),
  )
  use language <- decode.optional_field(
    "language",
    None,
    decode.optional(decode.string),
  )
  use implicit_rules <- decode.optional_field(
    "implicitRules",
    None,
    decode.optional(decode.string),
  )
  use meta <- decode.optional_field(
    "meta",
    None,
    decode.optional(meta_decoder()),
  )
  use id <- decode.optional_field("id", None, decode.optional(decode.string))

  use rt <- decode.field("resourceType", decode.string)
  use <- bool.guard(
    rt != "Visionprescription",
    decode.failure(
      visionprescription_new(
        prescriber:,
        date_written:,
        patient:,
        created:,
        status:,
      ),
      "resourceType",
    ),
  )
  decode.success(Visionprescription(
    lens_specification:,
    prescriber:,
    date_written:,
    encounter:,
    patient:,
    created:,
    status:,
    identifier:,
    modifier_extension:,
    extension:,
    contained:,
    text:,
    language:,
    implicit_rules:,
    meta:,
    id:,
  ))
}

pub type Resource {
  ResourceAccount(Account)
  ResourceActivitydefinition(Activitydefinition)
  ResourceActordefinition(Actordefinition)
  ResourceAdministrableproductdefinition(Administrableproductdefinition)
  ResourceAdverseevent(Adverseevent)
  ResourceAllergyintolerance(Allergyintolerance)
  ResourceAppointment(Appointment)
  ResourceAppointmentresponse(Appointmentresponse)
  ResourceArtifactassessment(Artifactassessment)
  ResourceAuditevent(Auditevent)
  ResourceBasic(Basic)
  ResourceBinary(Binary)
  ResourceBiologicallyderivedproduct(Biologicallyderivedproduct)
  ResourceBiologicallyderivedproductdispense(Biologicallyderivedproductdispense)
  ResourceBodystructure(Bodystructure)
  ResourceBundle(Bundle)
  ResourceCanonicalresource(Canonicalresource)
  ResourceCapabilitystatement(Capabilitystatement)
  ResourceCareplan(Careplan)
  ResourceCareteam(Careteam)
  ResourceChargeitem(Chargeitem)
  ResourceChargeitemdefinition(Chargeitemdefinition)
  ResourceCitation(Citation)
  ResourceClaim(Claim)
  ResourceClaimresponse(Claimresponse)
  ResourceClinicalimpression(Clinicalimpression)
  ResourceClinicalusedefinition(Clinicalusedefinition)
  ResourceCodesystem(Codesystem)
  ResourceCommunication(Communication)
  ResourceCommunicationrequest(Communicationrequest)
  ResourceCompartmentdefinition(Compartmentdefinition)
  ResourceComposition(Composition)
  ResourceConceptmap(Conceptmap)
  ResourceCondition(Condition)
  ResourceConditiondefinition(Conditiondefinition)
  ResourceConsent(Consent)
  ResourceContract(Contract)
  ResourceCoverage(Coverage)
  ResourceCoverageeligibilityrequest(Coverageeligibilityrequest)
  ResourceCoverageeligibilityresponse(Coverageeligibilityresponse)
  ResourceDetectedissue(Detectedissue)
  ResourceDevice(Device)
  ResourceDeviceassociation(Deviceassociation)
  ResourceDevicedefinition(Devicedefinition)
  ResourceDevicedispense(Devicedispense)
  ResourceDevicemetric(Devicemetric)
  ResourceDevicerequest(Devicerequest)
  ResourceDeviceusage(Deviceusage)
  ResourceDiagnosticreport(Diagnosticreport)
  ResourceDocumentreference(Documentreference)
  ResourceDomainresource(Domainresource)
  ResourceEncounter(Encounter)
  ResourceEncounterhistory(Encounterhistory)
  ResourceEndpoint(Endpoint)
  ResourceEnrollmentrequest(Enrollmentrequest)
  ResourceEnrollmentresponse(Enrollmentresponse)
  ResourceEpisodeofcare(Episodeofcare)
  ResourceEventdefinition(Eventdefinition)
  ResourceEvidence(Evidence)
  ResourceEvidencereport(Evidencereport)
  ResourceEvidencevariable(Evidencevariable)
  ResourceExamplescenario(Examplescenario)
  ResourceExplanationofbenefit(Explanationofbenefit)
  ResourceFamilymemberhistory(Familymemberhistory)
  ResourceFlag(Flag)
  ResourceFormularyitem(Formularyitem)
  ResourceGenomicstudy(Genomicstudy)
  ResourceGoal(Goal)
  ResourceGraphdefinition(Graphdefinition)
  ResourceGroup(Group)
  ResourceGuidanceresponse(Guidanceresponse)
  ResourceHealthcareservice(Healthcareservice)
  ResourceImagingselection(Imagingselection)
  ResourceImagingstudy(Imagingstudy)
  ResourceImmunization(Immunization)
  ResourceImmunizationevaluation(Immunizationevaluation)
  ResourceImmunizationrecommendation(Immunizationrecommendation)
  ResourceImplementationguide(Implementationguide)
  ResourceIngredient(Ingredient)
  ResourceInsuranceplan(Insuranceplan)
  ResourceInventoryitem(Inventoryitem)
  ResourceInventoryreport(Inventoryreport)
  ResourceInvoice(Invoice)
  ResourceLibrary(Library)
  ResourceLinkage(Linkage)
  ResourceListfhir(Listfhir)
  ResourceLocation(Location)
  ResourceManufactureditemdefinition(Manufactureditemdefinition)
  ResourceMeasure(Measure)
  ResourceMeasurereport(Measurereport)
  ResourceMedication(Medication)
  ResourceMedicationadministration(Medicationadministration)
  ResourceMedicationdispense(Medicationdispense)
  ResourceMedicationknowledge(Medicationknowledge)
  ResourceMedicationrequest(Medicationrequest)
  ResourceMedicationstatement(Medicationstatement)
  ResourceMedicinalproductdefinition(Medicinalproductdefinition)
  ResourceMessagedefinition(Messagedefinition)
  ResourceMessageheader(Messageheader)
  ResourceMetadataresource(Metadataresource)
  ResourceMolecularsequence(Molecularsequence)
  ResourceNamingsystem(Namingsystem)
  ResourceNutritionintake(Nutritionintake)
  ResourceNutritionorder(Nutritionorder)
  ResourceNutritionproduct(Nutritionproduct)
  ResourceObservation(Observation)
  ResourceObservationdefinition(Observationdefinition)
  ResourceOperationdefinition(Operationdefinition)
  ResourceOperationoutcome(Operationoutcome)
  ResourceOrganization(Organization)
  ResourceOrganizationaffiliation(Organizationaffiliation)
  ResourcePackagedproductdefinition(Packagedproductdefinition)
  ResourceParameters(Parameters)
  ResourcePatient(Patient)
  ResourcePaymentnotice(Paymentnotice)
  ResourcePaymentreconciliation(Paymentreconciliation)
  ResourcePermission(Permission)
  ResourcePerson(Person)
  ResourcePlandefinition(Plandefinition)
  ResourcePractitioner(Practitioner)
  ResourcePractitionerrole(Practitionerrole)
  ResourceProcedure(Procedure)
  ResourceProvenance(Provenance)
  ResourceQuestionnaire(Questionnaire)
  ResourceQuestionnaireresponse(Questionnaireresponse)
  ResourceRegulatedauthorization(Regulatedauthorization)
  ResourceRelatedperson(Relatedperson)
  ResourceRequestorchestration(Requestorchestration)
  ResourceRequirements(Requirements)
  ResourceResearchstudy(Researchstudy)
  ResourceResearchsubject(Researchsubject)
  ResourceRiskassessment(Riskassessment)
  ResourceSchedule(Schedule)
  ResourceSearchparameter(Searchparameter)
  ResourceServicerequest(Servicerequest)
  ResourceSlot(Slot)
  ResourceSpecimen(Specimen)
  ResourceSpecimendefinition(Specimendefinition)
  ResourceStructuredefinition(Structuredefinition)
  ResourceStructuremap(Structuremap)
  ResourceSubscription(Subscription)
  ResourceSubscriptionstatus(Subscriptionstatus)
  ResourceSubscriptiontopic(Subscriptiontopic)
  ResourceSubstance(Substance)
  ResourceSubstancedefinition(Substancedefinition)
  ResourceSubstancenucleicacid(Substancenucleicacid)
  ResourceSubstancepolymer(Substancepolymer)
  ResourceSubstanceprotein(Substanceprotein)
  ResourceSubstancereferenceinformation(Substancereferenceinformation)
  ResourceSubstancesourcematerial(Substancesourcematerial)
  ResourceSupplydelivery(Supplydelivery)
  ResourceSupplyrequest(Supplyrequest)
  ResourceTask(Task)
  ResourceTerminologycapabilities(Terminologycapabilities)
  ResourceTestplan(Testplan)
  ResourceTestreport(Testreport)
  ResourceTestscript(Testscript)
  ResourceTransport(Transport)
  ResourceValueset(Valueset)
  ResourceVerificationresult(Verificationresult)
  ResourceVisionprescription(Visionprescription)
}

pub fn resource_to_json(res: Resource) {
  case res {
    ResourceAccount(r) -> account_to_json(r)
    ResourceActivitydefinition(r) -> activitydefinition_to_json(r)
    ResourceActordefinition(r) -> actordefinition_to_json(r)
    ResourceAdministrableproductdefinition(r) ->
      administrableproductdefinition_to_json(r)
    ResourceAdverseevent(r) -> adverseevent_to_json(r)
    ResourceAllergyintolerance(r) -> allergyintolerance_to_json(r)
    ResourceAppointment(r) -> appointment_to_json(r)
    ResourceAppointmentresponse(r) -> appointmentresponse_to_json(r)
    ResourceArtifactassessment(r) -> artifactassessment_to_json(r)
    ResourceAuditevent(r) -> auditevent_to_json(r)
    ResourceBasic(r) -> basic_to_json(r)
    ResourceBinary(r) -> binary_to_json(r)
    ResourceBiologicallyderivedproduct(r) ->
      biologicallyderivedproduct_to_json(r)
    ResourceBiologicallyderivedproductdispense(r) ->
      biologicallyderivedproductdispense_to_json(r)
    ResourceBodystructure(r) -> bodystructure_to_json(r)
    ResourceBundle(r) -> bundle_to_json(r)
    ResourceCanonicalresource(r) -> canonicalresource_to_json(r)
    ResourceCapabilitystatement(r) -> capabilitystatement_to_json(r)
    ResourceCareplan(r) -> careplan_to_json(r)
    ResourceCareteam(r) -> careteam_to_json(r)
    ResourceChargeitem(r) -> chargeitem_to_json(r)
    ResourceChargeitemdefinition(r) -> chargeitemdefinition_to_json(r)
    ResourceCitation(r) -> citation_to_json(r)
    ResourceClaim(r) -> claim_to_json(r)
    ResourceClaimresponse(r) -> claimresponse_to_json(r)
    ResourceClinicalimpression(r) -> clinicalimpression_to_json(r)
    ResourceClinicalusedefinition(r) -> clinicalusedefinition_to_json(r)
    ResourceCodesystem(r) -> codesystem_to_json(r)
    ResourceCommunication(r) -> communication_to_json(r)
    ResourceCommunicationrequest(r) -> communicationrequest_to_json(r)
    ResourceCompartmentdefinition(r) -> compartmentdefinition_to_json(r)
    ResourceComposition(r) -> composition_to_json(r)
    ResourceConceptmap(r) -> conceptmap_to_json(r)
    ResourceCondition(r) -> condition_to_json(r)
    ResourceConditiondefinition(r) -> conditiondefinition_to_json(r)
    ResourceConsent(r) -> consent_to_json(r)
    ResourceContract(r) -> contract_to_json(r)
    ResourceCoverage(r) -> coverage_to_json(r)
    ResourceCoverageeligibilityrequest(r) ->
      coverageeligibilityrequest_to_json(r)
    ResourceCoverageeligibilityresponse(r) ->
      coverageeligibilityresponse_to_json(r)
    ResourceDetectedissue(r) -> detectedissue_to_json(r)
    ResourceDevice(r) -> device_to_json(r)
    ResourceDeviceassociation(r) -> deviceassociation_to_json(r)
    ResourceDevicedefinition(r) -> devicedefinition_to_json(r)
    ResourceDevicedispense(r) -> devicedispense_to_json(r)
    ResourceDevicemetric(r) -> devicemetric_to_json(r)
    ResourceDevicerequest(r) -> devicerequest_to_json(r)
    ResourceDeviceusage(r) -> deviceusage_to_json(r)
    ResourceDiagnosticreport(r) -> diagnosticreport_to_json(r)
    ResourceDocumentreference(r) -> documentreference_to_json(r)
    ResourceDomainresource(r) -> domainresource_to_json(r)
    ResourceEncounter(r) -> encounter_to_json(r)
    ResourceEncounterhistory(r) -> encounterhistory_to_json(r)
    ResourceEndpoint(r) -> endpoint_to_json(r)
    ResourceEnrollmentrequest(r) -> enrollmentrequest_to_json(r)
    ResourceEnrollmentresponse(r) -> enrollmentresponse_to_json(r)
    ResourceEpisodeofcare(r) -> episodeofcare_to_json(r)
    ResourceEventdefinition(r) -> eventdefinition_to_json(r)
    ResourceEvidence(r) -> evidence_to_json(r)
    ResourceEvidencereport(r) -> evidencereport_to_json(r)
    ResourceEvidencevariable(r) -> evidencevariable_to_json(r)
    ResourceExamplescenario(r) -> examplescenario_to_json(r)
    ResourceExplanationofbenefit(r) -> explanationofbenefit_to_json(r)
    ResourceFamilymemberhistory(r) -> familymemberhistory_to_json(r)
    ResourceFlag(r) -> flag_to_json(r)
    ResourceFormularyitem(r) -> formularyitem_to_json(r)
    ResourceGenomicstudy(r) -> genomicstudy_to_json(r)
    ResourceGoal(r) -> goal_to_json(r)
    ResourceGraphdefinition(r) -> graphdefinition_to_json(r)
    ResourceGroup(r) -> group_to_json(r)
    ResourceGuidanceresponse(r) -> guidanceresponse_to_json(r)
    ResourceHealthcareservice(r) -> healthcareservice_to_json(r)
    ResourceImagingselection(r) -> imagingselection_to_json(r)
    ResourceImagingstudy(r) -> imagingstudy_to_json(r)
    ResourceImmunization(r) -> immunization_to_json(r)
    ResourceImmunizationevaluation(r) -> immunizationevaluation_to_json(r)
    ResourceImmunizationrecommendation(r) ->
      immunizationrecommendation_to_json(r)
    ResourceImplementationguide(r) -> implementationguide_to_json(r)
    ResourceIngredient(r) -> ingredient_to_json(r)
    ResourceInsuranceplan(r) -> insuranceplan_to_json(r)
    ResourceInventoryitem(r) -> inventoryitem_to_json(r)
    ResourceInventoryreport(r) -> inventoryreport_to_json(r)
    ResourceInvoice(r) -> invoice_to_json(r)
    ResourceLibrary(r) -> library_to_json(r)
    ResourceLinkage(r) -> linkage_to_json(r)
    ResourceListfhir(r) -> listfhir_to_json(r)
    ResourceLocation(r) -> location_to_json(r)
    ResourceManufactureditemdefinition(r) ->
      manufactureditemdefinition_to_json(r)
    ResourceMeasure(r) -> measure_to_json(r)
    ResourceMeasurereport(r) -> measurereport_to_json(r)
    ResourceMedication(r) -> medication_to_json(r)
    ResourceMedicationadministration(r) -> medicationadministration_to_json(r)
    ResourceMedicationdispense(r) -> medicationdispense_to_json(r)
    ResourceMedicationknowledge(r) -> medicationknowledge_to_json(r)
    ResourceMedicationrequest(r) -> medicationrequest_to_json(r)
    ResourceMedicationstatement(r) -> medicationstatement_to_json(r)
    ResourceMedicinalproductdefinition(r) ->
      medicinalproductdefinition_to_json(r)
    ResourceMessagedefinition(r) -> messagedefinition_to_json(r)
    ResourceMessageheader(r) -> messageheader_to_json(r)
    ResourceMetadataresource(r) -> metadataresource_to_json(r)
    ResourceMolecularsequence(r) -> molecularsequence_to_json(r)
    ResourceNamingsystem(r) -> namingsystem_to_json(r)
    ResourceNutritionintake(r) -> nutritionintake_to_json(r)
    ResourceNutritionorder(r) -> nutritionorder_to_json(r)
    ResourceNutritionproduct(r) -> nutritionproduct_to_json(r)
    ResourceObservation(r) -> observation_to_json(r)
    ResourceObservationdefinition(r) -> observationdefinition_to_json(r)
    ResourceOperationdefinition(r) -> operationdefinition_to_json(r)
    ResourceOperationoutcome(r) -> operationoutcome_to_json(r)
    ResourceOrganization(r) -> organization_to_json(r)
    ResourceOrganizationaffiliation(r) -> organizationaffiliation_to_json(r)
    ResourcePackagedproductdefinition(r) -> packagedproductdefinition_to_json(r)
    ResourceParameters(r) -> parameters_to_json(r)
    ResourcePatient(r) -> patient_to_json(r)
    ResourcePaymentnotice(r) -> paymentnotice_to_json(r)
    ResourcePaymentreconciliation(r) -> paymentreconciliation_to_json(r)
    ResourcePermission(r) -> permission_to_json(r)
    ResourcePerson(r) -> person_to_json(r)
    ResourcePlandefinition(r) -> plandefinition_to_json(r)
    ResourcePractitioner(r) -> practitioner_to_json(r)
    ResourcePractitionerrole(r) -> practitionerrole_to_json(r)
    ResourceProcedure(r) -> procedure_to_json(r)
    ResourceProvenance(r) -> provenance_to_json(r)
    ResourceQuestionnaire(r) -> questionnaire_to_json(r)
    ResourceQuestionnaireresponse(r) -> questionnaireresponse_to_json(r)
    ResourceRegulatedauthorization(r) -> regulatedauthorization_to_json(r)
    ResourceRelatedperson(r) -> relatedperson_to_json(r)
    ResourceRequestorchestration(r) -> requestorchestration_to_json(r)
    ResourceRequirements(r) -> requirements_to_json(r)
    ResourceResearchstudy(r) -> researchstudy_to_json(r)
    ResourceResearchsubject(r) -> researchsubject_to_json(r)
    ResourceRiskassessment(r) -> riskassessment_to_json(r)
    ResourceSchedule(r) -> schedule_to_json(r)
    ResourceSearchparameter(r) -> searchparameter_to_json(r)
    ResourceServicerequest(r) -> servicerequest_to_json(r)
    ResourceSlot(r) -> slot_to_json(r)
    ResourceSpecimen(r) -> specimen_to_json(r)
    ResourceSpecimendefinition(r) -> specimendefinition_to_json(r)
    ResourceStructuredefinition(r) -> structuredefinition_to_json(r)
    ResourceStructuremap(r) -> structuremap_to_json(r)
    ResourceSubscription(r) -> subscription_to_json(r)
    ResourceSubscriptionstatus(r) -> subscriptionstatus_to_json(r)
    ResourceSubscriptiontopic(r) -> subscriptiontopic_to_json(r)
    ResourceSubstance(r) -> substance_to_json(r)
    ResourceSubstancedefinition(r) -> substancedefinition_to_json(r)
    ResourceSubstancenucleicacid(r) -> substancenucleicacid_to_json(r)
    ResourceSubstancepolymer(r) -> substancepolymer_to_json(r)
    ResourceSubstanceprotein(r) -> substanceprotein_to_json(r)
    ResourceSubstancereferenceinformation(r) ->
      substancereferenceinformation_to_json(r)
    ResourceSubstancesourcematerial(r) -> substancesourcematerial_to_json(r)
    ResourceSupplydelivery(r) -> supplydelivery_to_json(r)
    ResourceSupplyrequest(r) -> supplyrequest_to_json(r)
    ResourceTask(r) -> task_to_json(r)
    ResourceTerminologycapabilities(r) -> terminologycapabilities_to_json(r)
    ResourceTestplan(r) -> testplan_to_json(r)
    ResourceTestreport(r) -> testreport_to_json(r)
    ResourceTestscript(r) -> testscript_to_json(r)
    ResourceTransport(r) -> transport_to_json(r)
    ResourceValueset(r) -> valueset_to_json(r)
    ResourceVerificationresult(r) -> verificationresult_to_json(r)
    ResourceVisionprescription(r) -> visionprescription_to_json(r)
  }
}

pub fn resource_decoder() -> Decoder(Resource) {
  use tag <- decode.field("resourceType", decode.string)
  case tag {
    "Account" -> account_decoder() |> decode.map(ResourceAccount)
    "Activitydefinition" ->
      activitydefinition_decoder() |> decode.map(ResourceActivitydefinition)
    "Actordefinition" ->
      actordefinition_decoder() |> decode.map(ResourceActordefinition)
    "Administrableproductdefinition" ->
      administrableproductdefinition_decoder()
      |> decode.map(ResourceAdministrableproductdefinition)
    "Adverseevent" -> adverseevent_decoder() |> decode.map(ResourceAdverseevent)
    "Allergyintolerance" ->
      allergyintolerance_decoder() |> decode.map(ResourceAllergyintolerance)
    "Appointment" -> appointment_decoder() |> decode.map(ResourceAppointment)
    "Appointmentresponse" ->
      appointmentresponse_decoder() |> decode.map(ResourceAppointmentresponse)
    "Artifactassessment" ->
      artifactassessment_decoder() |> decode.map(ResourceArtifactassessment)
    "Auditevent" -> auditevent_decoder() |> decode.map(ResourceAuditevent)
    "Basic" -> basic_decoder() |> decode.map(ResourceBasic)
    "Binary" -> binary_decoder() |> decode.map(ResourceBinary)
    "Biologicallyderivedproduct" ->
      biologicallyderivedproduct_decoder()
      |> decode.map(ResourceBiologicallyderivedproduct)
    "Biologicallyderivedproductdispense" ->
      biologicallyderivedproductdispense_decoder()
      |> decode.map(ResourceBiologicallyderivedproductdispense)
    "Bodystructure" ->
      bodystructure_decoder() |> decode.map(ResourceBodystructure)
    "Bundle" -> bundle_decoder() |> decode.map(ResourceBundle)
    "Canonicalresource" ->
      canonicalresource_decoder() |> decode.map(ResourceCanonicalresource)
    "Capabilitystatement" ->
      capabilitystatement_decoder() |> decode.map(ResourceCapabilitystatement)
    "Careplan" -> careplan_decoder() |> decode.map(ResourceCareplan)
    "Careteam" -> careteam_decoder() |> decode.map(ResourceCareteam)
    "Chargeitem" -> chargeitem_decoder() |> decode.map(ResourceChargeitem)
    "Chargeitemdefinition" ->
      chargeitemdefinition_decoder() |> decode.map(ResourceChargeitemdefinition)
    "Citation" -> citation_decoder() |> decode.map(ResourceCitation)
    "Claim" -> claim_decoder() |> decode.map(ResourceClaim)
    "Claimresponse" ->
      claimresponse_decoder() |> decode.map(ResourceClaimresponse)
    "Clinicalimpression" ->
      clinicalimpression_decoder() |> decode.map(ResourceClinicalimpression)
    "Clinicalusedefinition" ->
      clinicalusedefinition_decoder()
      |> decode.map(ResourceClinicalusedefinition)
    "Codesystem" -> codesystem_decoder() |> decode.map(ResourceCodesystem)
    "Communication" ->
      communication_decoder() |> decode.map(ResourceCommunication)
    "Communicationrequest" ->
      communicationrequest_decoder() |> decode.map(ResourceCommunicationrequest)
    "Compartmentdefinition" ->
      compartmentdefinition_decoder()
      |> decode.map(ResourceCompartmentdefinition)
    "Composition" -> composition_decoder() |> decode.map(ResourceComposition)
    "Conceptmap" -> conceptmap_decoder() |> decode.map(ResourceConceptmap)
    "Condition" -> condition_decoder() |> decode.map(ResourceCondition)
    "Conditiondefinition" ->
      conditiondefinition_decoder() |> decode.map(ResourceConditiondefinition)
    "Consent" -> consent_decoder() |> decode.map(ResourceConsent)
    "Contract" -> contract_decoder() |> decode.map(ResourceContract)
    "Coverage" -> coverage_decoder() |> decode.map(ResourceCoverage)
    "Coverageeligibilityrequest" ->
      coverageeligibilityrequest_decoder()
      |> decode.map(ResourceCoverageeligibilityrequest)
    "Coverageeligibilityresponse" ->
      coverageeligibilityresponse_decoder()
      |> decode.map(ResourceCoverageeligibilityresponse)
    "Detectedissue" ->
      detectedissue_decoder() |> decode.map(ResourceDetectedissue)
    "Device" -> device_decoder() |> decode.map(ResourceDevice)
    "Deviceassociation" ->
      deviceassociation_decoder() |> decode.map(ResourceDeviceassociation)
    "Devicedefinition" ->
      devicedefinition_decoder() |> decode.map(ResourceDevicedefinition)
    "Devicedispense" ->
      devicedispense_decoder() |> decode.map(ResourceDevicedispense)
    "Devicemetric" -> devicemetric_decoder() |> decode.map(ResourceDevicemetric)
    "Devicerequest" ->
      devicerequest_decoder() |> decode.map(ResourceDevicerequest)
    "Deviceusage" -> deviceusage_decoder() |> decode.map(ResourceDeviceusage)
    "Diagnosticreport" ->
      diagnosticreport_decoder() |> decode.map(ResourceDiagnosticreport)
    "Documentreference" ->
      documentreference_decoder() |> decode.map(ResourceDocumentreference)
    "Domainresource" ->
      domainresource_decoder() |> decode.map(ResourceDomainresource)
    "Encounter" -> encounter_decoder() |> decode.map(ResourceEncounter)
    "Encounterhistory" ->
      encounterhistory_decoder() |> decode.map(ResourceEncounterhistory)
    "Endpoint" -> endpoint_decoder() |> decode.map(ResourceEndpoint)
    "Enrollmentrequest" ->
      enrollmentrequest_decoder() |> decode.map(ResourceEnrollmentrequest)
    "Enrollmentresponse" ->
      enrollmentresponse_decoder() |> decode.map(ResourceEnrollmentresponse)
    "Episodeofcare" ->
      episodeofcare_decoder() |> decode.map(ResourceEpisodeofcare)
    "Eventdefinition" ->
      eventdefinition_decoder() |> decode.map(ResourceEventdefinition)
    "Evidence" -> evidence_decoder() |> decode.map(ResourceEvidence)
    "Evidencereport" ->
      evidencereport_decoder() |> decode.map(ResourceEvidencereport)
    "Evidencevariable" ->
      evidencevariable_decoder() |> decode.map(ResourceEvidencevariable)
    "Examplescenario" ->
      examplescenario_decoder() |> decode.map(ResourceExamplescenario)
    "Explanationofbenefit" ->
      explanationofbenefit_decoder() |> decode.map(ResourceExplanationofbenefit)
    "Familymemberhistory" ->
      familymemberhistory_decoder() |> decode.map(ResourceFamilymemberhistory)
    "Flag" -> flag_decoder() |> decode.map(ResourceFlag)
    "Formularyitem" ->
      formularyitem_decoder() |> decode.map(ResourceFormularyitem)
    "Genomicstudy" -> genomicstudy_decoder() |> decode.map(ResourceGenomicstudy)
    "Goal" -> goal_decoder() |> decode.map(ResourceGoal)
    "Graphdefinition" ->
      graphdefinition_decoder() |> decode.map(ResourceGraphdefinition)
    "Group" -> group_decoder() |> decode.map(ResourceGroup)
    "Guidanceresponse" ->
      guidanceresponse_decoder() |> decode.map(ResourceGuidanceresponse)
    "Healthcareservice" ->
      healthcareservice_decoder() |> decode.map(ResourceHealthcareservice)
    "Imagingselection" ->
      imagingselection_decoder() |> decode.map(ResourceImagingselection)
    "Imagingstudy" -> imagingstudy_decoder() |> decode.map(ResourceImagingstudy)
    "Immunization" -> immunization_decoder() |> decode.map(ResourceImmunization)
    "Immunizationevaluation" ->
      immunizationevaluation_decoder()
      |> decode.map(ResourceImmunizationevaluation)
    "Immunizationrecommendation" ->
      immunizationrecommendation_decoder()
      |> decode.map(ResourceImmunizationrecommendation)
    "Implementationguide" ->
      implementationguide_decoder() |> decode.map(ResourceImplementationguide)
    "Ingredient" -> ingredient_decoder() |> decode.map(ResourceIngredient)
    "Insuranceplan" ->
      insuranceplan_decoder() |> decode.map(ResourceInsuranceplan)
    "Inventoryitem" ->
      inventoryitem_decoder() |> decode.map(ResourceInventoryitem)
    "Inventoryreport" ->
      inventoryreport_decoder() |> decode.map(ResourceInventoryreport)
    "Invoice" -> invoice_decoder() |> decode.map(ResourceInvoice)
    "Library" -> library_decoder() |> decode.map(ResourceLibrary)
    "Linkage" -> linkage_decoder() |> decode.map(ResourceLinkage)
    "Listfhir" -> listfhir_decoder() |> decode.map(ResourceListfhir)
    "Location" -> location_decoder() |> decode.map(ResourceLocation)
    "Manufactureditemdefinition" ->
      manufactureditemdefinition_decoder()
      |> decode.map(ResourceManufactureditemdefinition)
    "Measure" -> measure_decoder() |> decode.map(ResourceMeasure)
    "Measurereport" ->
      measurereport_decoder() |> decode.map(ResourceMeasurereport)
    "Medication" -> medication_decoder() |> decode.map(ResourceMedication)
    "Medicationadministration" ->
      medicationadministration_decoder()
      |> decode.map(ResourceMedicationadministration)
    "Medicationdispense" ->
      medicationdispense_decoder() |> decode.map(ResourceMedicationdispense)
    "Medicationknowledge" ->
      medicationknowledge_decoder() |> decode.map(ResourceMedicationknowledge)
    "Medicationrequest" ->
      medicationrequest_decoder() |> decode.map(ResourceMedicationrequest)
    "Medicationstatement" ->
      medicationstatement_decoder() |> decode.map(ResourceMedicationstatement)
    "Medicinalproductdefinition" ->
      medicinalproductdefinition_decoder()
      |> decode.map(ResourceMedicinalproductdefinition)
    "Messagedefinition" ->
      messagedefinition_decoder() |> decode.map(ResourceMessagedefinition)
    "Messageheader" ->
      messageheader_decoder() |> decode.map(ResourceMessageheader)
    "Metadataresource" ->
      metadataresource_decoder() |> decode.map(ResourceMetadataresource)
    "Molecularsequence" ->
      molecularsequence_decoder() |> decode.map(ResourceMolecularsequence)
    "Namingsystem" -> namingsystem_decoder() |> decode.map(ResourceNamingsystem)
    "Nutritionintake" ->
      nutritionintake_decoder() |> decode.map(ResourceNutritionintake)
    "Nutritionorder" ->
      nutritionorder_decoder() |> decode.map(ResourceNutritionorder)
    "Nutritionproduct" ->
      nutritionproduct_decoder() |> decode.map(ResourceNutritionproduct)
    "Observation" -> observation_decoder() |> decode.map(ResourceObservation)
    "Observationdefinition" ->
      observationdefinition_decoder()
      |> decode.map(ResourceObservationdefinition)
    "Operationdefinition" ->
      operationdefinition_decoder() |> decode.map(ResourceOperationdefinition)
    "Operationoutcome" ->
      operationoutcome_decoder() |> decode.map(ResourceOperationoutcome)
    "Organization" -> organization_decoder() |> decode.map(ResourceOrganization)
    "Organizationaffiliation" ->
      organizationaffiliation_decoder()
      |> decode.map(ResourceOrganizationaffiliation)
    "Packagedproductdefinition" ->
      packagedproductdefinition_decoder()
      |> decode.map(ResourcePackagedproductdefinition)
    "Parameters" -> parameters_decoder() |> decode.map(ResourceParameters)
    "Patient" -> patient_decoder() |> decode.map(ResourcePatient)
    "Paymentnotice" ->
      paymentnotice_decoder() |> decode.map(ResourcePaymentnotice)
    "Paymentreconciliation" ->
      paymentreconciliation_decoder()
      |> decode.map(ResourcePaymentreconciliation)
    "Permission" -> permission_decoder() |> decode.map(ResourcePermission)
    "Person" -> person_decoder() |> decode.map(ResourcePerson)
    "Plandefinition" ->
      plandefinition_decoder() |> decode.map(ResourcePlandefinition)
    "Practitioner" -> practitioner_decoder() |> decode.map(ResourcePractitioner)
    "Practitionerrole" ->
      practitionerrole_decoder() |> decode.map(ResourcePractitionerrole)
    "Procedure" -> procedure_decoder() |> decode.map(ResourceProcedure)
    "Provenance" -> provenance_decoder() |> decode.map(ResourceProvenance)
    "Questionnaire" ->
      questionnaire_decoder() |> decode.map(ResourceQuestionnaire)
    "Questionnaireresponse" ->
      questionnaireresponse_decoder()
      |> decode.map(ResourceQuestionnaireresponse)
    "Regulatedauthorization" ->
      regulatedauthorization_decoder()
      |> decode.map(ResourceRegulatedauthorization)
    "Relatedperson" ->
      relatedperson_decoder() |> decode.map(ResourceRelatedperson)
    "Requestorchestration" ->
      requestorchestration_decoder() |> decode.map(ResourceRequestorchestration)
    "Requirements" -> requirements_decoder() |> decode.map(ResourceRequirements)
    "Researchstudy" ->
      researchstudy_decoder() |> decode.map(ResourceResearchstudy)
    "Researchsubject" ->
      researchsubject_decoder() |> decode.map(ResourceResearchsubject)
    "Riskassessment" ->
      riskassessment_decoder() |> decode.map(ResourceRiskassessment)
    "Schedule" -> schedule_decoder() |> decode.map(ResourceSchedule)
    "Searchparameter" ->
      searchparameter_decoder() |> decode.map(ResourceSearchparameter)
    "Servicerequest" ->
      servicerequest_decoder() |> decode.map(ResourceServicerequest)
    "Slot" -> slot_decoder() |> decode.map(ResourceSlot)
    "Specimen" -> specimen_decoder() |> decode.map(ResourceSpecimen)
    "Specimendefinition" ->
      specimendefinition_decoder() |> decode.map(ResourceSpecimendefinition)
    "Structuredefinition" ->
      structuredefinition_decoder() |> decode.map(ResourceStructuredefinition)
    "Structuremap" -> structuremap_decoder() |> decode.map(ResourceStructuremap)
    "Subscription" -> subscription_decoder() |> decode.map(ResourceSubscription)
    "Subscriptionstatus" ->
      subscriptionstatus_decoder() |> decode.map(ResourceSubscriptionstatus)
    "Subscriptiontopic" ->
      subscriptiontopic_decoder() |> decode.map(ResourceSubscriptiontopic)
    "Substance" -> substance_decoder() |> decode.map(ResourceSubstance)
    "Substancedefinition" ->
      substancedefinition_decoder() |> decode.map(ResourceSubstancedefinition)
    "Substancenucleicacid" ->
      substancenucleicacid_decoder() |> decode.map(ResourceSubstancenucleicacid)
    "Substancepolymer" ->
      substancepolymer_decoder() |> decode.map(ResourceSubstancepolymer)
    "Substanceprotein" ->
      substanceprotein_decoder() |> decode.map(ResourceSubstanceprotein)
    "Substancereferenceinformation" ->
      substancereferenceinformation_decoder()
      |> decode.map(ResourceSubstancereferenceinformation)
    "Substancesourcematerial" ->
      substancesourcematerial_decoder()
      |> decode.map(ResourceSubstancesourcematerial)
    "Supplydelivery" ->
      supplydelivery_decoder() |> decode.map(ResourceSupplydelivery)
    "Supplyrequest" ->
      supplyrequest_decoder() |> decode.map(ResourceSupplyrequest)
    "Task" -> task_decoder() |> decode.map(ResourceTask)
    "Terminologycapabilities" ->
      terminologycapabilities_decoder()
      |> decode.map(ResourceTerminologycapabilities)
    "Testplan" -> testplan_decoder() |> decode.map(ResourceTestplan)
    "Testreport" -> testreport_decoder() |> decode.map(ResourceTestreport)
    "Testscript" -> testscript_decoder() |> decode.map(ResourceTestscript)
    "Transport" -> transport_decoder() |> decode.map(ResourceTransport)
    "Valueset" -> valueset_decoder() |> decode.map(ResourceValueset)
    "Verificationresult" ->
      verificationresult_decoder() |> decode.map(ResourceVerificationresult)
    "Visionprescription" ->
      visionprescription_decoder() |> decode.map(ResourceVisionprescription)

    _ ->
      decode.failure(ResourceCareteam(careteam_new()), expected: "resourceType")
  }
}

//std lib decode.optional supports myfield: null but what if myfield is omitted from json entirely?
fn none_if_omitted(d: decode.Decoder(a)) -> decode.Decoder(Option(a)) {
  decode.one_of(d |> decode.map(Some), [decode.success(None)])
}
